{"open_issues": {"1": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2804", "issue_id": "#2804", "issue_summary": "NotImplementedError when calling HTTPServer.listen in Python 3.8.1 and Tornado 6.0.x", "issue_description": "tcsmith commented 3 days ago\nA few of our devs upgraded to 3.8.1 and now get an error when calling listen on an HTTPServer object.\nHere is the callstack:\n  File \"C:\\Temp\\tornado_bugp\\service.py\", line 565, in _make_private_app\n    server = app.listen(\n  File \"C:\\Users\\dev\\.virtualenvs\\tornado-web-app-LhID9pTb\\lib\\site-packages\\tornado\\web.py\", line 2112, in listen\n    server.listen(port, address)\n  File \"C:\\Users\\dev\\.virtualenvs\\tornado-web-app-LhID9pTb\\lib\\site-packages\\tornado\\tcpserver.py\", line 152, in listen\n    self.add_sockets(sockets)\n  File \"C:\\Users\\dev\\.virtualenvs\\tornado-web-app-LhID9pTb\\lib\\site-packages\\tornado\\tcpserver.py\", line 165, in add_sockets\n    self._handlers[sock.fileno()] = add_accept_handler(\n  File \"C:\\Users\\dev\\.virtualenvs\\tornado-web-app-LhID9pTb\\lib\\site-packages\\tornado\\netutil.py\", line 279, in add_accept_handler\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n  File \"C:\\Users\\dev\\.virtualenvs\\tornado-web-app-LhID9pTb\\lib\\site-packages\\tornado\\platform\\asyncio.py\", line 99, in add_handler\n    self.asyncio_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)\n  File \"C:\\Users\\dev\\AppData\\Local\\Programs\\Python\\Python38-32\\Lib\\asyncio\\events.py\", line 501, in add_reader\n    raise NotImplementedError\nNotImplementedError\nHere is our call to listen:\nhandlers = [\n        tornado.web.URLSpec(\n            r'/config',\n            _ConfigHandler\n        ),\n        tornado.web.URLSpec(\n            r'/health',\n            _HealthHandler,\n            {\n                'service_state': service_state\n            }\n        ),\n        tornado.web.URLSpec(\n            r'/shutdown',\n            _ShutdownHandler,\n            {\n                'service_state': service_state\n            }\n        ),\n        tornado.web.URLSpec(\n            r'/status',\n            relayserver.StatusHandler,\n            {\n                'relay_server': relay_server,\n                'stats': stats\n            }\n        )\n    ]\n\n    app = tornado.web.Application(\n        handlers\n    )\nserver = app.listen(\n        tornado.options.options.private_port,\n        tornado.options.options.private_address,\n        xheaders=True,\n        max_body_size=tornado.options.options.max_body_size,\n        idle_connection_timeout=tornado.options.options.idle_timeout\n    )\nI double checked to make sure all the handlers actually exist and they do.\nWhen changing to 3.7 either system wide or in a virtual environment this works without issue.", "issue_status": "Open", "issue_reporting_time": "2020-01-27T21:01:39Z"}, "2": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2802", "issue_id": "#2802", "issue_summary": "Spawn a thread and communicate between the thread and tornado app?", "issue_description": "shamrin commented 8 days ago \u2022\nedited\nMy Tornado app needs to have bidirectional communicate with the worker thread spawned by .run_in_executor. Starting a worker thread takes time. It needs to initialise an expensive network connection before it can do the work.\nIs there a native Tornado approach to solve this problem?\nApproach 1: tornado.queue\nI've looked into tornado.queues module, but I couldn't figure out how to use it to communicate between sync and async worlds. Documentation suggests wrapping operations with IOLoop.add_callback:\ntornado/tornado/queues.py\nLines 21 to 24 in 18b653c\n    Unlike the standard library's `queue` module, the classes defined here \n    are *not* thread-safe. To use these queues from another thread, \n    use `.IOLoop.add_callback` to transfer control to the `.IOLoop` thread \n    before calling any queue methods. \nHowever, .add_callback is useful only for .put and .put_nowait methods, and not for .get and .get_nowait. There's no way to get the result back from .add_callback.\nApproach 2: standard queue library\nNext option is queue from Python standard library. It should work, but all queue operation needs to be wrapped with .run_in_executor. Seems excessive and not pretty.\nApproach 3: janus library\nThere's janus - library for mixed sync/async queue. Looks good, but it's not small and it's an extra dependency to maintain.\nApproach 4: Tornado native approach?\nIs there Tornado-native approach? For example something similar to trio.from_thread.run. It's the same as IOLoop.add_callback, but Trio's run also sends back the result of the operation. Thus run can safely wrap Trio queue methods (called \"memory channel\" in Trio). Example from Trio documentation:\ndef thread_fn(receive_from_trio, send_to_trio):\n    while True:\n        # Since we're in a thread, we can't call methods on Trio\n        # objects directly -- so we use trio.from_thread to call them.\n        try:\n            request = trio.from_thread.run(receive_from_trio.receive)\n        except trio.EndOfChannel:\n            trio.from_thread.run(send_to_trio.aclose)\n            return\n        else:\n            response = request + 1\n            trio.from_thread.run(send_to_trio.send, response)", "issue_status": "Open", "issue_reporting_time": "2020-01-22T17:03:49Z"}, "3": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2801", "issue_id": "#2801", "issue_summary": "process, tcpserver: Soft-deprecate multi-process mode", "issue_description": "Member\nbdarnell commented 9 days ago\nMulti-process mode has a lot of subtleties; it is responsible for a large fraction of our questions on stack overflow. And now that we have SO_REUSEPORT, I see little reason to use it instead of multiple independent processes (I've always viewed multiple independent processes as desirable for \"serious\" production use, but the need for an external load balancer is a significant operational overhead that justifies the shared-listener multiprocess mode. But if you can share a port without fork and its associates subtlety, that's even better)\nWe should at least update the docs to steer people towards reusing ports instead of forking multiple-processes. We might want to go as far as deprecating the process argument to server.start(), although I'm in no rush to actually remove it (I don't think I'd deprecate the process.fork_processes() function - empirically the people who get in trouble with multi-process mode are all using start(N); explicit forking is much more explicit and either the people who try it are able to get it working without difficulty or no one's trying it).", "issue_status": "Open", "issue_reporting_time": "2020-01-21T19:04:19Z"}, "4": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2800", "issue_id": "#2800", "issue_summary": "Replace gen.TimeoutError with asyncio.TimeoutError", "issue_description": "Contributor\nmrocklin commented 10 days ago\nAs applications increasingly use Tornado within Asyncio frameworks I find it challenging to figure out when I should be watching for gen.TimeoutErrors and when I should be watching out for asyncio.TimeoutErrors. I wonder if it is possible to unify the two\n# gen.py\n\nTimeoutError = asyncio.TimeoutError\nThis would simplify things a bit downstream", "issue_status": "Open", "issue_reporting_time": "2020-01-20T19:39:21Z"}, "5": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2790", "issue_id": "#2790", "issue_summary": "Tornado does not reject messages with BWS after field-name", "issue_description": "ZeddYu commented on 13 Dec 2019 \u2022\nedited\nRFC 7230: server MUST reject messages with BWS after field-name (#445)\nObey the RFC requirement to reject HTTP requests with whitespace\nbetween field-name and the colon delimiter. Rejection is\ncritical in the presence of broken HTTP agents that mishandle\nmalformed messages.\nIf not, it will be used to smuggle http request.\nTest code:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n    \n    def post(self):\n        data = self.request.body\n        self.write(str(data))\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8000)\n    tornado.ioloop.IOLoop.current().start()\nTest script:\nprintf 'POST / HTTP/1.1\\r\\n'\\\n'Host:localhost\\r\\n'\\\n'Content-length : 5\\r\\n'\\\n'Connection: close\\r\\n'\\\n'\\r\\n'\\\n'a=3\\r\\n'\\\n'\\r\\n'\\\n| nc -w 1 127.0.0.1 8000\nExpected behavior:\nreturn 400\nActual behavior:\nreturn 200\nVersion:\ntornado 6.0.3\npython 3.7.5", "issue_status": "Open", "issue_reporting_time": "2019-12-13T16:07:53Z"}, "6": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2788", "issue_id": "#2788", "issue_summary": "Prevent issue in blog example due to initialization order of containers", "issue_description": "Contributor\nkinow commented on 9 Dec 2019\nThe demo blog app has an issue with its Docker containers, where the Python app may initialize before the Postgres database.\nThis PR was using a solution to enforce the container order, but a better approach would be to prevent the Python application from crashing if possible. See the PR comments for me.", "issue_status": "Open", "issue_reporting_time": "2019-12-08T21:50:20Z"}, "7": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2787", "issue_id": "#2787", "issue_summary": "MemoryError in Octoprint", "issue_description": "MatthewCroughan commented on 9 Dec 2019\nI do not have any concept of why this issue is occuring, but Foosel believes this is an issue with Tornado rather than a misuse. So I'm placing it here since I am apparently banned from discussing anything further in Octoprint. I'll give more details when I can.\nfoosel/OctoPrint#3376", "issue_status": "Open", "issue_reporting_time": "2019-12-08T20:46:04Z"}, "8": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2785", "issue_id": "#2785", "issue_summary": "Unsuccessful TLS handshake leaking connections", "issue_description": "zejn commented on 5 Dec 2019\nTornado's IOStream.start_tls leaks connections when the handshake starts but does not complete. The AsyncHTTPClient returns \"HTTP 599: Timeout while connecting\", but the underlying connection is not closed.\nThis can be reproduced quite easily: start a netcat to listen on 127.0.0.1:9000 and run the attached example with \"ssl_leak.py http\" or \"ssl_leak.py https\" to observe different behaviors. HTTP closes the connection (and netcat exits), while HTTPS keeps the connection up even after the request errors.\nssl_leak.py.txt\nI've observed this behavior with\nOpenSSL: OpenSSL 1.1.0f 25 May 2017\nPython: 3.5.3 (default, Jan 19 2017, 14:11:04)\n[GCC 6.3.0 20170124]\nTornado: 4.5.3\nand\nOpenSSL: OpenSSL 1.1.1d 10 Sep 2019\nPython: 3.7.3 (default, Apr 3 2019, 05:39:12)\n[GCC 8.3.0]\nTornado: 6.0.3\nI've confirmed this is an issue in start_tls with a \"fix\", but this fix includes a timeout, which is currently hardcoded. This timeout value might need to be somehow passed into start_tls, but the start_tls is hidden quite deep.\niostream_tls_leak_fix.diff.txt", "issue_status": "Open", "issue_reporting_time": "2019-12-05T10:46:25Z"}, "9": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2769", "issue_id": "#2769", "issue_summary": "StaticFileHandler fails when the underlying file is enlarged when reading.", "issue_description": "jahodfra commented on 5 Nov 2019\nWe provide read access to logs which are still being appended. Sometimes it causes:\ntornado.httputil.HTTPOutputError: Tried to write more data than Content-Length\nThis will of course doesn't help when the file is truncated meantime - but this doesn't happen for us.\nI suppose that the followin line should also set end=size.\ntornado/tornado/web.py\nLine 2636 in 984aba0\n content_length = size ", "issue_status": "Open", "issue_reporting_time": "2019-11-05T08:48:45Z"}, "10": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2763", "issue_id": "#2763", "issue_summary": "websocket: Task was destroyed but it is pending!", "issue_description": "gdbrianlu commented on 29 Oct 2019\n[E 191029 10:54:51 base_events:1608] Task was destroyed but it is pending!\ntask: <Task pending coro=<WebSocketProtocol13._receive_frame_loop() done, defined at D:\\AndroidControl\\Python37\\lib\\site-packages\\tornado\\websocket.py:1115> wait_for=<Future pending cb=[IOLoop.add_future..() at D:\\AndroidControl\\Python37\\lib\\site-packages\\tornado\\ioloop.py:690, <TaskWakeupMethWrapper object at 0x000002AC48174468>()]> cb=[IOLoop.add_future..() at D:\\AndroidControl\\Python37\\lib\\site-packages\\tornado\\ioloop.py:690]>", "issue_status": "Open", "issue_reporting_time": "2019-10-29T03:00:29Z"}, "11": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2760", "issue_id": "#2760", "issue_summary": "Support for coroutine callback in autoreload.add_reload_hook.", "issue_description": "bhch commented on 27 Oct 2019\nSupporting coroutine callbacks in autoreload.add_reload_hook would be really helpful for closing database connections when the app auto reloads during development.\nI'm currently using aiopg and the function to close the connections is a coroutine.\nI tried using IOLoop.add_callback to run the coroutine from the reload hook callback, but it seems that the event loop is terminated before it can run the callback.", "issue_status": "Open", "issue_reporting_time": "2019-10-26T20:43:09Z"}, "12": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2753", "issue_id": "#2753", "issue_summary": "getting assert error", "issue_description": "himanshu4code commented on 11 Oct 2019 \u2022\nedited\nERROR:tornado.application:Error in connection callback\nTraceback (most recent call last):\nFile \"/home/ongraph/Desktop/botuserv/lib/python3.7/site-packages/tornado/tcpserver.py\", line 327, in _handle_connection\nfuture = self.handle_stream(stream, address)\nFile \"/home/ongraph/Desktop/botuserv/lib/python3.7/site-packages/tornado/httpserver.py\", line 229, in handle_stream\nconn.start_serving(self)\nFile \"/home/ongraph/Desktop/botuserv/lib/python3.7/site-packages/tornado/http1connection.py\", line 810, in start_serving\nself.stream.io_loop.add_future(fut, lambda f: f.result())\nFile \"/home/ongraph/Desktop/botuserv/lib/python3.7/site-packages/tornado/ioloop.py\", line 693, in add_future\nassert is_future(future)\nAssertionError\nwhen i checked i found out that future get object of Http1ServerConnection.\n<Task pending coro=<HTTP1ServerConnection._server_request_loop() >>", "issue_status": "Open", "issue_reporting_time": "2019-10-11T11:59:13Z"}, "13": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2752", "issue_id": "#2752", "issue_summary": "python occupied memory keeps getting accumulated when ran through service and not released to OS", "issue_description": "abhijeetbedagkar commented on 9 Oct 2019 \u2022\nedited\nHi,\nWe are facing issue where occupied memory keeps getting accumulated when ran through service and not released to OS (Please refer to sample code below).\nimport tornado.ioloop\nimport tornado.web\nfrom tornado.httpserver import HTTPServer\n\nclass BotoContainer:\n    def __init__(self):\n        import boto3 # 2\n        emr_client = boto3.client(\"emr\", **{'region_name': 'us-east-1',\n                                        'aws_access_key_id': 'XXXXXXX',\n                                        'aws_secret_access_key': 'XXXXXXX',\n                                        'aws_session_token': 'XXXXXXX'})\n        print emr_client # 3\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        BotoContainer()\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n        (r\"/abc\", MainHandler)\n    ]\n\n        tornado.web.Application.__init__(self, handlers)\n\n\nif __name__ == \"__main__\":\n    app = HTTPServer(Application())\n    app.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\nInitially, after running the service, consumed memory is \"12.0 MB\". When We hit http GET request for \"http://localhost:8888/abc\" at point 2 (Pointed in below code) Memory goes to 30MB. As code proceeds to point 3 memory consumption is increased till 31MB. After point 3, as per our observation the memory never comes down and it remains at 31 MB. As we invoke HTTP GET request multiple times this memory consumption in increased during each request as 32MB, 33MB and so on and it never comes down. We tried using \"del emr_client\" using del method to delete emr_client object but nothing seems to be working. In our larger code base this accumulated memory is causing our web server going into unhealthy status and only option we have is the stop and start the service. Same behavior exist for Linux machine too.\nWe understand that python keeps imported package in memory for faster execution during subsequent calls but any reason the memory is not released after life of an object (ex. emr_client in above example) comes to end after it's scope is complete.\nThanks,\nAbhijeet", "issue_status": "Open", "issue_reporting_time": "2019-10-09T04:53:23Z"}, "14": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2747", "issue_id": "#2747", "issue_summary": "Automatically redirect to https on tornadoweb.org", "issue_description": "Contributor\nsupakeen commented on 5 Oct 2019\nHi,\nvery minor gripe maybe even a nitpick is that tornadoweb.org serves on both http and https. I'd prefer it to redirect to https on any http request.\nI've enclosed a pull request to at least point the default README.rst link to https.", "issue_status": "Open", "issue_reporting_time": "2019-10-05T10:55:42Z"}, "15": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2743", "issue_id": "#2743", "issue_summary": "HTTP client gives incorrect Content-Length for automatically decompressed responses", "issue_description": "Contributor\nandersk commented on 25 Sep 2019\nThe application below has two handlers, the first of which serves a gzipped tarball at /hello.tar.gz, and the second of which tries to proxy /hello2.tar.gz to the first. But the second actually raises tornado.httputil.HTTPOutputError: Tried to write more data than Content-Length.\nThe reason is that the Tornado HTTP client has decompressed the Content-Encoding: gzip without adjusting the Content-Length field, resulting in an invalid response. A workaround is setting decompress_response=False.\nWhen decompress_response is on, Tornado should adjust or remove the Content-Length field of decompressed responses, similarly to how it already removes the Content-Encoding field.\nI would also argue that decompress_response is unexpected behavior that should really be off by default, even if it\u2019s fixed, as it changes the semantic meaning of the response: Content-Encoding is not Transfer-Encoding.\nimport tarfile\nimport io\nimport tornado.ioloop\nimport tornado.web\nimport tornado.httpclient\n\nclass TgzHandler(tornado.web.RequestHandler):\n    def get(self):\n        b = io.BytesIO()\n        with tarfile.open(fileobj=b, mode=\"w:gz\") as tar:\n            contents = b\"Hello, world!\\n\"\n            info = tarfile.TarInfo(\"hello.txt\")\n            info.size = len(contents)\n            tar.addfile(info, io.BytesIO(contents))\n        self.set_header(\"Content-Type\", \"application/x-tar\")\n        self.set_header(\"Content-Encoding\", \"gzip\")\n        self.write(b.getvalue())\n\nclass ProxyHandler(tornado.web.RequestHandler):\n    async def get(self):\n        resp = await tornado.httpclient.AsyncHTTPClient().fetch(\n            \"http://localhost:8888/hello.tar.gz\"\n        )\n        for k, v in resp.headers.get_all():\n            self.add_header(k, v)\n        self.write(resp.body)\n\napp = tornado.web.Application(\n    [(r\"/hello.tar.gz\", TgzHandler), (r\"/hello2.tar.gz\", ProxyHandler)]\n)\napp.listen(8888)\ntornado.ioloop.IOLoop.current().start()", "issue_status": "Open", "issue_reporting_time": "2019-09-24T22:02:27Z"}, "16": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2742", "issue_id": "#2742", "issue_summary": "Create a AsyncHTTPClient request with infinite timeout", "issue_description": "Contributor\npolygon commented on 12 Sep 2019 \u2022\nedited\nIs there a defined way to create a request using AsyncHTTPClient with an infinite timeout? I am currently using the simple httpclient implementation (should also not change) and I am requesting a page that streams an infinite amount of data. I am using streaming_callback to process the chunks of data.\nWith Python 3.6.4 and Tornado 5.0.2 I set request_timeout=0 on the fetch method call which worked. However, I recently upgraded to Python 3.7.4 and newest Tornado 6. When I set request_timeout=0 here, the future also never completes. However, the client will not even send a HTTP request to the destination. An example of this is the following:\nfrom tornado.httpclient import AsyncHTTPClient\nimport asyncio\n\nURL='http://localhost:8000/test'\n\nasync def test():\n    ahc = AsyncHTTPClient()\n    result = await ahc.fetch(URL, streaming_callback=chunker, request_timeout=0)\n\ndef chunker(data):\n    print(data)\n\nasyncio.get_event_loop().run_until_complete(test())\nThe program will not complete, but on the local server, there will not be a request, either. And, subsequently, chunker will also never be called. I can work around this by setting request_timeout=float('inf') but this feels really hacky and I fear that there may be a timeout at some point in the future anyways.\nSo question is if there is a way to never timeout the fetch request.", "issue_status": "Open", "issue_reporting_time": "2019-09-12T14:47:42Z"}, "17": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2731", "issue_id": "#2731", "issue_summary": "ValueError with ContextVar reset within decorated coroutine", "issue_description": "majorgreys commented on 23 Aug 2019\nI was getting the following error while updating code for Python 3.7 and Tornado 6:\nValueError: <Token var=<ContextVar ...> at 0x1059e4fc0> was created in a different Context\nI was able to reproduce this issue with the sample script below. The error only occurs when using decorate coroutines, whereas native coroutines work as expected.\nimport asyncio\nimport contextvars\nfrom tornado import gen, ioloop\n\ncv = contextvars.ContextVar(\"cv\", default=False)\n\nasync def foo():\n    await asyncio.sleep(1)\n\nasync def main_native():\n    token = cv.set(True)\n    print(f\"main_native before foo: Context={contextvars.Context()}\")\n    await foo()\n    print(f\"main_native after foo: Context={contextvars.Context()}\")\n    cv.reset(token)\n    print(\"main_native: OK\")\n\n@gen.coroutine\ndef main_decorated():\n    print(f\"main_decorated before foo: Context={contextvars.Context()}\")\n    token = cv.set(True)\n    yield foo()\n    print(f\"main_decorated after foo: Context={contextvars.Context()}\")\n    cv.reset(token)\n    print(\"main_decorated OK\")\n\nif __name__ == \"__main__\":\n    ioloop.IOLoop.current().run_sync(main_native)\n    ioloop.IOLoop.current().run_sync(main_decorated)\nThe output from Python 3.7 and Tornado 6.0.3 is:\nmain_native before foo: Context=<Context object at 0x10ee2b948>\nmain_native after foo: Context=<Context object at 0x10ee2b948>\nmain_native: OK\nmain_decorated before foo: Context=<Context object at 0x10ee2b7e0>\nmain_decorated after foo: Context=<Context object at 0x10ee2bcf0>\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/var/folders/9_/k78_39fn08991mz6r_ws9fc00000gn/T/babel-ZbUBrS/python-QPUJC9\", line 29, in <module>\n    ioloop.IOLoop.current().run_sync(main_decorated)\n  File \"/Users/tahir.butt/.virtualenvs/py37-tornado6/lib/python3.7/site-packages/tornado/ioloop.py\", line 532, in run_sync\n    return future_cell[0].result()\n  File \"/Users/tahir.butt/.virtualenvs/py37-tornado6/lib/python3.7/site-packages/tornado/gen.py\", line 748, in run\n    yielded = self.gen.send(value)\n  File \"/var/folders/9_/k78_39fn08991mz6r_ws9fc00000gn/T/babel-ZbUBrS/python-QPUJC9\", line 24, in main_decorated\n    cv.reset(token)\nValueError: <Token var=<ContextVar name='cv' default=False at 0x10ee1c570> at 0x10ee2bbd0> was created in a different Context\nWhereas the value of contextvars.Context() is not changed within the native coroutine main_native when calling the foo coroutine, this is not true for within the decorated courtine main_decorated.\nWe see here where this error originates in the cPython implementation for ContextVar.reset():\nhttps://github.com/python/cpython/blob/aacc77fbd77640a8f03638216fa09372cc21673d/Python/context.c#L295-L300\nThis issue reflects the fundamental problem addressed in #2716. Using that PR branch resolves the problem raised in this issue.", "issue_status": "Open", "issue_reporting_time": "2019-08-23T18:00:11Z"}, "18": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2717", "issue_id": "#2717", "issue_summary": "IOStream read can fail if closed with an open read buffer", "issue_description": "Contributor\nminrk commented on 1 Aug 2019\nI'm currently investigating the issue mentioned here and I've narrowed the situation down somewhat:\nSimpleAsyncHTTPRequest is making a POST request with an empty body to a server that is responding very quickly. In this case, it is the request to github.com to complete GitHub OAuth.\nWhen read_until_regex is called in\nread buffer is not empty, but\nstream is closed\nSo a closed check is apparently occurring before the read is attempted from the existing buffer. Interestingly, #2670 introduces exactly such a premature closed check (a _try_inline_read() would succeed if attempted), but the issue still occurs in 6.0.2, prior to #2670, so there must be an additional check that's causing StreamClosedError to be raised even when the\nI'm trying to provoke this with a self-contained test case that doesn't require github credentials, but haven't managed it yet. Will report back when I do.\nUsing curl_httpclient does not appear to exhibit this behavior.\nI think this is related to #2651 in that it's another issue in 6.0 where there are races between the closed state and pending reads/writes.", "issue_status": "Open", "issue_reporting_time": "2019-08-01T09:40:02Z"}, "19": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2714", "issue_id": "#2714", "issue_summary": "HTTPClient hangs forever decompressing data", "issue_description": "purplecover commented on 26 Jul 2019\nPython v3.7.4\nTornado v6.0.3\nRun the following code:\nimport tornado.httpclient\nhttp_client = tornado.httpclient.HTTPClient()\nhttp_client.fetch(\"https://www.lifeasastrawberry.com/easy-crusty-french-bread/\")\nTornado hangs forever. Hitting ctrl-C seems to show the hang in some decompression code. Probably the same issue as reported in #1755, so I added the debugging code mentioned there to _GzipMessageDelegate.data_received():\nif compressed_data and not decompressed:\n    raise Exception(\"Returned unconsumed tail without making progress. tail: %r chunk_size: %r\" % (compressed_data, self._chunk_size))\nRunning the above code with that in place does trigger the exception:\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"/Users/jhunter/Code/tornado-6.0.3/tornado/http1connection.py\", line 659, in _read_fixed_body\n    await ret\n  File \"/Users/jhunter/Code/tornado-6.0.3/tornado/http1connection.py\", line 739, in data_received\n    raise Exception(\"Returned unconsumed tail without making progress. tail: %r chunk_size: %r\" % (compressed_data, self._chunk_size))\nException: Returned unconsumed tail without making progress. tail: b'\\x00' chunk_size: 65536\nNot sure what lifeasastrawberry.com is doing here, but Tornado really doesn't like it.", "issue_status": "Open", "issue_reporting_time": "2019-07-26T01:20:16Z"}, "20": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2711", "issue_id": "#2711", "issue_summary": "on_finish() not called after max body size hit", "issue_description": "dylanbfox commented on 25 Jul 2019\nI override self.request.connection.set_max_body_size(XXXXXX) and set it to some value, say 5MB. I also depend on on_finish() to do some cleanup once the request finishes. If the connection is closed with the client because the body size limit is hit, on_finish does not get called.", "issue_status": "Open", "issue_reporting_time": "2019-07-24T21:29:55Z"}, "21": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2710", "issue_id": "#2710", "issue_summary": "function based wsgi container and return value bytes expected", "issue_description": "emattiza commented on 25 Jul 2019\nIn going through the docs, i saw a snippet to test a wsgi container, and ran as-is in a fresh environment. What i encountered was an error related to the docs such that the return value did not encode to bytes to send as the output of the WSGI container rudimentary function. Specifically, in https://www.tornadoweb.org/en/stable/wsgi.html\nimport tornado\nimport tornado.wsgi\nimport tornado.httpserver\nimport tornado.ioloop\n\ndef simple_app(environ, start_response):\n    status = \"200 OK\"\n    response_headers = [(\"Content-type\", \"text/plain\")]\n    start_response(status, response_headers)\n    return [\"Hello world!\\n\"]\n\ncontainer = tornado.wsgi.WSGIContainer(simple_app)\nhttp_server = tornado.httpserver.HTTPServer(container)\nhttp_server.listen(8888)\ntornado.ioloop.IOLoop.current().start()\nThe fix i applied was to change\nreturn [\"Hello world!\\n\"]\ninto\nreturn [\"Hello world!\\n\".encode(\"utf-8\")]\nWould a docs update suffice to contain this? Worth putting in a doc test? I would be a first time contributor here for the PR if so.\nThanks!", "issue_status": "Open", "issue_reporting_time": "2019-07-24T21:09:24Z"}, "22": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2702", "issue_id": "#2702", "issue_summary": "Provide default User-Agent in SimpleAsyncHTTPClient", "issue_description": "yan12125 commented on 5 Jul 2019\nFrom https://tools.ietf.org/html/rfc7231:\nA user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so.\nCurlAsyncHTTPClient provides default User-Agent string:\ntornado/tornado/curl_httpclient.py\nLines 380 to 383 in c92b883\n if request.user_agent: \n     curl.setopt(pycurl.USERAGENT, native_str(request.user_agent)) \n else: \n     curl.setopt(pycurl.USERAGENT, \"Mozilla/5.0 (compatible; pycurl)\") \nWhile SimpleAsyncHTTPClient writes User-Agent only when it's provided by the user:\ntornado/tornado/simple_httpclient.py\nLines 393 to 396 in c92b883\n if self.request.user_agent: \n     self.request.headers[\"User-Agent\"] = self.request.user_agent \n if not self.request.allow_nonstandard_methods: \n     # Some HTTP methods nearly always have bodies while others \nCould you consider adding default User-Agent string in SimpleAsyncHTTPClient?", "issue_status": "Open", "issue_reporting_time": "2019-07-05T01:05:29Z"}, "23": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2700", "issue_id": "#2700", "issue_summary": "BufferError: Existing exports of data: object cannot be re-sized", "issue_description": "rahultaing commented on 4 Jul 2019 \u2022\nedited\nWe have a single threaded application using tornado 4.5.3. The application calls stream.write to flush data downstream. We wrote a UT in which we mock the write_to_fd to return 0 bytes. We are trying to replicate a scenario in which the self._write_buffer would continually grow if no bound has been specified.\nThis test results in a BufferError every time the self._write_buffer is being updated either in write method self._write_buffer += data or in _handle_write method del self._write_buffer[:self._write_buffer_pos]\nLet me know if there is other information we can share to help root cause this issue.", "issue_status": "Open", "issue_reporting_time": "2019-07-04T01:09:47Z"}, "24": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2689", "issue_id": "#2689", "issue_summary": "CertificateErrors raised during handshare are uncaught", "issue_description": "kleptog commented on 25 Jun 2019\nWhen using the SSL Websocket we ran into the problem where CertificateErrors raised during _do_ssl_handshake() are sent straight to the global callback exception handler.\n2019-06-25 13:18:33,402 ERROR    tornado.general Uncaught exception, closing connection.\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 709, in _handle_events\n    self._handle_read()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 1581, in _handle_read\n    self._do_ssl_handshake()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 1501, in _do_ssl_handshake\n    self.socket.do_handshake()\n  File \"/usr/lib/python2.7/ssl.py\", line 848, in do_handshake\n    match_hostname(self.getpeercert(), self.server_hostname)\n  File \"/usr/lib/python2.7/ssl.py\", line 286, in match_hostname\n    % (hostname, dnsnames[0]))\nCertificateError: hostname u'192.168.132.79' doesn't match u'test-server'\nSeems to me that the IOStream should be handling certificate errors just like the other errors and passing them back to the user.\nI'll push a patch shortly.", "issue_status": "Open", "issue_reporting_time": "2019-06-25T16:25:12Z"}, "25": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2680", "issue_id": "#2680", "issue_summary": "Improve autoreload performance with many files", "issue_description": "RoelWKramer commented on 13 Jun 2019 \u2022\nedited\nCurrently when running tornado with autoreload, especially on VM's, the CPU usage is extremely high. For example:\nWe are running our development environment with docker. It loads around 400 files. It does a stat on every file and it is causing 100% cpu load on one of my cores. I am not using the latest mac book (2015) but my colleagues are using more recent models, which also suffer from high cpu usage. The load gets higher, on more cores, especially when running a few microservices in containers.\nThe CPU load is caused by the way autoreload is implemented. It just does a 'stat' on all imported python files every N seconds. There are much better ways to do that, for example: mechanisms like inotify, which is available on linux. Or use something like watchman, which supports many modes and has proven to work with a huge amounts of files. Watchman is used in javascript land quite a lot and can cope with file changes in huge projects. It can watch (parts of) node_modules/ for example. Additionally django is using watchman now as well.\nNote: Inotify is not cross platform, stat is working on all platforms i guess. Different platforms have different better solutions. Watchman covers that, but introduces a lot of dependencies.\nWhat would be nice is if there was a way of choosing/configuring autoreload mechanisms. The \"old\" stat autoreload plugin can then be used by default. Custom autoreload plugins can then be implemented by developers, or different plugins can be shipped together with tornado.\nSo the proposed solution is two fold:\nImplement plugin structure\nImplement the stat reloader as a plugin\nWhat i hope that happens afterward by the community\nImplement os specific reloaders, starting with inotify for linux\nImplement watchman reloader, which covers everything.\nCurrently web.py already has a configuration for enabling autoreload (self.settings.get(\"autoreload\")). What could be added is an option which defaults to the stat plugin loader (\"autoreload_stat\") or if a setting is available tries to load that plugin.\nself.settings.get(\"autoreload_plugin\", default=\"autoreload_stat\")\nSide note: When going through the tickets i also discovered this issue, which can be solved with a (3rd party) watchman plugin i think.\n4", "issue_status": "Open", "issue_reporting_time": "2019-06-13T10:49:24Z"}, "26": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2676", "issue_id": "#2676", "issue_summary": "docs: Upgrade to sphinx 2.1", "issue_description": "Member\nbdarnell commented on 10 Jun 2019\nSphinx 2.1 breaks our docs build. The first break is that it is incompatible with sphinxcontrib-asyncio (it has its own built-in version). It also breaks references to built-in types as noted in #2673 (comment).", "issue_status": "Open", "issue_reporting_time": "2019-06-09T21:12:34Z"}, "27": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2672", "issue_id": "#2672", "issue_summary": "A Template's 'include' statement always assumes literal strings", "issue_description": "castrapel commented on 7 Jun 2019\nHello,\nThe \"include\" verbiage in a template will not evaluate functions.formatted strings, or f-strings as an argument. Subsequently, this works:\n{% include \"../templates/header.html\" %}\nBut this does not:\n{% import os %}\n{% include os.get_cwd() + \"/templates/header.html\" %}\nNor do any of the following:\n{% include f\"os.get_cwd()/templates/header.html\" %}\n{% include  \"{}/templates/header.html\".format(os.get_cwd()) %}\n{% set header = f\"os.get_cwd()/templates/header.html\" %}\n{% include header %}\nIt seems like the input is always string'ified and never eval'ed. Is there a workaround for providing dynamic paths to the include call? Can we call the function directly somehow to include it in the template?\nThanks.", "issue_status": "Open", "issue_reporting_time": "2019-06-06T21:55:38Z"}, "28": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2671", "issue_id": "#2671", "issue_summary": "Add example how to connect via UNIX socket with httpclient", "issue_description": "spaceone commented on 5 Jun 2019\nIt would be very nice if there would be an example in the documentation how one can connect to a UNIX socket with tornado.httpclient.\nI currently could not figure out how to do this.", "issue_status": "Open", "issue_reporting_time": "2019-06-05T07:09:29Z"}, "29": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2668", "issue_id": "#2668", "issue_summary": "suggestion to add contributing doc in Readme", "issue_description": "malingyan2017 commented on 26 May 2019\nHi,\nI noticed that in the readme file, there is no contributing guide or authors' contact information.\nalthough that information is presented in your website, I feel that it might be beneficial to have the how to contribute guide in the readme file, since it is the very first place people would look at when they open the page in Github.\nThank you!\n1\n1", "issue_status": "Open", "issue_reporting_time": "2019-05-26T03:12:15Z"}, "30": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2666", "issue_id": "#2666", "issue_summary": "Add ASGI support", "issue_description": "pylorak commented on 24 May 2019 \u2022\nedited\nThis is a feature request / proposal to add ASGI support to tornado. Advantages are twofold:\nIt would \"automatically\" add HTTP/2-support to tornado given a suitable server like hypercorn or daphne. (#1438)\nIt would allow tornado users to choose their own (present or future) server to use with the tornado framework.\n6", "issue_status": "Open", "issue_reporting_time": "2019-05-23T20:11:27Z"}, "31": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2657", "issue_id": "#2657", "issue_summary": "tornado server close connection actively", "issue_description": "lxgithub24 commented on 10 May 2019\ni have a question here. could u please help me?@bdarnell\n#1200\nbelow is detail of this question:\nIt was a fairly arbitrary choice; I don't know how long browsers keep connections open. If the client closes its connection then Tornado should notice immediately; the hour timeout is the longest Tornado will wait for any client who doesn't close its connection. It's conservative because there was no limit before and so we didn't want to cut off connections prematurely for anyone who may be relying on this.\nAlso note that the default limits for file descriptors are quite low and there's no harm in increasing them significantly for Tornado servers - I generally set the limit to 50K on the servers I'm responsible for.\nI have two question:\n1.how to set the fd(file descriptors) count? is it a parameter tornado?\n2.the idle_connection_timeout default is 3600 second. In my tornado server, i set it to 31536000000(1000 years).\nconsidering the second one, it seems that i don't understand this parameter. i understand it a parameter that if the client don't request for anything after 'idle_connection_timeout' seconds, the server will close the connection directly. in that way, whether the client know that the server has already close the connection if the connection itself is a long connection.\ni asked for this because my company runs application online, but something beyond my expectation happens. my application runs behind a gateway service(zuul: a springcloud Dalston.SR2 service), and zuul send request to me with a keep alive connection. But sometimes the tornado server can't get the zuul request, when i read the tcp message (use tools: tcpdump and wireshark), i found that the client send request with an old connection that server almost close, so tornado server response the client with tcp.flags.reset==1, and zuul regard this as tornado server timeout.\nI was confused by this question for as long as a month. if there is something wrong i was doing, tell me.\nbelow is some code of my application:\nasync def main():\n    await eureka.register()\n    app = tornado.web.Application(handlers=rest_apis_handler, template_path=os.path.join(os.path.dirname(__file__),\"cangjie_gateway/utils/templates\"))\n    server = tornado.httpserver.HTTPServer(app, idle_connection_timeout=31536000000)\n    server.listen(port)\n    prerequest.smooth_reload(server)\n    while True:\n        await asyncio.sleep(60)\n        await eureka.renew()\nit confused me. hope for your reply!! @bdarnell", "issue_status": "Open", "issue_reporting_time": "2019-05-10T05:52:50Z"}, "32": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2655", "issue_id": "#2655", "issue_summary": "Units for websocket ping values", "issue_description": "akarukappadath commented on 6 May 2019\nI'm trying to set the websocket_ping_interval and websocket_ping_timeout values for a tornado websocket, but I'm not seeing any units mentioned in the docs (https://www.tornadoweb.org/en/stable/websocket.html). Is it just expecting an integer value? If yes, seconds or milliseconds?", "issue_status": "Open", "issue_reporting_time": "2019-05-06T14:55:13Z"}, "33": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2647", "issue_id": "#2647", "issue_summary": "LogFormatter: allow color support when sys.stderr.isatty() == False", "issue_description": "Contributor\njavabrett commented on 24 Apr 2019\nLogFormatter:\ntornado/tornado/log.py\nLine 81 in c447875\n class LogFormatter(logging.Formatter): \n\n... has very nice support for color logging via curses (or colorama).\nMy issue is with the test sys.stderr.isatty() in:\ntornado/tornado/log.py\nLines 55 to 71 in c447875\n def _stderr_supports_color() -> bool: \n     try: \n         if hasattr(sys.stderr, \"isatty\") and sys.stderr.isatty(): \n             if curses: \n                 curses.setupterm() \n                 if curses.tigetnum(\"colors\") > 0: \n                     return True \n             elif colorama: \n                 if sys.stderr is getattr( \n                     colorama.initialise, \"wrapped_stderr\", object() \n                 ): \n                     return True \n     except Exception: \n         # Very broad exception handling because it's always better to \n         # fall back to non-colored logs than to break at startup. \n         pass \n     return False \nThe LogFormatter might be able to be attached to a handler which is not writing to stderr type stream, but to some other TTY-capable device, which I have in my case. The syserr TTY test prevents attaching the LogFormatter to such logger handler and having color support.\nIf I monkey-patch _stderr_supports_color() to lambda: True, and make sure I make a call to curses.setupterm(fd=...), passing the fd of my TTY-capable stream, then I can log with the color support from LogFormatter, which is nice.\nMaybe the best fix is to change color: True to None, but default based on the detection above, or if set to True explicitly by the caller, honour that.", "issue_status": "Open", "issue_reporting_time": "2019-04-24T02:40:48Z"}, "34": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2639", "issue_id": "#2639", "issue_summary": "Dead link in modules documentation", "issue_description": "gruentee commented on 3 Apr 2019 \u2022\nedited\nThere is a dead link on the modules documentation index:\nhttp://www.tornadoweb.org/en/stable/_modules/_asyncio.html\nfun fact: I discovered this by executing the web spider example from the docs :-)", "issue_status": "Open", "issue_reporting_time": "2019-04-03T16:24:37Z"}, "35": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2635", "issue_id": "#2635", "issue_summary": "`start_tls` infinite loops if alert is sent during handshake", "issue_description": "jcrist commented on 28 Mar 2019\nI have a TLS proxy server that uses the SNI in the handshake to do the routing. When the SNI specified isn't found, alert 112 (Unrecognized name) is sent as a fatal alert, and the connection is closed (relevant code: https://github.com/jcrist/dask-gateway/blob/master/dask-gateway-proxy/schedulerproxy.go#L164-L168).\nEverything works fine if the SNI name is valid, but in the case of an unrecognized SNI, tornado infinite loops when awaiting on start_tls. I've debugged this down to Python's ssl implementation raising SSLErrorWantRead, which causes tornado to retry (https://github.com/tornadoweb/tornado/blob/master/tornado/iostream.py#L1392-L1394). I'm not sure why that error is being raised on the alert - it may be a problem with my server code, but I've checked things with both a go client and openssl s_client and things seem to work fine there.\nApologies for not providing a minimal reproducible issue here - figured I'd see if anyone had any ideas on this before spending time making a minimal issue.", "issue_status": "Open", "issue_reporting_time": "2019-03-28T18:10:43Z"}, "36": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2621", "issue_id": "#2621", "issue_summary": "Trouble using websockets behind Oauth2-proxy", "issue_description": "cbbba18 commented on 15 Mar 2019\nHi, I tried using bitly/oauth2_proxy#554 and got oauth2-proxy websockets working with a basic nodejs websocket connection successfully. Works great. But when I try with Jupyterlab (Tornado Server) I get \"Error during WebSocket handshake: Unexpected response code: 500\". Any ideas why tornado server in jupyter would have issue?", "issue_status": "Open", "issue_reporting_time": "2019-03-14T22:31:56Z"}, "37": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2620", "issue_id": "#2620", "issue_summary": "Memory issue: Possible reference cycle with run_on_executor", "issue_description": "peterkorodi commented on 12 Mar 2019 \u2022\nedited\nHi,\nI've built a simple tornado server app and run on python 3.7.2 with tornado 6.0.1:\nimport tornado.ioloop\nimport tornado.web\nimport gc\nimport sys\nfrom concurrent.futures.thread import ThreadPoolExecutor\n\nfrom tornado import gen\nfrom tornado.concurrent import run_on_executor\n\nexecutor = ThreadPoolExecutor(1)\n\n\ndef dump_referrers(obj):\n    print(sys.getrefcount(obj))\n    for i in gc.get_referrers(obj):\n        print('{} {}'.format(type(i).__name__, i))\n\n\nclass Test(object):\n    def __init__(self):\n        self.l = list(range(0, 100000))\n\n    def __del__(self):\n        print('del')\n\n\nclass Factory(object):\n    _executor = executor\n\n    @run_on_executor(executor='_executor')\n    def run(self):\n        test = Test()\n        return test\n\nfactory = Factory()\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def initialize(self):\n        print('Init MainHandler')\n\n    @gen.coroutine\n    def get(self):\n        test = yield factory.run()\n        dump_referrers(test)\n        self.write('data: {}'.format(test.l))\n        self.finish()\n        dump_referrers(test)\n\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nIf I call the endpoint with curl -i -X GET -H 'Content-Type: application/json' http://localhost:8888/\nI got the del text on the output of the server which means the ref count of test decreases to 0 and deleted by the system.\nBut If I call it more times. I don't have the del text anymore which means I guess there is a ref cycle which is will be deleted by the GC.\nIf I create a new run_on_executor_asyncio decorator and use the following code the test object always will be deleted.\nimport tornado.ioloop\nimport tornado.web\nimport gc\nimport sys\nfrom concurrent.futures.thread import ThreadPoolExecutor\nfrom tornado import gen\nfrom tornado.concurrent import run_on_executor\nimport asyncio\nimport functools\nfrom asyncio import Future\nfrom typing import Callable, Any\n\n\ndef run_on_executor_asyncio(*args: Any, **kwargs: Any) -> Callable:\n    def run_on_executor_decorator(fn: Callable) -> Callable[..., Future]:\n        _executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -> Future:\n            f = getattr(self, _executor).submit(fn, self, *args, **kwargs)\n            return asyncio.wrap_future(f)\n\n        return wrapper\n\n    if args and kwargs:\n        raise ValueError(\"cannot combine positional and keyword args\")\n    if len(args) == 1:\n        return run_on_executor_decorator(args[0])\n    elif len(args) != 0:\n        raise ValueError(\"expected 1 argument, got %d\", len(args))\n    return run_on_executor_decorator\n\n\n\nexecutor = ThreadPoolExecutor(1)\n\n\ndef dump_referrers(obj):\n    print(sys.getrefcount(obj))\n    for i in gc.get_referrers(obj):\n        print('{} {}'.format(type(i).__name__, i))\n\n\nclass Test(object):\n    def __init__(self):\n        self.l = list(range(0, 100000))\n\n    def __del__(self):\n        print('del')\n\n\nclass Factory(object):\n    _executor = executor\n\n    @run_on_executor_asyncio(executor='_executor')\n    def run(self):\n        test = Test()\n        return test\n\nfactory = Factory()\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def initialize(self):\n        print('Init MainHandler')\n\n    @gen.coroutine\n    def get(self):\n        test = yield factory.run()\n        dump_referrers(test)\n        self.write('data: {}'.format(test.l))\n        self.finish()\n        dump_referrers(test)\n\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nI know that the ref cycles will be removed by GC but If I call that endpoint frequently the memory usage can go up more than 1GB before the GC starts. With the second version of code I can't go up to 100MB.\nIs it possible that this is a bug in the run_on_executor decorator?", "issue_status": "Open", "issue_reporting_time": "2019-03-12T17:03:10Z"}, "38": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2619", "issue_id": "#2619", "issue_summary": "Web Socket Client Proxy support", "issue_description": "wtflanders commented on 12 Mar 2019\nAdd or modify web socket client class to take a proxy setting like the curl_httpclient class does.\nThis is a roadblock for connecting to a Websocket server, behind a corporate proxy, from a Tornado client python app.", "issue_status": "Open", "issue_reporting_time": "2019-03-12T16:30:03Z"}, "39": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2600", "issue_id": "#2600", "issue_summary": "Tornado Template i18n extract the text waited to translate", "issue_description": "mywaiting commented on 27 Feb 2019\nHello:\nI use tornado template in my website, and I need to take i18n to my website. This is a sample HTML template in my application\n  <div class=\"page404\">\n   <h1>{{ _(\"Page Not Found\") }}</h1>\n   <div class=\"markdown\">\n    <p>{{ _('You requested URL') }} </p>\n    <p>{{ _('Thats all we know.') }}</p>\n   </div>\n  </div>\nAs we know, _('xxxxx') is the i18n text waited to translate, but, if you used tornado template, You may NOT find any tools to extract those text as message.pot or en_US.cvs to take the translation.\nI found pybabel can extract the text fron jinja2 template, but it is NOT suitable to tornado template. As the same, GNU gettext not support HTML template to extract the text.\nAfter I review the source code of pybabel, I found it is simple to integreted to tornado template, What I need is just add some functions in tornado.locale, it is simeple and not much code, it will enhance tornado i18n.\nIf anyone like this and need the code to extract tornado template HTML file gettext string, I am happy to share how I do it.\nAnd more, if Ben like this, please feel free to leave a comment, I will make a PR ASAP.", "issue_status": "Open", "issue_reporting_time": "2019-02-27T16:16:36Z"}, "40": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2599", "issue_id": "#2599", "issue_summary": "Adding (user) callback to normalize option value ?", "issue_description": "rmedaer commented on 22 Feb 2019\nHere is my usecase: I create a tornado HTTPServer and its Application. They are configured with options both from parse_command_line and parse_config_file. For instance I define the option:\noptions.define(\n    'a-file-to-load',\n    type=str,\n    metavar='path',\n    help='This file will be loaded later in the application')\nI parse my config, initialize the app, start the HTTPServer; everything is going well. Then when everything is OK I daemonize my process. One of the operation is to change the current working directory to /. But my a-file-to-load option is maybe a relative path. When I try to open it later, it fails.\nMy concern is here to normalize my option value after parsing. I did try to put a callback:\ndef normalize_callback(path):\n    options.a_file_to_load = os.path.abspath(path)\nBut it loops recursively on the callback (because _Option#set method is actually calling the callback as well).\nMy question is: can we add a callback to normalize the option value or can we pass a flag to callback to avoid recursion ? Otherwise do you have any good idea to handle this use case ?", "issue_status": "Open", "issue_reporting_time": "2019-02-22T09:52:12Z"}, "41": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2597", "issue_id": "#2597", "issue_summary": "Redirect HTTP to HTTPS (for Heroku)", "issue_description": "Lucaszw commented on 21 Feb 2019\nI am running an instance of JupyterLab on Heroku.\nhttps://github.com/heroku/heroku-jupyterlab\nHeroku handles the SSL certificate but requires the WebServer on the app level to handle the redirecting:\nhttps://help.heroku.com/J2R1S4T8/can-heroku-force-an-application-to-use-ssl-tls\nThis seems to be possible with Django & Flask; but I can't seem to find any options for configuring Tornado to do the same (which is used to power JupyterLab).\nIt would be nice to have an option similar to in Rails and Django like config.force_ssl = true etc.", "issue_status": "Open", "issue_reporting_time": "2019-02-21T16:32:30Z"}, "42": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2596", "issue_id": "#2596", "issue_summary": "on windows sometimes WebSocket messages never received", "issue_description": "jonathon-love commented on 20 Feb 2019\nhi,\nwe use tornado in our desktop application, and we do have super-obscure issues on windows machines from time to time (this was an earlier one for example: https://github.com/tornadoweb/tornado/issues/2347)\nthe latest one is that on a couple of machines on_message() of WebSocket is never called. at a js console i go:\nlet ws = new WebSocket('ws://127.0.0.1:XX/coms')\nand open() in WebSocket is called (and returns)\nbut ws.send('fred') does not result in on_message() being called (the message fred does appear in the frames of the connection in the js dev tools however)\nif at the js console i go:\nws.close()\non_close() is called, but not for a while ... so it looks like it times out.\ni appreciate this is almost definitely a \"yeah, windows is sometimes weird\" issue, but i did wonder if you had any suggestions for debugging this. these issues are ultra-rare, i'd guess they affect < 1 in 1000 of our windows users.\nwith thanks\n1", "issue_status": "Open", "issue_reporting_time": "2019-02-20T02:06:15Z"}, "43": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2583", "issue_id": "#2583", "issue_summary": "tornado/test/gen_test.py:test_multi_performance is non-reproducible", "issue_description": "QuLogic commented on 5 Feb 2019\nThe test_multi_performance in tornado/test/gen_test.py tests that some bit of code executes in 1 second. Not only is this timing arbitrary, but it is not reproducible. On slow or loaded systems, it may or may not pass.\nIf it is possible, testing some kind of ratio would be better, or just removing the test altogether.", "issue_status": "Open", "issue_reporting_time": "2019-02-05T10:58:49Z"}, "44": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2575", "issue_id": "#2575", "issue_summary": "How to / doc: async configuration / awaitable loop.start()", "issue_description": "dimaqq commented on 24 Jan 2019 \u2022\nedited\nUser guide advocates following to start a web server:\napplication = ...\napplication.listen(...)\nIOLoop.current().start()\nNow let's bring in some async library and use that to get application config:\nconfig = IOLoop.current().run_sync(get_config_from_async_db)\napplication = SomeApp(config, ...)\napplication.listen(config[\"port\"])\nIOLoop.current().start()\nThen comes aio-libs/aiohttp#3331 where iohttp (kinda rightfully) decided that asyncio.get_event_loop().is_running() should be True.\nNow SomeApp constructor is going to create a aiohttp.TCPConnector(...) (a transitive dependency), which makes aiohttp unhappy (warning only, nothing is awaited at this point, but iohttp takes a reference to current event loop).\nI wish I could express application setup and start as:\nasync def main():\n    config = await get_config_from_async_db()\n    application = SomeApp(config, ...)\n    application.listen(config[\"port\"])\n    await application.serve_forever()\n\nasyncio.run(main())  # Or IOLoop.current().run(main())\nI this something like this would also be useful in tests, where a server may be started and stopped for each test.\nP.S. I apologise if this was covered somewhere and I couldn't find a doc or past issue.", "issue_status": "Open", "issue_reporting_time": "2019-01-24T05:08:33Z"}, "45": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2573", "issue_id": "#2573", "issue_summary": "support samesite xsrf cookie", "issue_description": "Contributor\nminrk commented on 18 Jan 2019\nA somewhat more recent approach to CSRF is setting samesite=strict on a cookie. SameSite is handy because it allows the browser to enforce the same-site-ness of a request, without needing application code to send the token separately. SameSite can be used almost everywhere, but not quite. It would be handy to support this strategy of csrf checking (cookie is present and samesite=strict) as equivalent to the current check of token delivery by both cookie and argument.\nIf I wanted to adopt this strategy now, do you suppose it would be preferable to:\ncreate a new samesite cookie for this purpose and implement my own handling, or\nmodify tornado's xsrf handling to attempt to apply samesite restrictions on the cookie\n?\nUnfortunately, only Python 3.8 has support for setting samesite cookies in the stdlib. This is easily patched (Morsel._reserved['samesite'] = 'SameSite'), but needing a patch is never great.\n4", "issue_status": "Open", "issue_reporting_time": "2019-01-18T11:20:43Z"}, "46": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2571", "issue_id": "#2571", "issue_summary": "Feature request: sock5 TCPClient", "issue_description": "dqzg12300 commented on 17 Jan 2019\nHow to Set up Sock5 and use tcpclient", "issue_status": "Open", "issue_reporting_time": "2019-01-17T02:48:51Z"}, "47": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2548", "issue_id": "#2548", "issue_summary": "Broken routing for urlencoded paths", "issue_description": "spaceone commented on 5 Dec 2018\nself.request.path is the raw urlencoded path from the HTTP start line (i.e. it doesn't even normalize anything and takes whatever the client gives).\nThe router PathMatches uses this to match the path against this.\nHaving a route definition like:\napplication = Application([\n(r\"/(cn=.*)/\", MainHandler),\n])\nfails for /cn%3Dfoo/ and /cn%3dfoo/ but not for /cn=foo/.\nA workaround is:\napplication = Application([\n(r\"/(cn(?:=|%3D|%3d).*)/\", MainHandler),\n])\nIn general I think it's wrong that request.path contains the urlencoded form of the path. It should be decoded. But it's probably an issue for backwards compatibility?\nAt least the routing component could decode the path before applying it to the routes!", "issue_status": "Open", "issue_reporting_time": "2018-12-05T11:14:33Z"}, "48": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2546", "issue_id": "#2546", "issue_summary": "SimpleAsyncHTTPClient randomly blocking on \"ValueError: IOStream is not idle; cannot convert to SSL\"", "issue_description": "kardaj commented on 3 Dec 2018 \u2022\nedited\nHi, I'm using SimpleAsyncHTTPClient to perform a few hundred requests per minute. It has been working fine until I started encountering the error below. This error happens randomly (I didn't manage to replicate it) and once it occurs, the SimpleAsyncHTTPClient fails on all his following requests (Timeout while connecting). A process restart solves the problem until the error occurs again. Any idea where this comes from or how to handle it?\nI tried catching it and managed to close the client and create a new instance, but it still can't perform HTTP requests until the program is restarted.\nERROR:tornado.application:Exception in callback <functools.partial object at 0x7f6a3894c3c0>\nTraceback (most recent call last):\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 758, in _run_callback\n    ret = callback()\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 779, in _discard_future_result\n    future.result()\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/gen.py\", line 1141, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/simple_httpclient.py\", line 272, in run\n    max_buffer_size=self.max_buffer_size)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/gen.py\", line 1147, in run\n    yielded = self.gen.send(value)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/tcpclient.py\", line 242, in connect\n    server_hostname=host)\n  File \"/home/ubuntu/env/local/lib/python2.7/site-packages/tornado/iostream.py\", line 1368, in start_tls\n    raise ValueError(\"IOStream is not idle; cannot convert to SSL\")\nValueError: IOStream is not idle; cannot convert to SSL\nI'm using tornado 5.1.1 on Python 2.7.15 and here's a snippet of how I initialize the HTTPClient:\n    client = AsyncHTTPClient(force_instance=True)\n    client.initialize(max_clients=200)", "issue_status": "Open", "issue_reporting_time": "2018-12-03T11:05:30Z"}, "49": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2542", "issue_id": "#2542", "issue_summary": "pycurl.error: curl object not on this multi-stack", "issue_description": "Contributor\nlilydjwg commented on 28 Nov 2018 \u2022\nedited\nTraceback\nThis error happens to me for the following combinations:\nwith my nvchecker program\nand some configurations passed to it. Here is one I've trimmed down to 22 items (I can't reproduce it with less items)\nthis happens on our own home machines (three have been found), not on a server I have tried (the server has an old curl.)\ndoesn't happen with self-made HTTP servers (I've tried to add random delays)\neasily reproducible here (maybe 50% or higher)\nwith Tornado 5.1.1 and master\npycurl 7.43.0.2-2 and curl 7.62.0-1 on Arch Linux x86_64\nI've added some logging and find that\nIn pycurl curl_multi_info_read gives out the same msg->easy_handle twice in a row\n_finish_pending_requests gets the same curl object twice in a row and tries to remove it twice\npycurl fails because it doesn't like that. curl_multi_remove_handle actually just ignores it if it's already removed\nI suggest that Tornado simply ignore this error and continue.", "issue_status": "Open", "issue_reporting_time": "2018-11-28T13:52:50Z"}, "50": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2536", "issue_id": "#2536", "issue_summary": "Tornado 4.5.3 hangs with openssl 1.1.1 and TLS 1.3", "issue_description": "bdrung commented on 15 Nov 2018\nI want to package the Python 3 version of tornado 4.5.3 (the latest 4.x release) for Debian unstable, because salt does not work with tornado 5 yet. See saltstack/salt-jenkins#995 for details.\nI updated the test certificate and tweaked the source code to work with Python 3.7:\nhttps://salsa.debian.org/python-team/modules/python-tornado/commit/2c6f99ca6c18d5934a97fb9e6d5d4fa9030efe42\nhttps://salsa.debian.org/python-team/modules/python-tornado/commit/19e541067a64b451ee31b7a3400c48ef61ec082d\nSadly the a few test cases still fail on Debian unstable (they succeed on Ubuntu 18.04):\n======================================================================\nERROR: test_inline_read_error (tornado.test.iostream_test.TestIOStreamSSL)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 556, in test_inline_read_error\n    server.read_bytes(1, lambda data: None)\n  File \"/usr/lib/python3.7/unittest/case.py\", line 203, in __exit__\n    self._raiseFailure(\"{} not raised\".format(exc_name))\n  File \"/usr/lib/python3.7/unittest/case.py\", line 135, in _raiseFailure\n    raise self.test_case.failureException(msg)\nAssertionError: OSError not raised\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 558, in test_inline_read_error\n    server.close()\n  File \"/tmp/building/package/tornado/iostream.py\", line 444, in close\n    self.close_fd()\n  File \"/tmp/building/package/tornado/iostream.py\", line 1042, in close_fd\n    self.socket.close()\n  File \"/usr/lib/python3.7/socket.py\", line 420, in close\n    self._real_close()\n  File \"/usr/lib/python3.7/ssl.py\", line 1108, in _real_close\n    super()._real_close()\n  File \"/usr/lib/python3.7/socket.py\", line 414, in _real_close\n    _ss.close(self)\nOSError: [Errno 9] Bad file descriptor\n\n======================================================================\nERROR: test_inline_read_error (tornado.test.iostream_test.TestIOStreamSSLContext)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 556, in test_inline_read_error\n    server.read_bytes(1, lambda data: None)\n  File \"/usr/lib/python3.7/unittest/case.py\", line 203, in __exit__\n    self._raiseFailure(\"{} not raised\".format(exc_name))\n  File \"/usr/lib/python3.7/unittest/case.py\", line 135, in _raiseFailure\n    raise self.test_case.failureException(msg)\nAssertionError: OSError not raised\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 558, in test_inline_read_error\n    server.close()\n  File \"/tmp/building/package/tornado/iostream.py\", line 444, in close\n    self.close_fd()\n  File \"/tmp/building/package/tornado/iostream.py\", line 1042, in close_fd\n    self.socket.close()\n  File \"/usr/lib/python3.7/socket.py\", line 420, in close\n    self._real_close()\n  File \"/usr/lib/python3.7/ssl.py\", line 1108, in _real_close\n    super()._real_close()\n  File \"/usr/lib/python3.7/socket.py\", line 414, in _real_close\n    _ss.close(self)\nOSError: [Errno 9] Bad file descriptor\n\n======================================================================\nFAIL: test_read_until_close_after_close (tornado.test.iostream_test.TestIOStreamSSL)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 451, in test_read_until_close_after_close\n    data = self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n======================================================================\nFAIL: test_streaming_read_until_close_after_close (tornado.test.iostream_test.TestIOStreamSSL)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 481, in test_streaming_read_until_close_after_close\n    data = self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n======================================================================\nFAIL: test_write_zero_bytes (tornado.test.iostream_test.TestIOStreamSSL)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 220, in test_write_zero_bytes\n    self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n======================================================================\nFAIL: test_read_until_close_after_close (tornado.test.iostream_test.TestIOStreamSSLContext)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 451, in test_read_until_close_after_close\n    data = self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n======================================================================\nFAIL: test_streaming_read_until_close_after_close (tornado.test.iostream_test.TestIOStreamSSLContext)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 481, in test_streaming_read_until_close_after_close\n    data = self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n======================================================================\nFAIL: test_write_zero_bytes (tornado.test.iostream_test.TestIOStreamSSLContext)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/building/package/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/building/package/tornado/test/iostream_test.py\", line 220, in test_write_zero_bytes\n    self.wait()\n  File \"/tmp/building/package/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/tmp/building/package/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/tmp/building/package/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\nYou can see the full build and test long here: https://salsa.debian.org/python-team/modules/python-tornado/-/jobs/77766 (you can ignore the test cases that fail with \"Cannot assign requested address\")\n1", "issue_status": "Open", "issue_reporting_time": "2018-11-15T16:08:11Z"}, "51": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2533", "issue_id": "#2533", "issue_summary": "StreamClosedError not raised when connecting to a TLS server when using incorrect certificates", "issue_description": "mariusvniekerk commented on 9 Nov 2018\nUnder some conditions (Python built against openssl 1.1+). Tornado does not raise a StreamClosedError when encountering UNKNOWN_CA errors.\nSee dask/distributed#2331 for a manifestation of this issue (and a mitigation)\nWhen using correct certificates the behavior is as expected.", "issue_status": "Open", "issue_reporting_time": "2018-11-08T21:52:27Z"}, "52": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2517", "issue_id": "#2517", "issue_summary": "Response time too long", "issue_description": "mangdian commented on 19 Oct 2018\nI use tornado to build a web service sever. Client use http to call the interface. The response time is about 1 second when the server is started. However, after several hours later, the response time keeps increasing, reaching about 20 minutes, which is unacceptable. Why would this happen? How can I solve it? Thanks.", "issue_status": "Open", "issue_reporting_time": "2018-10-19T02:07:13Z"}, "53": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2515", "issue_id": "#2515", "issue_summary": "Possible websocket memory leak", "issue_description": "3shao commented on 12 Oct 2018\nUse websocket to send large amounts of data to Android, and the sending frequency is high. when tornado run for a long time , it will be killed by system. What can I do?", "issue_status": "Open", "issue_reporting_time": "2018-10-12T02:50:04Z"}, "54": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2511", "issue_id": "#2511", "issue_summary": "Mixing Unnamed and Named Capture Groups in URLSpecs", "issue_description": "Contributor\nkippandrew commented on 3 Oct 2018 \u2022\nedited\nI know this is not currently supported, but I am very curious if that is for a philosophical reason, or a technical one. I would be interested in submitting a patch, but it would be great to get some context on this before I head down the rabbit hole. I also know its possible to add a custom route matcher, but my feeling is that this might be something many people would be interested in seeing supported out of the box.\nFor completeness, an example URL spec I wish was supported is:\n/foo/([0-9]+)/bar/([0-9]+)/properties/(?P<name>[A-Za-z0-9_\\.\\-]+)/?$\nAnd request handler method signature:\ndef get(self, *parent_ids, name=None)", "issue_status": "Open", "issue_reporting_time": "2018-10-02T21:54:45Z"}, "55": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2507", "issue_id": "#2507", "issue_summary": "peeking a read buffer", "issue_description": "mariusnita commented on 22 Sep 2018\nHi, it seems like the BaseIOStream read buffer does not support a peek operation (or, equivalently, a putback operation). This would be useful for example to parse a proxy protocol header if available, and if not default to base behavior. Is there a deep reason why peeking is not supported?", "issue_status": "Open", "issue_reporting_time": "2018-09-22T00:22:50Z"}, "56": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2495", "issue_id": "#2495", "issue_summary": "TLS 1.2 OCSP Stapling?", "issue_description": "knightcode commented on 16 Sep 2018\nI get my certificates from letsencrypt.org. They have an option called --must-staple that configures the certificate so as to require a browser to ensure my webserver responds to an OCSP query (I think that's what it does anyway). They also have a --staple-ocsp option that I use as well. But it doesn't seem to affect the issue I'm having, which is that Firefox shows an error page for my certificate with must-staple set. Other browsers seem to be fine, and reconfiguring the cert without --must-staple also lets Firefox load my site.\nWhen I run this command:\n openssl s_client -connect myserver.com:443 -status\nThe second line of output is:\nOCSP response: no response sent\nSo that it seems like this is something the webserver needs to handle, and I'm unable to find any documentation for how to set this up. pyOpenSSL discusses it here. I don't know enough about the protocol to know with whom the responsibility lay.", "issue_status": "Open", "issue_reporting_time": "2018-09-15T21:49:44Z"}, "57": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2492", "issue_id": "#2492", "issue_summary": "Enable parsing HAProxy's Proxy protocol for TCP Servers", "issue_description": "eulersIDcrisis commented on 13 Sep 2018\nMost of the time, tornado runs an HTTP(S) server or similar, and can run behind something like nginx that can supply X-* headers to get the client's real IP address.\nHowever, Tornado is capable of running non-HTTP services over TCP; in these cases, some load balancers support passing the client IP information via the HAProxy Proxy Protocol, as described here:\nhttps://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\nIt would be handy to have the parsing of the proxy protocol to be built into Tornado, so that the client's real IP address can be acquired in the non-HTTP settings.\nIt would also be useful, specifically in the HTTP case, to autodetect the proxy protocol (if configured to do so, of course) and update everything accordingly so yet another nginx server or similar isn't required.", "issue_status": "Open", "issue_reporting_time": "2018-09-12T22:44:20Z"}, "58": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2485", "issue_id": "#2485", "issue_summary": "CurlAsyncHTTPClient can not save cookie using pycurl.COOKIEJAR", "issue_description": "zkdfbb commented on 29 Aug 2018 \u2022\nedited\nWhen I use CurlAsyncHTTPClient, it can not save cookies automatically, If I use the response header\nto parse cookies myself, I can not get cookies if it's a 302/301 redirection, since the header is from the following url. How can I solve this problem?\nmy code is here:\n`\ndef callback(curl):\ncurl.setopt(pycurl.COOKIEFILE, 'cookies.txt')\ncurl.setopt(pycurl.COOKIEJAR, 'cookies.txt')\nhttp = CurlAsyncHTTPClient()\nloop = asyncio.get_event_loop()\nloop.run_until_complete(http.fetch(url, prepare_curl_callback=callback))\n`", "issue_status": "Open", "issue_reporting_time": "2018-08-29T12:31:16Z"}, "59": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2468", "issue_id": "#2468", "issue_summary": "Write about experience of dropping Python 2 and using MyPy", "issue_description": "Contributor\nmrocklin commented on 13 Aug 2018\nIn perusing old issues I saw two things that interested me:\nTornado dropped Python 2 support\nTornado added type annotations and MyPy type checking\nI'm curious to learn more about the costs and benefits of taking these steps within a project like Tornado. I also think that I'm not alone in this curiosity. I encourage the maintainers of Tornado to write about the experience after it is done.\nThis isn't really an issue with Tornado, and is more a suggestion of a community activity. Please feel free to close if this is not the appropriate venue for this kind of request.\n1", "issue_status": "Open", "issue_reporting_time": "2018-08-13T03:57:08Z"}, "60": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2458", "issue_id": "#2458", "issue_summary": "SimpleAsyncHTTPClient forwards Authorization headers to different hosts on redirect", "issue_description": "srcreigh commented on 25 Jul 2018\nReportedly cURL doesn't use the Authorization header if a request is redirected to a different host. See here for more info.\nI ran into this just now with Twilio redirecting to AWS, and AWS rejecting the redirected request because it had the Twilio authorization. The same request using command-line curl works fine.\nUsing Tornado 5.0.", "issue_status": "Open", "issue_reporting_time": "2018-07-25T14:53:24Z"}, "61": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2434", "issue_id": "#2434", "issue_summary": "async get_current_user", "issue_description": "Contributor\nminrk commented on 4 Jul 2018\nIs it in-scope for @web.authenticated to support an async .get_current_user()? Or does this belong more appropriately in custom auth decorators in applications? It seems generic enough to me to warrant a default implementation, but making sure handler.current_user access works in a backward-compatible way seems tricky.", "issue_status": "Open", "issue_reporting_time": "2018-07-04T09:47:50Z"}, "62": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2405", "issue_id": "#2405", "issue_summary": "Websocket client exception on redirect", "issue_description": "Contributor\nwillmcgugan commented on 30 May 2018 \u2022\nedited\nWhen the websocket client receives a redirect status code, rather than a 101, it throws the following exception:\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 237, in _read_message\n    delegate.finish()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 674, in finish\n    return self._delegate.finish()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 500, in finish\n    self.client.fetch(new_request, final_callback)\nAttributeError: 'NoneType' object has no attribute 'fetch'\nERROR:tornado.application:Exception in callback functools.partial(<function wrap.<locals>.wrapped at 0x107cd9ea0>, <Future finished exception=_QuietException()>)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 237, in _read_message\n    delegate.finish()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 674, in finish\n    return self._delegate.finish()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 500, in finish\n    self.client.fetch(new_request, final_callback)\nAttributeError: 'NoneType' object has no attribute 'fetch'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.6/site-packages/tornado/ioloop.py\", line 759, in _run_callback\n    ret = callback()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/stack_context.py\", line 344, in wrapped\n    raise_exc_info(exc)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/usr/local/lib/python3.6/site-packages/tornado/stack_context.py\", line 315, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 395, in <lambda>\n    lambda f: f.result())\n  File \"/usr/local/lib/python3.6/site-packages/tornado/gen.py\", line 1113, in run\n    yielded = self.gen.send(value)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 237, in _read_message\n    delegate.finish()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 55, in __exit__\n    raise _QuietException\ntornado.http1connection._QuietException\nThe Websocket spec has this to say about redirects:\nIf the status code received from the server is not 101, the\nclient handles the response per HTTP [RFC2616] procedures. In\nparticular, the client might perform authentication if it\nreceives a 401 status code; the server might redirect the client\nusing a 3xx status code (but clients are not required to follow\nthem), etc. Otherwise, proceed as follows.\nSo redirects don't appear to a requirement as such, but I don't see any reason why it shouldn't follow them. Websocket redirects have much the same use case as any http redirect. But the client should at the very least be able to handle a non-101 gracefully.\nFrom what I've seen of the code, it looks like Tornado is at least trying to follow the redirect. So I'm hoping it won't be too much effort to fix. With a few pointers I may be able to tackle this myself. Any assistance would be appreciated.", "issue_status": "Open", "issue_reporting_time": "2018-05-30T08:38:15Z"}, "63": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2403", "issue_id": "#2403", "issue_summary": "Tornado server side timeout", "issue_description": "lgrabowski commented on 26 May 2018\nHello!\nI am looking for a way to gracefully support timeout on tornado side, when request handler takes to long. I could not find it - and afaik it's not trivial or easily doable due to nature of IOloop and non-blocking.\nHowever someone has to find a way to do it since no one wants to have some to long hanging clients :)\nI ma using tornado 4.5.x", "issue_status": "Open", "issue_reporting_time": "2018-05-25T19:38:53Z"}, "64": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2398", "issue_id": "#2398", "issue_summary": "Tornado autoreload feature will auto-reload into a syntax error and crash", "issue_description": "timabbott commented on 21 May 2018\nZulip uses both Tornado and Django as part of our project, using the built-in autoreload tooling for both projects. We've for a long time been plagued by an annoying issue where whenever one does a rebase with merge conflicts, the Django process happily avoids reloading itself until those are fixed, but the Tornado process will reload into a state with syntax errors, crashing itself, and requiring a manual restart by the developer.\nAfter doing some code reading, the problem here is that using e.g. the autoreload=True option in tornado.web.Application just doesn't have any code to do a syntax check of the modified modules before attempting to reload (the problem here is primarily not the _reload_attempted logic for trying just once; the problem is that the process dies when it tries to reload). It seems like fixing that would completely solve this problem.\nI wrote a basically working patch to Tornado's autoreload module (which we've temporarily copied into Zulip) that we're using to solve this problem for us. The code is here: zulip/zulip@ae0a929; it'd need some cleanup before it could be integrated into mainline Tornado (mostly noted in the commit message, but I'll repeat it here):\nI dropped _watched_files support to make it a bit easier to implement which is OK for my project but not for others; since we don't have a syntax checker for those, probably we just need those to keep the old behavior.\nI don't think importlib.reload is the right function to call for doing the \"check import\" inside Python. I think it won't actually break anything important in most cases, but ideally we'd replace that with something that's always correct (possibly just using importlib.import_module after clearing the importlib cache for the target file?).\nIt generally needs more testing.\nMuch as I'd like to, I don't have time to do that cleanup and contribute this to Tornado upstream in the near future, but I hope these notes are helpful for someone who does have time. I'm happy to help with testing a PR for this feature, though.\n1", "issue_status": "Open", "issue_reporting_time": "2018-05-21T00:02:32Z"}, "65": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2376", "issue_id": "#2376", "issue_summary": "Instrumentation of IOLoop with Tornado 5", "issue_description": "timabbott commented on 5 May 2018\nHey folks! Zulip has been happily using Tornado for years, so thanks for a great framework!\nOn Tornado 4 and earlier, we've been using two features of Tornado to make it easy to monitor our Tornado system in production for bugs, both of which are effectively removed in Tornado 5:\nset_blocking_log_threshold, which helps catch situations where code blocks the IOLoop forever.\nA system for logging idle time, which is helpful for tracking the load of the Tornado service in production over time. This has been super helpful in making it easy to monitor how loaded our Tornado service was at a given time and cross-reference the data with our logs. It seems like it should be possible to do something similar with Tornado 5, perhaps by modifying _handle_event to track the time spent actually processing events (rather than tracking the idle time). But I'm not sure if that'd be accurate.\nSo my questions are (1) do you have plans to re-introduce the set_blocking_log_threshold feature in Tornado 5, and (2) Is there an effective way to implement our IOLoop busyness-level logging technique described above on top of Tornado 5.\n(It's possible that second thing would be a problem better solved in Tornado itself rather than monkey-patching the IOLoop implementation; If you folks are at the PyCon sprints next week, perhaps we can chat about this in person; I'll be there all 4 days)", "issue_status": "Open", "issue_reporting_time": "2018-05-05T14:27:26Z"}, "66": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2373", "issue_id": "#2373", "issue_summary": "CPU 100% with tornado 4.5.3?", "issue_description": "SylphiaWindy commented on 3 May 2018\nWe have built a app with tornado 4.5.3, along with pynsq 0.8.2(which was not compatible with tornado 5), running on CentOS 7.4 with default kernel 3.10.0-693.21.1.el7.x86_64.\nCPU usage came up to 100% soon after app started, with ~100 connections.\nWe are using tornado's TCPServer class and IOStream.read_bytes(4096, partial=True) to implement our async tcp server, something like\n        while True:\n            try:\n                buf = await self._stream.read_bytes(4096, partial=True)\n            except:\n                self.close()\n                return None\n            return buf\nMany lines like read(370, 0x2e47d80, 11) = -1 EAGAIN (Resource temporarily unavailable) in strace result, and strace -c result was:\n% time     seconds  usecs/call     calls    errors syscall\n------ ----------- ----------- --------- --------- ----------------\n 37.95    0.892246           4    245309    243731 read\n 35.95    0.845239           3    242459         2 ioctl\n 19.15    0.450160           4    119424           epoll_wait\n  4.58    0.107586          13      7996       590 futex\n  0.46    0.010713           3      3263      1395 recvfrom\n  0.43    0.010007           5      1908           sendto\n  0.33    0.007788           3      2700           epoll_ctl\n  0.30    0.006951           4      1638           write\n  0.19    0.004412           3      1746           fstat\n  0.17    0.004001           2      1711      1705 lseek\n  0.10    0.002335           3       754       726 getpeername\nA tornado issue?", "issue_status": "Open", "issue_reporting_time": "2018-05-03T10:47:00Z"}, "67": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2369", "issue_id": "#2369", "issue_summary": "Feature request: support buffer protocol objects in `tornado.web.RequestHandler.write`", "issue_description": "netheril96 commented on 1 May 2018\nCurrent write method only accepts bytes, str and dict. If it supports in addition objects conforming to buffer protocol, conversion to bytes can be avoided, and so are memory allocation and data copy.", "issue_status": "Open", "issue_reporting_time": "2018-05-01T16:07:01Z"}, "68": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2364", "issue_id": "#2364", "issue_summary": "Tornado & M2Crypto ?", "issue_description": "chaen commented on 24 Apr 2018\nHi,\nWe are currently evaluating Tornado.\nThe standard ssl library of python does not expose the get_peer_cert_chain call available in the C library of OpenSSL. This is very problematic (to say the least :-) ) for the use case we have. Clearly, I am not the only one having this issue, someone even provided an implementation, but the ssl library guys do not seem very keen to merge it (https://bugs.python.org/issue18233)...\nM2Crypto exposes just what I need (https://gitlab.com/m2crypto/m2crypto/blob/master/M2Crypto/SSL/Connection.py#L538)\nSo my questions would be:\nis there any plans to have Tornado using M2Crypto ?\nIf yes, what timescale ?\nif not, is there any good reason for not doing it ?\nHow difficult would it be ?\nWe would be very willing to make PR, but if it takes months to get it merged, then Tornado is maybe not the approach we would take :-/\nThanks a lot\nChris", "issue_status": "Open", "issue_reporting_time": "2018-04-24T12:41:46Z"}, "69": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2356", "issue_id": "#2356", "issue_summary": "tornado.queues consumers are difficult to stop cleanly", "issue_description": "zkdfbb commented on 16 Apr 2018 \u2022\nedited by bdarnell\nWhile using tornado 5.0.2, the following code will report\nERROR:asyncio:Task was destroyed but it is pending! task: <Task pending coro=<consumer() running at a.py:18> wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x10eb7a6a8>()]> cb=[IOLoop.add_future.<locals>.<lambda>() at /usr/local/lib/python3.6/site-packages/tornado/ioloop.py:720]>\nthis code is copied from http://www.tornadoweb.org/en/stable/queues.html\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\nfrom tornado.queues import Queue\n\nq = Queue(maxsize=2)\n\nasync def consumer():\n    async for item in q:\n        try:\n            print('Doing work on %s' % item)\n        finally:\n            q.task_done()\n\n\nasync def producer():\n    for item in range(1):\n        await q.put(item)\n        print('Put %s' % item)\n\n\nasync def main():\n    # Start consumer without waiting (since it never finishes).\n    IOLoop.current().spawn_callback(consumer)\n    await producer()     # Wait for producer to put all tasks.\n    await q.join()       # Wait for consumer to finish all tasks.\n    print('Done')\n\nIOLoop.current().run_sync(main)", "issue_status": "Open", "issue_reporting_time": "2018-04-16T13:42:49Z"}, "70": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2336", "issue_id": "#2336", "issue_summary": "tcpclient: cancelling TCPClient.connect", "issue_description": "enn0x commented on 31 Mar 2018 \u2022\nedited\nHello Ben,\nI think I found a problem with TCPClient. I have a web application which connects and disconnects to/from a TCP peer on user request. Now, when the user connects and while the TCPClient.connect method still is waiting (stream = await self.connect(self.host, self.port) already requests a stop I run into an exception. But first in order to handle start/stop requests I implemented something like this:\nasync def start(self):\n    self.task = asyncio.ensure_future(self._run())\n\nasync def stop(self):\n    self.task.cancel()\n    self.task = None\n\nasync def _run(self):\n    # --1-- Connect to peer\n    try:\n        stream = await self.connect(self.host, self.port)\n    except StreamClosedError:\n        return\n    ... now read from the stream\nThe exception I see is this:\n2018-03-31 16:10:11,027 [ERROR] Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0x000001FF4ABB1400>, <Future finished exception=StreamClosedError('Stream is closed',)>)\nTraceback (most recent call last):\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\gen.py\", line 1107, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\tcpclient.py\", line 234, in connect\n    af, addr, stream = yield connector.start(connect_timeout=timeout)\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\gen.py\", line 1099, in run\n    value = future.result()\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\tcpclient.py\", line 112, in on_connect_done\n    stream = future.result()\ntornado.iostream.StreamClosedError: Stream is closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\ioloop.py\", line 760, in _run_callback\n    ret = callback()\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\stack_context.py\", line 276, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\gen.py\", line 1199, in inner\n    self.run()\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\gen.py\", line 1139, in run\n    future_set_exc_info(self.result_future, sys.exc_info())\n  File \"C:\\Development\\Maelstrom\\src\\libs\\tornado\\concurrent.py\", line 597, in future_set_exc_info\n    future.set_exception(exc_info[1])\nasyncio.base_futures.InvalidStateError: invalid state\nThe problematic part of code is in tcpclient.py:\n    def on_connect_done(self, addrs, af, addr, future):\n        self.remaining -= 1\n        try:\n            stream = future.result()\n        except Exception as e:\n            if self.future.done():\n                return\n            # Error: try again (but remember what happened so we have an\n            # error to raise in the end)\n            self.last_error = e\n            self.try_connect(addrs)\n            if self.timeout is not None:\n                # If the first attempt failed, don't wait for the\n                # timeout to try an address from the secondary queue.\n                self.io_loop.remove_timeout(self.timeout)\n                self.on_timeout()\n            return\nIf I cancel the task then the future passed to on_connect_done is already done when this function is called (a CancelledError is set an thus future.done() is TRUE). However, you check again self.future.done() which returns FALSE since it is a different future.\nAdding a check to future.done() solves the problem for me:\n    def on_connect_done(self, addrs, af, addr, future):\n        self.remaining -= 1\n        try:\n            stream = future.result()\n        except Exception as e:\n            if future.done():   # <-- ADDED\n                return              # <-- ADDED\n            if self.future.done():\n                return\nI'm not sure if the first check to self.future.done() is required.\nKind Regards\nRalf", "issue_status": "Open", "issue_reporting_time": "2018-03-31T14:33:42Z"}, "71": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2303", "issue_id": "#2303", "issue_summary": "Future exception was never retrieved", "issue_description": "Contributor\nmrocklin commented on 8 Mar 2018\nIn switching to Tornado 5.0 I now find that a few extra errors get logged out when I stop an event loop, such as during shutdown. This only occurs if I use @gen.coroutine. It does not occur if I use async def. It does not occur on Python 2.7 . I apologize for not having a reproducible example, but hope that this information has some utility.", "issue_status": "Open", "issue_reporting_time": "2018-03-08T14:49:36Z"}, "72": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2250", "issue_id": "#2250", "issue_summary": "Timeout with HEAD method of AsyncHTTPClient on valid URL", "issue_description": "fabiopedrosa commented on 17 Jan 2018 \u2022\nedited\nI can't get AsyncHTTPClient to do a simple HEAD request.\nNot working:\n#!/usr/bin/env python\nimport logging\nfrom tornado import ioloop\nfrom tornado.web import gen\nfrom tornado.httpclient import AsyncHTTPClient\nlogging.basicConfig(level=logging.DEBUG)\n\n\n@gen.coroutine\ndef test():\n    url = \"https://r4---sn-8vq54vox2u-apne.googlevideo.com/videoplayback?aitags=133%2C134%2C135%2C136%2C160&sparams=aitags%2Cclen%2Cdur%2Cei%2Cgir%2Cid%2Cinitcwndbps%2Cip%2Cipbits%2Citag%2Ckeepalive%2Clmt%2Cmime%2Cmm%2Cmn%2Cms%2Cmv%2Cpl%2Crequiressl%2Csource%2Cexpire&mime=video%2Fmp4&id=o-AK1r9zLt8iQEN-zyIbOXynTtGcj201h1Qivmb4INkx0Q&itag=135&dur=125.600&lmt=1380999388644463&ip=94.62.195.82&key=yt6&expire=1516640181&clen=2196699&signature=53D81AE57372BADC88F66B6B33EB220E42847E10.B3EAC4C02578FFBAA553A47652BE63312A8DFF7D&ms=au&ei=VcNlWq62DtilWOP7m8AB&mv=m&mt=1516618492&ipbits=0&mn=sn-8vq54vox2u-apne&mm=31&requiressl=yes&keepalive=yes&pl=16&source=youtube&gir=yes&initcwndbps=940000&ratebypass=yes\"\n    client = AsyncHTTPClient()\n    try:\n        response = yield client.fetch(url, method=\"HEAD\", validate_cert=False)\n        print response.status\n        print response.headers\n    except:\n        logging.exception(\"error\")\n\n    ioloop.IOLoop.current().stop()\n\n\nif __name__ == '__main__':\n    test()\n    ioloop.IOLoop.current().start()\nworking just fine:\nimport requests\nurl = \"https://r4---sn-8vq54vox2u-apne.googlevideo.com/videoplayback?aitags=133%2C134%2C135%2C136%2C160&sparams=aitags%2Cclen%2Cdur%2Cei%2Cgir%2Cid%2Cinitcwndbps%2Cip%2Cipbits%2Citag%2Ckeepalive%2Clmt%2Cmime%2Cmm%2Cmn%2Cms%2Cmv%2Cpl%2Crequiressl%2Csource%2Cexpire&mime=video%2Fmp4&id=o-AK1r9zLt8iQEN-zyIbOXynTtGcj201h1Qivmb4INkx0Q&itag=135&dur=125.600&lmt=1380999388644463&ip=94.62.195.82&key=yt6&expire=1516640181&clen=2196699&signature=53D81AE57372BADC88F66B6B33EB220E42847E10.B3EAC4C02578FFBAA553A47652BE63312A8DFF7D&ms=au&ei=VcNlWq62DtilWOP7m8AB&mv=m&mt=1516618492&ipbits=0&mn=sn-8vq54vox2u-apne&mm=31&requiressl=yes&keepalive=yes&pl=16&source=youtube&gir=yes&initcwndbps=940000&ratebypass=yes\"\nr = requests.request('HEAD', url)\nprint r.headers", "issue_status": "Open", "issue_reporting_time": "2018-01-16T19:59:39Z"}, "73": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2243", "issue_id": "#2243", "issue_summary": "'autoreload=true' throws 'KeyboardInterrupt' while debugging with python3.6", "issue_description": "akoidan commented on 6 Jan 2018 \u2022\nedited\nTo reproduce the issue you can use default example:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hellof, world!\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ], debug=True, autoreload=True)\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nPycharm starts the script with\n/usr/bin/python3.6 /opt/pycharm-eap/helpers/pydev/pydevd.py --multiproc --qt-support=auto --client 127.0.0.1 --port 33261 --file file_name.py\nIf I edit the file and then save it I receive\nFailed to import the site module\nTraceback (most recent call last):\n  File \"/usr/lib/python3.6/site.py\", line 73, in <module>\n    import os\n  File \"/usr/lib/python3.6/os.py\", line 652, in <module>\n    from _collections_abc import MutableMapping\n  File \"/usr/lib/python3.6/_collections_abc.py\", line 288, in <module>\n    Iterator.register(str_iterator)\n  File \"/usr/lib/python3.6/abc.py\", line 158, in register\n    if issubclass(subclass, cls):\n  File \"/usr/lib/python3.6/abc.py\", line 207, in __subclasscheck__\n    ok = cls.__subclasshook__(subclass)\nKeyboardInterrupt\nThis issue reproduces with python 3.6. On python 2.7 autoreload works ok. I also tried to turn off Safe write in pycharm, but that doesn't affect it at all.\n1", "issue_status": "Open", "issue_reporting_time": "2018-01-06T14:01:10Z"}, "74": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2209", "issue_id": "#2209", "issue_summary": "Support streaming API for AsyncHTTPClient", "issue_description": "Contributor\nlegnaleurc commented on 7 Dec 2017 \u2022\nedited\nMostly like this:\nhttps://aiohttp.readthedocs.io/en/stable/client_quickstart.html#streaming-response-content\nThis could probably solve some usage like #157.\nIt is hard to control the process in streaming_callback, and it does not support async function as well.\n5", "issue_status": "Open", "issue_reporting_time": "2017-12-07T08:45:05Z"}, "75": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2207", "issue_id": "#2207", "issue_summary": "http headers are capitalized", "issue_description": "lxkaka commented on 5 Dec 2017\nIs there any probability do not capitalize the customized http header.\nfor example:\n{'authtoken': '1234'} will be capitalized through tornado.httputil.HttpHeaders {'Authtoken': '1234'}.\nThis can bring troubles for some servers.", "issue_status": "Open", "issue_reporting_time": "2017-12-05T13:51:32Z"}, "76": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2190", "issue_id": "#2190", "issue_summary": "wsgi: HEAD raises \"Tried to write more data than Content-Length\"", "issue_description": "sc-syf commented on 7 Nov 2017\nrefers to:Running WSGI apps on Tornado servers, I deployed Django project to tornado server.\nBut It will raise HTTP 500 sometimes(can not control, and the 500 error is accidental)\uff0c and while use\ncurl --head 127.0.0.1:8888\nit will raise Exception:\nERROR:tornado.application:Uncaught exception HEAD / (127.0.0.1)\nHTTPServerRequest(protocol='http', host='127.0.0.1:8888', method='HEAD', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Host': '127.0.0.1:8888', 'User-Agent': 'curl/7.54.0', 'Accept': '*/*'})\nTraceback (most recent call last):\n  File \"/Users/xxx/.py3/lib/python3.6/site-packages/tornado/web.py\", line 1446, in _execute\n    result = self.prepare()\n  File \"/Users/xxx/.py3/lib/python3.6/site-packages/tornado/web.py\", line 2706, in prepare\n    self.fallback(self.request)\n  File \"/Users/xxx/.py3/lib/python3.6/site-packages/tornado/wsgi.py\", line 304, in __call__\n    request.connection.write_headers(start_line, header_obj, chunk=body)\n  File \"/Users/xxx/.py3/lib/python3.6/site-packages/tornado/http1connection.py\", line 398, in write_headers\n    data += self._format_chunk(chunk)\n  File \"/Users/xxx/.py3/lib/python3.6/site-packages/tornado/http1connection.py\", line 410, in _format_chunk\n    \"Tried to write more data than Content-Length\")\ntornado.httputil.HTTPOutputError: Tried to write more data than Content-Length\nERROR:tornado.access:500 HEAD / (127.0.0.1) 5.99ms\nDjango version: 1.11.7\nTornado version: 4.5.2\nPython: 3.6.0\np.s. while degrade the Django version to 1.9.*, everything is ok.", "issue_status": "Open", "issue_reporting_time": "2017-11-07T03:51:13Z"}, "77": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2171", "issue_id": "#2171", "issue_summary": "Make IOStream class configurable", "issue_description": "Contributor\npitrou commented on 20 Oct 2017\nIn the light of the recent performance discussion, it could be useful to make the IOStream classes configurable. I'm thinking of something like this:\nclass MyTCPClient(TCPClient):\n    IOStream = MyIOStream\n\nclass MyTCPServer(TCPServer):\n    IOStream = MyIOStream\n\nclass MyIOStream(IOStream):\n    SSLIOStream = MySSLIOStream\n(note TCPServer can use start_tls instead of having its own reference to SSLIOStream)", "issue_status": "Open", "issue_reporting_time": "2017-10-20T09:31:36Z"}, "78": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2164", "issue_id": "#2164", "issue_summary": "Expose HTTP request handling time", "issue_description": "adamrothman commented on 17 Oct 2017 \u2022\nedited\nUntil recently, I had my Tornado applications using HTTPServerRequest::request_time to report request handling latencies. While conducting some tests with users in a bandwidth-constrained environment, I noticed that our request timings were downright awful.\nI found this surprising, given that nothing significant had changed in the application prior to the test. After some fruitless exploration, a coworker suggested that Tornado might be including the time taken by the client to complete transmission of the request in request_time. Using the server and client scripts below, I verified that this is in fact the case.\nimport asyncio\nimport logging\nfrom time import time\n\nfrom tornado.httpserver import HTTPServer\nfrom tornado.platform.asyncio import AsyncIOMainLoop\nfrom tornado.web import Application\nfrom tornado.web import RequestHandler\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass TestHandler(RequestHandler):\n\n    def post(self):\n        logger.info('request received')\n\n    # Lifecycle\n\n    def prepare(self):\n        self.start_time = time()\n\n    def on_finish(self):\n        tornado_time = self.request.request_time()\n        logger.info(f'Tornado says request took {tornado_time} s')\n\n        my_time = time() - self.start_time\n        logger.info(f'I say it took {my_time} s')\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    AsyncIOMainLoop().install()\n\n    app = Application(\n        handlers=[('/', TestHandler)],\n        autoescape=None,\n        debug=True,\n    )\n\n    server = HTTPServer(app)\n    server.listen(8080)\n\n    loop = asyncio.get_event_loop()\n    loop.run_forever()\nfrom time import sleep\n\nimport requests\n\n\nclass SlowFile:\n\n    lines = [\n        b'Now is the time',\n        b'for all good men',\n        b'to come to the aid',\n        b'of their country',\n    ]\n\n    def __iter__(self):\n        for l in type(self).lines:\n            sleep(2)\n            yield l\n\n\ndef main():\n    f = SlowFile()\n    requests.post('http://localhost:8080', data=f)\n\n\nif __name__ == '__main__':\n    main()\nTornado reports over 8 seconds, when the actual handling latency is well under a second.\nI understand the reasons for exposing this cumulative number, but I also imagine that most server app developers are more interested in the number they can affect more directly \u2013 the actual handling latency. That is, the delta between when a request is fully received and when the response is fully sent.\nIt's easy enough to implement this myself in a RequestHandler subclass, but it seems useful enough that maybe Tornado should just expose it.\nWhat do you think @bdarnell?", "issue_status": "Open", "issue_reporting_time": "2017-10-16T23:42:34Z"}, "79": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2140", "issue_id": "#2140", "issue_summary": "Need more parameters for auth get_authenticated_user method", "issue_description": "rajasankar commented on 22 Aug 2017\nGoogle OAuth2 has changed the parameters to be passed to change the code to access_token.\nparams = { 'code':code,\n'client_id':self.settings['google_oauth']['key'],\n'client_secret':self.settings['google_oauth']['secret'],\n'redirect_uri':'http://localhost',\n'grant_type':'authorization_code',\n}\nAs these params cant be passed in the current get_authenticated_user method, OAuth2 method fails to get access_token.\nI have used to requests to get the token and it works fine.\nExtra params option is coded in authorize_redirect , so it can be added in get_authenticated_user\nI havent tested for Facebook/Twitter, get_authenticated_user method for FacebookGraphMixin has extra fields and option to pass client_id and client_secret.\nSame can be added for get_authenticated_user in GoogleOAuth2Mixin", "issue_status": "Open", "issue_reporting_time": "2017-08-22T17:58:11Z"}, "80": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2136", "issue_id": "#2136", "issue_summary": "WebSocketProtocol13.periodic_ping exception", "issue_description": "tsantor commented on 18 Aug 2017\nWe are running a Tornado TCP server on a Windows server 2012 machine. This machine handles both an HTTP-based dashboard and 21 TCP Websocket connected clients. Occasionally in the logs we will see the following error. It seems to be at a very low level of the Websocket13 protocol. But from a networking standpoint what does it mean? Why would the write buffer not be greater than or equal to 0?\n[ERROR] [2017-08-17 11:54:14 AM] [tornado.application] Exception in callback <bound method WebSocketProtocol13.periodic_ping of <tornado.websocket.WebSocketProtocol13 object at 0x01D7AD30>>\n\nTraceback (most recent call last):\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\ioloop.py\", line 1026, in _run\n\n    return self.callback()\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\websocket.py\", line 1030, in periodic_ping\n\n    self.write_ping(b'')\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\websocket.py\", line 790, in write_ping\n\n    self._write_frame(True, 0x9, data)\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\websocket.py\", line 768, in _write_frame\n\n    return self.stream.write(frame)\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\iostream.py\", line 406, in write\n\n    self._handle_write()\n\nFile \"C:\\Python27\\lib\\site-packages\\tornado\\iostream.py\", line 847, in _handle_write\n\n    assert self._write_buffer_size >= 0\n\nAssertionError", "issue_status": "Open", "issue_reporting_time": "2017-08-18T16:10:50Z"}, "81": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2127", "issue_id": "#2127", "issue_summary": "CurlAsyncHTTPClient should warn when max_clients exceeded", "issue_description": "ssb22 commented on 7 Aug 2017\nmax_clients in CurlAsyncHTTPClient defaults to 10 (which seems low for high-load applications), and there is no option to warn when its _process_queue can't fit all self._requests into self._free_list. Surplus requests are queued\u2014but deadlock can occur if we're fetching from a back-end server which will not respond to the requests in progress until the queued requests are sent.\nIn my application, I needed to do some processing both downstream and upstream of a legacy proxy which I must treat as a \"black box\". So when a request R0 comes in from the client, I do things to it and then send a request R1 to the black box. Then the black box makes a request R2 back to me on a different port, and I do things to that and send a request R3 elsewhere. When I get the response from R3, I can send the reply for the black box's request R2, and that will cause the black box to reply to my R1 request and finally I can reply to R0. Notice that I won't get the response from R1 until I've finished servicing R2, which I can't do until I've sent and handled R3. So R1 depends on R3, so if R3 is put into a queue waiting for R1 to finish, I'm in trouble. Of course there are many ways I can work around this problem: I can set a larger value of max_clients to decrease the chances of that queue having to come into play, or I can run a completely different Tornado process for the other port, or something. But the issue was I had a deadlock and (for a few hours) no idea why. If there were some way of turning off the queue and raising an exception if I overload _free_list, or at least logging a warning, that would have saved some debugging. Thanks.", "issue_status": "Open", "issue_reporting_time": "2017-08-07T15:16:57Z"}, "82": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2110", "issue_id": "#2110", "issue_summary": "IOStream._handle_write blocks when _write_buffer is large", "issue_description": "Contributor\nmrocklin commented on 19 Jul 2017\nWhen dumping a gigabyte or so into an IOStream I observe my event loop pausing for long periods of time (about a second). I believe that this is due to long atomic calls to _handle_write that continue looping while the _write_buffer still has data. This can cause some unpleasant blocking in the application.\nIs it feasible to have _handle_write yield from time to time during large writes?", "issue_status": "Open", "issue_reporting_time": "2017-07-19T12:49:48Z"}, "83": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2102", "issue_id": "#2102", "issue_summary": "Reduce Websocket copies / accept memoryviews", "issue_description": "bryevdv commented on 30 Jun 2017\nSince masking of inbound (client->server) message is mandated by RFC, a copy in that case is unavoidable. However outbound masking (server->client) is not mandated, and appears to be turned off by default:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/websocket.py#L587\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/websocket.py#L461-L462\n(It is set to True in the WS client connection class, as expected)\nThis outbound case is the most relevant and important one for Bokeh, so any improvements to reduce copies on outbound messages would be beneficial for Bokeh users.\nBelow are some ideas from tracing through the code, I am sure there are many details I am not familiar with, but perhaps this can start a discussion.\nAllow write_messages to accept a memoryview. Then in _write_frame, instead of doing all these concatenations:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/websocket.py#L762-L767\nPlace the message chunks on the stream write buffer individually. I am not sure if multiple calls to self.stream.write(chunk) would suffice (I'm guessing not), or if iostream.write would have be modified to accept multiple ordered chunks. However, it seems that iostream.write is already capable of storing a list of pending writes when the write buffer is \"frozen\". Currently all of these buffers get concatenated:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/iostream.py#L840\nBut perhaps instead of concatenating before clearing pending writes, the list of buffers could be copied instead, then _handle_write could loop over these, instead of expecting one concatenated array.", "issue_status": "Open", "issue_reporting_time": "2017-06-30T16:16:23Z"}, "84": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2096", "issue_id": "#2096", "issue_summary": "Feature request: Implement `body_producer` for `curl_httpclient`", "issue_description": "Contributor\nlegnaleurc commented on 26 Jun 2017\nThis line seems implies the body is always a text, which is not always true:\nhttps://github.com/tornadoweb/tornado/blob/v4.5.1/tornado/curl_httpclient.py#L424\nCan we unify the API, e.g. wrap body_producer to pycurl.READFUNCTION?", "issue_status": "Open", "issue_reporting_time": "2017-06-25T19:46:53Z"}, "85": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2068", "issue_id": "#2068", "issue_summary": "Undeprecate maybe_future()?", "issue_description": "Contributor\npitrou commented on 31 May 2017\nmaybe_future is currently marked deprecated as it only handlers Futures and not other kinds of objects. However, convert_yielded already has the required logic to handle other kinds of objects.", "issue_status": "Open", "issue_reporting_time": "2017-05-31T14:41:49Z"}, "86": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2054", "issue_id": "#2054", "issue_summary": "Adding labels to show beginner issues?", "issue_description": "andymaheshw commented on 23 May 2017\nI'd very much like to assist with tornado development. Can tags be added to issues that indicate they are beginner level? Thanks!\n8", "issue_status": "Open", "issue_reporting_time": "2017-05-23T12:26:28Z"}, "87": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2049", "issue_id": "#2049", "issue_summary": "httpclient: Consider removing magic from AsyncHTTPClient", "issue_description": "Member\nbdarnell commented on 21 May 2017\nAsyncHTTPClient.__new__ is very magical: Unless you pass force_instance=True when constructing an AsyncHTTPClient, you may be reusing an existing object. This is partly done for convenience and efficiency (so you don't have to pass a single object around to reuse existing curl objects with their connection cache), but also to enforce good internet citizenship (so you have to think about what you're doing and increase max_clients before unleashing a massively parallel webcrawler).\nThe downside, of course, is that this magic is surprising and arguably un-pythonic and un-tornadoic. The force_instance workaround is unnatural, and this arrangement makes AsyncHTTPClient.close difficult to use safely (see #2026).\nFor Tornado 5.0, does it make sense to eliminate this magic and encourage developers to create a single AsyncHTTPClient at startup and pass it around? (or we could start encouraging this pattern now and make the actual change in a future x.0 release) The creation of a SimpleAsyncHTTPClient is fairly cheap since they are stateless, so the main \"cost\" to users of that client implementation would be the fact that the max_clients limit would effectively be lifted (some of these users will see that as a benefit rather than a cost). This change would have a larger performance impact on users of CurlAsyncHTTPClient since they'd lose the benefit of that objects' connection cache if they were \"creating\" new clients all over the place. The absence of an explicit close() call would also mean that these newly-created objects would be relying on GC for cleanup, which is expensive due to internal circular references.", "issue_status": "Open", "issue_reporting_time": "2017-05-20T18:37:53Z"}, "88": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2043", "issue_id": "#2043", "issue_summary": "httputil: Header normalization behaves oddly for \"\u00df\"", "issue_description": "kfrendrich commented on 17 May 2017\nHi.\nWe fuzzy tested our application and discovered a problem with the normalization of header keys.\nIf a header key contains special characters, the re-normalization of the key cause problems in certain cases.\nI am attaching the code that helps you to reproduce the problems.\nbug.py.txt", "issue_status": "Open", "issue_reporting_time": "2017-05-17T09:20:14Z"}, "89": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2034", "issue_id": "#2034", "issue_summary": "gen.WaitIterator mess up current_index", "issue_description": "DeoLeung commented on 4 May 2017\nHi, if we have some coroutines to return very quickly (using unittest mock, or quick sql query),\nthe result of current_index may be different in the async for loop, which will have less result return\ncurrently I need to use gen.Multi to avoid this\nquick_return_coros = {'name': coro, ...} # some coroutines return very quick\niterator = gen.WaitIterator(\n    **{k: ensure_future(x()) for x in quick_return_coros}\n)\nres = {}\nasync for result in iterator:\n  res[iterator.current_index] = result\n# res may be less than quick_return_coros   ", "issue_status": "Open", "issue_reporting_time": "2017-05-04T10:11:01Z"}, "90": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2029", "issue_id": "#2029", "issue_summary": "WaitIterator crashes if given the same future multiple times", "issue_description": "Groxx commented on 28 Apr 2017 \u2022\nedited\nWhile trying to do some shenanigans, I built a utility to simplify yield gen.multi(..., quiet_exceptions=...) for a bunch of code. One of my goals was to be able to abort a yield on the first-available error when yielding on multiple futures, rather than waiting for all futures to resolve - this can lead to a fairly significant response-time improvements when multiple errors occur, and one of them is due to a lengthy timeout.\nSo I made a small helper with WaitIterator, and started getting errors like this in tests:\n  File \".../lib/helpers.py\", line 275, in parallel\n    result = yield iterator.next()\n  File \".../env/local/lib/python2.7/site-packages/tornado/gen.py\", line 428, in next\n    self._return_result(self._finished.popleft())\n  File \".../env/local/lib/python2.7/site-packages/tornado/gen.py\", line 445, in _return_result\n    self.current_index = self._unfinished.pop(done)\nKeyError: <Future at 0x7f2fe2eedd10 state=finished returned MyEntity>\nAfter a bit of hunting, I narrowed it down to this (simplified pieces of WaitIterator):\nclass WaitIterator(object):\n    def __init__(self, *args, **kwargs):\n        if args and kwargs:\n            raise ValueError(\n                \"You must provide args or kwargs, not both\")\n\n        if kwargs:\n            self._unfinished = dict((f, k) for (k, f) in kwargs.items())\n            futures = list(kwargs.values())\n        else:\n# note that this is a dictionary keyed off items in args\n            self._unfinished = dict((f, i) for (i, f) in enumerate(args))\n# while this is a list\n            futures = args\n\n# and this is also a list\n        self._finished = collections.deque()\n        self.current_index = self.current_future = None\n        self._running_future = None\n\n        for future in futures:\n            future.add_done_callback(self._done_callback)\n\n    def next(self):\n        self._running_future = TracebackFuture()\n\n        if self._finished:\n# pops off a future from the list\n            self._return_result(self._finished.popleft())\n\n        return self._running_future\n\n    def _return_result(self, done):\n        chain_future(done, self._running_future)\n\n        self.current_future = done\n# and this removes the *single* future-key that matches\n        self.current_index = self._unfinished.pop(done)\nThis crash can be demonstrated with code like this:\n@coroutine\ndef tmp():\n  pass\n\nf = tmp()\ni = WaitIterator(f, f, f)\nwhile not i.done():\n  yield i.next()\nIn a nutshell, we have some parallel calls that we've mocked to return the same Future. This results in a single future being in the list multiple times, which gets deduplicated in the _unfinished dictionary, so the second duplicate that's finished errors with a KeyError.\nThis isn't actually breaking anything currently, but it strikes me as a potential landmine, and would've broken some experiments I've been planning. The workaround for users like me is to dedup manually / wrap everything in a new Future / etc, which I can do, but this was at least surprising and took some time to hunt down.\nIMO this needs one of two things. Both seem fine to me:\nDon't convert to a dictionary like this, keep both as lists. _unfinished.pop(_unfinished.index(done)) in _return_result wouldn't have this problem.\nI personally like this. Parallel yields are likely to be relatively small quantities, there's a decent chance that it'll perform better in most cases (at least, in most languages - small list scanning and indexing often out-performs hashing). It also lets WaitIterator return whatever was passed in, regardless of what it was given, which is what I expected.\nDocument it. This is a pretty low-level tool, it shouldn't under any circumstances be surprising people who haven't read the source in detail. At the very least this isn't expected behavior from reading the docs, since it allows passing in a list and not only sets/dicts.\nI can probably get a pull review up if it'd help, but I haven't yet looked into contributing here, and it seems like it'd be a pretty small change either way. And it's a bit esoteric, so I figured it needed some discussion to fit it in best with existing code :) Let me know what you think!\n1", "issue_status": "Open", "issue_reporting_time": "2017-04-27T22:52:44Z"}, "91": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1981", "issue_id": "#1981", "issue_summary": "Websocket error handling hook", "issue_description": "Member\nbdarnell commented on 25 Mar 2017 \u2022\nedited\nWebSocketHandler doesn't currently have a good way of installing a class-wide handler for uncaught exceptions. The only way is to override _run_callback, but that's awkward (and the method is changing in Tornado 4.5 so naive overrides may break the ability to use coroutines). We should add an explicit error-handling hook.\nThe add_future call to f.result() also needs to be refactored so its exceptions can be handled in the same way instead of escaping to the IOLoop.\nSee https://stackoverflow.com/questions/42822958/tornado-websocket-handler-uncaught-exception/43017469#43017469\n1", "issue_status": "Open", "issue_reporting_time": "2017-03-25T14:21:05Z"}, "92": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1955", "issue_id": "#1955", "issue_summary": "tornado.locale.Locale.get_closest does not find locales according to RFC", "issue_description": "dwt commented on 20 Feb 2017\nHi there,\nwe noticed this problem when we translated our app to 'zh_Hant' where 'Hant' is a script not a region, but Locale.get_closest treats it as it treats region codes and tries to find it capitalized.\nThis is AFAIK wrong on multiple levels. First rfc4647 says that\n    Language tags and thus language ranges are to be treated as case-\n    insensitive: there exist conventions for the capitalization of some\n    of the subtags, but these MUST NOT be taken to carry meaning.\n    Matching of language tags to language ranges MUST be done in a case-\n    insensitive manner.\nLanguage tags are to my understanding the whole string, (so 'zh_Hant' for us) and thus all matching should happen at least case insensitive.\nBut that code is also making lots of assumptions and does some parsing which probably is wrong (though I'm not deep enough in the RFC to say so).\nSome things that could be done here (in ascending order of severance of code changes)\nAdd a fallback that tries to find the original argument without trying to change it, so there is at least a workaround for programmers who know what they're doing.\nChange matching to be case insensitive. This would be more in line with the RFC, but also has more probability of introducing new problems for existing users.\nUse a propper locale parsing library (e.g. Babel )", "issue_status": "Open", "issue_reporting_time": "2017-02-20T10:28:31Z"}, "93": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1920", "issue_id": "#1920", "issue_summary": "tcpclient: Improper close of IOStream", "issue_description": "truekonrads commented on 22 Dec 2016\nHello,\nI am using the latest git master. This happens when the IOLoop is busy. Seems simlar to #32 and #1901:\nDEBUG:tornado.general:Error deleting fd from IOLoop\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/gen.py\", line 1054, in run\n    yielded = self.gen.send(value)\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/tcpclient.py\", line 175, in connect\n    raise gen.Return(stream)\ntornado.gen.Return: <tornado.iostream.SSLIOStream object at 0x7f0e70dba3c8>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/ioloop.py\", line 739, in remove_handler\n    self._impl.unregister(fd)\nFileNotFoundError: [Errno 2] No such file or directory", "issue_status": "Open", "issue_reporting_time": "2016-12-22T13:50:58Z"}, "94": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1912", "issue_id": "#1912", "issue_summary": "fork_processes() can leave orphan processes", "issue_description": "Contributor\npitrou commented on 12 Dec 2016 \u2022\nedited\nfork_processes() does not attempt to detect if the parent process receives a signal or a KeyboardInterrupt. As a result, if the parent process is killed with a signal or interrupted with Ctrl-C, it happily leaves around its children.\n1", "issue_status": "Open", "issue_reporting_time": "2016-12-12T15:54:06Z"}, "95": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1886", "issue_id": "#1886", "issue_summary": "Add a timeout argument to read_until_* methods", "issue_description": "giampaolo commented on 13 Nov 2016\n...so that one can do:\n    @gen.coroutine\n    def handle_stream(self, stream, address):\n        while True:\n            try:\n                data = yield stream.read_until(b\"\\r\\n\", timeout=30)\n            except TimeoutError:\n                print(\"no data was received in 30 secs\")\n                break", "issue_status": "Open", "issue_reporting_time": "2016-11-13T00:34:53Z"}, "96": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1863", "issue_id": "#1863", "issue_summary": "WebSocket with regex route doesn't call open callback", "issue_description": "M425 commented on 22 Oct 2016\nI binded a tornado.websocket.WebSocketHandler with a normal route like \"/ws\" and it works as expected. However when i bind the handler with a regex route like \"/nws/(.*)\" it doesn't call the \"open\" callback.\nFollows the shortest example i could build to show the issue:\nimport os\nimport tornado\nimport tornado.web\nimport tornado.gen\nimport tornado.websocket\n\nclass SocketHandler(tornado.websocket.WebSocketHandler):\n    def initialize(self):\n        print 'initialized'\n\n    def check_origin(self, origin):\n        return True\n\n    @tornado.gen.coroutine\n    def open(self):\n        print 'opened'\n        raise tornado.gen.Return()\n\n    @tornado.gen.coroutine\n    def on_message(self, message):\n        print 'on_message {}'.format(message)\n        self.write_message('resp: {}'.format(message))\n\n    @tornado.gen.coroutine\n    def on_close(self):\n        print 'closed'\n\n\napplication = tornado.web.Application([\n    (r\"/ws\",               SocketHandler),\n    (r\"/nws/(.*)\",         SocketHandler),\n])\napplication.listen(8181)\nprint 'Server started on port: {}, pid: {}'.format(8181, os.getpid())\ntornado.ioloop.IOLoop.instance().start()\nSo I run a normal client which fires the following operation:\nopen\nsend message \"test\"\nclose\nhere the output when the path is /ws\ninitialized\nopened\non_message test\nclosed\nhere the output when the path is /nws/abc\ninitialized\non_message test\nclosed", "issue_status": "Open", "issue_reporting_time": "2016-10-22T08:44:48Z"}, "97": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1858", "issue_id": "#1858", "issue_summary": "tornado.locale.Locale.get_closest() not getting closest match", "issue_description": "Deus-Vult commented on 3 Oct 2016\nThe tornado.locale.Locale.get_closest() (and as such by extension tornado.locale.get) function is a bit malformed. It tries to match two character language codes directly against the frozenset in which the five character language codes are stored, which obviously fails. As a result it can only get exact matches and will return the default locale when using two character codes.\n    @classmethod\n    def get_closest(cls, *locale_codes):\n        \"\"\"Returns the closest match for the given locale code.\"\"\"\n        for code in locale_codes:\n            if not code:\n                continue\n            code = code.replace(\"-\", \"_\")\n            parts = code.split(\"_\")\n            if len(parts) > 2:\n                continue\n            elif len(parts) == 2:\n                code = parts[0].lower() + \"_\" + parts[1].upper()\n            if code in _supported_locales:\n                return cls.get(code)\n            if parts[0].lower() in _supported_locales:\n                return cls.get(parts[0].lower())\n        return cls.get(_default_locale)\nSpecifically this part:\n            if parts[0].lower() in _supported_locales:\n                return cls.get(parts[0].lower())\nI wrote the following simple function in my own code to bypass this problem but I bet someone else can write it a bit nicer into the intended function:\nlocale = self.request.headers.get('Accept-Language')\n\nif locale:\n    for l in tornado.locale.get_supported_locales():\n        if locale == l.split(\"_\")[0]:\n            self.locale = tornado.locale.get(l)", "issue_status": "Open", "issue_reporting_time": "2016-10-03T11:18:10Z"}, "98": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1856", "issue_id": "#1856", "issue_summary": "XSRF Token mismatch", "issue_description": "digitaldavenyc commented on 3 Oct 2016 \u2022\nedited\nI am attempting to use xsrf_cookies with Tornado, Jinja2 and a JavaScript application that will submit POST requests. I am including xsrf_form_html in the GET requests Jinja template and including the token in the headers of a POST request via AJAX.\nAfter looking threw the logs in tornado, the token being set on GET does not match what Tornado is looking for in the AJAX POST. The xsrf_token is being reset and Tornado throws a 403 error on all AJAX requests.\n1", "issue_status": "Open", "issue_reporting_time": "2016-10-03T05:49:36Z"}, "99": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1849", "issue_id": "#1849", "issue_summary": "Possible unicode issues with validate_absolute_path", "issue_description": "realcr commented on 28 Sep 2016\nHi, I caught this traceback info in my server logs:\n    Uncaught exception GET /s/chat.html%E2%80%8F (**.**.**.**)\n    HTTPServerRequest(protocol='http', host='www.****.com', method='GET', uri='/s/chat.html%E2%80%8F', version='HTTP/1.1', remote_ip='**.**.**.**', headers={'X-Real-Ip': '**.**.**.**, 'Accept-Language': 'he-IL,he;q=0.8,en-US;q=0.6,en;q=0.4', 'Host': 'www.****.com', 'Connection': 'upgrade', 'Upgrade-Insecure-Requests': '1', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, sdch, br', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'})\n    Traceback (most recent call last):\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/web.py\", line 1445, in _execute\n            result = yield result\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n            value = future.result()\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n            raise_exc_info(self._exc_info)\n        File \"<string>\", line 3, in raise_exc_info\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/gen.py\", line 282, in wrapper\n            yielded = next(result)\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/web.py\", line 2265, in get\n            self.root, absolute_path)\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/site-packages/tornado/web.py\", line 2446, in validate_absolute_path\n            if (os.path.isdir(absolute_path) and\n        File \"/home/production/.virtualenvs/wchat/lib/python3.5/genericpath.py\", line 42, in isdir\n            st = os.stat(s)\n    UnicodeEncodeError: 'ascii' codec can't encode character '\\u200f' in position 52: ordinal not in range(128)\n(I removed the exact IP of the user and the domain names).\nThis error seems to happen every time I access the path /s/chat.html%E2%80%8F in my server. Note that this path (everything under /s) is server using web.StaticFileHandler.\nI still haven't fully investigated this myself, though I was wondering if anyone had a similar problem. For reference, my installed Tornado version is 4.3. I am using python 3.5.1.", "issue_status": "Open", "issue_reporting_time": "2016-09-28T16:34:05Z"}, "100": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1842", "issue_id": "#1842", "issue_summary": "parse_multipart_form_data for stream_request_body", "issue_description": "Lookyan commented on 23 Sep 2016\nHi!\nWe have a good feature for streaming HTTP body (decorator stream_request_body).\nUsing stream_request_body we get chunks of HTTP body in data_received method. But this data is raw. And It will be cool to have a support for higher level tool to work with streaming body (in case of multipart_form_data).\nIf it is not solved yet I can do this, but I'm not sure about architecture for solution.\nI want to implement smth like StreamParser, which will get boundary and infinite generator which will return file-like objects. This parser we can instantiate in prepare method and then simply pass chunks in data_received method to it. Parser will write to these file-like objects and efficiently use RAM. But this solution has drawbacks. At least, we don't have universal solution in case if we want to handle data with some logic. Also we can't return any meta info from these file-like objects. But there can be important information such as ObjectId in case of using for example mongodb gridfs.\nAnother solution is to implement a subclass of RequestHandler with stream_request_body decorator and overridden prepare and data_received methods. We can add some extra abstract methods such as open_file, close_file, new_data and pass to them info about current state and chunks which we can write to file and do whatever we want without thinking about boundaries, headers.\nWhat do you think about it?\n2", "issue_status": "Open", "issue_reporting_time": "2016-09-23T09:08:08Z"}, "101": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1832", "issue_id": "#1832", "issue_summary": "Why tornado parse GET request body?", "issue_description": "justdoit0823 commented on 18 Sep 2016\nIn RFC 2616 section 4.3, it writes down:\nA server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.\nBut in tornado, the GET request body arguments can still be obtained from web.RequestHandler.get_argument.", "issue_status": "Open", "issue_reporting_time": "2016-09-18T09:31:22Z"}, "102": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1826", "issue_id": "#1826", "issue_summary": "CurlAsyncHTTPClient is dramatically slower than AsyncHTTPClient", "issue_description": "andrewyoung1991 commented on 13 Sep 2016\nI'm working on a service that calls AWS endpoints using Tornado. As recommended by the documentation, I have been using the Curl client but unfortunately this is exponentially slower than the builtin simple_http_client.\nMy local setup is:\nPython 3.5 (using async/await)\nTornado 4.4.1\nPycURL 7.43.0\nlibcurl 7.38.0\nOpenSSL 1.0.1t\nDocker (Debian base image with Python 3.5 installed)\nThe time spent blocking the IOLoop for the Curl client is lower than the builtin client, the builtin client will block for more than 5ms occasionally, where an equivalent call with the Curl client will never block for more than 2ms.\nAfter some profiling I've found that using the Curl client the code spends 98% of the time polling (select.epoll.poll), and ~1% of the time on prepping/sending/returning the Curl request, and ~1% of the time processing the response. The roundtrip here is over 80ms for a request where about 79ms are spent waiting. The equivalent request with the simple_http_client takes ~4ms...\nAny insights on what is going wrong or advice on how to debug?", "issue_status": "Open", "issue_reporting_time": "2016-09-12T20:42:03Z"}, "103": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1820", "issue_id": "#1820", "issue_summary": "Unit tests failing on hurd-i386 kfreebsd-i386 and ppc64", "issue_description": "Contributor\nonovy commented on 4 Sep 2016\nHi,\nhttps://buildd.debian.org/status/package.php?p=python-tornado\nTornado unit tests is failing on this platforms.\nDetails:\nhttps://buildd.debian.org/status/fetch.php?pkg=python-tornado&arch=hurd-i386&ver=4.4.1-2&stamp=1470438019\nhttps://buildd.debian.org/status/fetch.php?pkg=python-tornado&arch=kfreebsd-i386&ver=4.4.1-2&stamp=1470499227\nhttps://buildd.debian.org/status/fetch.php?pkg=python-tornado&arch=ppc64&ver=4.4.1-2&stamp=1470484079", "issue_status": "Open", "issue_reporting_time": "2016-09-04T11:59:03Z"}, "104": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1812", "issue_id": "#1812", "issue_summary": "Custom option from config external file is \"required to be a int (<type 'long'> given)\"", "issue_description": "thinkh commented on 25 Aug 2016 \u2022\nedited\nIn my setup I defined a custom option as following:\ndefine(\"my_custom_int_option\", default=0, help=\"custom help text\", type=int)\nThen I used this option in an external config file:\nmy_custom_int_option=1461151993676\nFor reading the config file I created the following option:\n# override defined default options and CLI arguments with values from config file\ndefine(\"config\", default=\"\", type=str, help=\"path to global config file\", callback=lambda path: parse_config_file(path, final=False))\nI run the tornado server using the following command: python main.py -config=env.config.conf\nWhen I request a page I get the following error on the console:\n[E 160825 06:32:20 http1connection:54] Uncaught exception\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/http1connection.py\", line 238, in _read_message\n        delegate.finish()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httpserver.py\", line 289, in finish\n        self.delegate.finish()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 2047, in finish\n        self.execute()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 2067, in execute\n        **self.handler_kwargs)\n      File \"/var/server/tornado/data/mowis_viz/__init__.py\", line 105, in __init__\n        tornado.options.parse_config_file(config_file, final=False)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/options.py\", line 574, in parse_config_file\n        return options.parse_config_file(path, final=final)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/options.py\", line 322, in parse_config_file\n        self._options[normalized].set(config[name])\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/options.py\", line 475, in set\n        (self.name, self.type.__name__, type(value)))\n    Error: Option 'my_custom_int_option' is required to be a int (<type 'long'> given)\nI also tried a smaller number in the config file (e.g., my_custom_int_option=1) and get the same error message.\nDoes anyone know what could be the solution here?\nMy Tornado version is 4.4.1.", "issue_status": "Open", "issue_reporting_time": "2016-08-25T06:43:19Z"}, "105": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1798", "issue_id": "#1798", "issue_summary": "Order of module in template random causes modules to be unable to depend on each other", "issue_description": "anders-jansson commented on 14 Aug 2016\nIf you create a template with several module statement in it and the javascript code depends on each other in a deterministic way.\nExample: I have module that pulls in jQuery and another module that uses jQuery, called myajax. In jQuery i have javascript_files method that point out a CDN for some version and in myajax i do a reference to jQuery. When rendered the order of jQuery and myajax is nondeterministic so it will fail in the browser.\nBy forcing the RequestHandler._active_modules to a OrderedDict the order will be the order the modules are defined in the template and open to decision of the developer. The below diff shows the change necessary. (Sorry for not being able to do a proper pull request but github might hate me or something).\norder_module.diff.txt", "issue_status": "Open", "issue_reporting_time": "2016-08-14T13:57:40Z"}, "106": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1791", "issue_id": "#1791", "issue_summary": "any way to graceful exit tornado application?", "issue_description": "0x11-lgtm commented on 8 Aug 2016\nthere are many gist show how to graceful exit tornado application like this:\nstop_httpserver(http_server)\ndef try_stop_ioloop():\n    io_loop = IOLoop.instance()\n    if io_loop._callbacks or io_loop._timeouts:\n        io_loop.add_timeout(time.time()+1, try_stop_ioloop)\n    else:\n        io_loop.stop()\n\ntry_stop_ioloop()\nit's safy to test io_loop._timeouts or _callbacks ? or _timeouts can be ignored?\n3", "issue_status": "Open", "issue_reporting_time": "2016-08-08T06:26:43Z"}, "107": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1753", "issue_id": "#1753", "issue_summary": "request_timeout does not stop HTTP 599: Timeout", "issue_description": "jkozlowicz commented on 17 Jun 2016\nI am getting quite a few tornado.httpclient.HTTPError: HTTP 599: Timeout errors.\nI read #1400 and I increased request_timeout for all my HTTPRequests to 2400.00 (40 minutes) then I rerun the code and I am 100% positive that I got not as many but still a few tornado.httpclient.HTTPError: HTTP 599: Timeout errors even thought my code finished running after 10 minutes.\nI wonder why it is so and if there is something else I could do to fix it?\n9", "issue_status": "Open", "issue_reporting_time": "2016-06-17T13:30:24Z"}, "108": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1700", "issue_id": "#1700", "issue_summary": "Cannot stop Application/HTTPServer/RequestHandler", "issue_description": "nojz commented on 25 Apr 2016 \u2022\nedited\nHello guys!\nI had the same problem:\nhttp://stackoverflow.com/questions/23778213/stopping-a-tornado-application\nI made a code snippet using this knowledge, but it does not work.\nimport tornado.web\n\nhttpServer = None\n\nclass RequestHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"OK\")\n\nclass HandlerStarter(tornado.web.RequestHandler):\n    def get(self):\n        global httpServer\n        requestHandler = tornado.web.Application([\n            (r\"/\", RequestHandler),\n        ])\n        httpServer = requestHandler.listen(7777)\n        self.write(\"started handler\")\n\nclass HandlerCloser(tornado.web.RequestHandler):\n    def get(self):\n        httpServer.stop()\n        self.write(\"stopped handler\")\n\nif __name__ == \"__main__\":\n    app = tornado.web.Application([\n        (r\"/start\", HandlerStarter),\n        (r\"/stop\", HandlerCloser)\n    ])\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nHere is the problem:\nI open localhost:8888/start so it starts a requesthandler on port 7777.\nI open localhost:7777 and I got the OK.\nI open localhost:8888/stop so it calls stop on the previously started requesthandler.\nI open localhost:7777 and it still returns OK, so it does not stop.\nDo you guys know why this happens?", "issue_status": "Open", "issue_reporting_time": "2016-04-25T15:09:53Z"}, "109": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1687", "issue_id": "#1687", "issue_summary": "Unable to add handlers to the same host_pattern after app init", "issue_description": "unhashable commented on 9 Apr 2016\nIn the following example, I add 2 handlers - one during init, and one after.\napp = tornado.web.Application([\n    ('/health', HealthHandler),  # gets a host_pattern of '.*$'\n])\napp.add_handlers(\n    host_pattern='.*$',\n    host_handlers=[\n        ('.*$', CatchAllHandler),\n    ],\n)\nI would expect that the CatchAllHandler would be routed to for all requests that do not match the route /health. Unfortunately, this is not the case.\nWhat actually happens is that all requests get routed to the CatchAllHandler - this is because that, even though they both share the same host_pattern, app.hosts is a list, and dispatching routes to the handlers in the first matched host_pattern in that list.\nThis certainly feels like a bug - how should one go about adding a handler to the same host_pattern after the application has been instantiated?", "issue_status": "Open", "issue_reporting_time": "2016-04-08T22:43:45Z"}, "110": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1665", "issue_id": "#1665", "issue_summary": "AsyncHTTPTestCase's fetch swallows httpclient exception", "issue_description": "kwarunek commented on 15 Mar 2016\nPython: 3.5.1\nTornado: 4.3\nUbuntu 12.04\nCase:\nimport unittest\nfrom tornado import testing\nfrom tornado import web\nfrom tornado import gen\n\nclass Handler(web.RequestHandler):\n\n    @gen.coroutine\n    def post(self):\n        self.write('spam')\n\n\nclass HandlerTest(testing.AsyncHTTPTestCase):\n    def get_app(self):\n        return web.Application([('/', Handler)])\n\n    def test_post(self):\n        response = self.fetch('/', method='POST')\n        self.assertEqual(b'spam', response.body)\n\nif __name__ == '__main__':\n    unittest.main()\nProduces:\nF\n======================================================================\nFAIL: test_post (__main__.HandlerTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/testing.py\", line 132, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"test.py\", line 20, in test_post\n    self.assertEqual(b'spam', response.body)\nAssertionError: b'spam' != None\n\n----------------------------------------------------------------------\nRan 1 test in 0.005s\n\nFAILED (failures=1)\ninstead of \"meaningful\" error.\nIf changed to @gen_test, it produce proper error:\nimport unittest\nfrom tornado import testing\nfrom tornado import web\nfrom tornado import gen\nfrom tornado.testing import gen_test\n\nclass Handler(web.RequestHandler):\n\n    @gen.coroutine\n    def post(self):\n        self.write('spam')\n\n\nclass HandlerTest(testing.AsyncHTTPTestCase):\n    def get_app(self):\n        return web.Application([('/', Handler)])\n\n    @gen_test\n    def test_post(self):\n        response = self.http_client.fetch(self.get_url('/'), method='POST')\n        self.assertEqual(b'spam', response.body)\n\nif __name__ == '__main__':\n    unittest.main()\nand the error, that is ok:\nE\n======================================================================\nERROR: test_post (__main__.HandlerTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/testing.py\", line 132, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/testing.py\", line 525, in post_coroutine\n    timeout=timeout)\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/ioloop.py\", line 453, in run_sync\n    return future_cell[0].result()\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/gen.py\", line 267, in wrapper\n    result = func(*args, **kwargs)\n  File \"/tmp/t35/lib/python3.5/types.py\", line 243, in wrapped\n    coro = func(*args, **kwargs)\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/testing.py\", line 508, in pre_coroutine\n    result = f(self, *args, **kwargs)\n  File \"test.py\", line 22, in test_post\n    self.assertEqual(b'spam', response.body)\nAttributeError: 'Future' object has no attribute 'body'\n\n----------------------------------------------------------------------\nRan 1 test in 0.006s\n\nFAILED (errors=1)\nERROR:tornado.application:Future <tornado.concurrent.Future object at 0x7ffb966965c0> exception was never retrieved: Traceback (most recent call last):\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/gen.py\", line 264, in <lambda>\n    future, lambda future: callback(future.result()))\n  File \"/tmp/t35/lib/python3.5/site-packages/tornado/simple_httpclient.py\", line 353, in _on_connect\n    ('not ' if body_expected else '', self.request.method))\nValueError: Body must not be None for method POST (unless allow_nonstandard_methods is true)\nRef. http://stackoverflow.com/questions/36013805/can-only-perform-get-requests-in-tornado-test/36015750#36015750", "issue_status": "Open", "issue_reporting_time": "2016-03-15T15:54:21Z"}, "111": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1595", "issue_id": "#1595", "issue_summary": "Hanging concurrent.futures Future", "issue_description": "Contributor\nmrocklin commented on 25 Nov 2015\nCopying from this stackoverflow question\nWaiting on a concurrent.futures.Future from a ThreadPoolExecutor in a Tornado coroutine sometimes hangs for me:\nfrom concurrent.futures import ThreadPoolExecutor\ntp_executor = ThreadPoolExecutor(8)\n\ndef slowinc(x):\n    time.sleep(0.1)\n    return x + 1\n\nyield tp_executor.submit(slowinc, 1)  # sometimes hangs\nWhen I add a timeout it might hang for the timeout period, but seems to actually return the correct result after that time.\nyield gen.with_timeout(timedelta(seconds=5), \n                       executor.submit(...))  # hangs for 5sec, then works\nThis only happens in the context of a larger test suite, in which many unpleasant things occur (child processes are terminated mid-stride). This error is almost certainly related to this unpleasant context and not strictly the fault of Tornado. However, I believe that I have isolated these unpleasant things as well as possible.\nSo I apologize for the subtle bug and lack of a simple repeatable example. My hope is that the odd behavior of a failing timeout actually causing success is helpful in isolating my issue.\nSolutions in Python 3\nI resolve this problem In Python 3 by using a timeout and a while loop:\nwhile not future.done():\n    try:\n        yield gen.with_timeout(timedelta(seconds=1), future)\n    except gen.TimeoutError:\n        pass\n\nresult = future.result()\nIn this answer on stackoverflow @bdarnell suggests using a PeriodicCallback in order to wake up a stuck IOLoop.\nI don't have a complete solution but I think I can offer a simpler workaround: start up a background PeriodicCallback that does nothing in a short interval: PeriodicCallback(lambda: None, 500).start(). This will make sure the IOLoop wakes up periodically without intruding into all your yield executor.submit() calls.\nThe symptom suggests that the problem lies in the \"waker\" behavior of add_callback:\ntornado/tornado/ioloop.py\nLines 929 to 944 in d9c5bc8\n if thread.get_ident() != self._thread_ident: \n     # If we're not on the IOLoop's thread, we need to synchronize \n     # with other threads, or waking logic will induce a race. \n     with self._callback_lock: \n         if self._closing: \n             return \n         list_empty = not self._callbacks \n         self._callbacks.append(functools.partial( \n             stack_context.wrap(callback), *args, **kwargs)) \n         if list_empty: \n             # If we're not in the IOLoop's thread, and we added the \n             # first callback to an empty list, we may need to wake it \n             # up (it may wake up on its own, but an occasional extra \n             # wake is harmless).  Waking up a polling IOLoop is \n             # relatively expensive, so we try to avoid it when we can. \n             self._waker.wake() \nThis code was changed in Tornado 4.3 (https://github.com/tornadoweb/tornado/pull/1511/files). If you're on 4.3, see if the problem still exists in 4.2. Could anything in your \"unpleasant\" environment be causing thread.get_ident() to behave differently than tornado expects?\nThere are reports of (rare) problems with the waker \"pipe\" on windows: #1364\nPython 2 Failures\nThe timeout solution above works for Python 3.4 under both Tornado 4.2 and 4.3 but neither the timeout solution nor the PeriodicCallback solution resolves this problem under Python 2.7 Tornado 4.2 or 4.3.\nI still intermittently hang when yielding on concurrent.futures.Future objects, but only when using Python 2.\nDoes anyone have thoughts on what might be causing this and where I should start looking?", "issue_status": "Open", "issue_reporting_time": "2015-11-24T22:02:17Z"}, "112": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1581", "issue_id": "#1581", "issue_summary": "Vary: Accept-Encoding header for non-compressable content", "issue_description": "Contributor\nschlamar commented on 11 Nov 2015\nYou never compress non-compressable content such as png images. So why are you sending a Vary: Accept-Encoding header in this cases?", "issue_status": "Open", "issue_reporting_time": "2015-11-11T10:42:03Z"}, "113": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1580", "issue_id": "#1580", "issue_summary": "HEAD with compress_response is wrong", "issue_description": "Contributor\nschlamar commented on 11 Nov 2015\nTornado does not indicate gzip encoding and chunked transfer encoding in a HEAD request, so there is a header mismatch between GET and HEAD.\nExample application with static file handler:\napp = web.Application(compress_response=True, static_path='static')\napp.listen(8888)\nioloop.IOLoop.current().start()\nGET Request\n> GET /static/test.txt HTTP/1.1\n> User-Agent: curl/7.30.0\n> Host: 127.0.0.1:8888\n> Accept: */*\n> Accept-Encoding: deflate, gzip\n>\n< HTTP/1.1 200 OK\n< Content-Encoding: gzip\n< Transfer-Encoding: chunked\n< Accept-Ranges: bytes\n< Vary: Accept-Encoding\n* Server TornadoServer/4.4.dev1 is not blacklisted\n< Server: TornadoServer/4.4.dev1\n< Last-Modified: Wed, 11 Nov 2015 07:05:43 GMT\n< Etag: \"b08c2cde93fbd9504fbe88ec1d5c7662\"\n< Date: Wed, 11 Nov 2015 07:08:27 GMT\n< Content-Type: text/plain\nHEAD Request\n> HEAD /static/test.txt HTTP/1.1\n> User-Agent: curl/7.30.0\n> Host: 127.0.0.1:8888\n> Accept: */*\n> Accept-Encoding: deflate, gzip\n>\n< HTTP/1.1 200 OK\n< Content-Length: 9720\n< Accept-Ranges: bytes\n< Vary: Accept-Encoding\n* Server TornadoServer/4.4.dev1 is not blacklisted\n< Server: TornadoServer/4.4.dev1\n< Last-Modified: Wed, 11 Nov 2015 07:05:43 GMT\n< Etag: \"b08c2cde93fbd9504fbe88ec1d5c7662\"\n< Date: Wed, 11 Nov 2015 07:11:19 GMT\n< Content-Type: text/plain", "issue_status": "Open", "issue_reporting_time": "2015-11-11T07:19:25Z"}, "114": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1566", "issue_id": "#1566", "issue_summary": "Invalid Scopes: read_stream error in facebook", "issue_description": "rakeshsukla53 commented on 24 Oct 2015\nI am trying to run this tornado facebook application but I am continuously getting this error after passing my login credentials on facebook.\nIn my client Oauth settings, I have enabled both client and web login. Could anyone help me to get rid of this error?", "issue_status": "Open", "issue_reporting_time": "2015-10-24T08:24:50Z"}, "115": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1516", "issue_id": "#1516", "issue_summary": "tornado.httputil.HTTPServerRequest age property", "issue_description": "Contributor\nalunduil commented on 12 Sep 2015\nIn some signing and validation work I'm doing, it would be super convenient if the request had an age property (the time between request.headers['Date'] and time.time() in seconds). This would simply provide the age of the request as provided by the client and verification of the Date header would need to occur elsewhere if needed.\nWhat's the stance on adding properties like this? If you're receptive let me know and I can easily provide a pull request.", "issue_status": "Open", "issue_reporting_time": "2015-09-11T18:55:33Z"}, "116": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1504", "issue_id": "#1504", "issue_summary": "Access with server-sent events only logged after connection is closed", "issue_description": "Contributor\nmivade commented on 29 Aug 2015\nI have extended tornado.web.RequestHandler to support server-sent events:\nclass EventSource(RequestHandler):\n    \"\"\"Base handler for server-sent events.\"\"\"\n    def initialize(self, source):\n        \"\"\"The ``source`` parameter is a string that is updated with\n        new data. The :class:`EventSource` instance will continuously\n        check if it is updated and publish to clients when it is.\n\n        \"\"\"\n        assert isinstance(source, stores.DataStore)\n        self.source = source\n        self._last = None\n        self.finished = False\n        self.set_header('content-type', 'text/event-stream')\n        self.set_header('cache-control', 'no-cache')\n\n    @gen.coroutine\n    def publish(self, data):\n        \"\"\"Pushes data to a listener.\"\"\"\n        try:\n            self.write('data: {}\\n\\n'.format(data))\n            yield self.flush()\n        except StreamClosedError:\n            self.finished = True\n\n    @gen.coroutine\n    def get(self):\n        while not self.finished:\n            if self.source.data != self._last:\n                yield self.publish(self.source.data)\n                self._last = self.source.data\n            else:\n                yield gen.sleep(0.01)\n        self.finish()\nWhen connecting to an implementation of EventSource, I correctly receive the streamed data. However, accessing the stream is not logged until after the connection is closed. This results in access logs that indicate very long times:\n[I 150829 14:30:20 web:1908] 200 GET /stream/all (::1) 7856.83ms\n[I 150829 14:30:22 web:1908] 200 GET /stream/all (::1) 25523.45ms\n[I 150829 14:30:23 web:1908] 200 GET /stream/all (::1) 43150.50ms\nIt would be more useful for streams like this to log when the initial connection is made.", "issue_status": "Open", "issue_reporting_time": "2015-08-29T12:40:19Z"}, "117": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1490", "issue_id": "#1490", "issue_summary": "CurlAsyncHTTPClient does not support internationalized domain names", "issue_description": "Sjord commented on 18 Aug 2015\nWhen I try to request a page with non-ASCII characters in the URL, e.g. http://st\u00fctzstr\u00fcmpfe.de/ or https://nl.wikipedia.org/wiki/Belgi\u00eb, I get an UnicodeEncodeError exception when using the curl client. It works as expected with the default simple HTTP client.\nThis can be fixed by splitting the URL and encoding all parts correctly, as in this example.\nScript to reproduce:\n# coding: utf-8\nfrom tornado.httpclient import AsyncHTTPClient, HTTPClient\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\nhttp_client = HTTPClient()\nhttp_client.fetch('https://nl.wikipedia.org/wiki/Belgi\u00eb')\nhttp_client.fetch('http://www.st\u00fctzstr\u00fcmpfe.de')\nException:\nTraceback (most recent call last):\n  File \"reproduce.py\", line 6, in <module>\n    http_client.fetch('https://nl.wikipedia.org/wiki/Belgi\u00eb')\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/httpclient.py\", line 102, in fetch\n    self._async_client.fetch, request, **kwargs))\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/ioloop.py\", line 445, in run_sync\n    return future_cell[0].result()\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/concurrent.py\", line 215, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/curl_httpclient.py\", line 214, in _process_queue\n    curl.info[\"headers\"])\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/curl_httpclient.py\", line 283, in _curl_setup_request\n    curl.setopt(pycurl.URL, native_str(request.url))\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xeb' in position 35: ordinal not in range(128)\n1", "issue_status": "Open", "issue_reporting_time": "2015-08-18T12:54:49Z"}, "118": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1448", "issue_id": "#1448", "issue_summary": "use os.sendfile() when available", "issue_description": "scoder commented on 3 Jun 2015\nThe StaticFileHandler should use os.sendfile() if available. While static files would commonly be sent by an external webserver (nginx etc.) in a production environment, sometimes files are generated on the fly and need to be written out through the IOLoop. sendfile() would reduce the overhead here.\nI'd also like to have a general high-level RequestHandler.send_file(file_path, content_type=None) method for this case that the StaticFileHandler would call, but that other user code could conveniently use as well. If sendfile() is not available, it would simply fall back to forwarding chunks, but user code wouldn't have to care any more how exactly it works on the current system.\n2", "issue_status": "Open", "issue_reporting_time": "2015-06-03T13:30:27Z"}, "119": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1438", "issue_id": "#1438", "issue_summary": "HTTP/2 support", "issue_description": "dvirsky commented on 5 May 2015\nIt would be nice to see tornado implement http/2, not that AFAIK it's a standard.\n15", "issue_status": "Open", "issue_reporting_time": "2015-05-05T08:35:11Z"}, "120": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1426", "issue_id": "#1426", "issue_summary": "Problem with nested requests when using the FacebookGraphMixin get_authenticated_user call", "issue_description": "pfrantz commented on 21 Apr 2015\nWhen using the FacebookGraphMixin and calling get_authenticated_user with the extra_fields parameter set to a list of fields that contain nested fields, the returned dictionary will not contain any fields which are nested.\nWith the Facebook graph api you can specify nested fields which contain modifier and sub selectors. For example you can specify limit by adding a .limit(nn) to a field name.\nfor example a call lilke:-\nauth_info = yield self.get_authenticated_user(\nredirect_uri=my_url,\nclient_id=client_id,\nclient_secret=client_secret,\ncode=self.get_argument('code'),\nextra_fields=['email', 'gender', 'age_range', 'permissions', 'friends.limit(5000)'])\nwill not return the friend list because it don't realise that .limit(5000) is a modifier and the returned field name is friends not friends.limit(5000).\nthe fix is relatively easy in auth.py by changing the method FacebookGraphMixin._on_get_user_info to remove modifiers prior to mapping the results. Something like this at the start of the method would do\nfields = [field.split('.', 1)[0] for field in fields]", "issue_status": "Open", "issue_reporting_time": "2015-04-21T05:20:07Z"}, "121": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1414", "issue_id": "#1414", "issue_summary": "Doc/Wiki/Example on how to write non-blocking drivers to support Tornado IOLoop", "issue_description": "rskumar commented on 10 Apr 2015\nNeed official extensive doc/wiki with examples on how to write non-blocking networking IO based drivers to interact with external application.\nThat would be nice addon for developers who want to write libraries around Tornado. And it will benefit tornado community.", "issue_status": "Open", "issue_reporting_time": "2015-04-10T02:36:55Z"}, "122": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1334", "issue_id": "#1334", "issue_summary": "iostream - cancel read_until_close", "issue_description": "coffeeowl commented on 12 Feb 2015\nHello,\nI have a problem with switching a stream to TLS, it throws an exception saying that the stream is not idle. I guess it is because I have read_until_close called on it, so there is a read callback, but there is no actual data anywhere, so the stream could be switched to TLS.\nMaybe the solution is to use another read method which reads only some amount of data, but the problem is that I don't have a clear condition on where to stop waiting for new data, the process can take time and it is governed by a state machine, regex would not work there, basically I am implementing an XMPP client lib on tornado.iostream\nAny suggestions how to handle that? Is it possible to clear callbacks installed by read_until_close?", "issue_status": "Open", "issue_reporting_time": "2015-02-12T11:04:29Z"}, "123": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1321", "issue_id": "#1321", "issue_summary": "static_path should only claim /favicon.ico and /robots.txt if they exist", "issue_description": "Member\nbdarnell commented on 2 Feb 2015\nSince static_path inserts its handlers at the front of the list, it shouldn't claim additional top-level paths if the corresponding files don't exist.\nhttp://stackoverflow.com/questions/28278157/python-tornado-dont-match-favicon-ico", "issue_status": "Open", "issue_reporting_time": "2015-02-02T15:47:27Z"}, "124": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1239", "issue_id": "#1239", "issue_summary": "enhencment: auto reload with checking file finished uploading and syntax checking", "issue_description": "shimondoodkin commented on 2 Nov 2014\nnot sure how to add this to code. maybe someone to add this to project.\nthis is the first time i wrote python\nimport os\nimport tornado.ioloop\nimport tornado.web\nimport tornado.autoreload\nimport time\nfrom datetime import datetime\nimport json\n\ncompileerr=\"\"\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        global compileerr\n        if compileerr!=\"\":\n            self.write(\"<pre>Compile error:\\n\"+compileerr);\n            #self.render(\"index.html\")\n        else:\n            try:\n                with open(os.path.join(os.path.dirname(__file__), 'index.html')) as f:\n                    self.write(f.read())\n            except IOError as e:\n                self.write(\"404: Not Found\")\n\nes_empty_result={ \"hits\": {\"hits\": [], \"total\": 0, \"max_score\": None}, \"_shards\": {\"successful\": 5, \"failed\": 0, \"total\": 5 }, \"took\": 3, \"timed_out\": False }\n\n#some apis\nclass List1Handler(tornado.web.RequestHandler):\n    def get(self):\n        global es_empty_result\n        id=self.get_argument(\"id\", default=None, strip=False)\n        user=self.get_argument(\"user\", default=None, strip=False)\n        self.write(json.dumps(es_empty_result, sort_keys = False, indent = 4))\n\nclass List2Handler(tornado.web.RequestHandler):\n    def get(self):\n        global es_empty_result\n        id=self.get_argument(\"id\", default=None, strip=False)\n        user=self.get_argument(\"user\", default=None, strip=False)\n        self.write(json.dumps(es_empty_result, sort_keys = False, indent = 4))\n\napplication = tornado.web.Application([\n(r\"/$\", MainHandler),\n(r\"/list1$\", List1Handler),\n(r\"/list2$\", List2Handler),\n(r\"/.*\\.py$\", MainHandler),# don't serve python as static files \n(r\"/(.*)$\", tornado.web.StaticFileHandler, dict(path=os.path.dirname(__file__))),\n ])\n\nif __name__ == \"__main__\":\n    import py_compile\n    import logging\n    from threading import Timer\n\n    def ontimer_reload(prev_mtime,filepath,mainfile): # wait for file to stop changing, than check syntax,than reload\n        global compileerr\n        statinfo=os.stat(filepath)\n\n        if statinfo.st_size>0 and statinfo.st_ctime==statinfo.st_mtime and statinfo.st_mtime-prev_mtime==0: \n            compiled=False \n            try:\n                py_compile.compile(mainfile,doraise=True)\n                compiled=True\n            except py_compile.PyCompileError as e:\n                compileerr=str(e)\n                print \"reloading: compile error...\" \n                print e;\n            if compiled:\n                logging.info(\"%s modified; restarting server\", filepath)\n                tornado.autoreload._reload()\n        else:\n            print \"reloading: waiting for file upload complete.\"\n            Timer(0.3, ontimer_reload,(statinfo.st_mtime,filepath,mainfile)).start()\n    #usage:Timer(0.3, ontimer_reload,(path,__file__)).start()\n\n    def new_check_file(modify_times, filepath):\n        try:\n            modified = os.stat(filepath).st_mtime\n        except Exception:\n            return\n        if filepath not in modify_times:\n            modify_times[filepath] = modified\n            return\n        if modify_times[filepath] != modified:\n            modify_times[filepath] = modified\n            Timer(0.3, ontimer_reload,(modified, filepath,__file__)).start()\n            #monkey patch tornado reload class\n    tornado.autoreload._check_file = new_check_file\n\n    print \"server start\"\n    application.listen(8888)\n\n    #def beforereloading():\n    #   print \"reloading: exiting...\"\n\n    #tornado.autoreload.add_reload_hook(beforereloading)\n    #tornado.autoreload.watch(os.path.abspath('./file')) #additional file to watch\n    tornado.autoreload.start()\n    tornado.ioloop.IOLoop.instance().start()\n    tornado.autoreload.wait()\n\n\"\"\"\npaste large text here to test like duplicate the folowing text until 1000 lines\n\nHOWTO'S AND FAQ'    Difference between mtime, ctime and atime \n\nA common mistake is that ctime is the file creation time. This is not correct, it is the inode/file change time. mtime is the file modification time. A often heard question is What is the ctime, mtime and atime?.This is confusing so let me explain the difference between ctime, mtime and atime.\nctime\nctime is the inode or file change time. The ctime gets updated when the file attributes are changed, like changing the owner, changing the permission or moving the file to an other filesystem but will also be updated when you modify a file.\n\nmtime\nmtime is the file modify time. The mtime gets updated when you modify a file. Whenever you update content of a file or save a file the mtime gets updated.\n\nMost of the times ctime and mtime will be the same, unless only the file attributes are updated. In that case only the ctime gets updated.\n\natime\natime is the file access time. The atime gets updated when you open a file but also when a file is used for other operations like grep, sort, cat, head, tail and so on.\n\"\"\"", "issue_status": "Open", "issue_reporting_time": "2014-11-02T01:07:01Z"}, "125": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1237", "issue_id": "#1237", "issue_summary": "AsyncTestCase.wait(condition) doesn't work if stop called too soon", "issue_description": "Member\nbdarnell commented on 31 Oct 2014\nIf stop() is called before wait() begins, wait() never enters the loop in which it checks the condition. If a condition is set and has not been met, we should enter the loop even if stopped is true.", "issue_status": "Open", "issue_reporting_time": "2014-10-31T01:18:44Z"}, "126": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1223", "issue_id": "#1223", "issue_summary": "Exceptions in data_received() (while using @stream_request_body) are not handled properly", "issue_description": "socketpair commented on 15 Oct 2014\nTo overcome that, I use:\n@stream_request_body\nclass RestoreHandler(RequestHandler):\n    ...\n    @gen.coroutine\n    def data_received(self, chunk):\n        try:\n            yield buggy_operation()\n        except Exception:\n            self.set_header('Connection', 'close')\n            self.set_status(413, 'Upload aborted')\n            self.finish()\n    ...\nIf I do not catch exception, connection silently aborted (as browser said). But instead, Tornado should respond with HTTP response and close connection.", "issue_status": "Open", "issue_reporting_time": "2014-10-14T19:55:37Z"}, "127": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1152", "issue_id": "#1152", "issue_summary": "Implement PipeIOStream alternative for Windows.", "issue_description": "blakev commented on 22 Aug 2014\nIn tornado.iostream the _set_nonblocking is only not None on posix systems...otherwise it defaults and causes PipeIOStream to not work on Windows. I'm requesting a non-breaking alternative even if the functionality doesn't match the intended implementation as is on Unix.", "issue_status": "Open", "issue_reporting_time": "2014-08-21T21:09:43Z"}, "128": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1141", "issue_id": "#1141", "issue_summary": "Order of Operations issue in constructor to RequestHandler", "issue_description": "thehesiod commented on 7 Aug 2014\ncurrently it first calls self.clear() and then self.initialize(). This is an issue if you've overridden set_default_headers and initialize and relies on initialization parameters set from an initialize since clear() eventually calls set_default_headers.\nI recommend self.initialize() should be called before self.clear()", "issue_status": "Open", "issue_reporting_time": "2014-08-06T23:46:44Z"}, "129": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1122", "issue_id": "#1122", "issue_summary": "Unused client_secret parameter in OAuth2Mixin.authorize_redirect", "issue_description": "Member\nbdarnell commented on 20 Jul 2014\nOAut2Mixin.authorize_redirect takes a cilent_secret parameter but doesn't use it (_oauth_request_token_url also takes a client_secret and uses it, but it is not called form authorize_redirect). None of the other auth mixins take a client_secret parameter so this unused parameter should probably just be removed.", "issue_status": "Open", "issue_reporting_time": "2014-07-19T22:50:09Z"}, "130": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1099", "issue_id": "#1099", "issue_summary": "web.authenticated: allow 403 without redirection", "issue_description": "Contributor\nxose commented on 9 Jul 2014\nThe @web.authenticated decorator will always redirect with a 302 when the user is not logged in and the method is GET or HEAD. There is currently no way to return a 403 error for GET/HEAD requests using the decorator.\nThis is OK if the request comes form a web browser that expects HTML, but not if you are developing an API that's meant to be consumed using other methods.\nHere's my proposal:\nAllow the get_login_url() method to return None. Have the default implementation return None when login_url is not set in the config instead of raising an exception.\nHave @web.authenticated return a 403 when get_login_url() returns None instead of redirecting.", "issue_status": "Open", "issue_reporting_time": "2014-07-09T18:13:07Z"}, "131": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1095", "issue_id": "#1095", "issue_summary": "Provide control over gzip compression level in tornado.web.Application", "issue_description": "seibert commented on 4 Jul 2014\nBy default, GzipFile in the Python standard library uses a compression level of 9 (the highest available): https://docs.python.org/2/library/gzip.html#gzip.GzipFile\nMost other applications (like the gzip command line tool) default to level 6 or lower. The difference in throughput can be something like a factor of 3-5x on a single core, leading many people to incorrectly conclude that using gzip compression with Tornado is \"too slow\" compared to other web servers (like node.js, for example, which led me to discover the cause of this problem).\nIt would be nice if the gzip option to tornado.web.Application could also be a number (1-9), indicating the compresslevel to pass to GzipFile. If True is passed, I would also advocate that a default value of 6 is used, rather than the standard library default. The compression factor will be very close to that of level 9, but throughput will be much larger.\nIf this sounds reasonable, I can make a PR.", "issue_status": "Open", "issue_reporting_time": "2014-07-03T21:43:04Z"}, "132": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1094", "issue_id": "#1094", "issue_summary": "HTTPHeaders.get_list() improve functionality", "issue_description": "liamcoau commented on 3 Jul 2014\nCurrently if in the headers the Accept header had a value of\ntext/*, text/html, text/html;level=1, */*,\nthen\nself.request.headers.get_list(\"Accept\")\nwould return:\n[\"text/*, text/html, text/html;level=1, */*\"]\nThe documentation for get_list says:\n\"Returns all values for the given header as a list.\"\nWhen I originally read this I thought the multiple accept types would be broken up and all added to a list such as:\n[\"text/*\", \"text/html\", \"text/html;level=1\", \"*/*\"]\nI think that this would be much more useful and make more sense, or at least it would be in the project I'm working on.\nI achieved the same effect by the following code:\nresponse_type = self.request.headers.get_list(\"Accept\")\nresponse_type = [item.strip() for index in range(len(response_type)) for item in response_type[index].split(\",\")]\nAlso it would be helpful if the documentation was explicit about what's returned if the header name wasn't given.", "issue_status": "Open", "issue_reporting_time": "2014-07-03T13:39:13Z"}, "133": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1066", "issue_id": "#1066", "issue_summary": "Add debug-mode flag for translation files", "issue_description": "Member\nbdarnell commented on 26 May 2014\nThere is currently no way to reload translations (csv and gettext) without restarting the server. We should add a debug-mode flag to either reload the translations when they change, or watch them in autoreload so the whole server can restart.", "issue_status": "Open", "issue_reporting_time": "2014-05-26T02:40:38Z"}, "134": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1050", "issue_id": "#1050", "issue_summary": "get_ssl_certificate is untested", "issue_description": "Contributor\nmoijes12 commented on 10 May 2014\nThe HTTPRequest.get_ssl_certificate does not contain any tests. This should be fixed especially since it can be called in multiple ways (with different values for the binary_form parameter) and because it is a way to return the security certificate.", "issue_status": "Open", "issue_reporting_time": "2014-05-10T17:06:33Z"}, "135": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1036", "issue_id": "#1036", "issue_summary": "Parse proxy-style (absolute-url) requests", "issue_description": "Member\nbdarnell commented on 15 Apr 2014\nAccording to http://tools.ietf.org/html/rfc2616#section-5.1.2 it's valid to use absolute urls in the start line even for non-proxy requests, and servers MUST support it. Tornado needs to parse the url if it doesn't start with a slash (this will need to be messaged for people who are currently writing http proxies with a .* routing rule)", "issue_status": "Open", "issue_reporting_time": "2014-04-15T01:38:48Z"}, "136": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1003", "issue_id": "#1003", "issue_summary": "Better UDP support with a built in UDPServer class", "issue_description": "rferreira commented on 5 Mar 2014\nLet me know if this has been attempted/discussed in the past but having a sensible UDPServer class (the same way tornado provides a TCPServer one) would be tremendously helpful. I know there are examples sprinkled around the internets on how to use torando's io_loop on a UDP socket but it's all quite messy.\n3", "issue_status": "Open", "issue_reporting_time": "2014-03-05T15:14:54Z"}, "137": {"issue_url": "https://github.com/tornadoweb/tornado/issues/904", "issue_id": "#904", "issue_summary": "Add method to get client's claimed IP", "issue_description": "Member\nbdarnell commented on 22 Sep 2013\nThe HTTPRequest.remote_ip field is intended to contain a trustworthy equivalent of the TCP-level remote address, so it accepts only a single X-Forwarded-For hop, and only when configured to do so. For some purposes (e.g. geolocation), it is useful to take whatever IP address the client claims to be using even through a chain of untrusted proxies. There should be some method to return the first public IP address from X-Forwarded-For.", "issue_status": "Open", "issue_reporting_time": "2013-09-22T16:28:03Z"}, "138": {"issue_url": "https://github.com/tornadoweb/tornado/issues/903", "issue_id": "#903", "issue_summary": "Use stricter/platform-independent IP parsing for X-Forwarded-For", "issue_description": "Member\nbdarnell commented on 22 Sep 2013\nnetutil.is_valid_ip uses getaddrinfo in AI_NUMERICHOST mode to parse IP addresses. This method accepts some surprising formats (e.g. \"x.y\" is parsed as x.(y >> 16).((y>>8)&0xff).(y&0xff), at least on mac and linux). It would be good to limit this to a more formal specification (e.g. the one in http://tools.ietf.org/html/rfc3986#section-3.2.2, which is cited in http://tools.ietf.org/html/draft-ietf-appsawg-http-forwarded-10#section-6.1).", "issue_status": "Open", "issue_reporting_time": "2013-09-22T16:24:25Z"}, "139": {"issue_url": "https://github.com/tornadoweb/tornado/issues/902", "issue_id": "#902", "issue_summary": "HTTP 405 response must include an Allow header", "issue_description": "thijsvandien commented on 21 Sep 2013\nWhen an HTTPError(405) is raised, either manually or automatically because of not implementing a handler, Tornado does not set the officially required Allow header. Worse, if I set it myself, it is erased by RequestHandler.send_error. Bluntly said, it means that Tornado does not follow HTTP standards.\nWhen addressing this, please consider adding a possibility to override the list of supported methods, rather than looking only at the present handlers; I built my own mechanism to limit their usage at certain URLs:\nclass BaseHandler(RequestHandler):\n    def initialize(self, *args, **kwargs):\n        self.allowed_methods = kwargs.get('allowed_methods', type(self).SUPPORTED_METHODS)\n\n    def prepare(self):\n        if self.request.method not in self.allowed_methods: raise HTTPError(405)", "issue_status": "Open", "issue_reporting_time": "2013-09-21T16:03:59Z"}, "140": {"issue_url": "https://github.com/tornadoweb/tornado/issues/892", "issue_id": "#892", "issue_summary": "Inconsistent behaviour of static file serving", "issue_description": "sonicisthebest commented on 23 Aug 2013\nIf Tornado (3.1) is not running in debug mode, when a static file is accessed for the first time the included StaticFileHandler will generate an MD5 hash for it and store that hash in perpetuity. The handler will then read the content of the file and serve it up with the corresponding version and ETag. The next time the same client requests the file we get a 304 response and the client uses its own copy from its cache.\nNow let's modify the file and change something interesting in the static file. If the original client now requests the file again, we still get the cached copy from the local browser since the ETag is linked to the cached hash in Tornado.\nConsider now what happens if another distinct client that has not accessed the file before tries to fetch the same static file. Tornado will happily serve up the file, but it reads it off the disk again, and that client gets the new version of the file, but since Tornado already has a cached hash for that file it serves the new file with the old ETag. So now we have two different versions of the same file with the same ETag being shown on two different clients.\nSome ideas:\nCache the file along with the hash and always serve it consistently -- memory issues.\nUpdate the hash when the file is read by the second client -- inconsistent state, the original client shouldn't get a different response on the off chance that another client without a locally cached copy has fetched since the original client did.\nChange the ETag / revision hashing to avoid assigning the same hash two different versions of the file -- this would oblige some kind of stat call to see if the file has changed and would always serve the most recent version -- it would also need to check the hash is up to date when using static_url calls.\n1", "issue_status": "Open", "issue_reporting_time": "2013-08-23T11:30:03Z"}, "141": {"issue_url": "https://github.com/tornadoweb/tornado/issues/865", "issue_id": "#865", "issue_summary": "XSRF cookie expiration issues", "issue_description": "Member\nbdarnell commented on 5 Aug 2013\nThe xsrf cookie is not refreshed gracefully when it expires. Form-based applications will usually be OK since they will request a page with a fresh token before any form submission, but long-lived AJAXy pages can have trouble if a session crosses the 30-day boundary. There should be some way to refresh the token before it expires.\nAdditionally, the cache expiration of any page that includes xsrf_form_html should not be greater than the remaining time on the xsrf cookie.\nDiscussion: https://groups.google.com/forum/#!searchin/python-tornado/xsrf/python-tornado/1aN84IYC7h8/cW9-J9JbxcUJ", "issue_status": "Open", "issue_reporting_time": "2013-08-04T19:21:38Z"}, "142": {"issue_url": "https://github.com/tornadoweb/tornado/issues/864", "issue_id": "#864", "issue_summary": "Framework for setting cache-related headers", "issue_description": "Member\nbdarnell commented on 5 Aug 2013\nIf certain features of Tornado are used, the resulting pages should not be cached (e.g. xsrf tokens, locale detection). The Cache-Control and Vary headers are currently left up to the application (except for the Vary: Accept-Encoding header added by the gzip encoder). We should set the appropriate cache-related headers by default and probably introduce some new interfaces to coordinate these headers between the framework and application-level code (and middleware/mixins).\nTreat Vary header as a set while the response is being generated, both so multiple cookies don't each append their own Vary: Cookie header and for consistency between the multi-header form and the comma-separated list.\nConsider adding a method like get_header(name, default=None, set_vary=True).\nDocument recommended idioms for setting Vary header (e.g. emphasizing that Vary must be set whether the header you looked for was present or not).\nXSRF tokens (and cookies generally) often imply Cache-Control: private instead of Vary: cookie, but the single-valued Cache-Control header is tricker to coordinate than the multi-valued Vary.\nConsider making Cache-Control: private the default (except for StaticFileHandler) since public caching generally requires some care by the application developer.\nDiscussion: https://groups.google.com/forum/#!searchin/python-tornado/xsrf/python-tornado/1aN84IYC7h8/cW9-J9JbxcUJ", "issue_status": "Open", "issue_reporting_time": "2013-08-04T19:07:22Z"}, "143": {"issue_url": "https://github.com/tornadoweb/tornado/issues/845", "issue_id": "#845", "issue_summary": "Clear IOStream read buffer on connection close", "issue_description": "Member\nbdarnell commented on 7 Jul 2013\nCommit c439962 clears the IOStream write buffer when the stream is closed. We should clear the read buffer as well, but there are currently tests that fail when that is done.\nThe issue is that we allow reads from buffered data after the underlying connection is closed. As long as one read leads directly (and synchronously) to another, the close callback is delayed. When there is a gap between the two reads, the close callback is run at that point, but we have some tests that rely on the availability of buffered data at this point. (We could perhaps declare these tests to be incorrect, but would need to offer some way for applications to indicate an intent to read when they need to preserve the buffered data).\nThere is additional discussion in #747, but note that the solution I mention there (acting as if there is a pending read when the buffer is non-empty but no read_callback is set) won't work because there is no guarantee that a read will come later (consider HTTPServer while a request is in flight)", "issue_status": "Open", "issue_reporting_time": "2013-07-07T17:59:33Z"}, "144": {"issue_url": "https://github.com/tornadoweb/tornado/issues/820", "issue_id": "#820", "issue_summary": "Laziness of RequestHandler.current_user", "issue_description": "Contributor\nSuprDewd commented on 8 Jun 2013\nThe RequestHandler.current_user getter defers the evaluation of RequestHandler.get_current_user until it's needed. However, when either RequestHandler.get_template_namespace or UIModule.init is called, the current_user getter is called, and get_current_user is evaluated. This should be avoided, since the current request might not need the current user at all, and get_current_user might be expensive to evaluate.", "issue_status": "Open", "issue_reporting_time": "2013-06-08T00:42:26Z"}, "145": {"issue_url": "https://github.com/tornadoweb/tornado/issues/804", "issue_id": "#804", "issue_summary": "FacebookGraphMixin needs some work", "issue_description": "Member\nbdarnell commented on 27 May 2013\nFacebookGraphMixin returns byte strings for access tokens on python 3. It also returns a one-element list for the 'expires' field.", "issue_status": "Open", "issue_reporting_time": "2013-05-27T03:10:35Z"}, "146": {"issue_url": "https://github.com/tornadoweb/tornado/issues/778", "issue_id": "#778", "issue_summary": "simple_httpclient connection pooling (feature)", "issue_description": "kzahel commented on 8 May 2013\nI was considering using Tornado's httpclient to replace a pycurl implementation but saw that simple_httpclient does not do connection pooling. Perhaps it would make sense to implement in by pulling in from urllib3's connection pool.\nhttps://github.com/shazow/urllib3/blob/master/test/test_connectionpool.py\nDoes this seem like the right approach, or would you rather tornado rolls its own idea of a connection pool?", "issue_status": "Open", "issue_reporting_time": "2013-05-07T21:33:04Z"}, "147": {"issue_url": "https://github.com/tornadoweb/tornado/issues/763", "issue_id": "#763", "issue_summary": "Refactor xheaders configuration", "issue_description": "Member\nbdarnell commented on 27 Apr 2013\nXheader usage should not just be on or off, but specify which headers are expected (so an outsider can't spoof the one your proxy doesn't touch). For advanced usage (i.e. multiple layers of proxies) it might be nice to allow selection of a different value from the X-Forwarded-For list.", "issue_status": "Open", "issue_reporting_time": "2013-04-27T03:05:33Z"}, "148": {"issue_url": "https://github.com/tornadoweb/tornado/issues/756", "issue_id": "#756", "issue_summary": "Suggestion: add facebook_redirect_uri in settings", "issue_description": "paulocheque commented on 24 Apr 2013\nSo we can use the following and independent code in FacebookGraphMixin:\n        user_data = yield self.get_authenticated_user(\n            redirect_uri=self.settings['facebook_redirect_uri']\n            client_id=self.settings[\"facebook_api_key\"],\n            client_secret=self.settings[\"facebook_secret\"],\n            code=self.get_argument(\"code\"))", "issue_status": "Open", "issue_reporting_time": "2013-04-24T04:09:47Z"}, "149": {"issue_url": "https://github.com/tornadoweb/tornado/issues/731", "issue_id": "#731", "issue_summary": "Template loader problems with absolute paths", "issue_description": "Member\nbdarnell commented on 14 Apr 2013\nSeveral problems in Loader.resolve_path:\nIf RequestHandler.render() is passed an absolute path, relative paths in {%extends%} and friends don't work.\nIt uses startswith('/') instead of isabs()\nStrange things happen if you use .. in an extends directive to break out of the template loader's root.\nFrom the mailing list:\nIn my project, template folder is not include the template root path, such as Template Load: self.root is \"D:\\website\\app_1\\template\"\nbut some common template file is not include in this path. so When I use the {% extends%} like follow:\n{% extends \"../../template/common/layout.html\" %}\nI found if the \"../../template/common/layout.html\" has \"{% include logo.html%}\", the logo.html cannot be found in the current folder.\nWebsite tree like that:\n|- template\n| - common | |- layout.html #{%include logo.html%} |- logo.html #ERROR, cannot found this path\n- app - template\n`- main.html -- #{%extend ../../template/common/layout.html%}\nI found there is a bug in class Loader(BaseLoader) resolve_path method:\ndef resolve_path(self, name, parent_path=None):\n    if parent_path and not parent_path.startswith(\"<\") and \\\n       not parent_path.startswith(\"/\") and \\\n       not name.startswith(\"/\"):\n        current_path = os.path.join(self.root, parent_path)\n        file_dir = os.path.dirname(os.path.abspath(current_path))\n        relative_path = os.path.abspath(os.path.join(file_dir, name))\n        if relative_path.startswith(self.root):\n            name = relative_path[len(self.root) + 1:]\n        #BUG: should add else here\n        else:\n            name = relative_path\n    return name\nbdarnell:\nHmm, this code is strange - it doesn't really make sense to call abspath and put the result in a variable called \"relative_path\", but it's been there since the beginning. It looks like there are other issues too - the startswith(\"/\") calls should probably be os.path.isabs() to work on windows. If we make that change, your proposed fix no longer works, since layout.html's \"name\" will be absolute and it will no longer try to load logo.html as a relative path.\nIt doesn't feel right to use a template loader to access files outside of its root in the first place. I think it would be better if your loader's root was the common ancestor of all the templates you need. Or maybe we need a way to chain multiple loaders together. I'll have to think more about this code and what it's trying to do.", "issue_status": "Open", "issue_reporting_time": "2013-04-14T18:13:09Z"}, "150": {"issue_url": "https://github.com/tornadoweb/tornado/issues/728", "issue_id": "#728", "issue_summary": "Gracefully handle ssl errors when client cert is required but not given", "issue_description": "Member\nbdarnell commented on 14 Apr 2013\nFrom the mailing list:\nI'm working on a web service that requires a client-side certificate.\nI have noticed when a client without a certificate connects, the\nserver-side crashes and the client-side hangs until the server is\nterminated. On the server-side, I see this error:\n[E 111026 01:00:24 ioloop:296] Exception in I/O handler for fd 6\nTraceback (most recent call last):\nFile \"/home/berto/.virtualenvs/tornado/lib/python2.7/site-packages/tornado/ioloop.py\",\nline 287, in start\nself._handlers[fd](fd, events)\nFile \"/home/berto/.virtualenvs/tornado/lib/python2.7/site-packages/tornado/stack_context.py\",\nline 159, in wrapped\ncallback(_args, *_kwargs)\nFile \"/home/berto/.virtualenvs/tornado/lib/python2.7/site-packages/tornado/httpserver.py\",\nline 293, in _handle_events\n**self.ssl_options)\nFile \"/usr/lib/python2.7/ssl.py\", line 344, in wrap_socket\nciphers=ciphers)\nFile \"/usr/lib/python2.7/ssl.py\", line 119, in init\nciphers)\nSSLError: _ssl.c:327: No root certificates specified for\nverification of other-side certificates.\nShould tornado close the connection when the required certificate is\nnot provided?", "issue_status": "Open", "issue_reporting_time": "2013-04-14T17:47:12Z"}, "151": {"issue_url": "https://github.com/tornadoweb/tornado/issues/703", "issue_id": "#703", "issue_summary": "A way to set default values in templates", "issue_description": "Contributor\nemehrkay commented on 29 Mar 2013\nI've been trying to get some method to set a default value without any real success. In Jinja you can do:\n{% set name=name or \"John Doe\" %}\nBut that doesn't work with Tornado because name isn't defined and I can't quite figure out what in web.template to modify to get it to work.\nThis would be useful for situations like:\n{% set input_type=input_type or \"text\" %}\n{% set value=value or \"\" %}\n{% set attrs=attrs or \"\" %}\n<input type=\"{{ input_type }}\" value = \"{{ value }}\" {{ attrs }} />\nAm I missing something obvious? Thanks", "issue_status": "Open", "issue_reporting_time": "2013-03-29T15:57:40Z"}, "152": {"issue_url": "https://github.com/tornadoweb/tornado/issues/691", "issue_id": "#691", "issue_summary": "HTTPError creation raises an exception when connection is severed by the remote server during a long HTTPRequest", "issue_description": "nisanharamati commented on 7 Mar 2013\nWhen the remote server is shutdown before an HTTPRequest completes, the HTTPError exception fails to instantiate due to a TypeError in the string formatting of the error message. This prevents the real exception from being rethrown and passed in to the HTTPResponse object.\nA non-integer code argument is passed at the exception instance creation. This prevents HTTPClient from creating the appropriate 5xx HTTPError to pass to the client for handling, as the compiler raises its own exception at trying to format a non-integer into an integer format place holder.\nApart from fixing the offending code that tries to create the HTTPError instance with non-integer code parameter (I couldn't actually track that one down to the source), I suggest to change the format string to use non-type specific formatting as per the mini string formatting language spec. This will at least prevent the runtime from choking at Exception creation.\nSuggested fix:\nIn httpclient.py\nclass HTTPError(Exception):\n    ....\n    def __init__(self, code, message=None, response=None):\n        self.code = code\n        message = message or httputil.responses.get(code, \"Unknown\")\n        self.response = response\n        Exception.__init__(self, \"HTTP %d: %s\" % (self.code, message))\nchange\nException.__init__(self, \"HTTP %d: %s\" % (self.code, message))\nto\nException.__init__(self, \"HTTP {}: {}\" % (self.code, message))\nletting Python manage the types.", "issue_status": "Open", "issue_reporting_time": "2013-03-06T19:01:20Z"}, "153": {"issue_url": "https://github.com/tornadoweb/tornado/issues/630", "issue_id": "#630", "issue_summary": "IOStream writes to the root logger", "issue_description": "Contributor\npitrou commented on 12 Nov 2012\nIOStream is sprinkled with calls such as logging.warning(...). Instead, each IOStream should be configurable to use a dedicated Logger object.", "issue_status": "Open", "issue_reporting_time": "2012-11-12T14:20:49Z"}, "154": {"issue_url": "https://github.com/tornadoweb/tornado/issues/622", "issue_id": "#622", "issue_summary": "xgettext cannot extract strings from templates", "issue_description": "igungor commented on 31 Oct 2012\nConsider this example:\n<input type=\"text\" value={{ _(\"search term\") }} />\nI can extract the _() wrapped string with xgettext properly but when i translate and use tornado.locale.load_gettext_translations(), I get the translation of \"search\", not \"search term\".\nPO file is like below:\n: templates/index.html:1\nmsgid \"search term\"\nmsgstr \"terim ara\"\nBut i only see \"terim\" in the rendered page, not \"terim ara\". The problem here is the original string is the value of an attribute and didn't escaped by double quotes, thus the returned string from load_gettext_translations() is not escaped and contains whitespace.\nThe returned string from the translated text should be quoted by default, otherwise all we get is the first word before the whitespace.", "issue_status": "Open", "issue_reporting_time": "2012-10-31T14:27:20Z"}, "155": {"issue_url": "https://github.com/tornadoweb/tornado/issues/608", "issue_id": "#608", "issue_summary": "WebSocket connection closed on long messages", "issue_description": "ianb commented on 10 Oct 2012\nI've encountered problems sending somewhat large messages (more than 4k) from Firefox 18, and having the connection closed. The client reports error 1006 (which is just abnormal termination). Nothing is logged on the server.\nUsing the same client code and a Node.js server I'm not getting the same behavior, which is leading me to believe it's Tornado.\nI don't have a repeatable case, but wanted to at least note the issue in case anyone else encounters it, as it was hard to determine the source. Oddly this did not happen on localhost, but when connecting to a remote server.\n1", "issue_status": "Open", "issue_reporting_time": "2012-10-09T21:14:18Z"}, "156": {"issue_url": "https://github.com/tornadoweb/tornado/issues/559", "issue_id": "#559", "issue_summary": "Tornado httpclient fails requesting a url that urllib works with.", "issue_description": "mitechie commented on 5 Jul 2012\nI've hit a url that the httpclient it failing for that works with urllib. Below is a snippet of code with the url and showing it produces a 400 bad request from the httpclient side.\nimport urllib\nfrom tornado import httpclient\n\nurl = \"https://blogs.msdn.com/b/jmeier/archive/2012/05/13/the-rapid-research-method.aspx?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed: jmeier (J.D. Meier's Blog)&Redirected=true\"\n\nfh = urllib.urlopen(url)\n# This will load up the content just peachy...\ncontent = fh.read()\n\n# This will get me a 400 bad request response.\nhttp = httpclient.HTTPClient()\ntry:\n    response = http.fetch(url)\n    print \"Content should be in here.\"\nexcept Exception, e:\n    print \"but it goes BOOM!\"", "issue_status": "Open", "issue_reporting_time": "2012-07-05T00:29:23Z"}, "157": {"issue_url": "https://github.com/tornadoweb/tornado/issues/517", "issue_id": "#517", "issue_summary": "on_finish() is not called when the client closed first.", "issue_description": "KevinHua commented on 25 May 2012\nclass Webbench(tornado.web.RequestHandler):\ncount = 0\nfini_count = 0;\nclosed_count = 0;\n@tornado.web.asynchronous\ndef get(self, *args, **kwargs):\n    Webbench.count += 1\n    logging.debug(\"Webbench client count %d\" % Webbench.count)\n\n    self.write(\"hello world \" + str(Webbench.count))\n    // the finish() cause on_finish() being called.\n    // self.finish()\n\ndef on_finish(self):\n    Webbench.fini_count += 1\n    logging.debug(\"Webbench finished %d, closed %d, total %d\" \n                  % (Webbench.fini_count, Webbench.closed_count, Webbench.count))\n\ndef on_connection_close(self):\n    // when client reset or closed connection, the on_finish() was not called.\n    tornado.web.RequestHandler.on_connection_close(self)\n\n    Webbench.closed_count += 1\n    logging.debug(\"Webbench closed %d, finished %d, total %d\" \n                  % (Webbench.closed_count, Webbench.fini_count, Webbench.count))", "issue_status": "Open", "issue_reporting_time": "2012-05-25T15:26:55Z"}, "158": {"issue_url": "https://github.com/tornadoweb/tornado/issues/455", "issue_id": "#455", "issue_summary": "Inconsistency in the IOStream.closed method", "issue_description": "Contributor\noyerli commented on 4 Feb 2012\nHi,\nThe fix in the commit 501f596 caused a problem in my async web server application:\nI expect IOStream.closed method to return true AS SOON AS the close_callback is called. (This was the previous behaviour since it was not waiting for the pending callbacks). Now, the closed() method returns true but the close_callback waits the pending callbacks to finish. Hence the connection is not actually closed. Is it the intended behaviour?\nI expect the closed() method to return true after all pending callbacks finished AND the close_callback is called. Otherwise we cannot know if the connection is actually closed.", "issue_status": "Open", "issue_reporting_time": "2012-02-03T22:24:39Z"}, "159": {"issue_url": "https://github.com/tornadoweb/tornado/issues/374", "issue_id": "#374", "issue_summary": "WSGIContainer does not support Keep-Alive", "issue_description": "Contributor\ndavidgaleano commented on 5 Oct 2011\nApache Benchmark hangs when setting option -k if using FallbackHandler to a WSGIContainer.\nI think the problem is that WSGIContainer does not set a Connection header when the request does not support HTTP 1.1.\nCopying the code that sets the headers from RequestHandler.clear to WSGIContainer.__call__ fixes the issue:\n        if not request.supports_http_1_1():\n            if request.headers.get(\"Connection\", '').lower() == \"keep-alive\":\n                headers.append((\"Connection\", \"Keep-Alive\"))\nBtw, I have seen some clients sending a lowercase value for Keep-Alive, so I also suggest doing .lower() == \"keep-alive\" on RequestHandler.clear.", "issue_status": "Open", "issue_reporting_time": "2011-10-05T17:53:25Z"}, "160": {"issue_url": "https://github.com/tornadoweb/tornado/issues/324", "issue_id": "#324", "issue_summary": "SimpleAsyncHTTPClient and Connection:Keep-Alive", "issue_description": "cheesedoily commented on 2 Aug 2011\nSimpleAsyncHTTPClient does not support keep-alive requests, or at least not obviously so.\nHappy to fork this and build it in if pointed in the right direction.", "issue_status": "Open", "issue_reporting_time": "2011-08-01T19:53:42Z"}, "161": {"issue_url": "https://github.com/tornadoweb/tornado/issues/275", "issue_id": "#275", "issue_summary": "Module importing in templates must be block-local", "issue_description": "Contributor\nalekstorm commented on 5 Jun 2011\nModules imported with {% import <module> %} outside a block cannot be used inside it - they must be imported within its scope. I would expect imports at file scope to be available to all blocks.\n{% import os %}\n{{os}} {% comment \"works\" %}\n{% block \"block\" %}\n    {{os}} {% comment \"error\" %}\n    {% import os %}\n    {{os}} {% comment \"works\" %}\n{% end %}", "issue_status": "Open", "issue_reporting_time": "2011-06-04T22:05:54Z"}, "162": {"issue_url": "https://github.com/tornadoweb/tornado/issues/157", "issue_id": "#157", "issue_summary": "Add some way to close an ongoing HTTPRequest (AsyncHTTPClient)", "issue_description": "enki commented on 24 Oct 2010\njust call _finish on the handle?\ni have two use cases: one is to restart a streaming connection, the other is to limit the amount of data i want to read (not interested in downloading gigabytes)", "issue_status": "Open", "issue_reporting_time": "2010-10-24T00:43:09Z"}, "163": {"issue_url": "https://github.com/tornadoweb/tornado/issues/113", "issue_id": "#113", "issue_summary": "Get the content of the same block in parent template like block.super in Django", "issue_description": "ghost commented on 17 Jul 2010\nMaybe i can do that myself, but i really don't know how work the template system, so i think it's really fast to implement this for a person who know the system\nSorry for my language because I am french", "issue_status": "Open", "issue_reporting_time": "2010-07-17T17:16:31Z"}, "164": {"issue_url": "https://github.com/tornadoweb/tornado/issues/89", "issue_id": "#89", "issue_summary": "add unicode URLSpec support", "issue_description": "shuge commented on 14 May 2010\nPlease add unicode URLSpec support.\nPatch:\ndiff --git a/tornado/web.py b/tornado/web.py\nindex e51948a..cd9a6a4 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -1368,7 +1368,7 @@ class URLSpec(object):\n         \"\"\"\n         if not pattern.endswith('$'):\n             pattern += '$'\n-        self.regex = re.compile(pattern)\n+        self.regex = re.compile(pattern, re.UNICODE)\n         self.handler_class = handler_class\n         self.kwargs = kwargs\n         self.name = name", "issue_status": "Open", "issue_reporting_time": "2010-05-13T23:46:43Z"}}, "closed_issues": {"1": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2803", "issue_id": "#2803", "issue_summary": "parse_multipart_form_data for stream_request_body", "issue_description": "PLSDdev commented 7 days ago\nAs per the example in https://github.com/Lookyan/tornado-stream-request\n@stream_request_body\nclass UploadHandler(BaseHandler, StreamingFormDataParserDelegate):\ndef __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\nWhich class is BaseHandler.\nWhen I run the code I get the following error\nsuper().init(*args, **kwargs)\nTypeError: super() takes at least 1 argument (0 given)", "issue_status": "Closed", "issue_reporting_time": "2020-01-24T07:28:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "2": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2798", "issue_id": "#2798", "issue_summary": "Running sync code with run_sync_func tornado 5.1 and above", "issue_description": "Gusakovskiy commented 16 days ago\nPython 3.7\nTornado 5.1 and above.\nHello, I have a problem running async code in sync manner when tornado IOLoop is running.\nThe simplified version of what I am trying to achieve is looked like:\nimport tornado.ioloop\nimport tornado.web\nimport asyncio\n\ndef run_sync():\n    return asyncio.run(_async_connect())\n\nasync def _async_connect():\n      await asyncio.sleep(3)\n      return {'error': 42}\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        result = run_sync()\n        self.write(result)\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nBecause of some projects reasons function _async_connect can't be called with await.\nThis peace of code raises error that asyncio.run can not be called from other event lopp Traceback:\nERROR:tornado.application:Uncaught exception GET / (127.0.0.1)\nHTTPServerRequest(protocol='http', host='127.0.0.1:8888', method='GET', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1')\nTraceback (most recent call last):\n  File \".../python3.7/site-packages/tornado/web.py\", line 1590, in _execute\n    result = method(*self.path_args, **self.path_kwargs)\n  File \".../projects/todnado_check/main.py\", line 19, in get\n    result = run_sync()\n  File \".../projects/todnado_check/main.py\", line 8, in run_sync\n    return asyncio.run(_async_connect())\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/asyncio/runners.py\", line 34, in run\n    \"asyncio.run() cannot be called from a running event loop\")\nRuntimeError: asyncio.run() cannot be called from a running event loop\nSo the next step was to use tornado IOLoop and use run_sync method:\ndef run_sync():\n    tornado_loop = tornado.ioloop.IOLoop.current()\n    return tornado_loop.run_sync(_async_connect)()\nBut this raises other tracebacks that event loop is already runing:\nERROR:tornado.application:Uncaught exception GET / (127.0.0.1)\nHTTPServerRequest(protocol='http', host='127.0.0.1:8888', method='GET', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1')\nTraceback (most recent call last):\n  File \".../projects/todnado_check/envv/lib/python3.7/site-packages/tornado/web.py\", line 1590, in _execute\n    result = method(*self.path_args, **self.path_kwargs)\n  File \".../projects/todnado_check/main.py\", line 20, in get\n    result = run_sync()\n  File \"/Users/vitalii/projects/todnado_check/main.py\", line 9, in run_sync\n    return tornado_loop.run_sync(_async_connect)()\n  File \".../projects/todnado_check/envv/lib/python3.7/site-packages/tornado/ioloop.py\", line 571, in run_sync\n    self.start()\n  File \"...todnado_check/envv/lib/python3.7/site-packages/tornado/platform/asyncio.py\", line 132, in start\n    self.asyncio_loop.run_forever()\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/asyncio/base_events.py\", line 521, in run_forever\n    raise RuntimeError('This event loop is already running')\nRuntimeError: This event loop is already running\nERROR:tornado.access:500 GET / (127.0.0.1) 4.29ms\nThose runtime errors are blocking any calls to async functions from sync code handlers.", "issue_status": "Closed", "issue_reporting_time": "2020-01-14T20:13:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "3": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2794", "issue_id": "#2794", "issue_summary": "get_request alternative for tornado", "issue_description": "maxisme commented on 18 Dec 2019 \u2022\nedited\nin the webapp2 library there is a function get_request(): https://github.com/googleapis/google-cloud-python/blob/8bb406849475d753fbcacca13573377ee94ed1ab/logging/google/cloud/logging/handlers/_helpers.py#L91\nin django there is: https://github.com/googleapis/google-cloud-python/blob/8bb406849475d753fbcacca13573377ee94ed1ab/logging/google/cloud/logging/handlers/middleware/request.py#L27-L33\nand in flask there is request: https://github.com/googleapis/google-cloud-python/blob/8bb406849475d753fbcacca13573377ee94ed1ab/logging/google/cloud/logging/handlers/_helpers.py#L68\nIs there an alternative for tornado?\n1\n1", "issue_status": "Closed", "issue_reporting_time": "2019-12-18T13:54:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "4": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2793", "issue_id": "#2793", "issue_summary": "tornado RequestHandler.get_argument can not get parm for post request", "issue_description": "wpzhouGithub commented on 18 Dec 2019\ntornado RequestHandler.get_argument can not get parm for post request\uff0c which the content-type: application/json\n        if uri is not None:\n            self.path, sep, self.query = uri.partition(\"?\")\n        self.arguments = parse_qs_bytes(self.query, keep_blank_values=True)\n        self.query_arguments = copy.deepcopy(self.arguments)\n        self.body_arguments = {}  # type: Dict[str, List[bytes]]", "issue_status": "Closed", "issue_reporting_time": "2019-12-18T04:39:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "5": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2792", "issue_id": "#2792", "issue_summary": "dose tornado 6.x not support convert tornado app to WSGI app?", "issue_description": "woostundy commented on 16 Dec 2019\nI found that there is no WSGIAdapter in wsgi.py.\nWhy tornado remove it? will it back in feature?", "issue_status": "Closed", "issue_reporting_time": "2019-12-16T04:07:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "6": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2791", "issue_id": "#2791", "issue_summary": "Coroutine unexpectedly terminated when a page is served", "issue_description": "kriek commented on 16 Dec 2019\nHi there,\nI'm trying to build a tornado application (webserver.py) that connects to a TCP server (tcpserver.py). The application has a global tcp_reader coroutine responsible to read data from the server (and eventually share it via websockets).\nThis coroutine is added as a callback to the mainloop using main_loop.add_callback(tcp_reader).\nWhen the application starts, it starts receiving data from the TCP server (counter incremented every second) as expected.\nBut as soon as a browser opens http://localhost:8080/, a GeneratorExit is triggered in the tcp_reader coroutine and its task is destroyed:\nStarting server at port: 8080\n0\n1\n2\n3\n4\n5\n6\nOops\nERROR:asyncio:Task was destroyed but it is pending!\ntask: <Task pending name='Task-1' coro=<tcp_reader() done, defined at webserver.py:13> wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x7fde40a22ac0>()]> cb=[IOLoop.add_future.<locals>.<lambda>() at /home/sly/.envs/scientific/lib/python3.8/site-packages/tornado/ioloop.py:690]>\nWARNING:tornado.access:404 GET /favicon.ico (::1) 0.73ms\nI'm quite new to both tornado and asyncio and I don't get the reason for the task destruction.\nIf the page is requested first and the tcpserver.py started after that, the problem does not occur.\nwebserver.py\nimport asyncio\nimport os\n\nfrom tornado.web import RequestHandler, StaticFileHandler, Application, url\nfrom tornado import ioloop\n\n\nclass MainHandler(RequestHandler):\n    def get(self):\n        self.render(\"index.html\")\n\n\nasync def tcp_reader():\n    while True:\n        try:\n            reader, writer = await asyncio.open_connection('127.0.0.1', 8888)\n        except ConnectionRefusedError:\n            print(\"ConnectionRefused\")\n            await asyncio.sleep(1)\n            continue\n        while True:\n            try:\n                data = await reader.read(1024)\n            except GeneratorExit:\n                print(\"Oops\")\n                raise\n            if not data:\n                writer.close()\n                await writer.wait_closed()\n                break\n            print(data.decode(), end='')\n\n\ndef main():\n    port = os.environ.get(\"PORT\", 8080)\n    clients = []\n    app = Application([\n        url(r\"/\", MainHandler),\n    ])\n    print(\"Starting server at port: %s\" % port)\n    app.listen(port)\n    main_loop = ioloop.IOLoop.current()\n    main_loop.add_callback(tcp_reader)\n    ioloop.IOLoop.current().start()\n\n\nif __name__ == '__main__':\n    main()\ntcpserver.py\nimport asyncio\nfrom itertools import count\n\nasync def handle_connection(reader, writer):\n    try:\n        print(\"open\")\n        for i in count():\n            writer.write(f'{i}\\n'.encode())\n            await writer.drain()\n            await asyncio.sleep(1)\n    except ConnectionResetError:\n        print(\"closed\")\n\nasync def main():\n    server = await asyncio.start_server(\n        handle_connection, '127.0.0.1', 8888)\n    addr = server.sockets[0].getsockname()\n    print(f'Serving on {addr}')\n\n    async with server:\n        await server.serve_forever()\n\nif __name__ == '__main__':\n    asyncio.run(main())\nI'm using python 3.8 and tornado 6.0.3 under Ubuntu", "issue_status": "Closed", "issue_reporting_time": "2019-12-15T22:28:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "7": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2786", "issue_id": "#2786", "issue_summary": "Websocket parameter for an external port when running behind an L2/L3 forwarding device.", "issue_description": "EricZaluzec commented on 6 Dec 2019\nI have a tornado websocket running in python3 which is working on a host system correctly but I have been unable to get it working when the server is running behind an L2/L3 forwarding device. I am using an nginx ingress controller with a load balancer that is serving the tornado secure websocket application.\nUsing tornado, is there a websocket parameter that can give an external port number to forward too; maybe similar to the autobahn python websocket implementation? I've been able to get working the autobahn external port correctly but the server app is now using tornado.\nI've looked through the tornado docs but did not see anything relevant. Any feedback is much appreciated. Thank you.", "issue_status": "Closed", "issue_reporting_time": "2019-12-06T15:43:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "8": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2782", "issue_id": "#2782", "issue_summary": "BufferError: Existing exports of data: object cannot be re-sized", "issue_description": "lujinke commented on 27 Nov 2019 \u2022\nedited\nrelated to #2271\nOS:centos 7\npython: 2.7\ntornado: 4.5.3 (not fix this issue as claimed)\n[2019-11-27 14:10:26.584][ERROR][iostream.py:554]:Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 523, in _handle_events\n        self._handle_write()\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 872, in _handle_write\n        del self._write_buffer[:self._write_buffer_pos]\n    BufferError: Existing exports of data: object cannot be re-sized\n[2019-11-27 14:10:26.585][ERROR][ioloop.py:638]:Exception in callback None\n    Traceback (most recent call last):\n      File \"/usr/lib64/python2.7/site-packages/tornado/ioloop.py\", line 888, in start\n        handler_func(fd_obj, events)\n      File \"/usr/lib64/python2.7/site-packages/tornado/stack_context.py\", line 277, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 523, in _handle_events\n        self._handle_write()\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 872, in _handle_write\n        del self._write_buffer[:self._write_buffer_pos]\n    BufferError: Existing exports of data: object cannot be re-sized\n[2019-11-27 14:10:26.587][ERROR][acl.py:186]:Traceback (most recent call last):\n      File \"/home/dba/dba/dbas/handler/globals.py\", line 734, in wrapper\n        return fn(*args, **kwargs)\n      File \"/home/dba/dba/dbas/handler/acl.py\", line 92, in func_wrapper\n        return func(self)\n      File \"/home/dba/dba/dbas/handler/instancehandler.py\", line 26, in get\n        instance_type=instance_type, envs=data[\"envs\"]\n      File \"/usr/lib64/python2.7/site-packages/tornado/web.py\", line 782, in render\n        self.finish(html)\n      File \"/usr/lib64/python2.7/site-packages/tornado/web.py\", line 992, in finish\n        self.flush(include_footers=True)\n      File \"/usr/lib64/python2.7/site-packages/tornado/web.py\", line 953, in flush\n        return self.request.connection.write(chunk, callback=callback)\n      File \"/usr/lib64/python2.7/site-packages/tornado/http1connection.py\", line 437, in write\n        self._pending_write = self.stream.write(self._format_chunk(chunk))\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 406, in write\n        self._handle_write()\n      File \"/usr/lib64/python2.7/site-packages/tornado/iostream.py\", line 847, in _handle_write\n        assert self._write_buffer_size >= 0\n    AssertionError\nhere is my code:\ni try to make the http request async, so i use a wrapper and ThreadPoolExecutor, in the wrapper i submit the request to the ThreadPoolExecutor as the following:\ndef async(f):\n    @tornado.web.asynchronous\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        def callback(future):\n            try:\n                future.result()\n            except Exception, e:\n                logger.error(e)\n\n        AsyncExecutor.executor.submit(\n            partial(f, *args, **kwargs)\n        ).add_done_callback(\n            lambda future: tornado.ioloop.IOLoop.instance().add_callback(\n                partial(callback, future)))\n\n    return wrapper\nThe add_callback method is said thread safe to use in other threads as claimed in the tornado code:\n        Calls the given callback on the next I/O loop iteration.\n\n        It is safe to call this method from any thread at any time,\n        except from a signal handler.  Note that this is the **only**\n        method in `IOLoop` that makes this thread-safety guarantee; all\n        other interaction with the `IOLoop` must be done from that\n        `IOLoop`'s thread.  `add_callback()` may be used to transfer\n        control from other threads to the `IOLoop`'s thread.\n\n        To add a callback from a signal handler, see\n        `add_callback_from_signal`.\nGreat appreciate if someone can tell what's wrong here with my code.", "issue_status": "Closed", "issue_reporting_time": "2019-11-27T06:54:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "9": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2781", "issue_id": "#2781", "issue_summary": "Mix synchronous and asynchronous code", "issue_description": "afzoun commented on 24 Nov 2019 \u2022\nedited\nHi.\nI am using tornado 6.0.3 with python 3.7\nI get this RuntimeWarning that I don't know how to fix.\nTask was destroyed but it is pending!\ntask: <Task pending coro=<WebSocketProtocol13.write_message.<locals>.wrapper() running at /home/python3.7/site-packages/tornado/websocket.py:1102>>\n/usr/lib/python3.7/asyncio/base_events.py:604: RuntimeWarning: coroutine 'WebSocketProtocol13.write_message.<locals>.wrapper' was never awaited\nHere's my code where I am using write_message:\n`\ndef handle_events():\nmessage = redis.get_message()\n\nif message:\n\n    message = json.loads(message['data'])\n\n    data = {\n\n        'time': message.get('time')\n\n    }\n\n    for connection in connections:\n\n        connection.write_message(json.dumps(data))\n\n    threading.Timer(1, handle_events).start()`\nI should mention that it's working and I am not losing any messages, but I feel this is dangerous.\n1", "issue_status": "Closed", "issue_reporting_time": "2019-11-24T11:39:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "10": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2776", "issue_id": "#2776", "issue_summary": "StaticFileHandler uses MD5 which is disabled in FIPS environment", "issue_description": "idevat commented on 20 Nov 2019\nStaticFileHandler uses MD5 which is disabled in FIPS (Federal Information Processing Standards) environment. It reports (misleading) message \"Could not open static file ...\" (probably during etag computation).\nReproducer:\n>>> import os\n>>> os.path.exists(\"/tmp/tornado-test.css\")\nTrue\n>>> from tornado.web import StaticFileHandler\n>>> StaticFileHandler._get_cached_version(\"/tmp/tornado-test.css\")\nCould not open static file '/tmp/tornado-test.css'\n>>> StaticFileHandler.get_content_version(\"/tmp/tornado-test.css\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib64/python3.6/site-packages/tornado/web.py\", line 2833, in get_content_version\n    hasher = hashlib.md5()\nValueError: [digital envelope routines: EVP_DigestInit_ex] disabled for FIPS\nOverriding of the method get_content_version using sha1 instead of md5 can be used as a workaround.", "issue_status": "Closed", "issue_reporting_time": "2019-11-20T13:20:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "11": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2774", "issue_id": "#2774", "issue_summary": "Only one process receive msg while using reuse_port in multiprocess", "issue_description": "dulm commented on 12 Nov 2019 \u2022\nedited\nthe code run in osx 10.13.1 (17B1003), python3.7:\n    app = Application([(conf.base_uri + '/query', QueryHandler),\n                       ],\n                      debug=False)\n    http_server = HTTPServer(app)\n    #http_server.listen(options.port)\n    http_server.bind(options.port, reuse_port=True)\n\n    http_server.start(options.numprocs)\n    loop = asyncio.get_event_loop()\n\n    logger.info('server start.')\n    IOLoop.current().start()\n```python\n\nuse supervisord to start 2 process bind same port\n[program:recweb]\ncommand=python ./web_main.py --port=13246 --numprocs=1\nprocess_name=%(program_name)s-%(process_num)02d\nnumprocs=2\ndirectory=/Users/lqk/project/PycharmProjects/RecWebAsyn\nOnly one process handles msges founded in stdout and log.\nis there any problem in my solution, or osx not surport reuse_port?", "issue_status": "Closed", "issue_reporting_time": "2019-11-12T07:11:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "12": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2773", "issue_id": "#2773", "issue_summary": "tornado6.0.3 cannot import name 'responses'", "issue_description": "yoter commented on 12 Nov 2019\nTraceback (most recent call last):\nFile \"E:/Program Files/project/python/tornado/app/test.py\", line 1, in\nfrom tornado import httputil\nFile \"E:\\Program Files\\project\\python\\tornado\\venv\\lib\\site-packages\\tornado\\httputil.py\", line 27, in\nfrom http.client import responses\nImportError: cannot import name 'responses'", "issue_status": "Closed", "issue_reporting_time": "2019-11-12T06:05:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "13": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2771", "issue_id": "#2771", "issue_summary": "Documentation mismatch for parent process exit in tornado.process.fork_processes", "issue_description": "volinthius commented on 8 Nov 2019\nDocstring mismatches with parent process exit on success in tornado.process.fork_processes:\nIn the parent process, fork_processes returns None if all child processes have exited normally...\nThe behavior was changed in 4c23ba7.", "issue_status": "Closed", "issue_reporting_time": "2019-11-08T13:35:17Z", "fixed_by": "#2772", "pull_request_summary": "process: correct docs of fork_processes exit behavior", "pull_request_description": "Contributor\nploxiln commented on 10 Nov 2019\nfixes #2771", "pull_request_status": "Merged", "issue_fixed_time": "2019-11-12T02:49:40Z", "files_changed": [["5", "tornado/process.py"]]}, "14": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2770", "issue_id": "#2770", "issue_summary": "[Question] How to use persistent connections with CurlAsyncHTTPClient?", "issue_description": "armona commented on 6 Nov 2019\nBasically would like to use persistent HTTP connections when using the client, what is the correct way of implementing this (adding the Connection header is sufficient?)", "issue_status": "Closed", "issue_reporting_time": "2019-11-05T18:45:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "15": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2764", "issue_id": "#2764", "issue_summary": "Queue example AssertionError", "issue_description": "Contributor\njvansan commented on 2 Nov 2019\nThe example code for the concurrent web spider in the user guide raises an assertion error due to a dead link (referenced in Issue #2639 ).\nI will make a simple PR to fix this.", "issue_status": "Closed", "issue_reporting_time": "2019-11-02T00:03:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "16": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2762", "issue_id": "#2762", "issue_summary": "Limit threads created at startup", "issue_description": "loretoparisi commented on 28 Oct 2019\nWhen I initialize Tornado like\nclass WebServer(threading.Thread):\n    def run(self):\n        PORT = os.getenv('PORT', 8888)\n        asyncio.set_event_loop_policy(AnyThreadEventLoopPolicy())\n        app = application()\n        app.listen(PORT)\n        tornado.ioloop.IOLoop.instance().start()\nI see a number of threads created at startup, before the first api call:\n  689 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:33.89  `- python3 tornadoaas.py                                                                        \n  729 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.07      `- python3 tornadoaas.py                                                                    \n  730 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  731 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  732 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  733 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  734 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  735 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  736 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  737 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  738 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  739 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  741 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  742 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  743 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  744 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  745 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  746 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  747 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  748 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  749 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  750 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  751 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  752 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  753 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  754 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  755 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  756 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  757 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  758 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.00      `- python3 tornadoaas.py                                                                    \n  759 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.07      `- python3 tornadoaas.py                                                                    \n  760 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:22.85      `- python3 tornadoaas.py                                                                    \n  761 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:23.00      `- python3 tornadoaas.py                                                                    \n  762 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.02      `- python3 tornadoaas.py                                                                    \n  763 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.02      `- python3 tornadoaas.py                                                                    \n  764 root      20   0 9027376   2.1g 287324 S   0.0  13.1   0:00.02      `- python3 tornadoaas.py \nWhen the first api call is sent, all those threads get the same memory occupation like\n    1 root      20   0   27244  21312   7864 S   0.0   0.1   0:00.45 /usr/bin/python2 /usr/bin/supervisord                                                            \n    8 root      20   0  966536 143588  36936 S   0.3   0.9   0:01.71  `- python3 dash/app.py                                                                          \n  689 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:33.89  `- python3 tornadoaas.py                                                                        \n  729 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.07      `- python3 tornadoaas.py                                                                    \n  730 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  731 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  732 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  733 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  734 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  735 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  736 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  737 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  738 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  739 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  741 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py                                                                    \n  742 root      20   0 9255584   2.1g 288516 S   0.0  13.6   0:00.00      `- python3 tornadoaas.py       \n...", "issue_status": "Closed", "issue_reporting_time": "2019-10-28T14:22:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "17": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2761", "issue_id": "#2761", "issue_summary": "Is data size limited caused Exception in callback functools.partial(<function WebSocketProtocol._run_callback.<locals>.<lambda> at 0x000001F436C2B840>?", "issue_description": "gdbrianlu commented on 28 Oct 2019\nException in callback functools.partial(<function WebSocketProtocol._run_callback.. at 0x000001F436C2B840>,\nactually data size: 30952\ncode as follow\nasync def data_received(self, data):\nhost = 'localhost'\nport = 6379\nr = redis.Redis(host=host, port=port)\nr.set('foo', data)\nself.write(r.get('foo'))\nawait self.ws.write_message(r.get('foo'))#Get data from Redis", "issue_status": "Closed", "issue_reporting_time": "2019-10-28T13:24:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "18": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2759", "issue_id": "#2759", "issue_summary": "AssertionError: assert loop is None or isinstance(loop, AbstractEventLoop)", "issue_description": "loretoparisi commented on 26 Oct 2019\nI get this error when running Tornado in a thread and using AnyThreadEventLoopPolicy.\nclass WebServer(threading.Thread):\n    def run(self):\n        PORT = os.getenv('PORT', 8888)\n        \n        #asyncio.set_event_loop(asyncio.new_event_loop())\n        asyncio.set_event_loop(AnyThreadEventLoopPolicy())\n        \n        app = application()\n        app.listen(PORT)\n        tornado.ioloop.IOLoop.instance().start()\nWebServer.start()\nFull stack trace:\nException in thread Thread-1:\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.7/threading.py\", line 926, in _bootstrap_inner\n    self.run()\n  File \"tornadoaas.py\", line 101, in run\n    asyncio.set_event_loop(AnyThreadEventLoopPolicy())\n  File \"/usr/local/lib/python3.7/asyncio/events.py\", line 757, in set_event_loop\n    get_event_loop_policy().set_event_loop(loop)\n  File \"/usr/local/lib/python3.7/asyncio/unix_events.py\", line 1119, in set_event_loop\n    super().set_event_loop(loop)\n  File \"/usr/local/lib/python3.7/asyncio/events.py\", line 651, in set_event_loop\n    assert loop is None or isinstance(loop, AbstractEventLoop)\nAssertionError", "issue_status": "Closed", "issue_reporting_time": "2019-10-26T11:28:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "19": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2758", "issue_id": "#2758", "issue_summary": "How to pass \"contextvars\" to tornado.concurrent.run_in_executor ?", "issue_description": "zhubijia commented on 24 Oct 2019\nI build something with contextvars.Is there any way to pass it to tornado.concurrent.run_in_executor?", "issue_status": "Closed", "issue_reporting_time": "2019-10-24T13:39:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "20": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2756", "issue_id": "#2756", "issue_summary": "NotImplementedError raised when sphinx-autobuild tries to start tornado server on Python 3.8", "issue_description": "bskinn commented on 18 Oct 2019\nI just upgraded my Windows Python to 3.8.0 amd64, and now sphinx-autobuild is failing when it tries to bring up the web server. Based on the traceback, it looks to be a problem in tornado, trying to use a non-implemented (no-longer-implemented-in-3.8?) asyncio feature:\n>make livehtml\n\n+--------- manually triggered build ---------------------------------------------\n| Running Sphinx v2.2.0\n| loading pickled environment... done\n| loading intersphinx inventory from isphx/objects_python.inv...\n| loading intersphinx inventory from isphx/objects_numpy.inv...\n| encountered some issues with some of the inventories, but they had working alternatives:\n| intersphinx inventory 'isphx/objects_numpy.inv' not fetchable due to <class 'FileNotFoundError'>: [Errno 2] No such file or directory: 'C:\\\\...\\\\doc\\\\source\\\\isphx/objects_numpy.inv'\n| building [mo]: targets for 0 po files that are out of date\n| building [html]: targets for 0 source files that are out of date\n| updating environment: 0 added, 0 changed, 0 removed\n| looking for now-outdated files... none found\n| no targets are out of date.\n| build succeeded.\n|\n| The HTML pages are in build.\n+--------------------------------------------------------------------------------\n\n[I 191017 14:36:13 server:296] Serving on http://127.0.0.1:8000\nTraceback (most recent call last):\n  File \"c:\\...\\python38\\Lib\\runpy.py\", line 192, in _run_module_as_main\n    return _run_code(code, main_globals, None,\n  File \"c:\\...\\python38\\Lib\\runpy.py\", line 85, in _run_code\n    exec(code, run_globals)\n  File \"C:\\...\\env\\Scripts\\sphinx-autobuild.exe\\__main__.py\", line 7, in <module>\n  File \"c:\\...\\env\\lib\\site-packages\\sphinx_autobuild\\__init__.py\", line 318, in main\n    server.serve(port=portn, host=args.host, root=outdir)\n  File \"c:\\...\\env\\lib\\site-packages\\livereload\\server.py\", line 298, in serve\n    self.application(\n  File \"c:\\...\\env\\lib\\site-packages\\livereload\\server.py\", line 253, in application\n    app.listen(port, address=host)\n  File \"c:\\...\\env\\lib\\site-packages\\tornado\\web.py\", line 2112, in listen\n    server.listen(port, address)\n  File \"c:\\...\\env\\lib\\site-packages\\tornado\\tcpserver.py\", line 152, in listen\n    self.add_sockets(sockets)\n  File \"c:\\...\\env\\lib\\site-packages\\tornado\\tcpserver.py\", line 165, in add_sockets\n    self._handlers[sock.fileno()] = add_accept_handler(\n  File \"c:\\...\\env\\lib\\site-packages\\tornado\\netutil.py\", line 279, in add_accept_handler\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n  File \"c:\\...\\env\\lib\\site-packages\\tornado\\platform\\asyncio.py\", line 99, in add_handler\n    self.asyncio_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)\n  File \"c:\\...\\python38\\Lib\\asyncio\\events.py\", line 501, in add_reader\n    raise NotImplementedError\nNotImplementedError\nPackages in the environment:\n>pip list\nPackage                       Version\n----------------------------- ----------\nalabaster                     0.7.12\nappdirs                       1.4.3\nargh                          0.26.2\nattrs                         17.4.0\nBabel                         2.7.0\nblack                         19.3b0\nbleach                        3.1.0\ncertifi                       2019.9.11\nchardet                       3.0.4\nClick                         7.0\ncolorama                      0.4.1\ncoverage                      4.5.4\ndocutils                      0.15.2\nentrypoints                   0.3\nfilelock                      3.0.12\nflake8                        3.7.8\nflake8-docstrings             1.5.0\nidna                          2.8\nimagesize                     1.1.0\nJinja2                        2.10.3\nlivereload                    2.6.1\nMarkupSafe                    1.1.1\nmccabe                        0.6.1\nnumpy                         1.17.3+mkl\npackaging                     19.2\npathtools                     0.1.2\npip                           19.3\npkginfo                       1.5.0.1\npluggy                        0.13.0\nport-for                      0.3.1\npy                            1.8.0\npycodestyle                   2.5.0\npydocstyle                    4.0.1\npyflakes                      2.1.1\nPygments                      2.4.2\npyparsing                     2.4.2\npytz                          2019.3\nPyYAML                        5.1.2\nreadme-renderer               24.0\nrequests                      2.22.0\nrequests-toolbelt             0.9.1\nrestview                      2.9.2\nsetuptools                    41.4.0\nsix                           1.12.0\nsnowballstemmer               2.0.0\nSphinx                        2.2.0\nsphinx-autobuild              0.7.1\nsphinx-issues                 1.2.0\nsphinx-rtd-theme              0.4.3\nsphinxcontrib-applehelp       1.0.1\nsphinxcontrib-devhelp         1.0.1\nsphinxcontrib-htmlhelp        1.0.2\nsphinxcontrib-jsmath          1.0.1\nsphinxcontrib-qthelp          1.0.2\nsphinxcontrib-serializinghtml 1.1.3\ntoml                          0.10.0\ntornado                       6.0.3\ntox                           3.14.0\ntqdm                          4.36.1\ntwine                         2.0.0\nurllib3                       1.25.6\nvirtualenv                    16.7.6\nwatchdog                      0.9.0\nwebencodings                  0.5.1\nwheel                         0.33.6", "issue_status": "Closed", "issue_reporting_time": "2019-10-17T18:46:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "21": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2754", "issue_id": "#2754", "issue_summary": "Error generated by SSL Websocket when pinged by TCP SYN packets", "issue_description": "hk298 commented on 11 Oct 2019 \u2022\nedited\nI am running a rather simplistic Websocket server with SSL on a machine that sits behind an Amazon Network Load Balancer (NLB). This setup is beyond my control. The NLB does some health checks on the services it is supposed to be balancing and bombards my Websocket server with TCP SYN packets. Tornado replies with SYN/ACK and the NLB then closes the connection with FIN. This causes Tornado to spit out the following errors:\nERROR:tornado.general:Uncaught exception, closing connection.\nTraceback (most recent call last):\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 511, in _handle_events\n    self._handle_read()\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 1344, in _handle_read\n    self._do_ssl_handshake()\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 1264, in _do_ssl_handshake\n    self.socket.do_handshake()\n  File \"/usr/lib/python2.7/ssl.py\", line 840, in do_handshake\n    self._sslobj.do_handshake()\nerror: [Errno 0] Error\nERROR:tornado.application:Exception in callback None\nTraceback (most recent call last):\n  File \"/usr/lib/python2.7/dist-packages/tornado/ioloop.py\", line 887, in start\n    handler_func(fd_obj, events)\n  File \"/usr/lib/python2.7/dist-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 511, in _handle_events\n    self._handle_read()\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 1344, in _handle_read\n    self._do_ssl_handshake()\n  File \"/usr/lib/python2.7/dist-packages/tornado/iostream.py\", line 1264, in _do_ssl_handshake\n    self.socket.do_handshake()\n  File \"/usr/lib/python2.7/ssl.py\", line 840, in do_handshake\n    self._sslobj.do_handshake()\nerror: [Errno 0] Error\nIt looks like that the handling of the socket.error in _do_ssl_handshake (iostream.py) could handle this case. The server is quiet when I add 0 as another possible error number in the following:\n        except socket.error as err:\n            # Some port scans (e.g. nmap in -sT mode) have been known\n            # to cause do_handshake to raise EBADF and ENOTCONN, so make\n            # those errors quiet as well.\n            # https://groups.google.com/forum/?fromgroups#!topic/python-tornado/ApucKJat1_0\n            if (self._is_connreset(err) or\n                    err.args[0] in (errno.EBADF, errno.ENOTCONN, 0)):\n                return self.close(exc_info=True)\n            raise\nThis is probably not the correct way to deal with this situation, but it avoids the flood of errors messages that I received.\nYou can reproduce the issue by simply connecting to the Websocket with telnet and closing the session immediately.\nI observed this in versions 4.4.3 on Debian 9 and 4.5.3 on Ubuntu 18.04. The messages above are from 4.4.3. Version 4.5.3 does the same thing, only the line numbers are different.", "issue_status": "Closed", "issue_reporting_time": "2019-10-11T14:57:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "22": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2751", "issue_id": "#2751", "issue_summary": "python 3.8 changes default asyncio loop on windows https://bugs.python.org/issue37373", "issue_description": "Savier commented on 7 Oct 2019 \u2022\nedited\nSee https://bugs.python.org/issue37373\nI failed to find failing tests in tornado, but loop's add_reader() now \"not implemented\" by default on windows and asyncio platform uses it.\nHere is the crash form Jupyter notebook:\nC:\\Python38\\Scripts>jupyter-notebook.exe\nTraceback (most recent call last):\n  File \"c:\\python38\\lib\\runpy.py\", line 192, in _run_module_as_main\n    return _run_code(code, main_globals, None,\n  File \"c:\\python38\\lib\\runpy.py\", line 85, in _run_code\n    exec(code, run_globals)\n  File \"C:\\Python38\\Scripts\\jupyter-notebook.exe\\__main__.py\", line 9, in <module>\n  File \"c:\\python38\\lib\\site-packages\\jupyter_core\\application.py\", line 267, in launch_instance\n    return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)\n  File \"c:\\python38\\lib\\site-packages\\traitlets\\config\\application.py\", line 663, in launch_instance\n    app.initialize(argv)\n  File \"<c:\\python38\\lib\\site-packages\\decorator.py:decorator-gen-7>\", line 2, in initialize\n  File \"c:\\python38\\lib\\site-packages\\traitlets\\config\\application.py\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"c:\\python38\\lib\\site-packages\\notebook\\notebookapp.py\", line 1679, in initialize\n    self.init_webapp()\n  File \"c:\\python38\\lib\\site-packages\\notebook\\notebookapp.py\", line 1442, in init_webapp\n    self.http_server.listen(port, self.ip)\n  File \"c:\\python38\\lib\\site-packages\\tornado\\tcpserver.py\", line 152, in listen\n    self.add_sockets(sockets)\n  File \"c:\\python38\\lib\\site-packages\\tornado\\tcpserver.py\", line 165, in add_sockets\n    self._handlers[sock.fileno()] = add_accept_handler(\n  File \"c:\\python38\\lib\\site-packages\\tornado\\netutil.py\", line 279, in add_accept_handler\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n  File \"c:\\python38\\lib\\site-packages\\tornado\\platform\\asyncio.py\", line 99, in add_handler\n    self.asyncio_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)\n  File \"c:\\python38\\lib\\asyncio\\events.py\", line 501, in add_reader\n    raise NotImplementedError\nNotImplementedError\nI think patch is trivial:\ntornado/platform/asyncio.py :\nimport sys\n\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\nBut it's too hard to me is to write tests.\nThere is a note on the top of tornado/platform/asyncio.py describing situation, but it seems it pretends application must set such policy. I don't know which way is correct, my patch solves the problem for me, I think devs must communicate in all of three places - here, jupyter issues, python bugs to make a decision.", "issue_status": "Closed", "issue_reporting_time": "2019-10-07T13:09:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "23": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2744", "issue_id": "#2744", "issue_summary": "reverse_url() unescapes regex inconsistently", "issue_description": "Contributor\nremram44 commented on 4 Oct 2019 \u2022\nedited\nIf you have a rule with an escaped regex character coming after a group in parentheses, like:\nURLSpec('/project/([0-9]+)/export/codebook\\\\.csv', ExportCodebookCsv)\nit will correctly match /project/1/export/codebook.csv, but will reverse to /project/1/export/codebook\\.csv.\nOf course, if you remove the backslash:\nURLSpec('/project/([0-9]+)/export/codebook.csv', ExportCodebookCsv)\nit will reverse to the wanted /project/1/export/codebook.csv but then it will also match /project/1/export/codebookXcsv (the dot matches any character).\nThis is because re_unescape() is only called for the first fragment, not the following ones; see no unescaping line 630:\ntornado/tornado/routing.py\nLines 626 to 638 in ff985fe\n for fragment in pattern.split(\"(\"): \n     if \")\" in fragment: \n         paren_loc = fragment.index(\")\") \n         if paren_loc >= 0: \n             pieces.append(\"%s\" + fragment[paren_loc + 1 :]) \n     else: \n         try: \n             unescaped_fragment = re_unescape(fragment) \n         except ValueError: \n             # If we can't unescape part of it, we can't \n             # reverse this url. \n             return (None, None) \n         pieces.append(unescaped_fragment) \nSee also #1619", "issue_status": "Closed", "issue_reporting_time": "2019-10-04T01:30:23Z", "fixed_by": "#2745", "pull_request_summary": "Fix unescaping of regex routes", "pull_request_description": "Contributor\nremram44 commented on 4 Oct 2019 \u2022\nedited\nFixes #2744\nI will add tests tomorrow. done", "pull_request_status": "Merged", "issue_fixed_time": "2019-10-21T02:16:11Z", "files_changed": [["8", "tornado/routing.py"], ["4", "tornado/test/web_test.py"]]}, "24": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2740", "issue_id": "#2740", "issue_summary": "Tornado memory leak (may be not a bug but a usage error)", "issue_description": "ok2 commented on 5 Sep 2019\nI have such a code, which read's everything from stdin and send it to the given URL through websockets. All data which it gets from websockets will be send to stdout. It works well the most of the time, but sometimes it eats all of the memory and OOM killer comes, why?\n(it is on python 2 with tornado 5.1.1)\nconn = None\ninput_counter = 0\n\ndef on_message(message):\n    if message is None or message == '':\n        ioloop.stop()\n        return\n    sys.stdout.write(message)\n    sys.stdout.flush()\n\n@tornado.gen.coroutine\ndef on_input(fd, events):\n    global input_counter\n    if not events & ioloop.READ:\n        sys.stderr.write(\"ERROR: failed to read file (error 0x%03x)\\n\" % events)\n        sys.exit(1)\n    if input_counter >= 16:\n        time.sleep(0.1)\n        gc.collect()\n        return\n    input_counter += 1\n    data = None\n    try:\n        try: data = sys.stdin.read()\n        except: data = ''\n        if conn is None or conn.protocol is None:\n            sys.exit(1)\n        yield conn.write_message(data, binary = True)\n    except Exception as err:\n        if data != '':\n            sys.stderr.write(\"ERROR: %s\\n\" % repr(err))\n            sys.exit(1)\n    finally: input_counter -= 1\n\ndef on_start(*args):\n    fd = sys.stdin.fileno()\n    fcntl.fcntl(fd, fcntl.F_SETFL, fcntl.fcntl(fd, fcntl.F_GETFL) | os.O_NONBLOCK)\n    ioloop.add_handler(fd, on_input, ioloop.READ)\n\nurl = urlparse(sys.argv[2])\nioloop = tornado.ioloop.IOLoop.instance()\nrequest = tornado.httpclient._RequestProxy(tornado.httpclient.HTTPRequest(url, validate_cert = False),\n                                           tornado.httpclient.HTTPRequest._DEFAULTS)\nconn = tornado.websocket.WebSocketClientConnection(request, on_message_callback = on_message, max_message_size = 10*1024*1024)\nioloop.add_future(conn.connect_future, on_start)\nioloop.start()", "issue_status": "Closed", "issue_reporting_time": "2019-09-05T15:05:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "25": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2739", "issue_id": "#2739", "issue_summary": "How to get the IP address of the server which Tornado Async HTTP Client is trying to connect.", "issue_description": "DivyareddyS commented on 5 Sep 2019\nI want to know to which IP address is the hostname resolved to in Tornado when using AsyncHTTPClient using python.\nip_address = await tornado.netutil.Resolver.resolve(hostname)\nprint(\"IP ADDRESS Resolver: {}\".format(ip_address))\nI need to know the IP address of the server machine to which the hostname is resolved to.\nPlease guide and correct me where I'm wrong...", "issue_status": "Closed", "issue_reporting_time": "2019-09-05T07:47:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "26": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2738", "issue_id": "#2738", "issue_summary": "Attribute error while using AsyncHTTPClient", "issue_description": "lbolla commented on 4 Sep 2019 \u2022\nedited\nWhen using AsyncHTTPClient I get the below error (on Tornado 6.0.3).\n[E 190904 16:04:29 ioloop:763] Exception in callback functools.partial(<function _HTTPConnection.__init__.<locals>.<lambda> at 0x7f58706627b8>, <Task finished coro=<_HTTPConnection.run() done, defined at /usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py:289> exception=_QuietException()>)\n   Traceback (most recent call last):\n      File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 273, in _read_message\n        delegate.finish()\n      File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 756, in finish\n        return self._delegate.finish()\n      File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 657, in finish\n       fut.add_done_callback(lambda f: final_callback(f.result()))\n    AttributeError: 'coroutine' object has no attribute 'add_done_callback'\n\n    During handling of the above exception, another exception occurred:\n\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python3.6/site-packages/tornado/ioloop.py\", line 743, in _run_callback\n        ret = callback()\n      File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 286, in <lambda>\n        gen.convert_yielded(self.run()), lambda f: f.result()\n      File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 438, in run\n        await self._write_body(True)\n      File \"/usr/local/lib/python3.6/site-packages/tornado/simple_httpclient.py\", line 518, in _write_body\n        await self.connection.read_response(self)\n    File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 273, in _read_message\n        delegate.finish()\n     File \"/usr/local/lib/python3.6/site-packages/tornado/http1connection.py\", line 68, in __exit__\n        raise _QuietException\n    tornado.http1connection._QuietException\nI can't reproduce this error in all my environments: it seems to happen only in certain Docker containers. So, it may be caused a user misconfiguration, but given that it works most of the times, I am inclined to think that the code is right, but a bug in Tornado is revealed in certain (unknown) circumstances.\nI am using async/await syntax, not tornado.gen.coroutine, and Python 3.6.9.\nDo you know what may be causing this?", "issue_status": "Closed", "issue_reporting_time": "2019-09-04T16:13:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "27": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2737", "issue_id": "#2737", "issue_summary": "Explicitly use SelectorEventLoop on Windows", "issue_description": "animalize commented on 3 Sep 2019 \u2022\nedited\nOn Windows, Python 3.8's default event loop is now ProactorEventLoop. [1]\nBut tornado doesn't support ProactorEventLoop. [2]\nShould we use SelectorEventLoop explicitly on Windows?\n    if os.name == 'nt':\n        import asyncio\n        asyncio.DefaultEventLoopPolicy = asyncio.WindowsSelectorEventLoopPolicy\nFYI, Python 3.8.0's release schedule: [3]\n3.8.0 beta 4: Monday, 2019-08-26\n3.8.0 candidate 1: Monday, 2019-09-30\n3.8.0 candidate 2: Monday, 2019-10-07 (if necessary)\n3.8.0 final: Monday, 2019-10-21\n[1] https://docs.python.org/3.8/whatsnew/3.8.html#asyncio\n[2] https://github.com/tornadoweb/tornado/blob/master/tornado/platform/asyncio.py#L15-L19\n[3] https://www.python.org/dev/peps/pep-0569/#id6", "issue_status": "Closed", "issue_reporting_time": "2019-09-03T14:37:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "28": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2736", "issue_id": "#2736", "issue_summary": "cookies not saving in ios, other ways to authenticate", "issue_description": "kelvinthu commented on 29 Aug 2019\nHi,\nWhen I use set_secure_cookie in tornado, the cookie is returned by the server but the client does not save the cookie in ios and therefore authentication fails. It is the problem with cordova-ios and wkwebview.\nSo while I cannot solve the above problem, is there any other ways to authenticate? I do not want to store the cookies in local storage manually.", "issue_status": "Closed", "issue_reporting_time": "2019-08-29T13:20:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "29": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2733", "issue_id": "#2733", "issue_summary": "latin-1 codec can't encode characters", "issue_description": "FlameSky-S commented on 28 Aug 2019\nI'm using tornado to accept some POST data sended from clients I don't have access to. Everything works fine if only English characters appear in the data. When utf-8 encoded Chinese characters(3 bytes) are within the data, Tornado gives me this warning and the 'get_argument' function can't get anything at all.\nI debuged and simplified my code to the simplest, yet the warning still comes up\nclass DataHandler(tornado.web.RequestHandler):\n    def post(self):\n        print(\"test\")\n        print(self.get_argument(\"data\"))\n        print(\"1\")\n\napplication = tornado.web.Application([\n    (r\"/data\", Data),\n])\n\napplication.listen(5000)\ntornado.ioloop.IOLoop.instance().start()\nThe data the clients post is like:\ndata={\"id\":\"00f1c423\",\"name\":\"\u5f20\u4e09\"}\nThe data is x-www-form-urlencoded and WireShark shows the Chinese characters are perfectly 3-bytes utf-8 which starts with E(1110).\nIt has nothing to do with the print function because I actually tried simpler codes:\nclass Data(tornado.web.RequestHandler):\n    def post(self):\n        return\nThe warning is still there. So could anyone tell me where does this encoding thing come from since I did nothing about encoding in my code?", "issue_status": "Closed", "issue_reporting_time": "2019-08-28T07:37:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "30": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2732", "issue_id": "#2732", "issue_summary": "set_secure_cookie limit on content size?", "issue_description": "AMMullan commented on 27 Aug 2019\nI'm trying to use set_secure_cookie and it works perfectly until you try to put too much data in it - working content at 2907 bytes but fails when setting 2965 bytes.\nFrom what I can see, Chrome has a max cookie size of 4096 bytes so not sure if this is a known issue with Tornado or me doing something wrong? Firefox is letting me use a little bit more but not much.\nUsing Tornado 6.0.3 w/ Python 3.6.8\nCheers in advance :)", "issue_status": "Closed", "issue_reporting_time": "2019-08-27T13:40:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "31": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2729", "issue_id": "#2729", "issue_summary": "'AsyncIOMainLoop' object has no attribute 'run_on_executor' -- Python 3.6", "issue_description": "jayanth1991 commented on 19 Aug 2019\ntokens = await IOLoop.current().run_on_executor(None, self._get_alltokens)\nAttributeError: 'AsyncIOMainLoop' object has no attribute 'run_on_executor'\nPython: Python 3.6.8\nTornado: 6.0.3\nI am not sure what I am doing wrong, I've gone over multiple examples and the syntax seems to be the same. Any help regarding this is greatly appreciated.", "issue_status": "Closed", "issue_reporting_time": "2019-08-19T02:40:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "32": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2726", "issue_id": "#2726", "issue_summary": "Incorrectly removes \u2018Allow\u2019 header from HTTP 204 response", "issue_description": "Contributor\nandersk commented on 12 Aug 2019 \u2022\nedited\nIn this application, Tornado (6.0.3) filters the Allow header out of the 204 response to an OPTIONS request, while the misspelled Alloww header is passed through. RFC 7231 \u00a77.4.1 is clear that an Allow header MAY be sent on any response, and \u00a74.3.7 says that it SHOULD be sent if applicable in response to an OPTIONS request, so Tornado should not filter it out.\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n    def options(self):\n        self.set_header(\"Allow\", \"GET, OPTIONS\")\n        self.set_header(\"Alloww\", \"GET, OPTIONS\")\n        self.set_status(204)\n        self.finish()\n\nif __name__ == \"__main__\":\n    app = tornado.web.Application([(r\"/\", MainHandler)])\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\n$ curl -i -X OPTIONS http://localhost:8888\nHTTP/1.1 204 No Content\nServer: TornadoServer/6.0.3\nDate: Mon, 12 Aug 2019 01:49:10 GMT\nAlloww: GET, OPTIONS", "issue_status": "Closed", "issue_reporting_time": "2019-08-12T01:54:45Z", "fixed_by": "#2727", "pull_request_summary": "Clear fewer headers on 1xx/204/304 responses", "pull_request_description": "Contributor\nandersk commented on 12 Aug 2019 \u2022\nedited\nThis function is called on more than just 304 responses; it\u2019s important to permit the Allow header on 204 responses. Also, the relevant RFCs have changed significantly.\nFixes #2726.", "pull_request_status": "Merged", "issue_fixed_time": "2019-10-21T02:34:19Z", "files_changed": [["2", "tornado/test/httpclient_test.py"], ["1", "tornado/test/web_test.py"], ["22", "tornado/web.py"]]}, "33": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2724", "issue_id": "#2724", "issue_summary": "WSGI __call__() takes 2 positional arguments but 3 were given", "issue_description": "lalabuy948 commented on 10 Aug 2019\nTrying to wrap hello_world example in wsgi server\nfrom gevent.pywsgi import WSGIServer\nimport app\n\nhttp_server = WSGIServer(('', 8888), application=app.make_tornado_app())\nhttp_server.serve_forever()\nand getting always this error\nFile \"/venv/lib/python3.7/site-packages/gevent/pywsgi.py\", line 923, in run_application\n    self.result = self.application(self.environ, self.start_response)\nTypeError: __call__() takes 2 positional arguments but 3 were given\nor if using tornado.wsgi.WSGIContainer\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python/3.7.4/Frameworks/Python.framework/Versions/3.7/lib/python3.7/wsgiref/handlers.py\", line 137, in run\n    self.result = application(self.environ, self.start_response)\nTypeError: __call__() takes 2 positional arguments but 3 were given\n127.0.0.1 - - [10/Aug/2019 17:40:58] \"GET / HTTP/1.1\" 500 59", "issue_status": "Closed", "issue_reporting_time": "2019-08-10T17:32:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "34": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2722", "issue_id": "#2722", "issue_summary": "Misleading CSRF docs / bug in setting CSRF cookie?", "issue_description": "FWirtz commented on 6 Aug 2019\nThe docs read as such:\nThe XSRF cookie is normally set when xsrf_form_html is used, but in a pure-Javascript application that does not use any regular forms you may need to access self.xsrf_token manually (just reading the property is enough to set the cookie as a side effect).\nUpon further inspection, I found this:\ntornado/tornado/web.py\nLines 1417 to 1420 in 4ac3d54\n if version is None: \n     if self.current_user and \"expires_days\" not in cookie_kwargs: \n         cookie_kwargs[\"expires_days\"] = 30 \n     self.set_cookie(\"_xsrf\", self._xsrf_token, **cookie_kwargs) \nIt only seems to be setting the cookie as a side effect, if version is None.\nFor my usecase, I want to update the CSRF cookie with every mutating request (read != GET). I can't rely however on just calling self.xsrf_token, as it does not always update the cookie.\nI am unsure about the intended effect of said line for this project. For my usecase however it is breaking the side effect of the property or rather just runs it once.\nI think it would be nice if the documentation was changed this way or the part that sets the cookie was changed, not sure why it's only set when version is None.", "issue_status": "Closed", "issue_reporting_time": "2019-08-06T14:35:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "35": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2718", "issue_id": "#2718", "issue_summary": "Listen to IP address range", "issue_description": "YodaEmbedding commented on 1 Aug 2019\nConsider the Hello World example:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    PORT = 8080\n    ADDR = '192.168.100.0'\n    app = make_app()\n    app.listen(PORT, ADDR)\n    tornado.ioloop.IOLoop.current().start()\nFor ADDR set to '0.0.0.0' or '127.0.0.1', I am able to access the webpage from localhost:8080. However, if I try to listen only on my LAN, '192.168.100.0' doesn't do anything and '192.168.100.0/24' is just a parse error.\nIs there any reasonable way to listen to an IP address range? (Particularly for LAN.)", "issue_status": "Closed", "issue_reporting_time": "2019-08-01T11:28:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "36": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2713", "issue_id": "#2713", "issue_summary": "no files are saved by upload demo", "issue_description": "joshuacox commented on 26 Jul 2019 \u2022\nedited\nWhen running this code:\nhttps://github.com/tornadoweb/tornado/blob/master/demos/file_upload/file_receiver.py\nand uploading a file:\npython file_uploader.py --put /home/myuser/Pictures/filetest.jpg\n\nHTTPResponse(_body=None,_error_is_response_code=False,buffer=<_io.BytesIO object at 0x7fcb69baceb8>,code=200,effective_url='http://localhost:8888/filetest.jpg',error=None,headers=<tornado.httputil.HTTPHeaders object at 0x7fcb69b38588>,reason='OK',request=<tornado.httpclient.HTTPRequest object at 0x7fcb69be4358>,request_time=0.004802703857421875,start_time=1564094635.3881001,time_info={})\nor\ncurl -v -F name=filetest -F image=@/home/thoth/Pictures/filetest.jpg localhost:8888/post\n*   Trying ::1:8888...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 8888 (#0)\n> POST /post HTTP/1.1\n> Host: localhost:8888\n> User-Agent: curl/7.65.1\n> Accept: */*\n> Content-Length: 99169\n> Content-Type: multipart/form-data; boundary=------------------------eed1e4e250753c56\n> Expect: 100-continue\n> \n* Mark bundle as not supporting multiuse\n< HTTP/1.1 100 (Continue)\n* We are completely uploaded and fine\n* Mark bundle as not supporting multiuse\n< HTTP/1.1 200 OK\n< Server: TornadoServer/6.0.3\n< Content-Type: text/html; charset=UTF-8\n< Date: Thu, 25 Jul 2019 22:45:49 GMT\n< Content-Length: 2\n< \n* Connection #0 to host localhost left intact\nOK%                  \nNo file was saved.\n$ ls -alh\ntotal 12K\ndrwxr-xr-x 1 root root 4.0K Jul 25 22:26 .\ndrwxr-xr-x 1 root root 4.0K Jul 25 22:21 ..\n-rwxr-xr-x 1 root root 1.7K Jul 25 22:26 file_receiver.py\n$ ls -alh /tmp\ntotal 8.0K\ndrwxrwxrwt 1 root root 4.0K Jul 13 14:05 .\ndrwxr-xr-x 1 root root 4.0K Jul 25 22:26 ..\nAm I looking in the wrong places?\nExample docker test environment:\nFROM python:3\nWORKDIR /usr/src/app\nRUN pip install --no-cache-dir tornado\nCOPY ./file_receiver.py ./\nCMD [ \"python\", \"./file_receiver.py\" ]\nlogs from container:\n[I 190725 22:45:49 receiver:29] POST \"filetest.jpg\" \"image/jpeg\" 98877 bytes\n[I 190725 22:45:49 web:2246] 200 POST /post (172.17.0.1) 2.06ms\n[I 190725 22:47:26 receiver:29] POST \"filetest.jpg\" \"image/jpeg\" 98877 bytes\n[I 190725 22:47:26 web:2246] 200 POST /post (172.17.0.1) 1.47ms\n[I 190725 22:47:32 receiver:46] PUT \"filetest.jpg\" \"image/jpeg\" 98877 bytes\n[I 190725 22:47:32 web:2246] 200 PUT /filetest.jpg (172.17.0.1) 1.38ms\nIs there something that is wrong?", "issue_status": "Closed", "issue_reporting_time": "2019-07-25T22:02:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "37": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2712", "issue_id": "#2712", "issue_summary": "argument's value cut off by semicolon", "issue_description": "trysu commented on 25 Jul 2019\nIf a argument's value contain ;, the value will cut off by ;\ne.g:\nThere is a GET method : https://www.test.com/test?_arg1==face;book\nprint(self.get_query_argument(name=\"_arg1\", default=None))\nI hope output: face;book, but now only output:\nface\nand the ;book cut off by ;\nIs this a bug?", "issue_status": "Closed", "issue_reporting_time": "2019-07-25T07:57:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "38": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2709", "issue_id": "#2709", "issue_summary": "jupyter 4.4.0 did not work with tornado 6.0.3", "issue_description": "jimgunn3 commented on 24 Jul 2019\nI tried unsuccessfully to run a jupyter 4.4.0, notebook 5.7.4 with tornado 6.0..3. I am able to get it to run using tornado 5.1.1. Hopefully this can be fixed. Thanks.", "issue_status": "Closed", "issue_reporting_time": "2019-07-23T23:53:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "39": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2708", "issue_id": "#2708", "issue_summary": "Attribute Error: EPollIO object has no attribute 'run_in_executor'", "issue_description": "bbergmann commented on 24 Jul 2019 \u2022\nedited\npython version 3.5.7\ntornado version 6.03\nCentOS\nI am using code similar to the code using bcrypt in the tornado blog example:\n...\nhashed = await tornado.ioloop.IOLoop.current().run_in_executor(\nNone,\nbcrypt.hashpw,\ntornado.escape.utf8(self.get_argument('password')),\nbcrypt.gensalt()\n)\n...\nI am not sure what I am missing here.", "issue_status": "Closed", "issue_reporting_time": "2019-07-23T19:18:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "40": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2706", "issue_id": "#2706", "issue_summary": "ImportError: cannot import name 'Future' from 'tornado.concurrent'", "issue_description": "cTaoLee commented on 16 Jul 2019\nWhen I import the Queue module by from tornado.queues import Queue , it is error like that", "issue_status": "Closed", "issue_reporting_time": "2019-07-16T08:27:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "41": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2705", "issue_id": "#2705", "issue_summary": "Is there a ```get_current_request()``` method in tornado6.0 ?", "issue_description": "DachuanZhao commented on 12 Jul 2019\nI want to use both sqlalchemy and tornado.\nHere is my sqlalchemy code:\nfrom sqlalchemy.orm import sessionmaker,scoped_session,mapper\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\nengine = create_engine(MYSQL_DB_URL,pool_size=300,max_overflow=20,pool_recycle=1800,pool_pre_ping=True)\n\n@event.listens_for(engine, \"connect\")\ndef connect(dbapi_connection, connection_record):\n    connection_record.info['pid'] = os.getpid()\n\n@event.listens_for(engine, \"checkout\")\ndef checkout(dbapi_connection, connection_record, connection_proxy):\n    pid = os.getpid()\n    if connection_record.info['pid'] != pid:\n        connection_record.connection = connection_proxy.connection = None\n        raise exc.DisconnectionError(\n                \"Connection record belongs to pid %s, \"\n                \"attempting to check out in pid %s\" %\n                (connection_record.info['pid'], pid)\n        )\n\nDBSession = sessionmaker(bind=engine)\n\ndb_session = scoped_session(DBSession)\ntornado code:\nclass CustomTornadoHandler(tornado.web.RequestHandler):\n\n    \"\"\"\n    custom tornadoHandler with sqlalchemy session\n    \"\"\"\n\n    def set_default_headers(self):\n        \"\"\"\n        \"\"\"\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Headers\", \"x-requested-with,application/x-www-form-urlencoded\")\n        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, PATCH, DELETE, PUT')\n\n    def initialize(self, *args, **kwargs):\n        self.db_session = db_session()\n\n    def on_finish(self):\n        db_session.remove()\n\nclass TerminologyDetailHandler(CustomTornadoHandler):\n\n    executor = ThreadPoolExecutor()\n\n    @run_on_executor\n    def get(self):\n        data = SqlFunc.get_terminology_detail(self.db_session,**param_dict)\n        self.write('success')\nBut it goes wrong.\npymysql.err.internalerror: packet sequence number wrong - got 102 expected 8\nI think the reason for the error is that I should give the param scopefunc=get_current_request in method scoped_session()\nSo I want to know that is there a get_current_request() method in tornado6.0 ?", "issue_status": "Closed", "issue_reporting_time": "2019-07-12T04:09:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "42": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2704", "issue_id": "#2704", "issue_summary": "Problem converting IOStream to SSLIOStream with \"start_tls\" function", "issue_description": "amTorrinha commented on 10 Jul 2019\nI'm using Tornado to run as a Proxy Server that receives several requests from a client, redirecting most of them. However, in some specific cases, I want to establish a ssl connection between client and proxy. To do this, my idea was to use the start_tls function to convert the client's IOStream into an SSLIOStream, sending a self-signed certificate to the client, which will be used to encrypt their following communications.\nIn my client, I use Python Requests to perform the request, redirecting it to the proxy :\nproxies = {\n   'http' : 'http://user:1@localhost:8888',\n   'https': 'http://user:1@localhost:8888'  \n  }\n\nr = requests.request('GET', 'https://www.somedomain.com/', proxies = proxies, verify = False)\nIn my proxy, I'm using a RequestHandler that receives and deals with the requests. Inside the connect function, which will be called for https connections, I have the following code for the specific cases mentioned above:\nclass MainHandler(tornado.web.RequestHandler):\n\n   async def connect(self):\n      self.client = self.request.connection.stream\n      #some code\n      ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)                                                                                                        \n      ssl_context.load_cert_chain(certfile=\"ssl/cert.pem\", keyfile=\"ssl/key.pem\")                                                                                            \n      client_future = self.client.start_tls(server_side=True, ssl_options=ssl_context)\n      self.client = await client_future\nThe problem here is that the future's result is never set, so it blocks in the await. My goal is to send a self-signed certificate to the client, in order to be able to decrypt the client's data before sending it to the domain, by\"upgrading\" the client connection (self.client) to an SSL connection, with the handshake done, between my server and the client. Is this the best way to do it, or is there a better solution?", "issue_status": "Closed", "issue_reporting_time": "2019-07-10T17:40:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "43": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2703", "issue_id": "#2703", "issue_summary": "ioloop overwrites log format and log level", "issue_description": "jesopo commented on 8 Jul 2019 \u2022\nedited\n(using Python 3.7.3)\nThis line here https://github.com/jesopo/bitbot/blob/15e143fcff39d64c5acc2d93f61c2f00f65c2ee0/src/utils/http.py#L127 overwrites all the configuration done here https://github.com/jesopo/bitbot/blob/15e143fcff39d64c5acc2d93f61c2f00f65c2ee0/src/Logging.py#L19\n2019-07-08T12:21:29.059Z [DEBUG] [redcated] (raw recv) | @time=2019-07-08T11:21:29.000Z;account=[redacted] :[redacted] PRIVMSG BitBotTest :VERSION\n2019-07-08T12:21:29.360Z [DEBUG] [redcated] (raw recv) | :[redacted] 324 BitBotTest #bitbot +nt\n2019-07-08T12:21:29.361Z [DEBUG] [redcated] (raw recv) | :[redacted] 329 BitBotTest #bitbot 1562584887\n2019-07-08T12:21:29.362Z [DEBUG] [redcated] (raw recv) | :[redacted] 354 BitBotTest 111 jess [redacted]/bot/BitBot BitBotTest BitBot :BitBot\n2019-07-08T12:21:29.363Z [DEBUG] [redcated] (raw recv) | :[redacted] 315 BitBotTest #bitbot :End of /WHO list.\n2019-07-08T12:21:29.393Z [DEBUG] [redcated] (raw send) | NOTICE [redacted] :VERSION BitBot v1.10.0 (https://git.io/bitbot)\n2019-07-08T12:21:59.361Z [DEBUG] [redcated] (raw send) | PING hello\n2019-07-08T12:21:59.439Z [DEBUG] [redcated] (raw recv) | :[redacted1] PONG [redacted2] :hello\n\n// tornado.ioloop.IOLoop.current().run_sync(_request) is called\n\nTRACE:bitbot:executed query in 0.150282ms: \"SELECT value FROM channel_settings WHERE channel_id=? AND setting=?\" (params: [2, 'rss-seen-ids-https://lorem-rss.herokuapp.com/feed'])\nTRACE:bitbot:calling event: \"send.stdout\" (params: {'target': IRCChannel.Channel([redacted]|##bitbot), 'module_name': 'RSS', 'server': IRCServer.Server([redacted]), 'message': 'Lorem ipsum feed for an interval of 1 minutes: Lorem ip\nsum 2019-07-08T11:18:00Z by John Smith - http://example.com/test/1562584680'})\nTRACE:bitbot:executed query in 0.068126ms: \"SELECT value FROM bot_settings WHERE setting=?\" (params: ['command-method'])\nTRACE:bitbot:executed query in 0.064742ms: \"SELECT value FROM server_settings WHERE server_id=? AND setting=?\" (params: [1, 'command-method'])\nTRACE:bitbot:executed query in 0.060078ms: \"SELECT value FROM channel_settings WHERE channel_id=? AND setting=?\" (params: [2, 'command-method'])\nTRACE:bitbot:calling event: \"preprocess.send.privmsg\" (params: {'server': IRCServer.Server([redacted]), 'line': ParsedLine(PRIVMSG ##bitbot :[03RSS] Lorem ipsum feed for an interval of 1 minutes: Lorem ipsum 2019-07-08T11:18:00Z by John Smi\nth - http://example.com/test/1562584680), 'events': <src.EventManager.Events object at 0x7f4987fd5a20>})\nTRACE:bitbot:executed query in 0.061754ms: \"SELECT value FROM server_settings WHERE server_id=? AND setting=?\" (params: [1, 'message-filters'])\nTRACE:bitbot:executed query in 0.069875ms: \"SELECT value FROM channel_settings WHERE channel_id=? AND setting=?\" (params: [2, 'message-filters'])\nTRACE:bitbot:executed query in 0.069631ms: \"SELECT value FROM server_settings WHERE server_id=? AND setting=?\" (params: [1, 'strip-color'])\nTRACE:bitbot:executed query in 0.068505ms: \"SELECT value FROM channel_settings WHERE channel_id=? AND setting=?\" (params: [2, 'strip-color'])\nI've tried:\nimport tornado.options\ntornado.options.options.logging = None\nOn this line https://github.com/jesopo/bitbot/blob/15e143fcff39d64c5acc2d93f61c2f00f65c2ee0/src/utils/http.py#L6 but it doesn't help. What am I doing wrong?", "issue_status": "Closed", "issue_reporting_time": "2019-07-08T11:28:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "44": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2701", "issue_id": "#2701", "issue_summary": "Next request is being block", "issue_description": "losewin commented on 4 Jul 2019\nI don't know if this issue belongs here, but right now I don't know where should I ask this question.\nMy question is how could I make suck calls non-blocking though I already prove that tornado server is non-blocking. But I observe something if I call pricing multiple times the other link request is being blocked which is calling names. My question is what are the ways to make the pricing and nameAPI not being block.\nThepricing API will response even the other calls is uncompleted. But names API will not be called unless all the pricing API is done\n@tornado.gen.coroutine\n def get(self):\n  hotelId=self.get_argument('code',False)\n  try:\n   if not hotelId:\n    raise Error('Hotel ID is not defined')\n   params=json.loads(self.get_secure_cookie(utils.helpers.languages.Cookies.SEARCH))\n   result=yield Hotel.pricing(hotelId,params)\n   self.write(result)\n\n  except Error as e:\n   self.write_wrong(str(e))\n  except Exception as e:\n   print(traceback.format_exc())\n   self.write_wrong()\n  finally:\n   # time.sleep(15)\n   self.finish()", "issue_status": "Closed", "issue_reporting_time": "2019-07-04T02:36:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "45": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2699", "issue_id": "#2699", "issue_summary": "ujkok+++", "issue_description": "rdmontgomery commented on 3 Jul 2019\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2019-07-03T13:48:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "46": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2698", "issue_id": "#2698", "issue_summary": "ujkok+", "issue_description": "rdmontgomery commented on 3 Jul 2019\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2019-07-03T13:48:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "47": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2697", "issue_id": "#2697", "issue_summary": "Retry on Connection Timeout Only", "issue_description": "armona commented on 2 Jul 2019\nHi all,\nI noticed that both connection timeout (fail to establish a TCP connection?) and request timeout (HTTP response sent, no response was received) both return an HTTPError with 599 status code.\nI would like to retry on connection errors in my application, is there a way to distinguish between the two?", "issue_status": "Closed", "issue_reporting_time": "2019-07-02T10:44:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "48": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2695", "issue_id": "#2695", "issue_summary": "HTTPStreamClosedError when using old-style gen.coroutine", "issue_description": "Contributor\nminrk commented on 28 Jun 2019\nWe are seeing reliably reproducible HTTPStreamClosedErrors with SimpleHTTPClient attempting to make a POST request as the final step of an OAuth login with GitHub. I've tracked it down to using old-style @gen.coroutine instead of async def. When using async def there is no error.\nI haven't been able to reproduce it fully self-contained, unfortunately, but this sample application reproduces it if you set up a dummy GitHub OAuth application.\nThe failure occurs in:\n        params = dict(client_id=client_id, client_secret=client_secret, code=code)\n        url = url_concat(\"https://github.com/login/oauth/access_token\", params)\n        req = HTTPRequest(\n            url,\n            method=\"POST\",\n            headers={\"Accept\": \"application/json\"},\n            body='',  # Body is required for a POST...\n        )\n        resp = yield http_client.fetch(req)  \nTraceback:\nTraceback (most recent call last):\n  File \"/Users/benjaminrk/dev/py/test-oauth/lib/python3.7/site-packages/tornado/web.py\", line 1699, in _execute\n    result = await result\n  File \"/Users/benjaminrk/dev/py/test-oauth/lib/python3.7/site-packages/tornado/gen.py\", line 742, in run\n    yielded = self.gen.throw(*exc_info)  # type: ignore\n  File \"test-auth.py\", line 43, in get\n    resp = yield http_client.fetch(req)\n  File \"/Users/benjaminrk/dev/py/test-oauth/lib/python3.7/site-packages/tornado/gen.py\", line 735, in run\n    value = future.result()\ntornado.simple_httpclient.HTTPStreamClosedError: Stream closed\nThis is with tornado 6.0.3 and Python 3.7.2 on a mac. No error with tornado 5.1.1, or using async def instead of @gen.coroutine.\n1", "issue_status": "Closed", "issue_reporting_time": "2019-06-28T10:36:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "49": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2694", "issue_id": "#2694", "issue_summary": "AttributeError in netutil.py", "issue_description": "FrancisLF commented on 28 Jun 2019\nfrom tornado.web import Application,RequestHandler,StaticFileHandler\nFile \"/Users/useradmin/anaconda2/lib/python2.7/site-packages/tornado/web.py\", line 88, in\nfrom tornado import iostream\nFile \"/Users/useradmin/anaconda2/lib/python2.7/site-packages/tornado/iostream.py\", line 40, in\nfrom tornado.netutil import ssl_wrap_socket, _client_ssl_defaults, _server_ssl_defaults\nFile \"/Users/useradmin/anaconda2/lib/python2.7/site-packages/tornado/netutil.py\", line 44, in\n_client_ssl_defaults = ssl.create_default_context(\nAttributeError: 'module' object has no attribute 'create_default_context'", "issue_status": "Closed", "issue_reporting_time": "2019-06-28T03:07:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "50": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2693", "issue_id": "#2693", "issue_summary": "Overriding a @gen.coroutine method?", "issue_description": "Blizzke commented on 27 Jun 2019\nI'm trying to intercept/add some behavior in the Jupyter Hub DockerSpawner by introducing a \"derived\" class, more specifically the start method. Unfortunately most methods are @gen.coroutine and overriding this with a similarly defined function (including the decorator) cause a bunch of errors.\nCan someone perhaps point me in a possible solution here, bearing in mind that I would still need to be able to call the original method(s)?", "issue_status": "Closed", "issue_reporting_time": "2019-06-27T06:24:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "51": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2691", "issue_id": "#2691", "issue_summary": "URLSpec about", "issue_description": "jeeyshe commented on 26 Jun 2019 \u2022\nedited\nIt seems that the URLSpec has no difference with url tupple ?\njust see this demo:\nfrom tornado.web import URLSpec as U\n# fixme: from tornado.web import url \u8fd9\u4e2aurl\u5c31\u662fURLSpec\n\n\n# \u5b9e\u9645\u4e0a\u6211\u600e\u4e48\u89c9\u5f97\u8fd9\u4e2aURLSpec\u5c31\u662f\u6765\u641e\u7b11\u7684\uff0c\u76f4\u63a5\u4f20\u5143\u7ec4\u4e5f\u6ca1\u4ec0\u4e48\u95ee\u9898\n\nfrom index import handlers\n\nurl_list = (\n    U(r'/index.html', handlers.IndexHandler),\n    U(r'/account', handlers.AccountAreaHandler, {}, '222'),\n    ('/xxx', handlers.ReverUrlTestHandler, {}, 'xxx'),\n)\nwhen i tried to use a tupple like ({regex}, {hangdler}, {dict}, {name}), i also tried to use URLSpec \uff0c but i found no defference between them, so why not use tupple directly instead URLSpec?\uff0c is there any docs foucs this?", "issue_status": "Closed", "issue_reporting_time": "2019-06-26T06:07:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "52": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2682", "issue_id": "#2682", "issue_summary": "[Question] .NET C# client to Python Tornado server", "issue_description": "Icezman001 commented on 20 Jun 2019\nI have a python server running on my raspberry pi 3 B+ model.\nIt's running fine and everything works in html when I connect to it through my local ip with the correct port and shows button presses etc...\nThis is the server code:\nhttps://hatebin.com/hktvsljiur\nI want to connect to the python server with a C# client. (it will connect from the Unity game engine but not sure if this even matters).\nOptions I've checked:\nNET +4.5 websockets (https://docs.microsoft.com/en-us/dotnet/api/system.net.websockets.websocket?view=netframework-4.6)\nhttps://github.com/jirihybek/unity-websocket-webgl\nI think the most basic and straightforward way would be using the .NET websockets built into it right? Unity uses it too so might be easier?\nI really hope someone can help! I'm sure there's more people out there trying to connect to Tornado with a C# client but information is incredibly sparse about this subject.", "issue_status": "Closed", "issue_reporting_time": "2019-06-20T07:32:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "53": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2677", "issue_id": "#2677", "issue_summary": "Fix python 3.8 CI", "issue_description": "Member\nbdarnell commented on 10 Jun 2019\nCI is currently failing on python 3.8 nightly, so this configuration is disabled by ecd42b6", "issue_status": "Closed", "issue_reporting_time": "2019-06-09T21:13:30Z", "fixed_by": "#2683", "pull_request_summary": "gen: Adapt to py38 CancelledError changes", "pull_request_description": "Member\nbdarnell commented on 22 Jun 2019\npython/cpython#13528 broke us in two ways: asyncio.CancelledError is\nno longer an alias for concurrent.futures.CancelledError and it's now\na BaseException.\nFixes #2677\nCloses #2681\ncc @1st1", "pull_request_status": "Merged", "issue_fixed_time": "2019-06-22T14:33:38Z", "files_changed": [["2", ".travis.yml"], ["6", "tornado/gen.py"], ["5", "tornado/locks.py"]]}, "54": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2674", "issue_id": "#2674", "issue_summary": "Request for 2 new labels: \"feature_request\" and \"beginner_friendly\"", "issue_description": "dxdrummer commented on 9 Jun 2019\nHi Everyone,\nI'm fairly new to Tornado and I'm sorting through issues to contribute to and thought it would be helpful to have the labels \"feature_request\" and \"beginner_friendly\" added to the available labels for the issues.\nGranted this isn't 'critical' by any means but could help newbies like me find things they're interested in contributing to.", "issue_status": "Closed", "issue_reporting_time": "2019-06-09T06:57:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "55": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2669", "issue_id": "#2669", "issue_summary": "How can tornado's web service register at consul", "issue_description": "qiaojiang2 commented on 28 May 2019\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2019-05-28T06:35:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "56": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2667", "issue_id": "#2667", "issue_summary": "W 190524 12:06:02 web:2162] 404 GET /time/?key=121 (127.0.0.1) 0.97ms [W 190524 12:06:03 web:2162] 404 GET /time/?key=121 (127.0.0.1) 0.54ms [W 190524 12:06:12 web:2162] 404 GET /time/?key=121 (127.0.0.1) 0.33ms [W 190524 12:06:18 web:2162] 404 GET /vehicle/?key=121 (127.0.0.1) 0.71ms [W 190524 12:06:22 web:2162] 404 POST /vehicle/?key=121 (127.0.0.1) 0.55ms", "issue_description": "qiaojiang2 commented on 24 May 2019\nDo not find where the wrong configuration, why access is 404\uff1f\nThe following code\n\u5b9a\u4e49\u7aef\u53e3\u4e3a8080\ndefine(\"port\", default=9090, help=\"run on the given port\", type=int)\ndef main():\nparse_command_line()\napp = tornado.web.Application(\n[\n(r\"/vehicle\", VehicleRoutingHandler),\n(r\"/time\", TimeHandler),\n(r\"/timestamp\", TimeHandler),\n],\ncookie_secret=\"_TODO:GENERATE_YOUR_OWN_RANDOM_VALUE_HERE\",\ntemplate_path=os.path.join(os.path.dirname(file), \"templates\"),\nstatic_path=os.path.join(os.path.dirname(file), \"static\"),\nxsrf_cookies=True,\n)\napp.listen(options.port)\ntornado.ioloop.IOLoop.current().start()\nif name == \"main\":\nmain()", "issue_status": "Closed", "issue_reporting_time": "2019-05-24T04:12:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "57": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2665", "issue_id": "#2665", "issue_summary": "Chunked transfer encoding response with tornado.web.RequestHandler.render()", "issue_description": "keatinge commented on 23 May 2019 \u2022\nedited\nI know tornado.web.RequestHandler can do chunked responses by calling self.flush(). I am using tornados templates and am building a very large html file using self.render() to render the template to html. Is it possible for tornado to render the template and deliver a chunked response while it is rendering?\nLooking at the source code it doesn't seem to be possible because tornado first renders the whole template. Can anybody confirm that this is not currently possible? How difficult would it be for me to implement something like this?", "issue_status": "Closed", "issue_reporting_time": "2019-05-23T03:58:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "58": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2664", "issue_id": "#2664", "issue_summary": "When I asked for the API with Postman, I got the error. The error is \"RuntimeError: Task got bad yield: <tornado.concurrent.Future object at 0x11b3df048>\"", "issue_description": "Ludasheng commented on 16 May 2019 \u2022\nedited\nThe code (python3.7 tornado)\n     async def post_data(self, url, param_dict):\n        \"\"\"\n        send post requests\n        :param url:\n        :param param_dict:\n        :return:\n        \"\"\"\n        post_data = self._gen_request_data(param_dict)\n        headers = {\"content-type\": \"application/json\"}\n        import tornado.httpclient\n        request = tornado.httpclient.HTTPRequest(\n            url, method=\"POST\", headers=headers, body=post_data, validate_cert=False\n        )\n        response = await tornado.httpclient.AsyncHTTPClient().fetch(request)\n        return response.body\nFull error output:\n[E 190516 10:34:31 basehandler:205] HTTPServerRequest(protocol='http', host='127.0.0.1:12601', method='POST', uri='/didiapp/ocr/submit?image=', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Cache-Control': 'no-cache', 'Postman-Token': '7dc560ec-bb6d-4378-95a7-60dfed96d07c', 'User-Agent': 'PostmanRuntime/7.6.0', 'Accept': '/', 'Host': '127.0.0.1:12601', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'multipart/form-data; boundary=--------------------------875189288125929592701049', 'Content-Length': '47337', 'Connection': 'keep-alive'})\nTask got bad yield: <tornado.concurrent.Future object at 0x11b3df048>\nTraceback (most recent call last):\nFile \"/.pyenv/versions/3.7.1/lib/python3.7/site-packages/lib/base.py\", line 201, in process_module\nawait method.call()\nFile \"/didicapp/service/ocr/pull.py\", line 79, in post_data\nresponse = await tornado.httpclient.AsyncHTTPClient().fetch(request)\nFile \"\", line 3, in await\nRuntimeError: Task got bad yield: <tornado.concurrent.Future object at 0x11b3df048>", "issue_status": "Closed", "issue_reporting_time": "2019-05-16T10:53:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "59": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2663", "issue_id": "#2663", "issue_summary": "print window block server requests", "issue_description": "FatenElhariry commented on 16 May 2019\nI have General issue when running print in page and call any request from server it will be blocked\nwhat is the best solution from this issue", "issue_status": "Closed", "issue_reporting_time": "2019-05-16T08:36:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "60": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2661", "issue_id": "#2661", "issue_summary": "def_stderr_supports_color()-> bool:", "issue_description": "qianxiao111 commented on 15 May 2019\nhow to solve this problem", "issue_status": "Closed", "issue_reporting_time": "2019-05-15T01:16:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "61": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2660", "issue_id": "#2660", "issue_summary": "Where can I find an keycloak Adapters for tornado ?", "issue_description": "zhanglt commented on 13 May 2019\nWhere can I find an keycloak Adapters for tornado ?\nthx\uff01", "issue_status": "Closed", "issue_reporting_time": "2019-05-13T10:55:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "62": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2658", "issue_id": "#2658", "issue_summary": "Why is the return of epoll.poll() in a python2 tornado server less than the number of processes the tornado server started?", "issue_description": "langker commented on 10 May 2019 \u2022\nedited\nI have read the source code of the tornado these days, the version is 4.4.2.\nI just found one question that I can't figure out:\nI start 24 processes for testing, my system is using epoll, and add a print in the code\nhttps://github.com/tornadoweb/tornado/blob/branch4.4/tornado/netutil.py#L260\nIn my suppose, the print will be called 24 times if I send whatever request to it, but actually, the time is less than it.I changed the number of process about 10, the result is right. And I found that the problem is that the code https://github.com/tornadoweb/tornado/blob/branch4.4/tornado/ioloop.py#L862 is not called in 24 times.\nSo why?\nOr just give me a keyword that I can search for.\nThanks in advance.", "issue_status": "Closed", "issue_reporting_time": "2019-05-10T09:07:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "63": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2656", "issue_id": "#2656", "issue_summary": "\"not implemented\" message with jupyter notebook under python-3.8.0a4", "issue_description": "stonebig commented on 8 May 2019 \u2022\nedited\nI have this strange message with Tornado-5.1.1 and Jupyter Notebook\nTraceback (most recent call last):\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\runpy.py\", line 192, in _run_module_as_main\n    return _run_code(code, main_globals, None,\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\runpy.py\", line 85, in _run_code\n    exec(code, run_globals)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\scripts\\jupyter-notebook.exe\\__main__.py\", line 9, in <module>\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\jupyter_core\\application.py\", line 266, in launch_instance\n    return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\traitlets\\config\\application.py\", line 657, in launch_instance\n    app.initialize(argv)\n  File \"<C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\decorator.py:decorator-gen-7>\", line 2, in initialize\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\traitlets\\config\\application.py\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\notebook\\notebookapp.py\", line 1630, in initialize\n    self.init_webapp()\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\notebook\\notebookapp.py\", line 1407, in init_webapp\n    self.http_server.listen(port, self.ip)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\tornado\\tcpserver.py\", line 144, in listen\n    self.add_sockets(sockets)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\tornado\\tcpserver.py\", line 157, in add_sockets\n    self._handlers[sock.fileno()] = add_accept_handler(\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\tornado\\netutil.py\", line 268, in add_accept_handler\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\site-packages\\tornado\\platform\\asyncio.py\", line 79, in add_handler\n    self.asyncio_loop.add_reader(\n  File \"C:\\WinP\\bd38\\bu\\WPy64-3800a4\\python-3.8.0a4.amd64\\lib\\asyncio\\events.py\", line 499, in add_reader\n    raise NotImplementedError\nNotImplementedError\nDoes anyone as a clue of the problem ?", "issue_status": "Closed", "issue_reporting_time": "2019-05-08T13:12:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "64": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2651", "issue_id": "#2651", "issue_summary": "Tornado 6.0 and Jupyter notebook server issue.", "issue_description": "Contributor\nZsailer commented on 30 Apr 2019 \u2022\nedited\nWe're seeing tests fail in inside of Jupyter(Lab) when using Tornado 6.x, forcing us to pin to Tornado 5.x. (See the relevant issue).\nHere's the traceback we see in the tests:\n    Traceback (most recent call last):\n      File \"~/dev/tornado/tornado/web.py\", line 1699, in _execute\n        result = await result\n      File \"~/dev/tornado/tornado/gen.py\", line 736, in run\n        yielded = self.gen.throw(*exc_info)  # type: ignore\n      File \"~/dev/notebook/notebook/services/kernels/handlers.py\", line 239, in get\n        yield super(ZMQChannelsHandler, self).get(kernel_id=kernel_id)\n      File \"~/dev/tornado/tornado/gen.py\", line 729, in run\n        value = future.result()\n      File \"~/dev/tornado/tornado/gen.py\", line 736, in run\n        yielded = self.gen.throw(*exc_info)  # type: ignore\n      File \"~/dev/notebook/notebook/base/zmqhandlers.py\", line 293, in get\n        yield maybe_future(res)\n      File \"~/dev/tornado/tornado/gen.py\", line 729, in run\n        value = future.result()\n      File \"~/dev/tornado/tornado/websocket.py\", line 278, in get\n        await self.ws_connection.accept_connection(self)\n      File \"~/dev/tornado/tornado/websocket.py\", line 881, in accept_connection\n        await self._accept_connection(handler)\n      File \"~/dev/tornado/tornado/websocket.py\", line 964, in _accept_connection\n        await self._receive_frame_loop()\n      File \"~/dev/tornado/tornado/websocket.py\", line 1118, in _receive_frame_loop\n        await self._receive_frame()\n      File \"~/dev/tornado/tornado/websocket.py\", line 1130, in _receive_frame\n        data = await self._read_bytes(2)\n      File \"~/dev/tornado/tornado/websocket.py\", line 1124, in _read_bytes\n        data = await self.stream.read_bytes(n)\n      File \"~/dev/tornado/tornado/iostream.py\", line 436, in read_bytes\n        future = self._start_read()\n      File \"~/dev/tornado/tornado/iostream.py\", line 797, in _start_read\n        assert self._read_future is None, \"Already reading\"\nI'm hoping y'all might be able to provide some insight on the issue. I can't tell if we missed something in the jump to 6.x that you might be able to answer easily.\nWe've tracked down the exact commit that broke our tests.\nI dove a bit deeper into Tornado and found a single change that can toggle the break. Here's a summary of the change:\nBefore this commit, _maybe_add_error_listener ensured that all futures+callbacks were done+closed if the stream was closed by calling the_maybe_run_close_callback() method\n_maybe_run_close_callback() was renamed to _signal_closed()\nIn this commit, the _maybe_add_error_listener no longer calls signal_closed/_maybe_run_close_callback()\nReverting to previous behavior fixes the issue. Here's a patch showing the diff. I add this _signal_closed() method back to _maybe_add_error_listener and things seem to work again.\nI'm not sure if this is a bug in Tornado, or if Jupyter's notebook server is using this API wrong (possibly a missing await could be a likely culprit).\nAny thoughts? Let me know if I can provide you more detail.\n1", "issue_status": "Closed", "issue_reporting_time": "2019-04-29T18:35:40Z", "fixed_by": "#2670", "pull_request_summary": "check that stream is open before trying to read", "pull_request_description": "Contributor\nZsailer commented on 3 Jun 2019\nThis fixes #2651. See the issue for discussion.\nPinging @bdarnell for review.", "pull_request_status": "Merged", "issue_fixed_time": "2019-06-09T21:15:32Z", "files_changed": [["1", "tornado/iostream.py"]]}, "65": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2648", "issue_id": "#2648", "issue_summary": "LogFormatter DEFAULT_COLORS needs a logging.CRITICAL entry", "issue_description": "Contributor\njavabrett commented on 24 Apr 2019 \u2022\nedited\ntornado/tornado/log.py\nLines 108 to 113 in c447875\n DEFAULT_COLORS = { \n     logging.DEBUG: 4,  # Blue \n     logging.INFO: 2,  # Green \n     logging.WARNING: 3,  # Yellow \n     logging.ERROR: 1,  # Red \n } \nCurrently ERROR will log red, but CRITICAL will log in white. Curses COLOR_MAGENTA (5) is probably the best option.", "issue_status": "Closed", "issue_reporting_time": "2019-04-24T02:49:49Z", "fixed_by": "#2649", "pull_request_summary": "Added color for logging.CRITICAL = 5 (Magenta).", "pull_request_description": "Contributor\njavabrett commented on 24 Apr 2019\nFixed #2648.", "pull_request_status": "Merged", "issue_fixed_time": "2019-04-29T00:06:05Z", "files_changed": [["1", "tornado/log.py"]]}, "66": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2645", "issue_id": "#2645", "issue_summary": "how can i have a dict of streams when tcpserver running in processes?", "issue_description": "jack17951 commented on 23 Apr 2019\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2019-04-23T02:43:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "67": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2642", "issue_id": "#2642", "issue_summary": "coroutine without yield", "issue_description": "itayB commented on 4 Apr 2019\nHi,\nI'm using tornado 5.1 & python 2.7.\nI have a coroutine function that sometimes yield another coroutine function (fetch) and sometimes not (using \"cache\"). Is it ok to have such function or should I wrap the cached value with future (or something) and yield it as well?\nIn other words, does coroutine function must have yield in it?\nFor example:\n    @coroutine\n    def my_function(self, request):\n        async_http_client = AsyncHTTPClient()\n        if self.cached_res is None:  # first time only\n            response = yield async_http_client.fetch(self.url, method='POST', body=request)\n            self.cached_res = ujson.loads(response.body)\n        raise Return(self.cached_res)\nSame thing in OO design, let say I have BaseClass that 2 derived class AClass and BClass that both implement abstruct method of BaseClass:\nclass BaseClass(object):\n    @coroutine\n    def handle(self, request):\n        pass\n\nclass AClass(BaseClass):\n    @coroutine\n    def handle(self, request):\n        response = yield async_http_client.fetch(self.url, method='POST', body=request)\n        raise Return(self.cached_res)\n    \nclass BClass(BaseClass):\n    @coroutine\n    def handle(self, request):\n        raise Return([])\nhandle of BClass needed to be coroutine method (for polymorphizm things) but doesn't really yield something. Is it ok?", "issue_status": "Closed", "issue_reporting_time": "2019-04-04T13:44:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "68": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2641", "issue_id": "#2641", "issue_summary": "tornado 6.0.2 has breaking change for @web.asynchronous decorator", "issue_description": "DavidJVitale commented on 3 Apr 2019\nLooks like tornado == 6.0.2 has some breaking changes from 5.X.X when used with Jupyter Notebook's nbconvert package. See this related issue for more info: jupyter/nbconvert#978\nIf this is a conscious breaking change on a major version release, feel free to close this issue. Just looking for clarification, thanks!", "issue_status": "Closed", "issue_reporting_time": "2019-04-03T17:19:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "69": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2640", "issue_id": "#2640", "issue_summary": "Looks like March 23rd version in PyPi for python 2.7 is actually 3.5+ code", "issue_description": "syntheticgio commented on 3 Apr 2019\nIt looks like when I do a pip install tornado for python 2.7, the code added to site-packages/ looks like it is python 3.5 and not compatible with 2.7. Not sure if there is another reason going on, but rolling back to an older tornado version fixes the issue, so I think either the wrong code was pushed to pypi or something snuck in that isn't python2.7 compatible with the 2.7 repository.", "issue_status": "Closed", "issue_reporting_time": "2019-04-03T16:55:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "70": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2638", "issue_id": "#2638", "issue_summary": "tornado util references Type although it does not exist in typing library", "issue_description": "micscov2 commented on 3 Apr 2019\nTraceback (most recent call last):\nFile \"net_test_app.py\", line 1, in\nimport tornado.web\nFile \"/lib/python3.5/site-packages/tornado/web.py\", line 84, in\nfrom tornado.concurrent import Future, future_set_result_unless_cancelled\nFile \"/lib/python3.5/site-packages/tornado/concurrent.py\", line 34, in\nfrom tornado.log import app_log\nFile \"/lib/python3.5/site-packages/tornado/log.py\", line 34, in\nfrom tornado.escape import _unicode\nFile \"/lib/python3.5/site-packages/tornado/escape.py\", line 27, in\nfrom tornado.util import unicode_type\nFile \"/lib/python3.5/site-packages/tornado/util.py\", line 21, in\nfrom typing import (\nImportError: cannot import name 'Type'", "issue_status": "Closed", "issue_reporting_time": "2019-04-03T06:45:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "71": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2637", "issue_id": "#2637", "issue_summary": "coroutine with 2 yields / loop", "issue_description": "itayB commented on 29 Mar 2019\nSetup: Python 2.7.15, Tornado 5.1\nI'm a bit confused with the documention, especially about this sentence:\nIn older versions of Python, looping is tricky with coroutines since there is no way to yield on every iteration of a for or while loop and capture the result of the yield\nand I want to verify that I'm doing it right.\nScenario:\nfrom tornado.gen import coroutine, Return\n\n    @coroutine\n    def _build_requests(self):\n        requests = []\n        for slot_id, slots in self.slots_dict.items():\n            input1 = self._get_strategy_for_slot(some_args)\n            output1 = yield self._builders1(input1)\n            input2 = create_input2(output1)\n            output2 = yield self._get_second_strategy(input2)\n            requests += self.append(output2)\n        raise Return(requests)\nSomehow the overall process takes longer than before I've added the async things (@coroutine, yield and raise Return).\nThe function above mixed two different things I want to make sure:\nDoes coroutine function know how to handle more than 1 yield?\nDoes coroutine work with loops as in the example above? (and if I remove one yield?)", "issue_status": "Closed", "issue_reporting_time": "2019-03-29T14:22:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "72": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2636", "issue_id": "#2636", "issue_summary": "tornado.platform.twisted disappeared but did not explain its replacement", "issue_description": "glyph commented on 29 Mar 2019\nMany years' worth of documentation explains that folks can do\nfrom tornado.platform.twisted import install\nreactor = install()\nI can see that in 004de9c#diff-77b5a8a33248ef0bcafbc1bb71e9f013 Twisted integration was removed, since we can all depend on the stdlib loop APIs. This is great, but it also breaks a bunch of Jupyter notebooks, tutorials, etc.\nCould you be convinced to replace all those sprawling APIs with something like this:\ndef install():\n    from twisted.internet.asyncioreactor import install\n    install()\n    from twisted.internet import reactor\n    reactor.startRunning()\n    return reactor\npossibly with a warnings.warn explaining that users could just call these APIs directly, if that's the desired end-state?", "issue_status": "Closed", "issue_reporting_time": "2019-03-29T07:02:41Z", "fixed_by": "#2653", "pull_request_summary": "twisted: Restore the install() function", "pull_request_description": "Member\nbdarnell commented on 5 May 2019\nThis function had more usage than I was aware of and we can preserve\nthe old behavior by making it an alias for asyncioreactor.install.\nFixes #2636", "pull_request_status": "Merged", "issue_fixed_time": "2019-05-05T17:34:30Z", "files_changed": [["24", "tornado/platform/twisted.py"]]}, "73": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2634", "issue_id": "#2634", "issue_summary": "Strict type checking fails because of Any in RequestHandler __init__", "issue_description": "Contributor\nnoyainrain commented on 26 Mar 2019\nFirst of all, thanks for adding type annotations to Tornado\nFor stricter type checking, in our code base we have enabled mypy's disallow-any-expr flag. Unfortunately, this leads to errors in conjunction with Tornado's current type annotations.\nConsider main.py, a shortened version of the hello world example:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n ...\n\napplication = tornado.web.Application([(r\"/\", MainHandler)])\nRunning mypy on it produces the following error:\n$ mypy --disallow-any-expr main.py \nmain.py:7: error: Expression type contains \"Any\" (has type \"Type[MainHandler]\")\nThe reason is that the signature of RequestHandler.__init__() contains Any. The type system interprets RequestHandler as def (..., **kwargs: Any) -> main.MainHandler. Using the class as an expression (passing it to Application) will then trigger the (correct) error.\nIt seems to me the current convention is to rather use object in constructors and make use of Any only if something cannot be expressed completely by the type system. For example, this is what the typeshed coding style says:\nWhen adding type hints, avoid using the Any type when possible. Reserve the use of Any for when:\nthe correct type cannot be expressed in the current type system; and\nto avoid Union returns (see above).\nNote that Any is not the correct type to use if you want to indicate that some function can accept literally anything: in those cases use object instead.\nThus, a solution for the problem would be to swap **kwargs: Any with **kwargs: object for RequestHandler.\nPS: Grepping through the Tornado code base, I found 29 occurrences of Any in init. So for a general solution it may be necessary to look at each constructor and determine case-by-case if object would be more appropriate than Any.", "issue_status": "Closed", "issue_reporting_time": "2019-03-26T10:35:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "74": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2633", "issue_id": "#2633", "issue_summary": "Tornado AsyncHTTPClient performance degradation", "issue_description": "itayB commented on 26 Mar 2019\nI guys,\nI'm publishing my question from SO here, if someone can help:\nSetup: Python 2.7.15, Tornado 5.1\nI have a web-server machine that handles ~40 /recommend requests per second.\nThe average response time is 25ms, but there's a big divergence (some requests can take more than 500ms).\nEach request generates between 1-8 Elasticsearch queries (HTTP requests) internally.\nEach Elasticsearch query can take between 1-150ms.\nThe Elasticsearch requests are handled synchronously via elasticsearch-dsl library.\nThe goal is to reduce the i/o waiting time (queries to Elasticsearch) and handle more requests per second so I can reduce the number of machines.\nOne thing is unacceptable - I don't want to increase the average handle time (25ms).\nI found some tornado-elasticsearch implementations on the web, but since I need to use only one endpoint to Elasticsearch (/_search) I am trying to do that alone.\nBelow there's a degenerated implementation of my web-server. With the same load (~40 request per second) the average request response time increased to 200ms!\nDigging in, I see that the internal async handle time (queries to Elasticsearch) is not stable and the time takes to each fetch call might be different, and the total average (in ab load test) is high.\nI'm using ab to simulate the load and measure it internally by printing the current fetch handle time, average fetch handle time and maximum handle time.\nWhen doing one request at a time (concurrency 1):\nab -p es-query-rcom.txt -T application/json -n 1000 -c 1 -k 'http://localhost:5002/recommend'\nmy prints looks like: [avg req_time: 3, dur: 3] [current req_time: 2, dur: 3] [max req_time: 125, dur: 125] reqs: 8000\nBut when I try to increase the concurrency (up to 8): ab -p es-query-rcom.txt -T application/json -n 1000 -c 8 -k 'http://localhost:5002/recommend'\nnow my prints looks like: [avg req_time: 6, dur: 13] [current req_time: 4, dur: 4] [max req_time: 73, dur: 84] reqs: 8000\nThe average req is now x2 slower (or x4 by my measurements)!\nWhat do I miss here? why do I see this degradation?\nweb_server.py:\nimport tornado\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.options import define, options\nfrom tornado.httpserver import HTTPServer\nfrom web_handler import WebHandler\n\nSERVICE_NAME = 'web_server'\nNUM_OF_PROCESSES = 1\n\n\nclass Statistics(object):\n    def __init__(self):\n        self.total_requests = 0\n        self.total_requests_time = 0\n        self.total_duration = 0\n        self.max_time = 0\n        self.max_duration = 0\n\n\nclass RcomService(object):\n    def __init__(self):\n        print 'initializing RcomService...'\n        AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\", max_clients=3)\n        self.stats = Statistics()\n\n    def start(self, port):\n        define(\"port\", default=port, type=int)\n        db = self.get_db(self.stats)\n        routes = self.generate_routes(db)\n        app = tornado.web.Application(routes)\n        http_server = HTTPServer(app, xheaders=True)\n        http_server.bind(options.port)\n        http_server.start(NUM_OF_PROCESSES)\n        tornado.ioloop.IOLoop.current().start()\n\n    @staticmethod\n    def generate_routes(db):\n        return [\n            (r\"/recommend\", WebHandler, dict(db=db))\n        ]\n\n    @staticmethod\n    def get_db(stats):\n        return {\n            'stats': stats\n        }\n\n\ndef main():\n    port = 5002\n    print('starting %s on port %s', SERVICE_NAME, port)\n\n    rcom_service = RcomService()\n    rcom_service.start(port)\n\n\nif __name__ == '__main__':\n    main()\nweb_handler.py:\nimport time\nimport ujson\nfrom tornado import gen\nfrom tornado.gen import coroutine\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.web import RequestHandler\n\n\nclass WebHandler(RequestHandler):\n    def initialize(self, db):\n        self.stats = db['stats']\n\n    @coroutine\n    def post(self, *args, **kwargs):\n        result = yield self.wrapper_innear_loop([{}, {}, {}, {}, {}, {}, {}, {}])  # dummy queries (empty)\n        self.write({\n            'res': result\n        })\n\n    @coroutine\n    def wrapper_innear_loop(self, queries):\n        result = []\n        for q in queries:  # queries are performed serially \n            res = yield self.async_fetch_gen(q)\n            result.append(res)\n        raise gen.Return(result)\n\n    @coroutine\n    def async_fetch_gen(self, query):\n        url = 'http://localhost:9200/my_index/_search'\n\n        headers = {\n                'Content-Type': 'application/json',\n                'Connection': 'keep-alive'\n        }\n\n        http_client = AsyncHTTPClient()\n        start_time = int(round(time.time() * 1000))\n        response = yield http_client.fetch(url, method='POST', body=ujson.dumps(query), headers=headers)\n        end_time = int(round(time.time() * 1000))\n        duration = end_time - start_time\n        body = ujson.loads(response.body)\n        request_time = int(round(response.request_time * 1000))\n        self.stats.total_requests += 1\n        self.stats.total_requests_time += request_time\n        self.stats.total_duration += duration\n        if self.stats.max_time < request_time:\n            self.stats.max_time = request_time\n        if self.stats.max_duration < duration:\n            self.stats.max_duration = duration\n        duration_avg = self.stats.total_duration / self.stats.total_requests\n        time_avg = self.stats.total_requests_time / self.stats.total_requests\n        print \"[avg req_time: \" + str(time_avg) + \", dur: \" + str(duration_avg) + \\\n              \"] [current req_time: \" + str(request_time) + \", dur: \" + str(duration) + \"] [max req_time: \" + \\\n              str(self.stats.max_time) + \", dur: \" + str(self.stats.max_duration) + \"] reqs: \" + \\\n              str(self.stats.total_requests)\n        raise gen.Return(body)\nI tried to play a bit with the async class (Simple vs curl), the max_clients size, but I don't understand what is the best tune in my case.\nBut", "issue_status": "Closed", "issue_reporting_time": "2019-03-25T21:26:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "75": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2632", "issue_id": "#2632", "issue_summary": "Huge URLs return empty response instead of 414", "issue_description": "nieksand commented on 25 Mar 2019\nIf I hit Tornado with an insanely huge request URL, I get the following log output:\n[I 190325 14:37:00 iostream:734] Unsatisfiable read, closing connection: delimiter re.compile(b'\\r?\\n\\r?\\n') not found within 65536 bytes\nI can reproduce this with Python 3.6.7 on both Tornado 5.1.1 and Tornado 6.0.2.\nCurl shows an empty response:\n... snip giant GET line...\n> Host: localhost:9800\n> User-Agent: curl/7.61.0\n> Accept: */*\n> \n* Empty reply from server\n* Connection #0 to host localhost left intact\ncurl: (52) Empty reply from server\nHere is a Python snippet that generates a sufficiently nasty URL:\narg = 'a' * 70000\nprint(f\"curl --verbose 'http://localhost:9800/foo?x={arg}'\")\nI hit this in the real world. My normally beefy-but-manageable input data of ~1000 bytes had a crazy outlier that triggered this. Of course, I need to fix my code to not throw 70KB of crap in a request URL.\nTwo thoughts:\nThe error message should be more intuitive\nThis should return an http 414 (URI Too Long)", "issue_status": "Closed", "issue_reporting_time": "2019-03-25T13:52:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "76": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2628", "issue_id": "#2628", "issue_summary": "SyntaxError:invalid syntax while mkdocs serve", "issue_description": "dibasdas commented on 23 Mar 2019\npk@pk-Inspiron-5558:~/my-project$ mkdocs serve\nINFO - Building documentation...\nINFO - Cleaning site directory\nTraceback (most recent call last):\nFile \"/home/pk/.local/bin/mkdocs\", line 11, in\nsys.exit(cli())\nFile \"/home/pk/.local/lib/python2.7/site-packages/click/core.py\", line 764, in call\nreturn self.main(*args, **kwargs)\nFile \"/home/pk/.local/lib/python2.7/site-packages/click/core.py\", line 717, in main\nrv = self.invoke(ctx)\nFile \"/home/pk/.local/lib/python2.7/site-packages/click/core.py\", line 1137, in invoke\nreturn _process_result(sub_ctx.command.invoke(sub_ctx))\nFile \"/home/pk/.local/lib/python2.7/site-packages/click/core.py\", line 956, in invoke\nreturn ctx.invoke(self.callback, **ctx.params)\nFile \"/home/pk/.local/lib/python2.7/site-packages/click/core.py\", line 555, in invoke\nreturn callback(*args, **kwargs)\nFile \"/home/pk/.local/lib/python2.7/site-packages/mkdocs/main.py\", line 134, in serve_command\nlivereload=livereload\nFile \"/home/pk/.local/lib/python2.7/site-packages/mkdocs/commands/serve.py\", line 124, in serve\n_livereload(host, port, config, builder, site_dir)\nFile \"/home/pk/.local/lib/python2.7/site-packages/mkdocs/commands/serve.py\", line 36, in _livereload\nfrom livereload import Server\nFile \"/home/pk/.local/lib/python2.7/site-packages/livereload/init.py\", line 15, in\nfrom .server import Server, shell\nFile \"/home/pk/.local/lib/python2.7/site-packages/livereload/server.py\", line 20, in\nfrom tornado.wsgi import WSGIContainer\nFile \"/home/pk/.local/lib/python2.7/site-packages/tornado/wsgi.py\", line 51\ndef to_wsgi_str(s, bytes) -> str:\n^\nSyntaxError: invalid syntax", "issue_status": "Closed", "issue_reporting_time": "2019-03-22T21:25:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "77": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2627", "issue_id": "#2627", "issue_summary": "invalid syntax problem", "issue_description": "qianxiao111 commented on 22 Mar 2019\nwhen I install visdom, the problem is appeared.", "issue_status": "Closed", "issue_reporting_time": "2019-03-22T12:44:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "78": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2626", "issue_id": "#2626", "issue_summary": "When HttpResponse body is empty it returns a ValueError when it should not", "issue_description": "marijnd commented on 19 Mar 2019\nIn checkin 7b846ea the code for httpclient.HttpResponse.body was changed to throw a ValueError when the body is empty.\nBut since the message body is optional throwing an ValueError seems not right because it is not an error. Can it be reverted back to the 5 behavior of just returning a None when the body is empty.", "issue_status": "Closed", "issue_reporting_time": "2019-03-19T08:05:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "79": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2625", "issue_id": "#2625", "issue_summary": "RedirectHandler.get not taking kwargs", "issue_description": "AbsoluteVirtue commented on 18 Mar 2019 \u2022\nedited\nHi! Excuse me, if this has been discussed. Search isn't finding anything similar.\nAny particular reason, why it's not allowed to do this kind of stuff when using RedirectHandler out of the box?\nurl(\n        pattern=r'/?(?P<lang>ru|en)?/public/(?P<id>\\d+)/',\n        handler=handlers.Item,\n        name='item',\n    ),\n    url(\n        r'/?(?P<lang>ru|en)?/public/(?P<id>\\d+)', \nRedirectHandler,\n        dict(url='/{lang}/public/{id}/'),\n    ),", "issue_status": "Closed", "issue_reporting_time": "2019-03-18T16:11:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "80": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2624", "issue_id": "#2624", "issue_summary": "Can not install tornadio using pip", "issue_description": "pbirusk commented on 18 Mar 2019\nI have current issues installing tornado, not sure if the problem is tornado related or pip related. Any idea?\npi@raspberrypi:~ $ sudo pip install tornado\nCollecting tornado\n  Could not find a version that satisfies the requirement tornado (from versions: )\nNo matching distribution found for tornado\npi@raspberrypi:~ $ pip -V\npip 9.0.1 from /usr/lib/python2.7/dist-packages (python 2.7)", "issue_status": "Closed", "issue_reporting_time": "2019-03-18T14:17:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "81": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2623", "issue_id": "#2623", "issue_summary": "ImportError: cannot import name 'Type' since release 6.0", "issue_description": "nikokio commented on 18 Mar 2019 \u2022\nedited\nHello,\nTornado versions: 6.0 and 6.0.1\nTyping (dependency) versions: 3.6.4 and 3.6.6\nPython version: 3.5.1\nOS: Linux RedHat Entreprise 7.4\nTraceback (most recent call last):\n  File \"/path/bin/flower\", line 11, in <module>\n    load_entry_point('flower==0.9.2', 'console_scripts', 'flower')()\n  File \"/path/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 489, in load_entry_point\n    return get_distribution(dist).load_entry_point(group, name)\n  File \"/path/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2793, in load_entry_point\n    return ep.load()\n  File \"/path/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2411, in load\n    return self.resolve()\n  File \"/path/lib/python3.5/site-packages/pkg_resources/__init__.py\", line 2417, in resolve\n    module = __import__(self.module_name, fromlist=['__name__'], level=0)\n  File \"/path/lib/python3.5/site-packages/flower/__main__.py\", line 4, in <module>\n    from flower.command import FlowerCommand\n  File \"/path/lib/python3.5/site-packages/flower/command.py\", line 12, in <module>\n    from tornado.options import options\n  File \"/path/lib/python3.5/site-packages/tornado/options.py\", line 103, in <module>\n    from tornado.escape import _unicode, native_str\n  File \"/path/lib/python3.5/site-packages/tornado/escape.py\", line 27, in <module>\n    from tornado.util import unicode_type\n  File \"/path/lib/python3.5/site-packages/tornado/util.py\", line 21, in <module>\n    from typing import (\nImportError: cannot import name 'Type'\nCode extract:\nfrom typing import (\n    Any,\n    Optional,\n    Dict,\n    Mapping,\n    List,\n    Tuple,\n    Match,\n    Callable,\n    Type, <== Problem here\n    Sequence,\n)\nReverting to tornado 5.1.1 works\nThanks\nRegards", "issue_status": "Closed", "issue_reporting_time": "2019-03-18T12:53:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "82": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2622", "issue_id": "#2622", "issue_summary": "Tornado multiple sub-processes on windows", "issue_description": "marodev commented on 16 Mar 2019\nTornado doesn't seem to work properly on windows with multiple sub-processes.\nsimple hello world example:\nmain.py\nfrom abc import ABC\n\nimport tornado.ioloop\nimport tornado.web\nfrom tornado.httpserver import HTTPServer\n\n\nclass MainHandler(tornado.web.RequestHandler, ABC):\n\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/(\\d+)$\", MainHandler),\n    ])\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    server = HTTPServer(app)\n    server.bind(8888)\n    server.start(2)  # Forks multiple sub-processes\n    tornado.ioloop.IOLoop.current().start()\nexecution:\n$ pipenv install tornado\n$ pipenv run main.py\nexception:\nTraceback (most recent call last):\n  File \"C:\\Users\\marodev\\source\\repos\\TornadoHelloWorld2\\main.py\", line 24, in <module>\n    server.start(2)  # Forks multiple sub-processes\n  File \"C:\\Users\\marodev\\.virtualenvs\\TornadoHelloWorld2-GAcRFl-e\\lib\\site-packages\\tornado\\tcpserver.py\", line 241, in start\n    process.fork_processes(num_processes, max_restarts)\n  File \"C:\\Users\\marodev\\.virtualenvs\\TornadoHelloWorld2-GAcRFl-e\\lib\\site-packages\\tornado\\process.py\", line 142, in fork_processes\n    id = start_child(i)\n  File \"C:\\Users\\marodev\\.virtualenvs\\TornadoHelloWorld2-GAcRFl-e\\lib\\site-packages\\tornado\\process.py\", line 130, in start_child\n    pid = os.fork()\nAttributeError: module 'os' has no attribute 'fork'\nmy environment:\nwindows 10\npython 3.6.6\npipenv", "issue_status": "Closed", "issue_reporting_time": "2019-03-15T19:19:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "83": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2618", "issue_id": "#2618", "issue_summary": "Failed to upload file behind nginx", "issue_description": "harryzcy commented on 10 Mar 2019\nI'm using @tornado.web.stream_request_body for file uploading, which sould work fine. However, when I put tornado behind a nginx, the request fails with a 502 response, with an error log from nginx showing that upstream server temporarily disabled while reading response header from upstream.\nIt seems that methods like prepare and data_received are working but post is never reached.\nIs there any problem with tornado? Or its related to nginx configuration?", "issue_status": "Closed", "issue_reporting_time": "2019-03-10T17:53:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "84": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2617", "issue_id": "#2617", "issue_summary": "Tornado IOStream.read_bytes clean buffer method", "issue_description": "CNLHC commented on 7 Mar 2019\nHello,\nThis issue maybe relate to #1886\nI want to perform this logic:\nestablish tcp connection between a general client and tornado TCPServer\nServer use read_bytes API to get info from client\nServer must read 12 bytes in 3 seconds, otherwise , it will drop data already received and waiting for next 3 sec without close the connect.\nI have try this to implement logic above:\nclass SSCServer(TCPServer):\n    async def handle_stream(self,stream:IOStream,address):\n        print(\"connect from {0:s}:{1:d}\".format(address[0],address[1]))\n        loop = IOLoop.current() #type: IOLoop\n        while True:\n            try:\n                if not stream.reading():\n                    dataFuture = stream.read_bytes(12) #type:futures.Future\n                data = await gen.with_timeout(timedelta(seconds=3),dataFuture) \n                loop.run_in_executor(None,functools.partial(SSCDecoder.SSCDecodeFrame,data))\n                await stream.write(data)\n                \n            except StreamClosedError:\n                print(\"connection closed from {0:s}:{1:d}\".format(address[0],address[1]))\n                break\n\n            except gen.TimeoutError:\n                print(\"No response in 3 seconds {0:s}:{1:d}\".format(address[0],address[1]))\nThe TimeoutError will be captured, and connect won't be terminated. But after TimeoutError, the stream won't drop bytes it have read already.\nI think there should be some method to clear the stream RX-buffer which was not well document? Or clean RX-buffer is not supported in current version?\n(using tornado 6.0.1 with python 3.5.3)\nThanks", "issue_status": "Closed", "issue_reporting_time": "2019-03-07T03:17:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "85": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2616", "issue_id": "#2616", "issue_summary": "Unable to run tabpy server using windows batch file ,startup.bat", "issue_description": "amruutharao commented on 7 Mar 2019\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2019-03-06T21:48:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "86": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2615", "issue_id": "#2615", "issue_summary": "Running Tornado inside Jupyter notebook question", "issue_description": "wyattbiker commented on 5 Mar 2019\nWas wondering what to do, to structure a Tornado app when running it with Jupyter. The test app below works fine from the Python command line and code changes using vim will register. But if I load this into notebook cell although it runs, changes do not register unless I restart the Kernel.\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"<b>Hello Whats Up, world!!!<br>Test this</b>\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ],debug=True)\n\nif __name__ == \"__main__\":\n    port=8889\n    app = make_app()\n    app.listen(port)\n    print(f'listening on port {port}')\n    tornado.ioloop.IOLoop.current().start", "issue_status": "Closed", "issue_reporting_time": "2019-03-04T22:49:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "87": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2611", "issue_id": "#2611", "issue_summary": "WebsocketHandler.set_nodelay results in assertion failure", "issue_description": "jbms commented on 3 Mar 2019\nIn previous versions of Torando, WebsocketHandler.set_nodelay could be called from open to set the nodelay option. In Tornado 6.0, this results in an assertion failure:\nFile \".../tornado/websocket.py\", line 561, in set_nodelay\nassert self.stream is not None", "issue_status": "Closed", "issue_reporting_time": "2019-03-03T17:16:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "88": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2608", "issue_id": "#2608", "issue_summary": "Prepare for python 3.8 on windows", "issue_description": "Member\nbdarnell commented on 2 Mar 2019\nPython 3.8 asyncio is going to make the \"proactor\" event loop the default, instead of the current \"selector\" event loop. This is a problem for Tornado because the proactor event loop doesn't support the unix-style add_reader APIs that Tornado uses.\nAnyone using Tornado 5+ on windows with python 3.8 will need to configure asyncio to use the selector event loop; we'll have to document this. We should also try to detect the use of a proactor event loop and give a clear error message (the current NotImplementError message can be seen in this SO post).\nI don't think it would be appropriate for Tornado itself to configure the selector event loop automatically, since it has drawbacks (less scalability than the proactor loop, the user may want to use another event loop entirely like uvloop). Applications using Tornado (like jupyter notebook) may wish to do so, though. Maybe there should even be some more magical way to choose the selector loop (an environment variable? a special package to install?) to avoid the need to build this in to each application, although i don't really like the idea of that much magic.\n1", "issue_status": "Closed", "issue_reporting_time": "2019-03-02T17:41:03Z", "fixed_by": "#2686", "pull_request_summary": "docs: Add notice about WindowsSelectorEventLoop on py38", "pull_request_description": "Member\nbdarnell commented on 23 Jun 2019\nFixes #2608", "pull_request_status": "Merged", "issue_fixed_time": "2019-06-22T18:50:37Z", "files_changed": [["7", "docs/index.rst"]]}, "89": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2607", "issue_id": "#2607", "issue_summary": "tornado 6.0 raises error while using jupyter notebook", "issue_description": "zxh126 commented on 2 Mar 2019\nit works by downgrade to tornado 5.1.1", "issue_status": "Closed", "issue_reporting_time": "2019-03-02T16:34:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "90": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2604", "issue_id": "#2604", "issue_summary": "Import failure using Python 3.5.2", "issue_description": "douglas-raillard-arm commented on 1 Mar 2019 \u2022\nedited\nHi,\nTornado 6.0 tornado.concurrent module seems to not be importable on Python 3.5.1 as can be seen on that backtrace:\nTraceback (most recent call last):\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/bin/jupyter-labextension\", line 6, in <module>\n    from jupyterlab.labextensions import main\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/jupyterlab/labextensions.py\", line 16, in <module>\n    from .commands import (\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/jupyterlab/commands.py\", line 27, in <module>\n    from jupyterlab_server.process import which, Process, WatchHelper\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/jupyterlab_server/__init__.py\", line 4, in <module>\n    from .app import LabServerApp\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/jupyterlab_server/app.py\", line 9, in <module>\n    from .server import ServerApp\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/jupyterlab_server/server.py\", line 14, in <module>\n    from notebook.base.handlers import (\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/notebook/base/handlers.py\", line 30, in <module>\n    from tornado import web, gen, escape, httputil\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/tornado/web.py\", line 84, in <module>\n    from tornado.concurrent import Future, future_set_result_unless_cancelled\n  File \"/home/travis/build/ARM-software/lisa/.lisa-venv-3.5/lib/python3.5/site-packages/tornado/concurrent.py\", line 175, in <module>\n    future: Union[\"futures.Future[_T]\", \"Future[_T]\"], value: _T\n  File \"/usr/lib/python3.5/typing.py\", line 552, in __getitem__\n    dict(self.__dict__), parameters, _root=True)\n  File \"/usr/lib/python3.5/typing.py\", line 512, in __new__\n    for t2 in all_params - {t1} if not isinstance(t2, TypeVar)):\n  File \"/usr/lib/python3.5/typing.py\", line 512, in <genexpr>\n    for t2 in all_params - {t1} if not isinstance(t2, TypeVar)):\n  File \"/usr/lib/python3.5/typing.py\", line 190, in __subclasscheck__\n    self._eval_type(globalns, localns)\n  File \"/usr/lib/python3.5/typing.py\", line 177, in _eval_type\n    eval(self.__forward_code__, globalns, localns),\n  File \"<string>\", line 1, in <module>\nTypeError: 'type' object is not subscriptable\nPlease note that it seems to fail on 3.5.2 as well, but works fine on Python 3.5.6, so concurrent.py is probably relying on a typing feature introduced in between, maybe that one: https://docs.python.org/3/library/typing.html#typing.ClassVar\nBest regards,\nDouglas", "issue_status": "Closed", "issue_reporting_time": "2019-03-01T16:55:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "91": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2598", "issue_id": "#2598", "issue_summary": "Serving static files under authentication", "issue_description": "m2datacenter commented on 22 Feb 2019\nHi,\nIt is possible to serve some static files like .doc, .xls, .pdf, etc only if the user is authenticated?\nThis way:\n(r\"/files/([a-z0-9.]+)\", tornado.web.StaticFileHandler, {\"path\": \"/mnt/drive/docs\"})\nany one can dowload the files", "issue_status": "Closed", "issue_reporting_time": "2019-02-21T19:33:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "92": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2595", "issue_id": "#2595", "issue_summary": "Async over-the-network logger", "issue_description": "betatim commented on 20 Feb 2019\nWhere could I go to find/start reading about existing logging handlers that send messages over the network and play well with tornado?\nIt seems like a logging handler that does network I/O should be async but I can't find many examples which makes me wonder if I am missing something. Has everyone switched to using an external tool that follows the tornado logs and then ships them off? Or do synchronous loggers work just fine?\nThe goal I'd like to achieve is to be able to send JSON formatted messages over the network to a remote machine.\nSo far I've found https://github.com/B2W-BIT/aiologger (async but no networking) and https://github.com/vklochan/python-logstash (networked but not async).", "issue_status": "Closed", "issue_reporting_time": "2019-02-19T21:52:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "93": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2594", "issue_id": "#2594", "issue_summary": "Latest release dropped @asynchronus decorator", "issue_description": "2stacks commented on 20 Feb 2019\nIf it was intentional I'll just lock my requirements version until I have time to update my code.\nLooks like Tornado dropped this decorator in the latest release v6.0.0b1.\nWhen trying to run 'celery flower' last message in stack trace is;\nAttributeError: module 'tornado.web' has no attribute 'asynchronous'", "issue_status": "Closed", "issue_reporting_time": "2019-02-19T19:51:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "94": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2593", "issue_id": "#2593", "issue_summary": "Handle WebSocketHandler check_origin asynchronous using Motor", "issue_description": "m2datacenter commented on 17 Feb 2019 \u2022\nedited\nHi!\nI'm looking for the proper way to check if an origin value is present on database.\nSince I can't do this:\n@tornado.web.asynchronous\nasync def check_origin(self, origin):\nreturn await self.motor[\"collection\"].find_one({...})\nAre there some solution for this?\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2019-02-17T16:01:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "95": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2592", "issue_id": "#2592", "issue_summary": "AttributeError: exception:'NoneType' object has no attribute 'fetch'", "issue_description": "VersionHX commented on 14 Feb 2019 \u2022\nedited\nI try to use tornado.httpclient with proxy , so i chose the 'curl_httpclient' mode like\uff1a\nhttp_client = tornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\nreq = tornado.httpclient.HTTPRequest(url=url, method=method, headers=headers, connect_timeout=conn_timeout, request_timeout=request_timeout, body=body, proxy_host=proxy_host, proxy_port=proxy_port)\nres = http_client.fetch(req, raise_error=False)\nand get the error : AttributeError: exception:'NoneType' object has no attribute 'fetch'\nHowever, when i choose 'simple_httpclient' mode, everything goes fine with no proxy.\nIs there anyone who can help?", "issue_status": "Closed", "issue_reporting_time": "2019-02-14T12:33:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "96": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2591", "issue_id": "#2591", "issue_summary": "broken SSL dependency", "issue_description": "Albert65 commented on 11 Feb 2019 \u2022\nedited\nHi All, I am trying to install tornado 5.1.1 on Redhat Linux x86/64.\nPython3 was manually compiled and installed without issues along with many other packages.\nTornado depends of SSL module, which was written for (?) Python2.\nI fixed manually one issue in SSL, but still:\npip3 install jupyter --no-index --find-links=file:///${HOME}/work/py36whl/\nLooking in links: file:///${HOME}/work/py36whl/\nCollecting jupyter\nCollecting notebook (from jupyter)\nCollecting ipywidgets (from jupyter)\nCollecting qtconsole (from jupyter)\nCollecting jupyter-console (from jupyter)\nCollecting nbconvert (from jupyter)\nCollecting ipykernel (from jupyter)\nCollecting prometheus-client (from notebook->jupyter)\nCollecting Send2Trash (from notebook->jupyter)\nCollecting nbformat (from notebook->jupyter)\nCollecting traitlets>=4.2.1 (from notebook->jupyter)\nCollecting tornado>=4 (from notebook->jupyter)\nComplete output from command python setup.py egg_info:\nTraceback (most recent call last):\nFile \"\", line 1, in\nFile \"/tmp/pip-install-y8kh14v4/tornado/setup.py\", line 18, in\nimport ssl\nFile \"....../lib/python3.6/ssl.py\", line 101, in\nimport _ssl # if we can't import it, let the error propagate\nModuleNotFoundError: No module named '_ssl'\n----------------------------------------\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-install-y8kh14v4/tornado/\nIs it possible to avoid outdated SSL module?", "issue_status": "Closed", "issue_reporting_time": "2019-02-11T13:55:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "97": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2584", "issue_id": "#2584", "issue_summary": "Release schedule for Tornado 6", "issue_description": "Contributor\nmrocklin commented on 7 Feb 2019\nI suspect that the question is \"sometimes in the indefinite future\" but I thought I'd ask, is there an expectation of when Tornado 6 will be released?\nI've run into a case where tornado/asyncio interactions run more smoothly with master than with the latest release, and I'm curious if I should dig into them, or just wait for the next release.\nNo pressure on this, just planning things on my end.", "issue_status": "Closed", "issue_reporting_time": "2019-02-07T14:29:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "98": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2582", "issue_id": "#2582", "issue_summary": "Allow for streaming file uploads with multipart/form-data.", "issue_description": "eulersIDcrisis commented on 5 Feb 2019\nRight now, there are functions to parse out files received from form data for a request, using calls like: tornado.httputil.parse_multipart_form_data(). Data that is received in this format is made available through the RequestHandler via: self.request.files.\nHowever, this has the drawback that the entire request needs to be stored in memory. Is it possible to implement a \"streaming\" form of this route that would enable streaming the input files so that the whole request does not need to be stored in memory?\nMaybe this could be a decorator that behaves similar to @tornado.web.stream_request_body, with a hook def write_to_file(self, file_info, data_received) instead of def data_received(self, data).", "issue_status": "Closed", "issue_reporting_time": "2019-02-04T22:04:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "99": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2578", "issue_id": "#2578", "issue_summary": "Excessive logging at warning when content-encoding header is present", "issue_description": "goswamisandeep commented on 31 Jan 2019\ntornado prints following log in warning which floods our logs\n'httputil.py - 755 - Unsupported Content-Encoding: deflate`\nideally it should be info or debug\ntornado/tornado/httputil.py\nLine 780 in 975e916\n if headers and \"Content-Encoding\" in headers: ", "issue_status": "Closed", "issue_reporting_time": "2019-01-31T07:02:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "100": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2576", "issue_id": "#2576", "issue_summary": "Why not make application.settings as util.ObjectDict()?", "issue_description": "mywaiting commented on 24 Jan 2019\nWhen I call handler.settings.debug in tornado template, It will throw an error duo to handler.settings is python Dict. It can not access to its attribute like handler.settings.debug\nActually, tornado itself has util.ObjectDict() or we can use collection.OrderedDict\ncode ref here: https://github.com/tornadoweb/tornado/blob/stable/tornado/web.py#L1981\nI post this issue here. and let us talk about it. If everyone like to access this, I will make PR ASAP.", "issue_status": "Closed", "issue_reporting_time": "2019-01-24T13:13:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "101": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2570", "issue_id": "#2570", "issue_summary": "Unhandled exception in open coroutine of websockethandler does not close connection", "issue_description": "heybuddy commented on 12 Jan 2019\nI tested the following app with version 5.1.1 of tornado:\nimport tornado\nimport tornado.websocket\nimport tornado.ioloop\nfrom tornado import gen\n\n\nclass MySocket(tornado.websocket.WebSocketHandler):\n    def open(self):\n        print 'socket opened'\n        raise Exception('bad')\n\n    @gen.coroutine\n    def on_message(self, message):\n        print message\n\n    def on_close(self):\n        print 'closed'\n\n\ndef create_application():\n    return tornado.web.Application([\n        (r\"^/?$\", MySocket),\n    ])\n\n\napplication = create_application()\napplication.listen(8000)\ntornado.ioloop.IOLoop.current().start()\nIf I connect with a client, I get the following (correct) output on the server side:\nsocket opened\nERROR:tornado.application:Uncaught exception GET / (127.0.0.1)\nHTTPServerRequest(protocol='http', host='localhost:8000', method='GET', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1')\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/websocket.py\", line 546, in _run_callback\n    result = callback(*args, **kwargs)\n  File \"./test.py\", line 10, in open\n    raise Exception('bad')\nException: bad\nclosed\nHowever, if I add the gen.coroutine annotation to open and run the same test, I get this output instead:\nsocket opened\nERROR:tornado.application:Exception in callback <functools.partial object at 0x7fea30c31c00>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 758, in _run_callback\n    ret = callback()\n  File \"/usr/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/websocket.py\", line 553, in <lambda>\n    self.stream.io_loop.add_future(result, lambda f: f.result())\n  File \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 307, in wrapper\n    result = func(*args, **kwargs)\n  File \"./test.py\", line 11, in open\n    raise Exception('bad')\nException: bad\nERROR:tornado.application:Future exception was never retrieved: Traceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 1141, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/websocket.py\", line 757, in _accept_connection\n    yield open_result\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 307, in wrapper\n    result = func(*args, **kwargs)\n  File \"./test.py\", line 11, in open\n    raise Exception('bad')\nException: bad\nNote that there is no \"closed\" message. On the client side, the client still thinks the connection is still open and I can send messages without error. Without the coroutine, the client gets a broken pipe error the next time it tries to send a message.", "issue_status": "Closed", "issue_reporting_time": "2019-01-11T22:29:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "102": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2569", "issue_id": "#2569", "issue_summary": "ERROR:tornado.application:Uncaught exception GET / (127.0.0.1)", "issue_description": "flyfreeme commented on 10 Jan 2019\nERROR:tornado.application:Uncaught exception GET / (127.0.0.1)\nHTTPServerRequest(protocol='http', host='tornado', method='GET', uri='/', version='HTTP/1.0', remote_ip='127.0.0.1')\nself.render(_config[\"template\"], **template_data)\n\u6211\u5728\u6267\u884c\u8fd9\u4e2a\u65b9\u6cd5\u7684\u65f6\u5019\u62a5\u9519\nnamespace.update(self.ui)\nTypeError: 'NoneType' object is not iterable\n\u4f46\u662f\u6267\u884cself.write(template_data)\u5374\u4e0d\u62a5\u9519\n\u800c\u4e14\u5728\u6267\u884cself.write(template_data)\u540e\uff0c\u518d\u6267\u884cself.render(_config[\"template\"], **template_data)\u5374\u53c8\u4e0d\u62a5\u9519\u4e86\u3002\n\u4e0d\u77e5\u9053\u8fd9\u662fpython\u7684\u95ee\u9898\uff0c\u8fd8\u662ftornado\u7684\u95ee\u9898\n\u4e0d\u77e5\u9053\u6709\u6ca1\u6709\u54ea\u4f4d\u670b\u53cb\u4e5f\u9047\u5230\u4e86\u4e0a\u9762\u7684\u95ee\u9898\uff1f", "issue_status": "Closed", "issue_reporting_time": "2019-01-10T08:56:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "103": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2568", "issue_id": "#2568", "issue_summary": "WebSocketClosedError\uff1fStreamClosedError\uff1f", "issue_description": "xnys commented on 7 Jan 2019 \u2022\nedited\ntornado 5.1.1\nI often trigger this error, but I don't know how to solve it.Help!\ntry-catch has been added.\ntry:\n    self.write_message(data)\nexcept ...\n[2019-01-07 05:32:34,509 ERROR asyncio] Future exception was never retrieved\nfuture: <Future finished exception=WebSocketClosedError()>\nTraceback (most recent call last):\n  File \"/usr/zb/.local/lib/python3.6/site-packages/tornado/websocket.py\", line 874, in wrapper\n    yield fut\n  File \"/usr/zb/.local/lib/python3.6/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\ntornado.iostream.StreamClosedError: Stream is closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/zb/.local/lib/python3.6/site-packages/tornado/gen.py\", line 1141, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/zb/.local/lib/python3.6/site-packages/tornado/websocket.py\", line 876, in wrapper\n    raise WebSocketClosedError()\ntornado.websocket.WebSocketClosedError", "issue_status": "Closed", "issue_reporting_time": "2019-01-07T12:08:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "104": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2567", "issue_id": "#2567", "issue_summary": "Complex and long JSON structures can be destroyed in response", "issue_description": "libobo1112006 commented on 6 Jan 2019\nclass MainHandler(tornado.web.RequestHandler):\ndef post(self):\nprint \"MainHandler\"\nfp = open(\"/root/Apps/AppEngine/test.result\")\nresult_json = fp.read()\nresult = json.loads(result_json)\nfp.close()\nreturn self.finish(result_json)\nresponse.content.rfind(\"}\")\n31662\nlen(response.content)\n68527", "issue_status": "Closed", "issue_reporting_time": "2019-01-06T03:59:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "105": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2558", "issue_id": "#2558", "issue_summary": "Copyright on docs/conf.py not be reproducible", "issue_description": "eamanu commented on 28 Dec 2018 \u2022\nedited\nHi,\nThis is a issue opened by Chris Lamb (https://alioth-lists.debian.net/pipermail/python-modules-team/2018-December/051712.html)\nThe line\ncopyright = \"2009-%s, The Tornado Authors\" % time.strftime(\"%Y\")\non docs/conf.py will no be reproducible. So, in Debian packaging a patch was created to use SOURCE_DATE_EPOCH environment variable. This way we avoid the mentioned problem.\nThe patch is here\nYou can read more about SOURCE_DATE_EPOCH here. Please, consider support it.", "issue_status": "Closed", "issue_reporting_time": "2018-12-28T11:48:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "106": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2556", "issue_id": "#2556", "issue_summary": "Staticfilehandler incredibly slow uploads across WAN.", "issue_description": "LordOdin commented on 21 Dec 2018\nI have 50Mbit upload and an NVME SSD but when trying to move files to other people from a local tornado server I get at most 5 Mbit upload. Even for large files over 100MB - 1GB\nTrying to move files to 30ms Florida(Gigabit connection) or 140ms Germany(50Mbit connection) are about equally as slow", "issue_status": "Closed", "issue_reporting_time": "2018-12-20T20:58:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "107": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2555", "issue_id": "#2555", "issue_summary": "REOPEN #2475 Bug in TemplateEngine if quoted if else", "issue_description": "nkordulla commented on 20 Dec 2018 \u2022\nedited\nTo clarify I just copied it in a better way\n{% if user.get('sex', '') == str(\"{% if user.get('sex', '') == 1 %}as{% end %}\") %}\nas\n{% else %}\n1\n{% end %}\nThe str(\"{% if user.get('sex', '') == 1 %}as{% end %}\")is just a str python expression\nI take the if expression and it works in python so should it inside the template language\n>>> user = {}\n>>> user.get('sex', '') == str(\"{% if user.get('sex', '') == 1 %}as{% end %}\")\nFalse\nSo essentially I just do\n{% if A == B %}\nas\n{% else %}\n1\n{% end %}\nWhere A is user.get('sex', '') and b is just a string: str(\"{% if user.get('sex', '') == 1 %}as{% end %}\")\nI think the parser there has just an error and dont respect strings inside the {% if %} block. Perhaps it is a minor but it is a bug.\nOriginally posted by @nkordulla in #2475 (comment)", "issue_status": "Closed", "issue_reporting_time": "2018-12-20T13:51:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "108": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2553", "issue_id": "#2553", "issue_summary": "Stack overflow in gen.py", "issue_description": "bdrung commented on 14 Dec 2018\nI am trying to build salt 2018.3.3 against tornado 4.5.3 for Debian. tornado 4.5.3 builds with the test succeeded (except four, see #2536) after renaming it from tornado to tornado4 (to make it co-installable). The test suite for salt fails:\nhttps://launchpadlibrarian.net/401405967/buildlog_ubuntu-disco-amd64.salt_2018.3.3+dfsg1-1~wip20181213~ubuntu19.04.1~ppa1_BUILDING.txt.gz\nCurrent thread 0x00007f1f5d3bc740 (most recent call first):\n  File \"/usr/lib/python3.7/abc.py\", line 139 in __instancecheck__\n  File \"/usr/lib/python3.7/inspect.py\", line 226 in isawaitable\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 1279 in convert_yielded\n  File \"/usr/lib/python3.7/functools.py\", line 824 in wrapper\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 1142 in handle_yield\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 1000 in __init__\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 319 in wrapper\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 1280 in convert_yielded\n[....]\n  File \"/usr/lib/python3.7/functools.py\", line 824 in wrapper\n  File \"/usr/lib/python3/dist-packages/tornado4/gen.py\", line 1142 in handle_yield\n  ...\nHereby I request help for debugging the issue. The stacktrace points to tornado as culprit. Here are the changes that I did to it: https://salsa.debian.org/python-team/modules/python-tornado/commits/tornado4", "issue_status": "Closed", "issue_reporting_time": "2018-12-13T20:08:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "109": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2552", "issue_id": "#2552", "issue_summary": "Exceptions in run_in_executor are swallowed", "issue_description": "ndvbd commented on 12 Dec 2018 \u2022\nedited\nI have a function that is a network call (blocking), that I want to 'fire and forget' and run on a different thread . (No Futures / co-routines / etc.)\nFrom one of my functions I run the instruction:\ntornado.ioloop.IOLoop.current().run_in_executor(None, long_blocking_call)\nHowever, if there are exceptions in the long_blocking_call, they are never shown. Why? How to solve it?\nI don't need the calling function to wait (yield) to the anything returned by the run_in_executor result, because I don't want to block any code after the run_in_executor line.\nI use python 2.7, tornado 5.1.1", "issue_status": "Closed", "issue_reporting_time": "2018-12-12T16:46:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "110": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2551", "issue_id": "#2551", "issue_summary": "verify_cert=False on tornado.websocket.websocket_connect()", "issue_description": "wolfxvi commented on 12 Dec 2018 \u2022\nedited\nIm trying some weeks now to connect to a websocket that has bad ssl cert and i cant figure out how to connect with tornado.websocket.websocket_connect() without verifying the cert. Any help?\ni have tried this with no luck:\nrequest= tornado.httpclient.HTTPRequest(url=self.url, validate_cert=False)\nw = yield tornado.websocket.websocket_connect(url=request, connect_timeout=5)", "issue_status": "Closed", "issue_reporting_time": "2018-12-11T22:05:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "111": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2550", "issue_id": "#2550", "issue_summary": "Is this project using Semantic Versioning", "issue_description": "zoomzhao10 commented on 11 Dec 2018\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2018-12-11T13:21:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "112": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2543", "issue_id": "#2543", "issue_summary": "Migrating from p2.7 to 3.6 - TypeError: object dict can't be used in 'await' expression", "issue_description": "felipefaraco commented on 2 Dec 2018\nPython 3.6\nTornado 5.1.1\nThis works:\n@tornado.gen.coroutine\ndef _http(self, _list):\nresponses = yield { name: self.http_client.fetch(self._build_request(name)) for name in _list }\nraise tornado.gen.Return(responses)\nThis throws TypeError: object dict can't be used in 'await' expression:\nasync def _http(self, _list):\nresponses = await { name: self.http_client.fetch(self._build_request(name)) for name in _list }\nreturn responses\nWhere self.http_client = AsyncHTTPClient()\nI thought they would be equivalent, but clearly I'm wrong.", "issue_status": "Closed", "issue_reporting_time": "2018-12-02T10:14:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "113": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2541", "issue_id": "#2541", "issue_summary": "Python2 tornado locks / conditions", "issue_description": "ndvbd commented on 22 Nov 2018\nFor my tornado websockets server, I would like to make sure my on_message() is waiting until open() has finished (open has some tasks takes takes a bit time).\nI assume the right way to do it by by using tornado locks (condition variable). However, there is no 'await' in python 2.7. What's the equivalent in python2? Or should I use yield gen.sleep(5) over a loop with some if inside?", "issue_status": "Closed", "issue_reporting_time": "2018-11-22T17:03:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "114": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2540", "issue_id": "#2540", "issue_summary": "InvalidStateError when cancelling http requests", "issue_description": "nieksand commented on 21 Nov 2018 \u2022\nedited\nI am using Tornado 5.1.1 with Python 3.6 asyncio.\nWhen I cancel() an asyncio task holding a Tornado http fetch request, I get the following exception:\nERROR:tornado.application:Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0x7fda5decba60>, HTTPResponse(_body=None,_error_i\nTraceback (most recent call last):\nFile \"/data/workspace/cape/attribute-pipeline/python/lib/python3.6/site-packages/tornado/ioloop.py\", line 758, in _run_callback\nret = callback()\nFile \"/data/workspace/cape/attribute-pipeline/python/lib/python3.6/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\nreturn fn(*args, **kwargs)\nFile \"/data/workspace/cape/attribute-pipeline/python/lib/python3.6/site-packages/tornado/httpclient.py\", line 290, in handle_response\nfuture.set_exception(response.error)\nasyncio.base_futures.InvalidStateError: invalid state\nThe problem looks like it's here in httpclient.py:\n        def handle_response(response):\n            if raise_error and response.error:\n                if isinstance(response.error, HTTPError):\n                    response.error.response = response\n                future.set_exception(response.error)\n            else:\n                if response.error and not response._error_is_response_code:\n                    warnings.warn(\"raise_error=False will allow '%s' to be raised in the future\" %\n                                  response.error, DeprecationWarning)\n                future_set_result_unless_cancelled(future, response)\n        self.fetch_impl(request, handle_response)\n        return future\nFor results Tornado uses the wrapper future_set_result_unless_cancelled.\nFor exceptions, Tornado just invokes future.set_exception(response.error) which triggers the invalid state error since the future has been cancelled externally:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/httpclient.py#L293\nPerhaps the set_exception() just needs a similar check-if-cancelled wrapper?", "issue_status": "Closed", "issue_reporting_time": "2018-11-21T09:53:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "115": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2539", "issue_id": "#2539", "issue_summary": "RuntimeError: inconsistent AsyncHTTPClient cache", "issue_description": "EFanZh commented on 21 Nov 2018 \u2022\nedited\nTornado version: 5.1.1\nRunning the following code causes RuntimeError: inconsistent AsyncHTTPClient cache\nfrom tornado import httpclient\n\n\ndef f():\n    pass\n\n\nc = httpclient.HTTPClient()\nError log:\nException ignored in: <bound method HTTPClient.__del__ of <tornado.httpclient.HTTPClient object at 0x7fef4def84a8>>\nTraceback (most recent call last):\n  File \"/\u2588\u2588\u2588\u2588/lib/python3.5/site-packages/tornado/httpclient.py\", line 99, in __del__\n  File \"/\u2588\u2588\u2588\u2588/lib/python3.5/site-packages/tornado/httpclient.py\", line 104, in close\n  File \"/\u2588\u2588\u2588\u2588/lib/python3.5/site-packages/tornado/simple_httpclient.py\", line 139, in close\n  File \"/\u2588\u2588\u2588\u2588/lib/python3.5/site-packages/tornado/httpclient.py\", line 220, in close\nRuntimeError: inconsistent AsyncHTTPClient cache\nSince the error is ignored, it may be harmless to the program. But the error message may confuse some new users, so I think it should be fixed.", "issue_status": "Closed", "issue_reporting_time": "2018-11-21T09:16:11Z", "fixed_by": "#2544", "pull_request_summary": "httpclient: Fix warning logged by sync HTTPClient destructor", "pull_request_description": "Member\nbdarnell commented on 2 Dec 2018\nIf an HTTPClient is closed from its destructor instead of an explicit\nclose() call, it sometimes logs an \"inconsistent AsyncHTTPClient\ncache\" error because the weakrefs appear to get cleaned up in an\nunexpected order. Relax the checks in AsyncHTTPClient.close to allow\nfor a missing value in the instance cache.\nFixes #2539", "pull_request_status": "Merged", "issue_fixed_time": "2018-12-03T00:43:53Z", "files_changed": [["4", ".travis.yml"], ["9", "tornado/httpclient.py"], ["33", "tornado/test/httpclient_test.py"]]}, "116": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2538", "issue_id": "#2538", "issue_summary": "Tornado websocket proxy", "issue_description": "ndvbd commented on 20 Nov 2018\nCan't seem to find in the docs or in the code the right way to implement a simple tornado websocket proxy, that just creates a very simple server, and:\nOnce a connection is opened (open), connect to the other server\nOnce a message is received (on_message), forward the message to the other server\nI just need a way to do some create_connection with the ability to pass on_message callback.", "issue_status": "Closed", "issue_reporting_time": "2018-11-20T10:39:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "117": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2535", "issue_id": "#2535", "issue_summary": "The main process seems be suspended after running a while", "issue_description": "xulei890817 commented on 15 Nov 2018\nWindows 10\npython 3.6.7\ntornado 5.1.1\n class MainHandler(tornado.web.RequestHandler):\n     def get(self):\n         self.write(500k_size_json_obj)\n\n # build app\n tornado.web.Application([(r\"/\", MainHandler)])\n # start a thread\n t = Thread(target=_print_counter_every_1s, args=())\n t.start()\nuse python requests lib keep getting url \"/\".\nafter running a while,maybe 30 ~ 80 mins.\nThe process seems to be suspended, requests can not get \"/\" any more,and the thread stop print the counter num.", "issue_status": "Closed", "issue_reporting_time": "2018-11-15T12:22:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "118": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2534", "issue_id": "#2534", "issue_summary": "get session gets idle (by timeout) when using tornado_sqlalchemy make_session_factory", "issue_description": "itamarf84 commented on 11 Nov 2018 \u2022\nedited\nWhen creating a connection pool using tornado_sqlalchemy.make_session_factory there is a default timeout of 30 min.\nthis timeout waits for thread notification on the pool, which in case async code is used will block execution for that time (and in extreme scenarios will create a deadlock), and will break the async model.\nprobably need to create some async session factory.\nin order to reproduce define pool_size as 1 an run several concurent request", "issue_status": "Closed", "issue_reporting_time": "2018-11-11T09:17:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "119": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2532", "issue_id": "#2532", "issue_summary": "awaits in async on_message() block receiving more messages (?)", "issue_description": "jonathon-love commented on 5 Nov 2018\nhi,\ni'm basically having this issue: https://www.tornadoweb.org/en/stable/faq.html#why-isn-t-this-example-with-time-sleep-running-in-parallel with websockets.\ninside on_message() i go await asyncio.sleep(5), but for those 5 seconds no more websocket messages are received.\nis this by design? (i appreciate websockets aren't send-respond, so the case for await inside on_message() isn't as strong)\nsorry if i'm overlooking something obvious (i did ponder if it was a quirk of the websocket client queueing requests up, but i don't think that can be the case)\nwith thanks", "issue_status": "Closed", "issue_reporting_time": "2018-11-04T22:56:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "120": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2531", "issue_id": "#2531", "issue_summary": "There is no current event loop in thread 'Thread-5'", "issue_description": "jonathon-love commented on 4 Nov 2018\nhi,\ni have a tornado websocket handler, and in async def on_message(...) i want to call a long running function with loop.run_in_executor(...), so i call asyncio.get_event_loop(), but this throws the exception:\nRuntimeError: There is no current event loop in thread 'Thread-5'.\nbut i don't understand this, because my application is a simple, single-threaded application, and there must be an even loop running for on_message(...) to be called. if i call print(threading.current_thread().name) from on_message(), i get MainThread.\nto begin the io loop in the first place, i just go:\nloop = asyncio.get_event_loop()  # this `.get_event_loop()` works!\n...\nprint(threading.current_thread().name)  # this also outputs `MainThread`\n...\nloop.run_forever()\ni've read up on other issues like this, but they all seem to do unusual things with threads, like this one.\nwhat am i doing wrong?\nwith thanks", "issue_status": "Closed", "issue_reporting_time": "2018-11-04T09:19:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "121": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2525", "issue_id": "#2525", "issue_summary": "RuntimeError: Cannot share PollIOLoops across processes", "issue_description": "light9009 commented on 31 Oct 2018 \u2022\nedited\nMulti process startup tornado error, why\uff1f centos 7 ,py2.7, tornado 5.0.2\nFile \"/usr/lib64/python2.7/site-packages/tornado/ioloop.py\", line 930, in start\nraise RuntimeError(\"Cannot share PollIOLoops across processes\")\nRuntimeError: Cannot share PollIOLoops across processes", "issue_status": "Closed", "issue_reporting_time": "2018-10-31T11:31:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "122": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2523", "issue_id": "#2523", "issue_summary": "'Restarting' tornado keeps old application/handlers active", "issue_description": "Contributor\nmaartenbreddels commented on 30 Oct 2018\nThanks for the awesome library, have been using it for years now, and I can usually solve issues with all the resources around, but now I'm stuck.\nBased on this answer, I expected this snippet:\n#! /usr/bin/env python\n\nimport tornado.ioloop\nimport tornado.web\nimport time\nimport datetime\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world!\\n\")\n\nclass MainHandler2(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world2!\\n\")\n\ndef start_app(*args, **kwargs):\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    server = application.listen(7888)\n    print(\"Starting app\")\n    return server\n\ndef start_app2(*args, **kwargs):\n    application = tornado.web.Application([\n        (r\"/\", MainHandler2),\n    ])\n    server = application.listen(7888)\n    print(\"Starting app2\")\n    return server\n\ndef stop_tornado():\n    ioloop = tornado.ioloop.IOLoop.current()\n    ioloop.add_callback(ioloop.stop)\n    print(\"Asked Tornado to exit\")\n\ndef main():\n    server = start_app()\n    tornado.ioloop.IOLoop.current().add_timeout(\n        datetime.timedelta(seconds=10),\n        stop_tornado)\n    tornado.ioloop.IOLoop.current().start()\n    print(\"Tornado finished\")\n    server.stop()\n\n    # Starting over\n    start_app2()\n    tornado.ioloop.IOLoop.current().start()\nmain()\nTo answer 'Hello, world!' for ~10 seconds, and after printing 'Starting app2' to answer 'Hello world2!'. However, it keeps the old handlers active it seems. Is this supported, maybe a bug, and is there a workaround?\nI need this because i start a server to make the browser do something, then I close the server, and later on, an external library might start the server again. Since it hosts files from a tempdir, I see 404s (since the files are deleted). I think I've reduced my issue to this example here.", "issue_status": "Closed", "issue_reporting_time": "2018-10-30T15:13:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "123": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2521", "issue_id": "#2521", "issue_summary": "StaticFileHandler breaks with negative range", "issue_description": "dvenza commented on 30 Oct 2018\nWhen passing a negative range (example: bytes=-30720) in the Range header, but the requested file is smaller than the range requested, StaticFileHandler will try to seek to a negative position in the file and get an error from the operating system (linux in my case).\nTraceback (most recent call last):\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 1592, in _execute\n    result = yield result\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n    raise self._exception\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/gen.py\", line 326, in wrapper\n    yielded = next(result)\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 2525, in get\n    for chunk in content:\n  File \"/home/venzano/venvs/zoe-2018.08/lib/python3.5/site-packages/tornado/web.py\", line 2680, in get_content\n    file.seek(start)\nOSError: [Errno 22] Invalid argument\nThe code (file web.py around line 2494 in Tornado 5.1.1):\n            if start is not None and start < 0:\n                start += size\nis not sufficient, it should check if size is smaller than start and in that case just set start=size.", "issue_status": "Closed", "issue_reporting_time": "2018-10-30T11:46:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "124": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2516", "issue_id": "#2516", "issue_summary": "Connection closed while trying to send HTTP 102 in tests", "issue_description": "Contributor\nWouldYouKindly commented on 17 Oct 2018\nHi!\nI have a code like this\nfrom tornado.web import RequestHandler, Application\nfrom tornado.testing import AsyncHTTPTestCase\n\n\nclass Handler(RequestHandler):\n    def get(self):\n        self.set_status(102)\n\n\nclass TestHandler(AsyncHTTPTestCase):\n    def get_app(self):\n        return Application(handlers=[('/', Handler)])\n\n    def test(self):\n        result = self.fetch('/')\n        self.assertEqual(102, result.code)\nWhen I run tests, I get AssertionError: 102 != 599\nWhen I do result = self.fetch('/', raise_error=True), I get\nTraceback (most recent call last):\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/simple_httpclient.py\", line 424, in _write_body\n    yield self.connection.read_response(self)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/gen.py\", line 1141, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/http1connection.py\", line 212, in _read_message\n    yield self._read_message(delegate)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/gen.py\", line 326, in wrapper\n    yielded = next(result)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/http1connection.py\", line 160, in _read_message\n    max_bytes=self.params.max_header_size)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/iostream.py\", line 357, in read_until_regex\n    self._try_inline_read()\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/iostream.py\", line 911, in _try_inline_read\n    self._check_closed()\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/iostream.py\", line 1112, in _check_closed\n    raise StreamClosedError(real_error=self.error)\ntornado.iostream.StreamClosedError: Stream is closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/testing.py\", line 125, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/Users/ptz/stuff/test_t.py\", line 16, in test\n    result = self.fetch('/', raise_error=True)\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/testing.py\", line 423, in fetch\n    timeout=get_async_test_timeout())\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/ioloop.py\", line 576, in run_sync\n    return future_cell[0].result()\n  File \"/Users/ptz/.virtualenvs/e/lib/python3.7/site-packages/tornado/simple_httpclient.py\", line 474, in on_connection_close\n    raise HTTPStreamClosedError(message)\ntornado.simple_httpclient.HTTPStreamClosedError: Connection closed\nThis same happens with some other HTTP codes as well.\nIf I run this server, everything is okay:\n$ http http://localhost/\nHTTP/1.1 102 Processing\nDate: Wed, 17 Oct 2018 17:52:19 GMT\nServer: TornadoServer/5.1.1\nAm I doing something wrong?", "issue_status": "Closed", "issue_reporting_time": "2018-10-17T18:00:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "125": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2513", "issue_id": "#2513", "issue_summary": "Back-porting of security updates", "issue_description": "b71729 commented on 4 Oct 2018\nHi all,\nIs there an official duration that each release will have security updates back-ported to?\nI ask since the HEAD of master has had code merged that drops compatibility with Python 2.7.", "issue_status": "Closed", "issue_reporting_time": "2018-10-04T15:13:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "126": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2510", "issue_id": "#2510", "issue_summary": "Little help to identify the source of a bug?", "issue_description": "P-EB commented on 30 Sep 2018 \u2022\nedited\nHi,\nI'm trying to have vcr.py tests pass in python3.7 (python3.6 and earlier are going fine), and during tests with tornado 5.1.1 (from debian), I get this error :\n=================================== FAILURES ===================================\n_________________ test_tornado_exception_can_be_caught[simple] _________________\n\nget_client = <function get_client.<locals>.<lambda> at 0x7f5f24da02f0>\n\n    @pytest.mark.gen_test\n    @vcr.use_cassette(path_transformer=vcr.default_vcr.ensure_suffix('.yaml'))\n    def test_tornado_exception_can_be_caught(get_client):\n        try:\n            yield get(get_client(), 'http://httpbin.org/status/500')\n        except http.HTTPError as e:\n            assert e.code == 500\n    \n        try:\n>           yield get(get_client(), 'http://httpbin.org/status/404')\n\ntests/integration/test_tornado.py:337: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <vcr.cassette.CassetteContextDecorator object at 0x7f5f256781d0>\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7f5f256e69d8>\n\n    def _handle_generator(self, fn):\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\n            duration of the generator.\n            \"\"\"\n        with self as cassette:\n            coroutine = fn(cassette)\n            # We don't need to catch StopIteration. The caller (Tornado's\n            # gen.coroutine, for example) will handle that.\n            to_yield = next(coroutine)\n            while True:\n                try:\n>                   to_send = yield to_yield\n\nvcr/cassette.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <tornado.gen.Runner object at 0x7f5f256728d0>\n\n    def run(self):\n        \"\"\"Starts or resumes the generator, running until it reaches a\n            yield point that is not ready.\n            \"\"\"\n        if self.running or self.finished:\n            return\n        try:\n            self.running = True\n            while True:\n                future = self.future\n                if not future.done():\n                    return\n                self.future = None\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    exc_info = None\n    \n                    try:\n>                       value = future.result()\nE                       tornado.httpclient.HTTPClientError: HTTP 404: NOT FOUND\n\n/usr/lib/python3/dist-packages/tornado/gen.py:1133: HTTPClientError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <vcr.cassette.CassetteContextDecorator object at 0x7f5f256781d0>\nfn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7f5f256e69d8>\n\n    def _handle_generator(self, fn):\n        \"\"\"Wraps a generator so that we're inside the cassette context for the\n            duration of the generator.\n            \"\"\"\n        with self as cassette:\n            coroutine = fn(cassette)\n            # We don't need to catch StopIteration. The caller (Tornado's\n            # gen.coroutine, for example) will handle that.\n            to_yield = next(coroutine)\n            while True:\n                try:\n                    to_send = yield to_yield\n                except Exception:\n>                   to_yield = coroutine.throw(*sys.exc_info())\nE                   StopIteration\n\nvcr/cassette.py:139: StopIteration\n\nThe above exception was the direct cause of the following exception:\n\npyfuncitem = <Function 'test_tornado_exception_can_be_caught[simple]'>\n\n    @pytest.mark.tryfirst\n    def pytest_pyfunc_call(pyfuncitem):\n        gen_test_mark = pyfuncitem.keywords.get('gen_test')\n        if gen_test_mark:\n            io_loop = pyfuncitem.funcargs.get('io_loop')\n            run_sync = gen_test_mark.kwargs.get('run_sync', True)\n    \n            funcargs = dict((arg, pyfuncitem.funcargs[arg])\n                            for arg in _argnames(pyfuncitem.obj))\n            if iscoroutinefunction(pyfuncitem.obj):\n                coroutine = pyfuncitem.obj\n                future = tornado.gen.convert_yielded(coroutine(**funcargs))\n            else:\n                coroutine = tornado.gen.coroutine(pyfuncitem.obj)\n                future = coroutine(**funcargs)\n            if run_sync:\n>               io_loop.run_sync(lambda: future, timeout=_timeout(pyfuncitem))\n\n/usr/lib/python3/dist-packages/pytest_tornado/plugin.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3/dist-packages/tornado/ioloop.py:576: in run_sync\n    return future_cell[0].result()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <tornado.gen.Runner object at 0x7f5f256728d0>\n\n    def run(self):\n        \"\"\"Starts or resumes the generator, running until it reaches a\n            yield point that is not ready.\n            \"\"\"\n        if self.running or self.finished:\n            return\n        try:\n            self.running = True\n            while True:\n                future = self.future\n                if not future.done():\n                    return\n                self.future = None\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    exc_info = None\n    \n                    try:\n                        value = future.result()\n                    except Exception:\n                        self.had_exception = True\n                        exc_info = sys.exc_info()\n                    future = None\n    \n                    if exc_info is not None:\n                        try:\n>                           yielded = self.gen.throw(*exc_info)\nE                           RuntimeError: generator raised StopIteration\n\n/usr/lib/python3/dist-packages/tornado/gen.py:1141: RuntimeError\nI submitted an issue here : kevin1024/vcrpy#396 but I'm not convinced the change of behaviour isn't due to tornado updates. My guess would be that the exception handling behaves differently before 3.7.\nDoes anyone have a little time to help me find the issue?\nThanks in advance! :)", "issue_status": "Closed", "issue_reporting_time": "2018-09-29T23:52:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "127": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2508", "issue_id": "#2508", "issue_summary": "Allow AsyncHTTPClient to call configure more than once", "issue_description": "gaheinrichs commented on 26 Sep 2018\nAt the start of my application this gets called:\nAsyncHTTPClient.configure(CurlAsyncHTTPClient, max_clients=1000, defaults=defaults)\nThe defaults can change while the app is still running. I was not able to re configure AsyncHTTPClient without restarting the app.\nIs there a way to do this?\nI am currently calling this line below as a work around:\ndelattr(AsyncHTTPClient, '_async_client_dict_' + AsyncHTTPClient.__name__)\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2018-09-25T22:40:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "128": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2505", "issue_id": "#2505", "issue_summary": "AsyncHTTPClient grows process thread count with no cleanup", "issue_description": "willhak commented on 20 Sep 2018 \u2022\nedited\nUsing Tornado version 5.0 + (python 2.7 and 3.7) we've noticed that the AsyncHTTPClient causes the number of threads used by the Python process to grow and these don't seem to get cleaned up. The example below is trivial, but we use tornado in long running processes that are making hundreds of async fetches an hour and we find that we can quickly run into OS thread caps This same behaviour is not observed in Tornado versions 4.5.x. Should we expect threads created by the async client to be cleaned up once a request has completed?\nfrom tornado import httpclient, ioloop, gen\nimport threading\n\ntarget = \"http://google.com\"\nclient = httpclient.AsyncHTTPClient()\n\ndef print_thread_count():\n        print (\"There are {} threads\".format(len(threading.enumerate())))\n\nasync def get():\n        for i in range(10):\n                await client.fetch(target, method=\"GET\")\n                print_thread_count()\n\nprint_thread_count()\nprint (\"Starting fetch...\")\nioloop.IOLoop.current().run_sync(get)\nprint (\"Done fetching...\")\nprint_thread_count()\nOutput:\npython3 test_tornado.py\nThere are 1 threads\nStarting fetch...\nThere are 3 threads\nThere are 5 threads\nThere are 7 threads\nThere are 9 threads\nThere are 11 threads\nThere are 13 threads\nThere are 15 threads\nThere are 17 threads\nThere are 19 threads\nThere are 21 threads\nDone fetching...\nThere are 21 threads", "issue_status": "Closed", "issue_reporting_time": "2018-09-19T19:40:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "129": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2504", "issue_id": "#2504", "issue_summary": "TLS-enabled server logs spurious errors on TCP connections", "issue_description": "davidblewett commented on 19 Sep 2018 \u2022\nedited\nWe are terminating TLS in Tornado so that we can do client certificate validation. Tornado is then proxied to via an AWS ELB that is doing TCP-level health checks of the service. Because these connections do not complete the handshake, I see a lot of logs like this:\ndragnet-56f746f99b-v9c8n dragnet 2018-09-19 14:13:13,497 1 ERROR   [asyncio:1591] Exception in callback None()                               \ndragnet-56f746f99b-v9c8n dragnet handle: <Handle cancelled>                                                                              \ndragnet-56f746f99b-v9c8n dragnet Traceback (most recent call last):                                                                       \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/asyncio/events.py\", line 88, in _run                                                                                                                                                               \ndragnet-56f746f99b-v9c8n dragnet     self._context.run(self._callback, *self._args)                                                  \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/site-packages/tornado/platform/asyncio.py\", line 122, in _handle_events\ndragnet-56f746f99b-v9c8n dragnet     handler_func(fileobj, events)                                                                        \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\ndragnet-56f746f99b-v9c8n dragnet     return fn(*args, **kwargs)                                                                           \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/site-packages/tornado/iostream.py\", line 709, in _handle_events    \ndragnet-56f746f99b-v9c8n dragnet     self._handle_read()                                                                                 \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/site-packages/tornado/iostream.py\", line 1581, in _handle_read          \ndragnet-56f746f99b-v9c8n dragnet     self._do_ssl_handshake()                                                                        \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/site-packages/tornado/iostream.py\", line 1501, in _do_ssl_handshake    \ndragnet-56f746f99b-v9c8n dragnet     self.socket.do_handshake()                                                                        \ndragnet-56f746f99b-v9c8n dragnet   File \"/usr/local/lib/python3.7/ssl.py\", line 1108, in do_handshake                                    \ndragnet-56f746f99b-v9c8n dragnet     self._sslobj.do_handshake()                                                                     \ndragnet-56f746f99b-v9c8n dragnet OSError: [Errno 0] Error\nI've tested on Python 3.7 and Python 3.6, Tornado 5.1.\nSimple test case:\nimport ssl\nimport tornado.web\nssl_ctx = ssl.create_default_context()\nssl_ctx.check_hostname = False\napp = tornado.web.Application()\napp.listen(8888, ssl_options=ssl_ctx)\ntornado.ioloop.IOLoop.current().start()\nThen sleep 0.1 | telnet 127.0.0.1 8888 or nc -vz 127.0.0.1 8888 (btw, the check_hostname is to prevent this traceback; not sure how to set server_hostname correctly in this context):\nERROR:asyncio:Exception in callback BaseAsyncIOLoop._handle_events(12, 1)\nhandle: <Handle BaseAsyncIOLoop._handle_events(12, 1)>\nTraceback (most recent call last):\n  File \"/usr/lib/python3.6/asyncio/events.py\", line 145, in _run\n    self._callback(*self._args)\n  File \"/home/dblewett/.virtualenvs/dragnet-0UOjSQS6/lib/python3.6/site-packages/tornado/platform/asyncio.py\", line 122, in _handle_events\n    handler_func(fileobj, events)\n  File \"/home/dblewett/.virtualenvs/dragnet-0UOjSQS6/lib/python3.6/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/dblewett/.virtualenvs/dragnet-0UOjSQS6/lib/python3.6/site-packages/tornado/netutil.py\", line 262, in accept_handler\n    callback(connection, address)\n  File \"/home/dblewett/.virtualenvs/dragnet-0UOjSQS6/lib/python3.6/site-packages/tornado/tcpserver.py\", line 263, in _handle_connection\n    do_handshake_on_connect=False)\n  File \"/home/dblewett/.virtualenvs/dragnet-0UOjSQS6/lib/python3.6/site-packages/tornado/netutil.py\", line 573, in ssl_wrap_socket\n    **kwargs)\n  File \"/usr/lib/python3.6/ssl.py\", line 407, in wrap_socket\n    _context=self, _session=session)\n  File \"/usr/lib/python3.6/ssl.py\", line 770, in __init__\n    raise ValueError(\"check_hostname requires server_hostname\")\nValueError: check_hostname requires server_hostname", "issue_status": "Closed", "issue_reporting_time": "2018-09-19T14:53:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "130": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2503", "issue_id": "#2503", "issue_summary": "logging file handler set encoding is not supported.", "issue_description": "wanghongzhou commented on 19 Sep 2018\nIn the enable_pretty_logging function, create RotatingFileHandler or TimedRotatingFileHandler cannot be set encoding", "issue_status": "Closed", "issue_reporting_time": "2018-09-19T09:58:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "131": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2502", "issue_id": "#2502", "issue_summary": "Retry error causing exception during status_code checking.", "issue_description": "javajenks commented on 18 Sep 2018\nPython Version: 3.7\nTornado Version: 5.1\nPlatform: Docker (python3.7 base image)\nSomewhere along the line, self._status_code is being set to the value of MaxRetryError, causing a TypeError. Havent looked into this in detail yet.\n[2018-09-18 08:32:15 ERROR-MYAPI_4-(MaxRetryError('HTTPSConnectionPool(host=\\'xxxxxxxx.com\\', port=443): Max retries exceeded with url: /yyyyyyyyy/read (Caused by SSLError(SSLError(\"bad handshake: SysCallError(-1, \\'Unexpected EOF\\')\")))'),)\n2018-09-18 08:32:15 ERROR-tornado.application-Uncaught exception GET /message (172.17.0.3)\nHTTPServerRequest(protocol='http', host='zzzzzz:7998', method='GET', uri='/message', version='HTTP/1.1', remote_ip='172.17.0.3')\nTraceback (most recent call last):\n  File \"/opt/myapi/lib/python3.7/site-packages/tornado/web.py\", line 1594, in _execute\n    self.finish()\n  File \"/opt/myapi/lib/python3.7/site-packages/tornado/web.py\", line 1038, in finish\n    (self._status_code >= 100 and self._status_code < 200)):\nTypeError: '>=' not supported between instances of 'MaxRetryError' and 'int'](url)", "issue_status": "Closed", "issue_reporting_time": "2018-09-18T13:38:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "132": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2501", "issue_id": "#2501", "issue_summary": "Web server with tornado 4.5.3 run in docker is blocked\uff0c docker image is based on Python3.6.5", "issue_description": "baby-care commented on 18 Sep 2018 \u2022\nedited\nI build a image base on Python3.6.5\uff0cand install tornado 4.5.3. My server receive http request with post and call other http service with IOLoop add_callback\nI use Apache Benchmark (ab\uff09test with 2000 requests, 100 users. Most of the request are not returned immediately and timeout, and server looks like blocked.\nBut run the server on the machine not in docker container, Or update tornado to version 5.x run in container that's fine.", "issue_status": "Closed", "issue_reporting_time": "2018-09-18T09:26:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "133": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2493", "issue_id": "#2493", "issue_summary": "on tornado 5.1 run_in_executor params error", "issue_description": "lau-jay commented on 15 Sep 2018\nUser guide show below demo:\nasync def call_blocking():\n    await IOLoop.current().run_in_executor(blocking_func, args)\nIn fact, this params is wrong, like this you will give blocking_func to executor param.\nI'm not good idea fix it.\njust using like this:\nasync def call_blocking():\n    await IOLoop.current().run_in_executor(None, blocking_func, args)\nto using default executor", "issue_status": "Closed", "issue_reporting_time": "2018-09-15T03:27:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "134": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2491", "issue_id": "#2491", "issue_summary": "Chat Demo", "issue_description": "ghost commented on 12 Sep 2018 \u2022\nedited by ghost\nUsing sample code the app behaves odd as this occurs in web inspector:\n`\n\n<title style=\"display: block;\">Title</title> <title style=\"display: block;\">Title</title> <title style=\"display: block;\">Title</title> <title style=\"display: block;\">Title</title> <title style=\"display: block;\">Title</title> <title style=\"display: block;\">Title</title>\n`\nEssentially the word 'Title' is displayed instead of the input text.", "issue_status": "Closed", "issue_reporting_time": "2018-09-12T09:51:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "135": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2489", "issue_id": "#2489", "issue_summary": "problem when creating multi-proceccing service which calling so-lib file", "issue_description": "thomas010 commented on 9 Sep 2018\nI can't creat multi-proceccing service with tornado in which my request handler loads shared library (so lib)\u3002problem show infomation as following and keep staying there.\nWARNING:tornado.general:child 1 (pid 38338) killed by signal 11, restarting\nI have tried in two ways, but both come with the problem as described before.\nsockets = tornado.netutil.bind_sockets(8890)\ntornado.process.fork_processes(0)\nserver = tornado.httpserver.HTTPServer(app)\nserver.add_sockets(sockets)\ntornado.ioloop.IOLoop.instance().start()\nand the second\napp = tornado.web.Application(handlers=[\n(r\"/nlu\", NluHandler),\n], autoreload=False, debug=False)\nhttp_server = tornado.httpserver.HTTPServer(app)\nhttp_server.bind(8890)\nhttp_server.start(2)\ntornado.ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2018-09-09T09:51:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "136": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2488", "issue_id": "#2488", "issue_summary": "Unable to connect to the Tornado SSL based server from Tornado Client", "issue_description": "Waseem-farooqui commented on 8 Sep 2018\nI am new to the ssl and stuff, I have generated the self signed certificates using openssl.\nopenssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 3650 -out certificate.pem\nWhere Server has the following Code.\nif __name__ == \"__main__\":\n    context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n    context.load_cert_chain(\"/home/rootkit/ssl/certificate.pem\",\n                            \"/home/rootkit/ssl/key.pem\")\n\n    http_server = tornado.httpserver.HTTPServer(Application(), ssl_options=context)\n    #\n    # http_server = tornado.httpserver.HTTPServer(Application(), ssl_options={\n    #     'certfile': '/home/rootkit/ssl/certificate.pem',\n    #     'keyfile': '/home/rootkit/ssl/key.pem',\n    # })\n    http_server.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nWhen I access the url from chrome it just give the exception because it is not signed by any authority so I proceed it as unsafe.\nBut if I see the traffic via wireshark it shows the encrypted traffic.\nBut when I tried to connect with the Tornado Client it throws the following error.\n    WARNING:tornado.general:SSL Error on 6 ('127.0.0.1', 8888): [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)\n    ERROR:tornado.application:Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0xb72e514c>, <Task finished coro=<check_status() done, defined at /home/rootkit/PycharmProjects/websocketserver/file_upload/websocketclient.py:82> exception=SSLError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)')>)\n    Traceback (most recent call last):\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/ioloop.py\", line 758, in _run_callback\n        ret = callback()\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/ioloop.py\", line 779, in _discard_future_result\n        future.result()\n      File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n        raise self._exception\n      File \"/usr/lib/python3.5/asyncio/tasks.py\", line 241, in _step\n        result = coro.throw(exc)\n      File \"/home/rootkit/PycharmProjects/websocketserver/file_upload/websocketclient.py\", line 89, in check_status\n        param = await client.fetch(request)\n      File \"/usr/lib/python3.5/asyncio/futures.py\", line 361, in __iter__\n        yield self  # This tells Task to wait for completion.\n      File \"/usr/lib/python3.5/asyncio/tasks.py\", line 296, in _wakeup\n        future.result()\n      File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n        raise self._exception\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/simple_httpclient.py\", line 272, in run\n        max_buffer_size=self.max_buffer_size)\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/gen.py\", line 1133, in run\n        value = future.result()\n      File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n        raise self._exception\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/gen.py\", line 1141, in run\n        yielded = self.gen.throw(*exc_info)\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/tcpclient.py\", line 242, in connect\n        server_hostname=host)\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/gen.py\", line 1133, in run\n        value = future.result()\n      File \"/usr/lib/python3.5/asyncio/futures.py\", line 274, in result\n        raise self._exception\n      File \"/home/rootkit/.local/lib/python3.5/site-packages/tornado/iostream.py\", line 1501, in _do_ssl_handshake\n        self.socket.do_handshake()\n      File \"/usr/lib/python3.5/ssl.py\", line 988, in do_handshake\n        self._sslobj.do_handshake()\n      File \"/usr/lib/python3.5/ssl.py\", line 633, in do_handshake\n        self._sslobj.do_handshake()\n    ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)\nHere is the Client code.\nasync def check_status():\n    url = \"https://127.0.0.1:8888/\"\n    request = httpclient.HTTPRequest(url=url,\n                                        method=\"GET\",\n                                        client_key=\"/home/rootkit/client.key\",\n                                        client_cert=\"/home/rootkit/ssl/client.pem\")\n    client = httpclient.AsyncHTTPClient()\n    param = await client.fetch(request)\n    print(param)\nI have generated the client certificates using the came command I used for the server.\nWhat could be the possible issue.\nWhat I am missing ?", "issue_status": "Closed", "issue_reporting_time": "2018-09-08T17:32:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "137": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2487", "issue_id": "#2487", "issue_summary": "Unable to control headers in StaticFileHandler during error response", "issue_description": "ecbftw commented on 7 Sep 2018 \u2022\nedited\nI don't see a way to control HTTP headers (e.g. removing the Server header, adding security headers) when using the StaticFileHandler when the StaticFileHandler returns an error (e.g. 404s). Here's my current subclass:\ncsp = \"script-src 'self'; connect-src 'self'; style-src 'self' 'unsafe-inline'; frame-ancestors 'self'\"\n\nclass StaticHandler(tornado.web.StaticFileHandler):\n    def set_default_headers(self):\n        self.clear_header('Server')\n        self.set_header('Content-Security-Policy', csp)\n        self.set_header('X-Content-Security-Policy', csp)\n\n    def set_extra_headers(self, path):\n        self.set_default_headers()\n\n    def validate_absolute_path(self, root, absolute_path):\n        self.set_default_headers()\n        return super().validate_absolute_path(root, absolute_path)\nStaticFileHandler does not appear to honor overrides of write_error as RequestHandler does, and somehow overriding validate_absolute_path (as above) isn't working either. The HTTP response headers I'm getting on a 404 are unchanged:\nHTTP/1.1 404 Not Found\nServer: TornadoServer/5.0.2\nContent-Type: text/html; charset=UTF-8\nDate: Fri, 07 Sep 2018 14:19:58 GMT\nContent-Length: 69\nConnection: close\nTo be clear, my desired header changes work just fine on normal 200 responses, just not on errors. What am I missing?", "issue_status": "Closed", "issue_reporting_time": "2018-09-07T14:28:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "138": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2486", "issue_id": "#2486", "issue_summary": "Sending fast causes the write buffer queueing the reqs and not sending it via IOStream", "issue_description": "mabdelndi commented on 5 Sep 2018\nHi,\nim facing a problem when trying to send a burst of requests via IOStream during a specific amount of time. For some reason the buffer is writing the reqs but the reqs are not processed and sent, and im wondering if theres any limit on the req/s that im not aware about.\nBR", "issue_status": "Closed", "issue_reporting_time": "2018-09-05T10:06:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "139": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2484", "issue_id": "#2484", "issue_summary": "RuntimeError: There is no current event loop in thread 'Thread-4'.", "issue_description": "garg10may commented on 28 Aug 2018 \u2022\nedited\nI am calling below from different threads. It was working all fine, until I changed from\n4.5.1 to 5.1\ntornado.ioloop.IOLoop.current().add_callback( callback=lambda : socketObject.send(simplejson.dumps(msg)))\nDo things need to be done differently?", "issue_status": "Closed", "issue_reporting_time": "2018-08-28T12:00:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "140": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2483", "issue_id": "#2483", "issue_summary": "TwitterMixin.authorize_redirect hangs on network failure", "issue_description": "MartinAltmayer commented on 27 Aug 2018\nWhen TwitterMixin.authorize_redirect fails to connect to Twitter, the future returned by this method is never resolved. (the network error is raised in some callback, but never reaches the future).\nCode example (to receive a network error, you can switch your network off, but the issue is demonstrated even without connection problems due to the bogus twitter consumer data):\nimport tornado\nimport tornado.web\nimport tornado.auth\n\n\nclass TwitterLoginHandler(\n    tornado.web.RequestHandler,\n    tornado.auth.TwitterMixin\n):\n    async def get(self):\n        if self.get_argument(\"oauth_token\", None):\n            user = await self.get_authenticated_user()\n        else:\n            try:\n                await self.authorize_redirect()\n                print(\"This line is never reached\")\n            except Exception:\n                print(\"Nor is this line\")\n                \n\ndef make_app():\n    return tornado.web.Application(\n        [(r\"/\", TwitterLoginHandler)],\n        twitter_consumer_key='12341234',\n        twitter_consumer_secret='secret'\n    )\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2018-08-27T07:39:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "141": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2482", "issue_id": "#2482", "issue_summary": "Twitter OAuth does not work", "issue_description": "MartinAltmayer commented on 27 Aug 2018\nSince the upgrade to Tornado 5.1 our Twitter OAuth login does not work anymore. The reason seems to be that OAuthMixin._on_request_token expects a future, but TwitterMixin.authenticate_redirect passes it as callback to http.fetch, which will call it with the fetched response instead of a future (line 799 in auth.py), raising\nException: Could not get request token: 'HTTPResponse' object has no attribute 'result'\nCode example:\nimport tornado\nimport tornado.web\nimport tornado.auth\n\n\nclass TwitterLoginHandler(\n    tornado.web.RequestHandler,\n    tornado.auth.TwitterMixin\n):\n    async def get(self):\n        if self.get_argument(\"oauth_token\", None):\n            user = await self.get_authenticated_user()\n        else:\n            await self.authenticate_redirect()\n                \n\ndef make_app():\n    return tornado.web.Application(\n        [(r\"/\", TwitterLoginHandler)],\n        twitter_consumer_key='12341234',\n        twitter_consumer_secret='secret'\n    )\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2018-08-27T07:29:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "142": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2481", "issue_id": "#2481", "issue_summary": "\u8bf7\u6559\u4e0b\uff1atornado.web.RequestHandler\u91cc\u7684\u90a3\u4e2aapplication\u7684\u5b9e\u4f8b\u662f\u5728\u4ec0\u4e48\u65f6\u5019\u4f20\u9012\u7684\uff1f", "issue_description": "vperson commented on 26 Aug 2018\n\u6700\u8fd1\u5728\u5b66\u4e60Tornado\uff0c \u770b\u81ea\u5e26\u8bf4\u660e\u5b9e\u4f8b\u53d1\u73b0\uff0c BaseHandler\u5e76\u6ca1\u6709\u663e\u793a\u7684\u8c03\u7528\u7236\u7c7b\u7684__init__\u65b9\u6cd5\uff0c\u4f46\u662f\u5374\u4f7f\u7528\u4e86self.application.db \u8fd9\u4e2a\u53d8\u91cf\u3002\u7136\u540e\u53bb\u770b\u6e90\u4ee3\u7801\u53d1\u73b0RequestHandler\u91cc\u6709\u4e2aapplication\u53c2\u6570\uff0c\u4f46\u662f\u4e00\u76f4\u6ca1\u770b\u5230\u5728\u54ea\u91cc\u8c03\u7528\u3002\nclass Application(tornado.web.Application):\n    def __init__(self, *args, **kwargs):\n        super(Application, self).__init__(*args, **kwargs)\n        self.db = torndb.Connection(**config.mysql_options)\n        self.redis = redis.StrictRedis(**config.redis_options)\n\n\ndef main():\n    options.log_file_prefix = config.log_path\n    options.logging = config.log_level\n    tornado.options.parse_command_line()\n    app = Application(\n        urls,\n        **config.settings\n    )\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\nif __name__ == \"__main__\":\n    main()\n\u5728\u6e90\u7801\u4e2d\u5e76\u6ca1\u6709\u627e\u5230RequestHandler\u548cApplication\u7684\u8c03\u7528\u5173\u7cfb\uff0c\u4f46\u662f\u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u5374\u53ef\u4ee5\u5728\u5b50\u7c7b\u4e2d\u76f4\u63a5\u8c03\u7528self.application.db\nclass BaseHandler(RequestHandler):\n    \"\"\"\u81ea\u5b9a\u4e49\u57fa\u7c7b\"\"\"\n    @property\n    def db(self):\n        \"\"\"\u4f5c\u4e3aRequestHandler\u5bf9\u8c61\u7684db\u5c5e\u6027\"\"\"\n        return self.application.db\n\n    @property\n    def redis(self):\n        \"\"\"\u4f5c\u4e3aRequestHandler\u5bf9\u8c61\u7684redis\u5c5e\u6027\"\"\"\n        return self.application.redis", "issue_status": "Closed", "issue_reporting_time": "2018-08-26T14:28:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "143": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2480", "issue_id": "#2480", "issue_summary": "Two messages getting appended", "issue_description": "garg10may commented on 26 Aug 2018 \u2022\nedited\nI have seen this multiple times, sometimes tornado appends two messages being sent together.\nHeartBeat gets appended (Notice 'h' at the end of quote) to the quote and JSON fails to parse.\n`a[\"[256, 1, \\\"NSECM\\\", \\\"\\\", \\\"\\\", 3351, 0, 485432, 198936872.48, \\\"l\\\", \\\"+\\\", \\\"\\\", \\\"\\\", 5, 514.5, 35, 0, 0, 514.0, 513.7, 519.25, 512.1, 245467, 319739, 452.2, 552.6, 516.14, 0, 0, 0, 0, 0, 5, 5, [514.45, 514.4, 514.35, 514.3, 514.25], [], [55, 216, 471, 450, 629], [], [514.5, 514.65, 514.7, 514.75, 514.8], [], [6, 44, 87, 1233, 291], []]\"]h`\n\n`Error : Uncaught SyntaxError: Unexpected token h in JSON at position 345|URL : https://manik.walle.internal.utradesolutions.com/|Line Number : 1|Client ID : MANIK5|Time : Sun Aug 26 2018 12:46:43`\nSimilarly I have many times other messages being sent been binded together. Why is tornado doing so?\na[\"PONG\"]a[\"DATE 2018-04-350477723\"]\nHow to avoid this?", "issue_status": "Closed", "issue_reporting_time": "2018-08-26T08:06:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "144": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2479", "issue_id": "#2479", "issue_summary": "assert data.endswith(b'\\x00\\x00\\xff\\xff')", "issue_description": "garg10may commented on 24 Aug 2018 \u2022\nedited\nWe are receiving stocks market data at a high burst rate over UDP connection. It is then relayed to the browser using tornado. However once in a while (once in few hours to few minutes) it fails randomly/unpredictably with the below error.\nThe data is sent to majorly all connected sockets with the tornado.\nNot sure why it is failing.\nERROR:2018-08-24 18:17:01,033:get_broadcast\nTraceback (most recent call last):\n  File \"/release/manik/muTrade-1.0.0-1.7.4.5/web/utrade/WebSocket/get_broadcast.py\", line 321, in _send_msg_to_clients\n    socketConnectionObject.send(smart_str(simplejson.dumps(data)))\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/sockjs/tornado/conn.py\", line 49, in send\n    self.session.send_message(message, binary=binary)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/sockjs/tornado/session.py\", line 322, in send_message\n    self.send_jsonified(proto.json_encode(bytes_to_str(msg)), stats)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/sockjs/tornado/session.py\", line 337, in send_jsonified\n    self.handler.send_pack('a[%s]' % msg)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/sockjs/tornado/transports/websocket.py\", line 86, in send_pack\n    self.write_message(message, binary)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/tornado/websocket.py\", line 252, in write_message\n    return self.ws_connection.write_message(message, binary=binary)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/tornado/websocket.py\", line 783, in write_message\n    message = self._compressor.compress(message)\n  File \"/release/st01/py3Env/lib/python3.6/site-packages/tornado/websocket.py\", line 548, in compress\n    assert data.endswith(b'\\x00\\x00\\xff\\xff')\nAssertionError", "issue_status": "Closed", "issue_reporting_time": "2018-08-24T12:53:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "145": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2478", "issue_id": "#2478", "issue_summary": "How to test websocket latency?", "issue_description": "gangadhars commented on 23 Aug 2018\nI'm new to tornado and would like to know how to calculate the web socket latency to the client. I have seen ping/pong but didn't understand clearly.\nCould anyone give an example of how to calculate the web socket latency?", "issue_status": "Closed", "issue_reporting_time": "2018-08-23T18:23:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "146": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2476", "issue_id": "#2476", "issue_summary": "blog example problem", "issue_description": "tatarqa commented on 20 Aug 2018\nhello I tried to run basic version of tornado and aiopg inspired from your blog example, my full code is here.\nwhen I tried to run the code with tornado.ioloop.IOLoop.current().run_sync(main) it always gets stuck on method async with aiopg.create_pool(dsn) as db: and I was able to stop it only with ctrl+c which produced this traceback:\n^CTraceback (most recent call last): File \"/home/pocitac/vs_projects/whatthehell/bshit.py\", line 42, in <module> tornado.ioloop.IOLoop.current().run_sync(main) File \"/usr/lib/python3/dist-packages/tornado/ioloop.py\", line 453, in run_sync self.start() File \"/usr/lib/python3/dist-packages/tornado/ioloop.py\", line 863, in start event_pairs = self._impl.poll(poll_timeout) KeyboardInterrupt\nAlso when I stop it with ctrl+c, new record apears in postgres log which says '2018-08-20 18:27:24.541 CEST [22236] [unknown]@[unknown] LOG: incomplete startup packet'\nSame thing happend (stuck on method async with aiopg.create_pool(...) as db:) when I use and run blog example code 1:1.\nbut when I run the server with asyncio loop:\nimport tornado.platform.asyncio\n......\nif __name__ == \"__main__\":\n   loop=tornado.platform.asyncio.AsyncIOMainLoop()\n   loop.run_sync(main)\neverything works OK.\nmy python version is following\nPython 3.6.5 (default, Apr 1 2018, 05:46:30) [GCC 7.3.0] on linux\nI know blog example works, cause I tried it on another computer (same python version) without problem, but on this computer, it just does not work.\nDoes anybody have some idea where could be a problem?\nAnd many thanks for your great work at this project.", "issue_status": "Closed", "issue_reporting_time": "2018-08-20T16:34:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "147": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2475", "issue_id": "#2475", "issue_summary": "Bug in TemplateEngine if quoted if else", "issue_description": "nkordulla commented on 17 Aug 2018\nHello,\nThis code\n{% if user.get('sex', '') == str(\"{% if user.get('sex', '') == 1 %}as{% end %}\") %}as{% else %}1{% end %}\nproduces\ntornado.template.ParseError: else outside {'while', 'if', 'for', 'try'} block at :1\nWhy? This should work or?", "issue_status": "Closed", "issue_reporting_time": "2018-08-17T17:18:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "148": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2474", "issue_id": "#2474", "issue_summary": "how to write an Image file into tornado reply", "issue_description": "vkuehn commented on 17 Aug 2018\nI would like to write dynamically genereated Images into a tornado reply. Issue 1922 was similiar and has beenclosed with a hint to stackoverflow. Unfortunatetly such questens (even with bounty) have not been answered\nhttps://stackoverflow.com/questions/51785365/genrerated-image-not-in-tornado-reply\nA working example can be found here with BaseHTTPServer\nhttps://github.com/vkuehn/simple_mjpeg_streamer_http_server/blob/master/mjpg_http_streamer_server/mjpg_streamer_http_server.py\nI used version e.g. Python 3.6.5, Tornado 5.0.2\nas I don't like to mix a tornado solution, hint to documentation etc. is greatly appreciated !", "issue_status": "Closed", "issue_reporting_time": "2018-08-17T14:31:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "149": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2473", "issue_id": "#2473", "issue_summary": "CORS with credentials", "issue_description": "mmoreirasouza commented on 16 Aug 2018\nHey guys.\nPlease, is it possible to use cross-site authentication between two different domains?\nI'm logged in on http://app.example.com and my app needs to consume some data (get and post) from http://api.example.com.\nSo, when the host is equal, it works.\nTornado\n`\nclass BaseRequestHandler(tornado.web.RequestHandler):\ndef set_default_headers(self):\n\n    origin = self.request.headers.get(\"Origin\", None)\n\n    if origin:\n        self.set_header(\"Access-Control-Allow-Origin\", origin)\n        self.set_header('Access-Control-Allow-Credentials', \"true\")\n        self.set_header('Access-Control-Allow-Methods', \"GET, POST, OPTIONS\")\n        self.set_header('Access-Control-Expose-Headers', \"Content-Type\")\n        self.set_header('Access-Control-Allow-Headers', \"Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, Cache-Control\")\n        self.set_header('Access-Control-Max-Age', 600)\n\ndef options(self):\n\n    self.set_status(204)\n    self.finish()\n`\nJavascript\nxmlHttpRequest = new XMLHttpRequest(); xmlHttpRequest.open(\"GET\",http://..., true); xmlHttpRequest.withCredentials = true; xmlHttpRequest.setRequestHeader(\"Content-Type\", \"application/json\"); xmlHttpRequest.send();\ntornado is not getting the cookie.\nPlease, can anybody help me.\nthanks.", "issue_status": "Closed", "issue_reporting_time": "2018-08-16T00:13:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "150": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2471", "issue_id": "#2471", "issue_summary": "IOLoop doc example code doesn't work correctly", "issue_description": "Contributor\npeterdn commented on 14 Aug 2018 \u2022\nedited\nThe example TCP server shown in the IOLoop documentation doesn't work correctly with Python 3.7 (and probably earlier versions).\nThis is because the handle_connection function is declared async, however is never awaited or otherwise scheduled, therefore doesn't actually run when a connection is established.\nUpon running the snippet and connecting with nc 127.0.0.1 8888, the following warning is output:\nioloop_example.py:23: RuntimeWarning: coroutine 'handle_connection' was never awaited", "issue_status": "Closed", "issue_reporting_time": "2018-08-14T02:40:14Z", "fixed_by": "#2472", "pull_request_summary": "Fix IOLoop doc example code", "pull_request_description": "Contributor\npeterdn commented on 14 Aug 2018\nfixes #2471\nUses tornado.gen.convert_yielded to convert the handle_connection coroutine into a future and schedules it in the event loop.", "pull_request_status": "Merged", "issue_fixed_time": "2018-08-16T03:02:30Z", "files_changed": [["4", "tornado/ioloop.py"]]}, "151": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2470", "issue_id": "#2470", "issue_summary": "Blocked on asyncio.sleep", "issue_description": "pedrokiefer commented on 13 Aug 2018\nWhen running this code, it seems that I'm unable to open multiple simultaneous connections to the server. Maybe tornado is blocked on the asyncio.sleep()? Is this behaviour expected?\nI've tested this on 5.0.1, 5.1 and master.\nclass MainHandler(tornado.web.RequestHandler):\n\n    async def get(self):\n        sleep = random.randrange(10)\n        logger.info('REQUEST will sleep for {}'.format(sleep))\n        await asyncio.sleep(sleep)\n        logger.info('woke up')\n        self.write('Ok')\n\ndef main():\n    logging_setup()\n    tornado.platform.asyncio.AsyncIOMainLoop().install()\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    application.listen(8000)\n    tornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2018-08-13T16:39:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "152": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2464", "issue_id": "#2464", "issue_summary": "testing utils asyncclient delete method missing", "issue_description": "ray1888 commented on 9 Aug 2018\ni try to test my web appliaction on tornado . i use the code like below\nthis is within a asynchttptestcase Class\nresponse = self.fetch('/group', headers=self.headers, method=\"DELETE\", body=json.dumps(mockdata))\n            b = json.loads(response.body.decode())\nbut it can't get to my delete method , and i saw the doc ,it seem to not supporting http delete method ? can u guys add this feature?", "issue_status": "Closed", "issue_reporting_time": "2018-08-09T03:25:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "153": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2463", "issue_id": "#2463", "issue_summary": "Asyncio equivalent of call_soon", "issue_description": "Contributor\nmrocklin commented on 6 Aug 2018\nCurrently calling add_callback with Tornado's asyncio backend eventually calls call_soon_threadsafe, which incurs a bit of a cost (see this stack overflow question)\nWould it be cheaper to call asyncio's call_soon instead when scheduling a callback from code operating on the same thread as the event loop?\nIf yes, then is there any Tornado API that allows this. By grepping through the codebase I think that there isn't. Should there be?\nAlso, I modified tornado's add_callback to include a threadsafe keyword to try this out and got a reduction of overhead, but also a surprising increase in latency that I can't explain. I suspect that this is something to do with my system, but thought I'd mention it in case someone else could explain it easily.\n+++ b/tornado/platform/asyncio.py\n@@ -146,8 +146,13 @@ class BaseAsyncIOLoop(IOLoop):\n         timeout.cancel()\n \n     def add_callback(self, callback, *args, **kwargs):\n+        threadsafe = kwargs.pop('threadsafe', False)\n+        if threadsafe:\n+            call_soon = self.asyncio_loop.call_soon\n+        else:\n+            call_soon = self.asyncio_loop.call_soon_threadsafe\n         try:\n-            self.asyncio_loop.call_soon_threadsafe(\n+            call_soon(\n                 self._run_callback,\n                 functools.partial(callback, *args, **kwargs))\n         except RuntimeError:", "issue_status": "Closed", "issue_reporting_time": "2018-08-06T01:23:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "154": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2462", "issue_id": "#2462", "issue_summary": "options.py getattr ?", "issue_description": "suparek commented on 3 Aug 2018\n    def _normalize_name(self, name):\n        return name.replace('_', '-')\nwhy replace '_' with '-' ?\nis it a bug?", "issue_status": "Closed", "issue_reporting_time": "2018-08-03T06:38:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "155": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2457", "issue_id": "#2457", "issue_summary": "does anyone notice that tornado 5.1 is quite slower than 4.5.3", "issue_description": "lostangelwangyang commented on 25 Jul 2018\nthe test code is quite simple:\n`from tornado import ioloop, web, gen\n#import asyncio\n#import uvloop\n#asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\nimport json\nfrom tornado import simple_httpclient\nclass MainHandler(web.RequestHandler):\n@gen.coroutine\ndef get(self):\nself.write({'name': \"The source code for the benchmark can be found in benchmarks directory\"})\ndef make_app():\nreturn web.Application([\n(r\"/\", MainHandler),\n])\nif name == \"main\":\napp = make_app()\napp.listen(8888)\nioloop.IOLoop.current().start()`\nthe speed I got with siege [ siege 'http://10.10.10.xxx:8888/' -c 30 -t 30s -b ]\npython-3.5.2 tornado-5.1\nTransactions: 36831 hits\nAvailability: 100.00 %\nElapsed time: 29.47 secs\nData transferred: 2.88 MB\nResponse time: 0.02 secs\nTransaction rate: 1249.78 trans/sec\nThroughput: 0.10 MB/sec\nConcurrency: 29.97\nSuccessful transactions: 36831\nFailed transactions: 0\nLongest transaction: 0.40\nShortest transaction: 0.00\npython-2.7.12 tornado-5.1\nTransactions: 37760 hits\nAvailability: 100.00 %\nElapsed time: 29.29 secs\nData transferred: 2.95 MB\nResponse time: 0.02 secs\nTransaction rate: 1289.18 trans/sec\nThroughput: 0.10 MB/sec\nConcurrency: 29.98\nSuccessful transactions: 37760\nFailed transactions: 0\nLongest transaction: 0.38\nShortest transaction: 0.01\npython-3.5.2 tornado-5.1 on uvloop-0.8.1\nTransactions: 40683 hits\nAvailability: 100.00 %\nElapsed time: 29.16 secs\nData transferred: 3.18 MB\nResponse time: 0.02 secs\nTransaction rate: 1395.16 trans/sec\nThroughput: 0.11 MB/sec\nConcurrency: 29.97\nSuccessful transactions: 40683\nFailed transactions: 0\nLongest transaction: 0.36\nShortest transaction: 0.00\npython-2.7.12 tornado-4.5.3\nTransactions: 45485 hits\nAvailability: 100.00 %\nElapsed time: 29.43 secs\nData transferred: 3.56 MB\nResponse time: 0.02 secs\nTransaction rate: 1545.53 trans/sec\nThroughput: 0.12 MB/sec\nConcurrency: 29.97\nSuccessful transactions: 45485\nFailed transactions: 0\nLongest transaction: 0.17\nShortest transaction: 0.00\npython-3.5.2 tornado-4.5.3\nTransactions: 46496 hits\nAvailability: 100.00 %\nElapsed time: 29.95 secs\nData transferred: 3.64 MB\nResponse time: 0.02 secs\nTransaction rate: 1552.45 trans/sec\nThroughput: 0.12 MB/sec\nConcurrency: 29.97\nSuccessful transactions: 46496\nFailed transactions: 0\nLongest transaction: 0.17\nShortest transaction: 0.00\nthe 5.1 is more slower then 4.5.3 no mater python2/python3.\nIs that because asyncio runs slow?", "issue_status": "Closed", "issue_reporting_time": "2018-07-25T04:52:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "156": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2455", "issue_id": "#2455", "issue_summary": "error in blog demo in the demo section", "issue_description": "prusj commented on 24 Jul 2018 \u2022\nedited\nThere is an error when making an edit to blog post for the blog demo in the demo section.\nError is copy pasted here:\nTraceback (most recent call last):\nFile \"/home/jpru5/blog/env/lib64/python3.6/site-packages/tornado/web.py\", line 1592, in _execute\nresult = yield result\nFile \"/home/jpru5/blog/env/lib64/python3.6/site-packages/tornado/gen.py\", line 1133, in run\nvalue = future.result()\nFile \"app.py\", line 189, in post\nslug = entry.slug\nAttributeError: 'list' object has no attribute 'slug'\nline 189 reads \"slug = entry.slug\" but it should read \"slug = entry[0].slug\" since \"self.query(...\" on line 186 returns a list of dictionaries\n...or better yet, where line 186 has \"self.query(...\" it should be replaced with \"self.queryone(...\"", "issue_status": "Closed", "issue_reporting_time": "2018-07-24T01:31:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "157": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2451", "issue_id": "#2451", "issue_summary": "Release 5.1.1", "issue_description": "Member\nbdarnell commented on 21 Jul 2018\nThings to cherry-pick into 5.1.1 when I'm ready to make that release:\n#2449 (new functionality not working)\n#2433 (improve compatibility with pipenv)\n3", "issue_status": "Closed", "issue_reporting_time": "2018-07-21T16:22:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "158": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2450", "issue_id": "#2450", "issue_summary": "too many file descriptors in select()", "issue_description": "zhoufankai commented on 20 Jul 2018\nI use tornado tcp process on windows 10. But my process always break by too many file descriptors. I am a little nervous that it will happen on Linux.\nThere is my linux config.\nLimit Soft Limit Hard Limit Units Max open files 1000000 1000000 files\nRight now. I can see my process's FD number below:\n[root@10-10-216-144 data]# ll /proc/25116/fd/ | wc -l 12578\nIt increased all the time. Never reduce. Does my code have some problems?\nclass EchoServer(TCPServer):\n    def handle_stream(self, stream, address):\n        conn = TcpConnection(stream,address)\n        conn.stream_handler()\n\nclass TcpConnection(object):\n    def __init__(self,stream,address):\n        self._stream=stream\n        self._address=address\n\n    @coroutine\n    def stream_handler(self):\n        while True:\n            try:\n                message = yield self._stream.read_until(b'\\r\\n')\n                # ...\n\n            except StreamClosedError:\n                break\n\n        self._stream.close()", "issue_status": "Closed", "issue_reporting_time": "2018-07-20T10:21:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "159": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2448", "issue_id": "#2448", "issue_summary": "RequestHandler.finish() future not resolving", "issue_description": "sbrandtb commented on 20 Jul 2018\nJust tried Tornado 5.1 for the first time and am wondering if I'm doing something wrong when waiting for the future of the finish method:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    async def get(self):\n        print('before')\n        await self.finish(\"Hello, world\")\n        print('after')\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nIt seems like the future is never resolved. after is not printed and interrupting the application outputs:\nKeyboardInterrupt\nERROR:asyncio:Task was destroyed but it is pending!\ntask: <Task pending coro=<MainHandler.get() running at main.py:7> wait_for=<Future pending cb=[<TaskWakeupMethWrapper object at 0x7f0cb0b25e28>()]> cb=[IOLoop.add_future.<locals>.<lambda>() at /home/sebastian/.virtualenvs/tempenv-2fc3210213e1f/lib/python3.6/site-packages/tornado/ioloop.py:719]>\nPython 3.6, Ubuntu", "issue_status": "Closed", "issue_reporting_time": "2018-07-20T07:55:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "160": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2447", "issue_id": "#2447", "issue_summary": "Periodic pings shouldn't be sent after socket close", "issue_description": "bugy commented on 19 Jul 2018\nHi, I'm using tornado websockets with periodic pings (#1640).\nWhen sending large amount of data before closing the socket from server-side, I noticed the error on client side in Chrome: Ping received after close.\nAs far as I understood, the error happens, when client receives the frames in the following order:\ndata1, data2, ..., dataN, close, ping\nThe problem here is that periodic ping can be sent even after calling socket.close(): this method is only about sending a close frame. However periodic pings check real connection state, which will be closed only after client confirms the socket close frame.\nI guess, periodic ping should be stopped immediately on socket.close() or at least check for socket state, instead of real connection.\nAs I local workaround I added a call web_socket.ws_connection.connection.ping_callback.stop() before close and don't get this error anymore\nAttached is a sample tornado server with \"overloaded\" websocket and an html page for connecting to the socket. This can be not 100% reproducible, depending on ping occurences.\nping_bug.zip\nTornado version: 5, but I believe it applies to other versions as well", "issue_status": "Closed", "issue_reporting_time": "2018-07-18T21:08:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "161": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2446", "issue_id": "#2446", "issue_summary": "Introduce Authentication with OpenID Connect", "issue_description": "Contributor\nmalcm commented on 17 Jul 2018\nHey!\nDid you already plan to implement the \"OpenID Connect\" authentication? I plan to use it in my project. If not I should probably start creating this authentication method for tornado.\nBest\nMartin\n3", "issue_status": "Closed", "issue_reporting_time": "2018-07-17T08:29:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "162": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2438", "issue_id": "#2438", "issue_summary": "clear input in demo projects", "issue_description": "pouya-abbassi commented on 9 Jul 2018\nI know it's not really huge bug and I know it's not a critical issue.\nBut it bothers me anyway.\nIn file demos/websocket/static/chat.js line 36 should be changed from:\nform.find(\"input[type=text]\").val(\"\").select();\nto:\n$(\"#message\").val(\"\").select();\nin order to really clear input and set focus on it.", "issue_status": "Closed", "issue_reporting_time": "2018-07-09T14:58:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "163": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2435", "issue_id": "#2435", "issue_summary": "httpclient: Make size limit less surprising", "issue_description": "Agnewee commented on 5 Jul 2018\ndemo code:\nimport sys\nfrom functools import partial\n\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpclient import AsyncHTTPClient\n\ndef stream_callback(file_obj, chunk):\n    file_obj.write(chunk)\n\n@gen.coroutine\ndef download(io_loop, url, save_path):\n    client = AsyncHTTPClient()\n    with open(save_path, 'wb') as file_obj:\n        streaming_callback = partial(stream_callback, file_obj)\n        resp = yield client.fetch(url, streaming_callback=streaming_callback)\n        if resp.code != 200:\n            print('download file error')\n        else:\n            print('download file ok')\n        io_loop.stop()\n\nif __name__ == '__main__':\n    url = sys.argv[1]\n    save_path = sys.argv[2]\n    io_loop = IOLoop().current()\n    io_loop.spawn_callback(download, io_loop, url, save_path)\n    io_loop.start()\nBut it throw HTTPStreamClosedError when i run the script to download a 127Mb file\nERROR:tornado.application:Exception in callback <functools.partial object at 0x7f221b58c838>\nTraceback (most recent call last):\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/ioloop.py\", line 758, in _run_callback\n    ret = callback()\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/stack_context.py\", line 300, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/ioloop.py\", line 779, in _discard_future_result\n    future.result()\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/gen.py\", line 1141, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"test.py\", line 26, in download\n    resp = yield client.fetch(url, streaming_callback=streaming_callback)\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/gen.py\", line 1133, in run\n    value = future.result()\n  File \"/usr/local/python2.7/lib/python2.7/site-packages/tornado/concurrent.py\", line 261, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\nHTTPStreamClosedError: Connection closed\nAnd the access.log of Nginx output\n10.1.10.212 - - [05/Jul/2018:18:09:07 +0800] \"GET /api/v2/hub/download?id=e13bc8742cfe4789873d7c1790245ed5&apikey=e10adc3949ba59abbe56e057f2gg88dd HTTP/1.1\" 200 105311898 \"-\" \"-\"\npython -c \"import tornado; print(tornado.version)\"\n5.1b1", "issue_status": "Closed", "issue_reporting_time": "2018-07-05T10:22:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "164": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2433", "issue_id": "#2433", "issue_summary": "Use environment marker in setup.py", "issue_description": "hexchain commented on 3 Jul 2018\nIs there any particular reason we don't use PEP 508 environment markers for conditional dependencies in setup.py? The current method is causing problems for tools like pipenv (e.g. missing dependencies).\nI'd like to open a PR if we don't have any problems with environmental markers.\n2", "issue_status": "Closed", "issue_reporting_time": "2018-07-03T16:32:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "165": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2431", "issue_id": "#2431", "issue_summary": "AsyncHTTPClient joins multiple Set-Cookie headers into one header", "issue_description": "ayamnikov commented on 28 Jun 2018 \u2022\nedited\nCode example:\n#!/usr/bin/env python\n# coding: utf-8\n\nfrom tornado import web, ioloop, gen\nfrom tornado.httpclient import AsyncHTTPClient\n\n\nclass Target(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        self.set_cookie('x', '1')\n        self.set_cookie('y', '2')\n        self.set_cookie('z', '3')\n\n\nclass Proxy(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        cli = AsyncHTTPClient()\n        response = yield cli.fetch(\n            'http://127.0.0.1:8080', method='GET',\n            request_timeout=1, connect_timeout=1)\n        for k, v in response.headers.items():\n            if k in ('Content-Length', 'Content-Encoding'):\n                continue\n            self.set_header(k, v)\n        self.finish(response.body)\n\n\napp1 = web.Application([\n    ('.*', Target)\n])\napp1.listen(8080)\n\n\napp2 = web.Application([\n    ('.*', Proxy)\n])\napp2.listen(8081)\n\n\nioloop.IOLoop.current().start()\nOutput:\nMaking request directly to target server:\n$ curl -v http://127.0.0.1:8080/\n...\n< Set-Cookie: y=2; Path=/\n< Set-Cookie: x=1; Path=/\n< Set-Cookie: z=3; Path=/\n...\nRequesting via proxy:\n$ curl -v http://127.0.0.1:8081/\n...\n< Set-Cookie: y=2; Path=/,x=1; Path=/,z=3; Path=/\n...\nUPD: tested on Python 2.7, Tornado 5.0.2", "issue_status": "Closed", "issue_reporting_time": "2018-06-28T12:40:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "166": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2430", "issue_id": "#2430", "issue_summary": "force replace '+' with ' ' in query parameter", "issue_description": "Cyrus414 commented on 27 Jun 2018\nI have some request like GET localhost:8888/test?token=Adsf77fljg+fdajl086POfs, I use get_query_argument function to get the value and I got 'Adsf77fljg fdajl086POfs' .\nI found some code like name = nv[0].replace('+', ' ') in tornado, it seems that tornado force replace '+' with ' ' in query parameter.\nI want to know why tornado do this and how can I get the value without replacing.", "issue_status": "Closed", "issue_reporting_time": "2018-06-27T02:30:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "167": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2429", "issue_id": "#2429", "issue_summary": "open function seems missing a parameter in tornado/websocket.py", "issue_description": "ZoeShaw101 commented on 23 Jun 2018\nopen function task\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n open_sockets = set()\n\n def __init__(self, *args, **kwargs):\n  self._consumer = NewConsumer()\n  self._producer = Producer()\n  super(WebSocketHandler, self).__init__(*args, **kwargs)\n\n def open(self):\n  print 'websocket is opened!'\n  self._consumer.start()\n  self._producer.start()\n  self.set_nodelay(True)\n  type(self).open_sockets.add(self)\nIt seems wrong\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 494, in _run_callback\n    result = callback(*args, **kwargs)\nTypeError: open() takes exactly 1 argument (2 given)\nAfter I changed to this, it worked\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n open_sockets = set()\n\n def __init__(self, *args, **kwargs):\n  self._consumer = NewConsumer()\n  self._producer = Producer()\n  super(WebSocketHandler, self).__init__(*args, **kwargs)\n\n def open(self, *args):\n  print 'websocket is opened!'\n  self._consumer.start()\n  self._producer.start()\n  self.set_nodelay(True)\n  type(self).open_sockets.add(self)\n ", "issue_status": "Closed", "issue_reporting_time": "2018-06-23T02:19:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "168": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2427", "issue_id": "#2427", "issue_summary": "Resource Warnings on python3.5", "issue_description": "ghost commented on 21 Jun 2018\nAm getting ResourceWarning errors on tornado, especially when using websockets\n/usr/local/lib/python3.5/dist-packages/tornado/gen.py:1154: ResourceWarning: unclosed <socket.socket fd=120, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('0.0.0.0', 0)> self.future, inner)\nThis interferes with debugging actual errors as the socket is sending data to client side in a loop, so every time it does a socket.write_message(), a resource warning is emitted, so its kinda hard to notice any bugs as the terminal is filled with ResourceWarning emissions\nI tried disabling this warnings using the warning module to no avail, also I tried to disable from the commandline as\npython3 -W ignore server.py\nstill doesnt work....\nKindly Help,\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2018-06-21T06:32:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "169": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2426", "issue_id": "#2426", "issue_summary": "http_server.start multiple instance fails in python3.5", "issue_description": "chrjxj commented on 19 Jun 2018\nthe very basic multi instances code fails on python 3.5 env. It works with python2.7 and 3.6.4.\nPython 3.5.2\ntornado                5.0.1\nFlask                  0.12.2\nFlask-Cors             3.0.3\ngevent                 1.2.2\ngreenlet               0.4.13\ngunicorn               19.7.1\nlxml                   4.2.0\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS, cross_origin\nfrom tornado.wsgi import WSGIContainer\nfrom tornado.httpserver import HTTPServer\nfrom tornado.ioloop import IOLoop\n\napp = Flask(__name__)\nPROD = True\nCORS(app)\n\n\n@app.route('/api/check/alive', methods=['GET'])\ndef handle_api_alive():\n    resp = jsonify(dict(status=\"OK\"))\n\n    return resp\n\n\nif __name__ == '__main__':\n    # start HTTP server\n    http_server = HTTPServer(WSGIContainer(app))\n    http_server.bind(9999)\n    http_server.start(num_processes=2)\n    IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2018-06-19T11:04:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "170": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2425", "issue_id": "#2425", "issue_summary": "Possible memory retention issue", "issue_description": "BrianTsengZyxel commented on 18 Jun 2018 \u2022\nedited\nHi, I build a simple hello world tornado application.\nAnd then I send 20,000 POST requests which contain 1MB data on its body to the application.\nAfter the requests are done, I find the server's used memory doesn't been released.\nI trace the source code, and I find the chunks doesn't be cleared after generating the request.body\ntornado/tornado/web.py\nLines 2189 to 2201 in 0b2b055\n def finish(self): \n     if self.stream_request_body: \n         future_set_result_unless_cancelled(self.request.body, None) \n     else: \n         self.request.body = b''.join(self.chunks) \n         self.request._parse_body() \n         self.execute() \n    def on_connection_close(self): \n     if self.stream_request_body: \n         self.handler.on_connection_close() \n     else: \n         self.chunks = None \nThe value of need_delegate_close is False, it doesn't trigger the on_connection_close method of web.py\ntornado/tornado/http1connection.py\nLines 259 to 263 in 0b2b055\n if need_delegate_close: \n     with _ExceptionLoggingContext(app_log): \n         delegate.on_connection_close() \n header_future = None \n self._clear_callbacks() \nhello-world server\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def data_received(self, chunk):\n        pass\n\n    def post(self):\n        self.write(\"Hello, world\")\n\n    def on_finish(self):\n        self.request.body = None\n\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8000)\n    tornado.ioloop.IOLoop.current().start()\nmemory usage\ntop status\nVIRT RES SHR %MEM\nInitial usage 76184 23032 8508 1.2\nAfter serving all requests 276984 224248 8564 11.3\nThanks!\n6", "issue_status": "Closed", "issue_reporting_time": "2018-06-18T02:32:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "171": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2424", "issue_id": "#2424", "issue_summary": "WARNING:tornado.general:SSL Error on 8 ('77.39.7.162', 33865): [SSL: HTTP_REQUEST] http request (_ssl.c:645)", "issue_description": "pythonmobile commented on 17 Jun 2018\nAny ideas why this happens? I have a letsencrypt key on my server and in my tests, I can't reproduce this error.", "issue_status": "Closed", "issue_reporting_time": "2018-06-16T23:17:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "172": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2423", "issue_id": "#2423", "issue_summary": "ioloop: Remove IOLoop.initialized()", "issue_description": "rddaz2013 commented on 16 Jun 2018\nJust a hint..\nnever remove a methode without a deprecate warning.\nhttps://softwareengineering.stackexchange.com/questions/67837/when-to-deprecate-and-when-to-delete-in-java", "issue_status": "Closed", "issue_reporting_time": "2018-06-16T09:41:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "173": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2421", "issue_id": "#2421", "issue_summary": "AttributeError: module 'platform' has no attribute 'python_implementation'", "issue_description": "kenorb commented on 14 Jun 2018 \u2022\nedited\nThe app works when run as standalone, however when I run in debug mode using Visual Code IDE, it fails with below error:\n$ env \"PYTHONIOENCODING=UTF-8\" \"PYTHONUNBUFFERED=1\" python3 ~/.vscode/extensions/ms-python.python-2018.5.0/pythonFiles/PythonTools/visualstudio_py_launcher.py ~/Projects/Current 53555 34806ad9-833a-4524-8cd6-18ca4aa74f14 RedirectOutput,RedirectOutput /usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tornado/web.py\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tornado/web.py\", line 84, in <module>\n    from tornado.concurrent import Future, future_set_result_unless_cancelled\n  File \"/usr/local/lib/python3.6/site-packages/tornado/concurrent.py\", line 42, in <module>\n    from concurrent import futures\n  File \"/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tornado/concurrent.py\", line 59, in <module>\n    _GC_CYCLE_FINALIZERS = (platform.python_implementation() == 'CPython' and\nAttributeError: module 'platform' has no attribute 'python_implementation'\nI'm using Tornado v5.0.2 in Python 3.6.5.", "issue_status": "Closed", "issue_reporting_time": "2018-06-14T00:30:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "174": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2420", "issue_id": "#2420", "issue_summary": "websocket connection closed immediately on nginx", "issue_description": "ManiDOSS commented on 13 Jun 2018 \u2022\nedited\nI am really very tried to configure tornado websocket configuration with nginx finally I got one issue but i cannot fix it. Is I made any mistake in my configuration?\nThis is my websocket.py:\nimport logging\nimport tornado.escape\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.websocket\nimport os.path\nimport uuid\nimport tornado.wsgi\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n                     (r\"/\", MainHandler),\n     (\"/chatsocket\",ChatSocketHandler)\n        ]\n        settings = dict(\n                    cookie_secret=\"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__\",\n                    template_path=os.path.join(os.path.dirname(__file__), \"templates\"),\n                   static_path=os.path.join(os.path.dirname(__file__), \"static\"),\n                   xsrf_cookies=False,\n                  debug = True\n        )\n       super(Application, self).__init__(handlers, **settings)\n\nclass ChatSocketHandler(tornado.websocket.WebSocketHandler):\n    def check_origin(self, origin):\n        return True\n    def open(self, *args, **kwargs):\n       print('connection opened')\n\n    def on_close(self):\n        print('connection closed')\n    def on_message(self, message):\n        print(message)\n        self.write_message(message)\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render(\"index.html\")\n\napp = Application()\napplication = tornado.wsgi.WSGIAdapter(app)\n\ndef main():\n    # tornado.options.parse_command_line()\n     tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == \"__main__\":\n    main()\nThis is my client script:\nlet url = \"ws://209.97.139.107/chatsocket\";\nlet socket = new WebSocket(url);\nsocket.onmessage = function(event) {\n       console.log(event);\n };\nsocket.onopen = function () {\n       console.log('opend');\n       socket.send('Hello World')\n};\nsocket.onclose = function () {\n       console.log('closed');\n};\nIn my web browser console:\nopened\nclosed\nIn my web browser console without nginx configuration:\nopened\nMessageEvent{....}", "issue_status": "Closed", "issue_reporting_time": "2018-06-13T10:36:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "175": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2419", "issue_id": "#2419", "issue_summary": "tornado.locks is missing locked() method", "issue_description": "volinthius commented on 12 Jun 2018\nToro has Lock.locked() but tornado.locks.Lock is missing this method. It could be implemented with the following change:\ndiff --git a/tornado/locks.py b/tornado/locks.py\nindex 9566a45..f4faefc 100644\n--- a/tornado/locks.py\n+++ b/tornado/locks.py\n@@ -412,6 +412,9 @@ class Semaphore(_TimeoutGarbageCollector):\n                     lambda _: io_loop.remove_timeout(timeout_handle))\n         return waiter\n \n+    def locked(self):\n+        return self._value == 0\n+\n     def __enter__(self):\n         raise RuntimeError(\n             \"Use Semaphore like 'with (yield semaphore.acquire())', not like\"\n@@ -511,6 +514,9 @@ class Lock(object):\n         except ValueError:\n             raise RuntimeError('release unlocked lock')\n \n+    def locked(self):\n+        return self._block.locked()\n+\n     def __enter__(self):\n         raise RuntimeError(\n             \"Use Lock like 'with (yield lock)', not like 'with lock'\")", "issue_status": "Closed", "issue_reporting_time": "2018-06-12T12:12:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "176": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2415", "issue_id": "#2415", "issue_summary": "Seems there Is a Redundant Assignment for 'cursor'.", "issue_description": "ykh commented on 10 Jun 2018\ntornado/demos/chat/static/chat.js\nLines 119 to 121 in bbdd75a\n updater.cursor = response.cursor; \n var messages = response.messages; \n updater.cursor = messages[messages.length - 1].id; ", "issue_status": "Closed", "issue_reporting_time": "2018-06-10T06:21:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "177": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2414", "issue_id": "#2414", "issue_summary": "_curl_setup_request in curl_httpclient.py raise exception when url contains no-ascii char", "issue_description": "restran commented on 4 Jun 2018 \u2022\nedited\nIf request.url contains no-ascii char, such as http://www.example.com/\u5907\u4efd.rar will raises exception\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 22-23: ordinal not in range(128)\ntornado/curl_httpclient.py\ni do this change, and it works for me.\ndef _curl_setup_request(self, curl, request, buffer, headers):\n    # change native_str to utf8\n    curl.setopt(pycurl.URL, utf8(request.url))", "issue_status": "Closed", "issue_reporting_time": "2018-06-04T16:33:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "178": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2413", "issue_id": "#2413", "issue_summary": "Could not override handle_callback_exception in IOLoop", "issue_description": "ElenaVasylenko commented on 4 Jun 2018 \u2022\nedited\nGood day, I have a simple Tornado-web server (Tornado 4.5.3, Python 2.7 ) and want to override handle_callback_exception to implement own exception description, so I've created class which inherits from IOLoop and rewrite described method, like this:\nclass IOLoopHandler(IOLoop):\ndef add_timeout(self, deadline, callback, *args, **kwargs):\nreturn super(IOLoopHandler, self).add_timeout(time.time, callback, *args, **kwargs)\ndef handle_callback_exception(self, callback):\n _logger.error(\"Exception catched!\")\nWhen I start server, I use the instance of my own writen IOLoop class:\nIOLoopHandler.instance().start()\nI am trying to handle Exception in callback <bound method WebSocketProtocol13.periodic_ping of <tornado.websocket.WebSocketProtocol13 object at 0x7f52f4\n870150>> Traceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 1026, in _run\nreturn self.callback()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 1038, in periodic_ping\nself.write_ping(b'')\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 798, in write_ping\nself._write_frame(True, 0x9, data)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 776, in _write_frame\nreturn self.stream.write(frame)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 395, in write\nself._write_buffer += data\nBufferError: Existing exports of data: object cannot be re-sized\nBut always called the standart handle_callback_exception. Maybe I missed something? Or it is bug?\nWill be thankful for your help", "issue_status": "Closed", "issue_reporting_time": "2018-06-04T12:51:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "179": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2404", "issue_id": "#2404", "issue_summary": "tornado.queues.Queue.get does't return after time set on linux platform, but ok on windows", "issue_description": "Aireed commented on 28 May 2018 \u2022\nedited\nFYI:\nwindow: tornado==5.0\nlinux: tornado==4.4\nI just found that,\non windows, i can get TimeoutError error, but on linux, the get function hang.\non Windows:\non linux:\nit hang\nmy code :\nQUEUE_MAX_SIZE = 10000\nQUERY_TASK_QUE = Queue(maxsize=QUEUE_MAX_SIZE)\n\n@gen.coroutine\ndef worker(gen_id):\n   \"\"\"\u7a7aworker\"\"\"\n   while True:\n       try:\n           print \"[query_keyword-{} restore to run!!]\".format(gen_id)\n           item = yield QUERY_TASK_QUE.get(timeout=time.time() + 2)\n           print item\n       except tornado.util.TimeoutError:\n           # yield gen.sleep(10)\n           print traceback.format_exc()\n           continue\n       except Exception as e:\n           print traceback.format_exc()\n           continue\n\ndef check_proc_main(*args, **kwargs):\n   parse_command_line()\n\n   # \u68c0\u67e5\u66f4\u65b0\u65f6\u95f4\n   io_loop = tornado.ioloop.IOLoop.current()\n   # io_loop.spawn_callback(wucInst.wechat_loader)\n   \n   for item in range(0, 10):\n       io_loop.spawn_callback(worker, item)\n   \n   io_loop.start()\n\n\nif __name__ == \"__main__\":\n   check_proc_main()", "issue_status": "Closed", "issue_reporting_time": "2018-05-28T07:30:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "180": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2388", "issue_id": "#2388", "issue_summary": "How to debug a hanging ioloop", "issue_description": "gtmanfred commented on 17 May 2018\nHello, I am hoping you can help me.\nI am working on the last failure for salt to support tornado 5.0.\nWe are currently hanging on this line\nhttps://github.com/gtmanfred/salt/blob/2017.7.6/salt/transport/tcp.py#L907\nBut only on python2.7 with tornado 5.0.\nTo replicate this\ngit clone git://github.com/gtmanfred/salt.git -b 2017.7.6\ncd salt\npip2 install -r requirements/dev_python27.txt -r requirements/zeromq.py\npytest -ra -sv --log-cli-level=debug tests/unit/transport/test_tcp.py -k test_basic\nIt works when running running each one of those tests individually, but when running them together, it fails.\nIf I put a PeriodicCallback there, to see if it continue, everything works, but then when the whole test suite runs, I get an error for too many open files, so I think that the ioloop is not actually getting stopped.\nI tried also setting set_blocking_log_threshold, since we are still on py2 and not asyncio (which works fine), but nothing gets logged ever.\nAny help on what I can do to troubleshoot this further would be greatly appreciated\nThanks,\nDaniel", "issue_status": "Closed", "issue_reporting_time": "2018-05-16T21:49:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "181": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2384", "issue_id": "#2384", "issue_summary": "Error with deploying app using tornado on heroku", "issue_description": "answerquest commented on 9 May 2018\nHi, looking for help if any on this.. herokuapp was working fine with my python program (that uses tornado) up untill today. Now, on pushing the latest version, I got this error:\nremote: -----> Python app detected\nremote:  !     The latest version of Python 3 is python-3.6.5 (you are using python-3.6.4, which is unsupported).\nremote:  !     We recommend upgrading by specifying the latest version (python-3.6.5).\nremote:        Learn More: https://devcenter.heroku.com/articles/python-runtimes\nremote: -----> Installing requirements with pip\nremote:        Collecting tornado==5.0.2 (from -r /tmp/build_20cccfb2326b79af83625387b8940a07/requirements.txt (line 2))\nremote:          Downloading https://files.pythonhosted.org/packages/cf/d1/3be271ae5eba9fb59df63c9891fdc7d8044b999e8ac145994cdbfd2ae66a/tornado-5.0.2.tar.gz (506kB)\nremote:            Complete output from command python setup.py egg_info:\nremote:            /app/.heroku/python/lib/python3.6/distutils/dist.py:261: UserWarning: Unknown distribution option: 'install_requires'\nremote:              warnings.warn(msg)\nremote:            /app/.heroku/python/lib/python3.6/distutils/dist.py:261: UserWarning: Unknown distribution option: 'python_requires'\nremote:              warnings.warn(msg)\nremote:            usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\nremote:               or: -c --help [cmd1 cmd2 ...]\nremote:               or: -c --help-commands\nremote:               or: -c cmd --help\nremote:            \nremote:            error: invalid command 'egg_info'\nremote:            \nremote:            ----------------------------------------\nremote:        Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-z4g5q15a/tornado/\nremote:  !     Push rejected, failed to compile Python app.\nremote: \nremote:  !     Push failed\nremote: Verifying deploy...\nremote: \nremote: ! Push rejected to lit-mesa-97724.\nremote: \nTo https://git.heroku.com/lit-mesa-97724.git\n ! [remote rejected] master -> master (pre-receive hook declined)\nerror: failed to push some refs to 'https://git.heroku.com/lit-mesa-97724.git'\nI tried down-grading the tornado version to 5.0 but even that gave the same error. The app is running fine on my local system, but I'm not able to deploy it on my heroku site.", "issue_status": "Closed", "issue_reporting_time": "2018-05-09T06:42:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "182": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2383", "issue_id": "#2383", "issue_summary": "Stack context no longer works with async methods on 5.0.2", "issue_description": "canoon commented on 9 May 2018 \u2022\nedited\nUsing this test code\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.stack_context\n\nioloop = tornado.ioloop.IOLoop.current()\n\n\nclass TestContext:\n    def __enter__(self):\n        print(\"__enter__\")\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        print(\"__exit__\")\n\n\nasync def async_method():\n    print(\"async_method\")\n\n\n@tornado.gen.coroutine\ndef test_method():\n    print(\"test_method\")\n    yield async_method()\n    print(\"test_method\")\n\n\n@tornado.gen.coroutine\ndef wrapper_method():\n    yield tornado.stack_context.run_with_stack_context(tornado.stack_context.StackContext(TestContext), test_method)\n\nioloop.run_sync(wrapper_method)\nWhich on tornado 5.0.2 outputs\n-> % pip install tornado==5.0.2\nCollecting tornado==5.0.2\nInstalling collected packages: tornado\n  Found existing installation: tornado 4.5.2\n    Uninstalling tornado-4.5.2:\n      Successfully uninstalled tornado-4.5.2\nSuccessfully installed tornado-5.0.2\nYou are using pip version 9.0.3, however version 10.0.1 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n-> % python test_stack_context.py\n__enter__\ntest_method\n__exit__\nasync_method\n__enter__\ntest_method\n__exit__\nWhile on 4.5.2\n-> % pip install tornado==4.5.2\nCollecting tornado==4.5.2\nInstalling collected packages: tornado\n  Found existing installation: tornado 5.0.2\n    Uninstalling tornado-5.0.2:\n      Successfully uninstalled tornado-5.0.2\nSuccessfully installed tornado-4.5.2\nYou are using pip version 9.0.3, however version 10.0.1 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n-> % python test_stack_context.py\n__enter__\ntest_method\nasync_method\ntest_method\n__exit__\nNote that the async_method is no longer executed inside the stack context.\nI'm on Python 3.5.1 if that matters.", "issue_status": "Closed", "issue_reporting_time": "2018-05-09T05:48:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "183": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2382", "issue_id": "#2382", "issue_summary": "Is WebSocketHandler.open guaranteed to complete before the first handling of WebSocketHandler.on_message?", "issue_description": "samfrances commented on 8 May 2018\nI'm looking for the appropriate place to do some set up before the first websocket message is handled. I was considering using WebSocketHandler.open, but it isn't clear to me whether (a) this can be a coroutine, and if so (b) would it be guaranteed to complete before the first call to on_message.\nLooking at the code suggests to me that the answer may be \"no\", but I'm not familiar enough with the code to know for sure.\n(If this is the wrong place to post such questions, please let me know - I wasn't able to find an official mailing list or anything like that.)", "issue_status": "Closed", "issue_reporting_time": "2018-05-08T13:47:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "184": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2381", "issue_id": "#2381", "issue_summary": "UnboundLocalError: local variable 'current_state' referenced before assignment", "issue_description": "kunal-bajpai commented on 8 May 2018\nHi,\nI encountered the following error in the logs of a Salt minion that uses tornado's IOLoop.\n[tornado.application][ERROR   ][18889] Exception in callback <functools.partial object at 0x7f094dbf8e10>\nTraceback (most recent call last):\n  File \"/root/.pex/install/tornado-4.5.1-cp27-cp27mu-linux_x86_64.whl.fb67a9263e015c45296bb7103c9afdb612cd69fa/tornado-4.5.1-cp27-cp27mu-linux_x86_64.whl/tornado/ioloop.py\", line 605, in _run_callback\n    ret = callback()\n  File \"/root/.pex/install/tornado-4.5.1-cp27-cp27mu-linux_x86_64.whl.fb67a9263e015c45296bb7103c9afdb612cd69fa/tornado-4.5.1-cp27-cp27mu-linux_x86_64.whl/tornado/stack_context.py\", line 279, in null_wrapper\n    _state.contexts = current_state\nUnboundLocalError: local variable 'current_state' referenced before assignment\nHere's the construct this originates from\nhttps://github.com/tornadoweb/tornado/blob/branch4.5/tornado/stack_context.py#L274-L279\nThis seems like a weird construct given that there are no globals by the name current_state. Any pointers as to why this could happen?", "issue_status": "Closed", "issue_reporting_time": "2018-05-08T10:54:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "185": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2379", "issue_id": "#2379", "issue_summary": "Why not return HTTP 401 instead of HTTP 403 in @tornado.web.authenticated ?", "issue_description": "chiqj commented on 7 May 2018\nThe definition of HTTP 401 from MDN:\nThe HTTP 401 Unauthorized client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.\nThis status is sent with a WWW-Authenticate header that contains information on how to authorize correctly.\nThis status is similar to 403, but in this case, authentication is possible.\nThe definition of HTTP 403 from MDN\nThe HTTP 403 Forbidden client error status response code indicates that the server understood the request but refuses to authorize it.\nThis status is similar to 401, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic (like an incorrect password).\nIf user not logged in of the authentication expired, he should login again, so maybe he can access the resource. But HTTP 403 means you can't access the resource no matter what you do, I think HTTP 401 is more suitable.\n1", "issue_status": "Closed", "issue_reporting_time": "2018-05-07T09:26:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "186": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2372", "issue_id": "#2372", "issue_summary": "Implement tornado.web.RequestHandler.get_cookie_secret", "issue_description": "whardier commented on 3 May 2018\nThere's some require_setting logic that keeps me issuing a pull request.\nI'm hoping to simply override a proposed method named get_cookie_secret that by default returns the cookie_secret application setting.\nAn upstream driven cookie secret would be very useful for several internal projects I'm working on where there are already established authorization cookies that can help create per session cookie secrets.", "issue_status": "Closed", "issue_reporting_time": "2018-05-02T22:43:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "187": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2371", "issue_id": "#2371", "issue_summary": "wsgi adapter throwing runtime error", "issue_description": "raghumy commented on 3 May 2018\nThe 5.0.2 wsgi adapter seems to be throwing a runtime error:\n[Wed May 02 19:43:09.367974 2018] [:error] [pid 31085] [remote 172.31.12.172:164] mod_wsgi (pid=31085): Exception occurred processing WSGI script '/opt/python/current/app/application.py'.\n[Wed May 02 19:43:09.368100 2018] [:error] [pid 31085] [remote 172.31.12.172:164] Traceback (most recent call last):\n[Wed May 02 19:43:09.368138 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/opt/python/run/venv/local/lib64/python3.6/site-packages/tornado/wsgi.py\", line 222, in call\n[Wed May 02 19:43:09.368147 2018] [:error] [pid 31085] [remote 172.31.12.172:164] self.application(request)\n[Wed May 02 19:43:09.368154 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/opt/python/run/venv/local/lib64/python3.6/site-packages/tornado/web.py\", line 2041, in call\n[Wed May 02 19:43:09.368157 2018] [:error] [pid 31085] [remote 172.31.12.172:164] return dispatcher.execute()\n[Wed May 02 19:43:09.368162 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/opt/python/run/venv/local/lib64/python3.6/site-packages/tornado/web.py\", line 2172, in execute\n[Wed May 02 19:43:09.368165 2018] [:error] [pid 31085] [remote 172.31.12.172:164] **self.path_kwargs)\n[Wed May 02 19:43:09.368180 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/opt/python/run/venv/local/lib64/python3.6/site-packages/tornado/gen.py\", line 288, in wrapper\n[Wed May 02 19:43:09.368183 2018] [:error] [pid 31085] [remote 172.31.12.172:164] future = _create_future()\n[Wed May 02 19:43:09.368188 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/opt/python/run/venv/local/lib64/python3.6/site-packages/tornado/gen.py\", line 186, in _create_future\n[Wed May 02 19:43:09.368190 2018] [:error] [pid 31085] [remote 172.31.12.172:164] future = Future()\n[Wed May 02 19:43:09.368195 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/usr/lib64/python3.6/asyncio/events.py\", line 678, in get_event_loop\n[Wed May 02 19:43:09.368198 2018] [:error] [pid 31085] [remote 172.31.12.172:164] return get_event_loop_policy().get_event_loop()\n[Wed May 02 19:43:09.368202 2018] [:error] [pid 31085] [remote 172.31.12.172:164] File \"/usr/lib64/python3.6/asyncio/events.py\", line 584, in get_event_loop\n[Wed May 02 19:43:09.368205 2018] [:error] [pid 31085] [remote 172.31.12.172:164] % threading.current_thread().name)\n[Wed May 02 19:43:09.368219 2018] [:error] [pid 31085] [remote 172.31.12.172:164] RuntimeError: There is no current event loop in thread 'Dummy-1'.\nI switched to 4.5.3 and don't get this error. Looks like something in 5.0.2 is causing this issue.", "issue_status": "Closed", "issue_reporting_time": "2018-05-02T20:04:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "188": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2370", "issue_id": "#2370", "issue_summary": "tornado.queues.Queue.get timeout is inconsistent with queue.Queue.get", "issue_description": "Contributor\nmrocklin commented on 2 May 2018\nFrom the queue.Queue.get docstring\nIf 'timeout' is a non-negative number, it blocks at most 'timeout' seconds and raises the Empty exception if no item was available within that time.\nFrom the tornado.queues.Queue.get docstring\ntimeout may be a number denoting a time (on the same scale as tornado.ioloop.IOLoop.time, normally time.time), or a datetime.timedelta object for a deadline relative to the current time.\nI found this confusing. I wanted to verify that it was intentional.", "issue_status": "Closed", "issue_reporting_time": "2018-05-02T15:18:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "189": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2368", "issue_id": "#2368", "issue_summary": "Tornado multi processes, what is the advantage of reuse_port ?", "issue_description": "asynchronoust commented on 30 Apr 2018\nWhen use multi processes in tornado, the child processes inherit the socket fd from father process, so the child processes also listen the same ip-port, and they can receive data from the inherited socket.\nreuse_port param of socket means child processes can bind the same port of the father process binded. This use also make child processed and father process can bind the same port to improve the speed of the server.\nso when use multi process in tornado, what is the difference between reuse_port=True and reuse_port=False? It seems that there is no need to use reuse_port=True, because the child processes inherit the socket fd and they can receive data from the same port socket\nThanks !!", "issue_status": "Closed", "issue_reporting_time": "2018-04-30T17:43:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "190": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2367", "issue_id": "#2367", "issue_summary": "KeyError when closing IOLoop", "issue_description": "Contributor\nmrocklin commented on 26 Apr 2018\nThis started showing up in Dask's test suite recently:\ndistributed/utils_test.py:144: in pristine_loop\n    loop.close(all_fds=True)\n../../Software/anaconda/envs/test-environment/lib/python3.6/site-packages/tornado/platform/asyncio.py:223: in close\n    super(AsyncIOLoop, self).close(all_fds=all_fds)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <tornado.platform.asyncio.AsyncIOLoop object at 0x7f5751d46eb8>, all_fds = True\n\n    def close(self, all_fds=False):\n        self.closing = True\n        for fd in list(self.handlers):\n            fileobj, handler_func = self.handlers[fd]\n            self.remove_handler(fd)\n            if all_fds:\n                self.close_fd(fileobj)\n        self.asyncio_loop.close()\n>       del IOLoop._ioloop_for_asyncio[self.asyncio_loop]\nE       KeyError: <_UnixSelectorEventLoop running=False closed=True debug=False>\nThis is likely due to some change in upstream dependencies. It looks like Tornado hasn't had a release during the time when this arose, so it's likely something else. Still, I thought I'd raise the issue.", "issue_status": "Closed", "issue_reporting_time": "2018-04-26T13:36:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "191": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2366", "issue_id": "#2366", "issue_summary": "Post method doesn't work", "issue_description": "bloodknight2010 commented on 26 Apr 2018\nI request the post method client side. but doesn't work I got the following error\nUncaught exception POST /categories (127.0.0.1)\nHTTPServerRequest(protocol='http', host='localhost:9292', method='POST', uri='/categories', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Origin': 'http://localhost:9292', 'Content-Length': '34', 'Accept-Language': 'en-US,en;q=0.9', 'Accept-Encoding': 'gzip, deflate, br', 'Userid': 'bf138344-ba7f-4e73-9591-46715ca68317', 'Host': 'localhost:9292', 'Accept': 'application/json, text/javascript, /; q=0.01', 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36', 'Connection': 'keep-alive', 'X-Requested-With': 'XMLHttpRequest', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', 'Referer': 'http://localhost:9292/category-list', 'Content-Type': 'application/json; charset=UTF-8', 'Cookie': '_ga=GA1.1.1415872405.1522071386; fbsr_1789508618024488=uMLzTD29lyg7hGZXNChlTlCLuWOfOxbPI9Amwxl28fE.eyJhbGdvcml0aG0iOiJITUFDLVNIQTI1NiIsImNvZGUiOiJBUURSNHF4a2tZcWJzTnpTNjZtdFhLZXd6anlMbXRxQUNUejU5SV9MS1JYR3pRcmRqSVp3ODhyc0ZDM0pmSlk4NHpSVjZLdUhYYzhJSzB5WUg5cXZmQldBOGNwR2o5T0MyLTVCOEN4eDRjZmgteTVlU1F0bnU4X1c1WkNpaWgyeUxwTVZpLVUyand4Y3ctOVpPYlR3SGRMRnJFdm12a3dSZGdKeVVBaWdzVmVRNWdXTXdkdmdtVDE1bVY0VXpGU0dYOHAyc25LYWJuT1lsTUt1QVlmRmtHc1d6T0NnSWJiWTA4MFdzX0FiLVpjVkI1b0tLM0NNSzFQM3BuYVlXS0dtN1gwcDVIV2lnU2hybGdkMXJYU0JHQkNka0M3QUVLWHg4Ulp5d2VYUUNfX1NZM0xNd3JQUnpHSUdvZk5lUUptbVAweERJT2VkeDVZeU1uNzJNdHhTNHRGUCIsImlzc3VlZF9hdCI6MTUyNDQ3MzI1OCwidXNlcl9pZCI6IjE3OTM1MTQyNTQwMjczNjcifQ; fbsr_1755374758101377=UPvV56iYVc_RzwC7jyR_Kl7GZUkGVQKckZhe6cuOHsg.eyJhbGdvcml0aG0iOiJITUFDLVNIQTI1NiIsImNvZGUiOiJBUUFhaGlHTWJETWctUWhqZXVJZUk1bldqWlZHcFlvTy1yeWYwQmZ4WU5YZlY4dkNfdEF1VXlDcThGLUVGRWM2cmRLaU15c1RhQUJaQlFiWFhhQ1RqalhVUE9hbkotTnFuU2lYRmNrN1RDY2g1enlBLWRuMy00NkFrVG85WE9Fcy1LQklzYVJaS1pxRnBicGROdmdES0VWczZpTFNnRjZmcXpoajNSSVBja09iUDd0Skt1MlFVcExlejFvTHNOcnhZcjBQcWNvWTh2SGJjd2JrX203Qi0zc1ZBV05QQWhBeVJkSEF3V0JLZTBTenBrc2xieEwyOEF0TDlHbDBOWU9yU0lUd0FUeC1RcEJpbjZHOVRONE8ySWpVMGlnME4zRTQtc0RWOVVreEF3V3ZrRVBzdWtlRHNhMGo5YjhoTkdMZ1JHelVvZG1FR0E4OHVDUndlM3Zyb2M1SkZmNHRBZkdzOW5aMlpvVDlRYzVOSFEiLCJpc3N1ZWRfYXQiOjE1MjQ3NDM4MTEsInVzZXJfaWQiOiIxNzQ4NTc2NjI4NTIxMTMwIn0; user=\"2|1:0|10:1524743811|4:user|736:eyJzdGF0dXMiOiAiQWN0aXZlIiwgInVzZXJuYW1lIjogIldhaSBZYW4gTWluIEh0d2UiLCAiYWNjZXNzdG9rZW4iOiAiRUFBWThnUWpuZ1lFQkFETjlvTjBxSkxtNmpkeXp1cElEMXhiV3FFSUJ3N3pPUExPSjVnWWhaQjE4bmxCOWNZVEcxbUJFWkNWOXJ4UzdtWXJ4M3JzeDZWTUxjOGo4eWdXNnRwWW9zV2g3em1MUHFENEM0dmZpR1VvZEtuMTdyUDNSYUt2NFloSnRsT0VtVnZKbWpQam90RlFHUjYyWkJiZGJOWkFPcURET2tia1ZYc3haQXB2dWFuNURQZGRuRzYzdGhFNUZFR2dWbnZLdGRUQWp2dW5lWkFERDBiTTBCT29aQ0laRCIsICJ1c2VyX3VybCI6ICJodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8xNzQ4NTc2NjI4NTIxMTMwL3BpY3R1cmUiLCAic3RhbXAiOiB7InRpbWV6b25lIjogIiswMDowMCIsICIkcmVxbF90eXBlJCI6ICJUSU1FIiwgImVwb2NoX3RpbWUiOiAxNTI0NzQzODExLjM1Mn0sICJmYnVzZXJJZCI6ICIxNzQ4NTc2NjI4NTIxMTMwIiwgInJvbGUiOiAiUGF0aWVudCIsICJpZCI6ICJlNmQ1NWJlNy0wYjRmLTQ1YWUtOWEyYS1mNjlmZTE3MjZhMjgifQ==|2ccab98777a4f3bffd79e002860f5a19226780d7271a1de8d3f03f6a6f2d66b6\"'})\nTraceback (most recent call last):\nFile \"/home/wymh/anaconda2/envs/hexcode/lib/python2.7/site-packages/tornado/web.py\", line 1467, in _execute\nresult = method(*self.path_args, **self.path_kwargs)\nTypeError: 'Table' object is not callable\nGet request is working but post is not work.\nI create the following code.\n`class categoryHandler(JsonHandler):\n@tornado.web.authenticated\n@gen.coroutine\ndef get(self):\n    _id = self.request.headers.get('userid')\n    if _id:\n        feed = yield self.category.order_by('stamp').run(time_format=\"raw\")\n    self.write(dict(category=feed))\n\n\n@gen.coroutine\ndef post(self):\n    _id = self.request.headers.get('userid')\n    cat_name = self.get_argument('name', default = None)\n    logging.info(cat_name)\n    if _id:\n        result = yield self.category.insert(category_json['category'],return_changes=True).run(time_format=\"raw\")\n        self.write(dict(post = [result['changes'][0]['new_val']]))`\nPls help me.", "issue_status": "Closed", "issue_reporting_time": "2018-04-26T12:23:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "192": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2365", "issue_id": "#2365", "issue_summary": "tornado.gen.with_timeout dose not work with coroutine ?", "issue_description": "LiangXianSen commented on 26 Apr 2018 \u2022\nedited\ndevelopment environment:\npython 3.5.1\ntornado 4.5.2\nused ThreadPoolExecutor :\nimport time\nimport datetime\nimport os\nimport tornado.web\nfrom tornado import gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\n\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('index')\n        print('index')\n\n\nclass NonBlockingHandler(tornado.web.RequestHandler):\n    executor = ThreadPoolExecutor(4)\n\n    @gen.coroutine\n    def get(self):\n        try:\n            start = time.time()\n            result1, result2 = yield gen.with_timeout(datetime.timedelta(seconds=1), [self.doing(), self.doing()], quiet_exceptions=tornado.gen.TimeoutError)\n            self.write(\"NO Timeout\")\n            print(result1, result2)\n            print(time.time() - start)\n        except gen.TimeoutError:\n            self.write(\"Timeout\")\n            print(\"Timeout\")\n            print(time.time() - start)\n\n    @run_on_executor\n    def doing(self):\n        # time.sleep(10)\n        # yield gen.sleep(10)\n        os.system(\"ping -c 20 www.baidu.com\")  # \u6a21\u62dfI/O \u4efb\u52a1\n        return 'Non-Blocking'\n\n\napplication = tornado.web.Application([\n    (r\"/index\", IndexHandler),\n    (r\"/nonblocking\", NonBlockingHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\noutput:\n/usr/local/bin/python3 /Users/lianliang/Desktop/yisuo-faceid/learning/futures-threadpool-timeout.py\nPING www.a.shifen.com (61.135.169.121): 56 data bytes\n64 bytes from 61.135.169.121: icmp_seq=0 ttl=52 time=53.593 ms\nTimeout\n1.0016818046569824\n64 bytes from 61.135.169.121: icmp_seq=1 ttl=52 time=92.630 ms\n64 bytes from 61.135.169.121: icmp_seq=2 ttl=52 time=100.531 ms\n64 bytes from 61.135.169.121: icmp_seq=3 ttl=52 time=17.301 ms\n64 bytes from 61.135.169.121: icmp_seq=4 ttl=52 time=13.203 ms\nindex\n64 bytes from 61.135.169.121: icmp_seq=5 ttl=52 time=40.333 ms\n64 bytes from 61.135.169.121: icmp_seq=6 ttl=52 time=81.788 ms\n... ...\nthat is correct. After that I used coroutine :\nimport time\nimport datetime\nimport os\nimport tornado.web\nfrom tornado import gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\n\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write('index')\n        print('index')\n\n\nclass NonBlockingHandler(tornado.web.RequestHandler):\n    executor = ThreadPoolExecutor(4)\n\n    @gen.coroutine\n    def get(self):\n        try:\n            start = time.time()\n            result1, result2 = yield gen.with_timeout(datetime.timedelta(seconds=1), [self.doing(), self.doing()], quiet_exceptions=tornado.gen.TimeoutError)\n            self.write(\"NO Timeout\")\n            print(result1, result2)\n            print(time.time() - start)\n        except gen.TimeoutError:\n            self.write(\"Timeout\")\n            print(\"Timeout\")\n            print(time.time() - start)\n\n    @gen.coroutine\n    def doing(self):\n        # time.sleep(10)\n        # yield gen.sleep(10)\n        os.system(\"ping -c 20 www.baidu.com\")  # \u6a21\u62dfI/O \u4efb\u52a1\n        return 'Non-Blocking'\n\n\napplication = tornado.web.Application([\n    (r\"/index\", IndexHandler),\n    (r\"/nonblocking\", NonBlockingHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\noutput:\n... ...\n64 bytes from 61.135.169.121: icmp_seq=19 ttl=52 time=24.226 ms\n\n--- www.a.shifen.com ping statistics ---\n20 packets transmitted, 20 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 4.867/41.387/82.361/22.810 ms\nNon-Blocking Non-Blocking\n38.22840881347656\nindex\ntornado.gen.with_timeout dose not work, I don't know why?", "issue_status": "Closed", "issue_reporting_time": "2018-04-26T04:08:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "193": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2363", "issue_id": "#2363", "issue_summary": "RuntimeError: There is no current event loop in thread 'Thread-2'.", "issue_description": "cleverbao commented on 24 Apr 2018\nAbout tornado error: RuntimeError: There is no current event loop in thread 'Thread-2'.\nUsing threads to call websocket.write_message() function in the program, an error occurs.\nthis my code:\nclass SocketHandler(tornado.websocket.WebSocketHandler):\nwaiters = set()\ndef init(self, application, request):\nsuper(SocketHandler, self).init(application, request)\nthreading.Thread(target = self.__send_messages, args = (que,)).start()\ndef allow_draft76(self):\n# for iOS 5.0 Safari\nreturn True\ndef check_origin(self, origin):\n# set open must with Browser\nreturn True\ndef open(self):\nusername = self.get_secure_cookie('cookie_user')\nif not username:\nreturn\nSocketHandler.waiters.add(self)\ndef on_close(self):\nSocketHandler.waiters.remove(self)\ndef on_message(self, message):\n@classmethod\ndef __send_messages(cls, que):\nwhile 1:\nstatus = json.dumps(que.get())\nfor waiters in cls.waiters:\ntry:\nwaiters.write_message(status)\nexcept Exception as e:\ncontinue\nque.queue.clear()\nI searched for some issues and said that it is asyncio and threading problems.\nHere is the sample code:\nImport asyncio\nImport time, threading\nDef loop():\n    Print('thread %s is running...' % threading.current_thread().name)\n    Loop = asyncio.get_event_loop()\n    Time.sleep(1)\n    Print('thread %s ended.' % threading.current_thread().name)\nIf name == 'main':\n    Print('thread %s is running...' % threading.current_thread().name)\n    t = threading.Thread(target=loop, name='LoopThread')\n    T.start()\n    T.join()\n    Print('thread %s ended.' % threading.current_thread().name)\nError message:\nRuntimeError: There is no current event loop in thread 'LoopThread'.\nHis solution:\nDef loop():\n    Print('thread %s is running...' % threading.current_thread().name)\n    New_loop = asyncio.new_event_loop()\n    Asyncio.set_event_loop(new_loop)\n    Loop = asyncio.get_event_loop()\n    Time.sleep(1)\n    Print('thread %s ended.' % threading.current_thread().name)\nHowever, I am getting an error when modifying the tornado source code.", "issue_status": "Closed", "issue_reporting_time": "2018-04-24T09:09:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "194": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2362", "issue_id": "#2362", "issue_summary": "Proxy host not working when using a subclass of httprequest and AsyncHTTPClient", "issue_description": "gabeorlanski commented on 23 Apr 2018\nHello. I am having the issue where I cannot use proxy hosts with the AsyncHTTPClient. I installed curl and am using the curl_httpclient.CurlAsyncHTTPClient. I am using the AsyncHTTPClient to build a scraper. Here is my code for the Custom httprequest:\nconfig = {\n    'proxy_host': '185.85.21.6',\n    'proxy_port': 53281\n}\n\n\nclass CustomHTTPRequest(HTTPRequest):\n    \"\"\"We're going to subclass HTTPRequest\"\"\"\n\n    _DEFAULTS = dict(connect_timeout=20.0, request_timeout=20.0, follow_redirects=True, max_redirects=5, decompress_response=True, proxy_password='',\n            allow_nonstandard_methods=False, validate_cert=True)\n\n    def __init__(self, url, method=\"GET\", headers=None, body=None, auth_username=None, auth_password=None, auth_mode=None, connect_timeout=None,\n                 request_timeout=None, if_modified_since=None, follow_redirects=None, max_redirects=None, user_agent=None, use_gzip=None,\n                 network_interface=None, streaming_callback=None, header_callback=None, prepare_curl_callback=None, proxy_host=None, proxy_port=None,\n                 proxy_username=None, proxy_password=None, proxy_auth_mode=None, allow_nonstandard_methods=None, validate_cert=None, ca_certs=None,\n                 allow_ipv6=None, client_key=None, client_cert=None, body_producer=None, expect_100_continue=False, decompress_response=None,\n                 ssl_options=None, key=None):\n\n        self.headers = headers\n        if if_modified_since:\n            self.headers[\"If-Modified-Since\"] = httputil.format_timestamp(if_modified_since)\n        self.proxy_host = proxy_host\n        self.proxy_port = proxy_port\n        self.proxy_username = proxy_username\n        self.proxy_password = proxy_password\n        self.proxy_auth_mode = proxy_auth_mode\n        self.url = url\n        self.method = method\n        self.body = body\n        self.body_producer = body_producer\n        self.auth_username = auth_username\n        self.auth_password = auth_password\n        self.auth_mode = auth_mode\n        self.connect_timeout = connect_timeout\n        self.request_timeout = request_timeout\n        self.follow_redirects = follow_redirects\n        self.max_redirects = max_redirects\n        self.user_agent = user_agent\n        self.key = key\n        if decompress_response is not None:\n            self.decompress_response = decompress_response\n        else:\n            self.decompress_response = use_gzip\n        self.network_interface = network_interface\n        self.streaming_callback = streaming_callback\n        self.header_callback = header_callback\n        self.prepare_curl_callback = prepare_curl_callback\n        self.allow_nonstandard_methods = allow_nonstandard_methods\n        self.validate_cert = validate_cert\n        self.ca_certs = ca_certs\n        self.allow_ipv6 = allow_ipv6\n        self.client_key = client_key\n        self.client_cert = client_cert\n        self.ssl_options = ssl_options\n        self.expect_100_continue = expect_100_continue\n        self.start_time = time.time()\nHere is the code for the requester:\nclass Scraper():\n\n    def __init__(self, request_params=[{}], max_clients=100, maxsize=100, connect_timeout=9999999, request_timeout=9999999, auth_username=None,\n            auth_password=None, method='GET', func=None, sleep=0, endpoint=None):\n        self.sleep = sleep\n        self.endpoint = endpoint\n        \"\"\"Instantiate a tornado async http client to do multiple concurrent requests\"\"\"\n        self.max_clients = max_clients\n        AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\", max_clients=100, defaults=config)\n        self.request_params = request_params\n        self.method = method\n\n        self.maxsize = maxsize\n        self.auth_username = auth_username\n        self.auth_password = auth_password\n        self.connect_timeout = connect_timeout\n        self.request_timeout = request_timeout\n        self.to_return = []\n        self.http_client =AsyncHTTPClient()\n        self.queue = Queue(maxsize=self.maxsize)\n        self.func = func\n        self.read(self.request_params)\n        self.get(self.connect_timeout, self.request_timeout, self.http_client)\n        self.loop = ioloop.IOLoop.current()\n        self.join_future = self.queue.join()\n\n        def done(future):\n            self.loop.stop()\n\n        self.join_future.add_done_callback(done)\n        self.loop.start()\n\n    @gen.coroutine\n    def read(self, request_params):\n        for request_param in request_params:\n            yield self.queue.put(request_param)\n\n    @gen.coroutine\n    def get(self, connect_timeout, request_timeout, http_client):\n        print(\"Getting Links\")\n        self.counter = 1\n        while True:\n            request_param = yield self.queue.get()\n            url = request_param.get('url', self.endpoint)\n            body = request_param.get('body', None)\n            dictKey = request_param['dictKey']\n            # request_param['headers']['dictKey'] = dictKey\n\n            request = CustomHTTPRequest(url, method=self.method, headers=request_param['headers'], body=body, connect_timeout=connect_timeout,\n                    request_timeout=request_timeout, auth_username=self.auth_username, auth_password=self.auth_password, key=dictKey)\n\n            def handle_response(response):\n                if not self.func:\n                    if response.error:\n                        self.to_return.append({'key': response.request.__dict__['key'], 'response': str(response.error)})\n                    else:\n                        self.to_return.append({'key': response.request.__dict__['key'], 'response': response.body})\n                else:\n                    try:\n                        self.func(response.body, response.request.__dict__['key'])\n                    except Exception as e:\n                        pass\n                # print(self.counter)\n                self.counter += 1\n                self.queue.task_done()\n\n            future = self.http_client.fetch(request, handle_response)\n\n            time.sleep(self.sleep)\n\n    def return_results(self):\n        return self.to_return\nWhen I run that, it returns (as the body) (43, ''). It doesn't raise an error. It just returns that.", "issue_status": "Closed", "issue_reporting_time": "2018-04-23T00:19:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "195": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2358", "issue_id": "#2358", "issue_summary": "websocket: Allow open() to be a coroutine", "issue_description": "cngo-github commented on 20 Apr 2018\nAccording to this PR, the websocket handler's open method cannot be a coroutine: #1650\nIs this still true?", "issue_status": "Closed", "issue_reporting_time": "2018-04-20T05:09:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "196": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2354", "issue_id": "#2354", "issue_summary": "dead jupyter kernel as soon as the notebook starts", "issue_description": "JyotsnaT commented on 12 Apr 2018 \u2022\nedited\nI am using jupyter 4.4.0, ipython 5.3.0 with python 2.7.12 on ubuntu 16.04. I recently installed jupyter using pip. But as soon as I open a notebook, the kernel dies with the following error.\nRuntimeError: IOLoop is already running\n[I 07:12:14.164 NotebookApp] KernelRestarter: restarting kernel (3/5), new random ports\nTraceback (most recent call last):\nFile \"/usr/lib/python2.7/runpy.py\", line 174, in _run_module_as_main\n\"main\", fname, loader, pkg_name)\nFile \"/usr/lib/python2.7/runpy.py\", line 72, in _run_code\nexec code in run_globals\nFile \"/usr/local/lib/python2.7/dist-packages/ipykernel_launcher.py\", line 16, in\napp.launch_new_instance()\nFile \"/usr/local/lib/python2.7/dist-packages/traitlets/config/application.py\", line 658, in launch_instance\napp.start()\nFile \"/usr/local/lib/python2.7/dist-packages/ipykernel/kernelapp.py\", line 477, in start\nioloop.IOLoop.instance().start()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 928, in start\nraise RuntimeError(\"IOLoop is already running\")\nRuntimeError: IOLoop is already running\n[W 07:12:15.167 NotebookApp] Timeout waiting for kernel_info reply from 70106048-4b5a-4c24-a62c-45a3305cf243\n[I 07:12:17.171 NotebookApp] KernelRestarter: restarting kernel (4/5), new random ports\nWARNING:root:kernel 70106048-4b5a-4c24-a62c-45a3305cf243 restarted\nTraceback (most recent call last):\nFile \"/usr/lib/python2.7/runpy.py\", line 174, in _run_module_as_main\n\"main\", fname, loader, pkg_name)\nFile \"/usr/lib/python2.7/runpy.py\", line 72, in _run_code\nexec code in run_globals\nFile \"/usr/local/lib/python2.7/dist-packages/ipykernel_launcher.py\", line 16, in\napp.launch_new_instance()\nFile \"/usr/local/lib/python2.7/dist-packages/traitlets/config/application.py\", line 658, in launch_instance\napp.start()\nFile \"/usr/local/lib/python2.7/dist-packages/ipykernel/kernelapp.py\", line 477, in start\nioloop.IOLoop.instance().start()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 928, in start\nraise RuntimeError(\"IOLoop is already running\")\nRuntimeError: IOLoop is already running\n[W 07:12:20.182 NotebookApp] KernelRestarter: restart failed\n[W 07:12:20.182 NotebookApp] Kernel 70106048-4b5a-4c24-a62c-45a3305cf243 died, removing from map.\nERROR:root:kernel 70106048-4b5a-4c24-a62c-45a3305cf243 restarted failed!\n[W 07:12:20.193 NotebookApp] 410 DELETE /api/sessions/f5f784a8-4c4a-4629-ac09-25cb33e651fd (127.0.0.1): Kernel deleted before session\n[W 07:12:20.194 NotebookApp] Kernel deleted before session\n[W 07:12:20.195 NotebookApp] 410 DELETE /api/sessions/f5f784a8-4c4a-4629-ac09-25cb33e651fd (127.0.0.1) 3.79ms referer=http://localhost:8888/notebooks/acad/new_note.ipynb\nI have tried cleaning up jupyter from pip list and reinstalling. But this doesn't work. I also referred to #1796, doesn't solve my purpose. Any leads on this?", "issue_status": "Closed", "issue_reporting_time": "2018-04-12T01:38:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "197": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2352", "issue_id": "#2352", "issue_summary": "RuntimeError: There is no current event loop in thread 'Thread-1'.", "issue_description": "rgaufman commented on 9 Apr 2018\nI have this code:\n#!/usr/bin/env python3\n\nimport threading\nimport tornado.ioloop\nimport tornado.web\nfrom tornado import gen\n\nclass RequestHandler(tornado.web.RequestHandler):\n\n    @tornado.web.asynchronous\n    @gen.coroutine\n    def get(self, path):\n        self.write(\"Test\")\n        self.finish()\n\nclass WebServer(threading.Thread):\n    def run(self):\n        application = tornado.web.Application([\n            (r\"/(.*)\", RequestHandler)])\n        application.listen(12345)\n        tornado.ioloop.IOLoop.instance().start()\n\nWebServer().start()\nIt works just fine on Linux, however, on Mac I get an exception:\n$ python3 testtornado.rb\nException in thread Thread-1:\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py\", line 916, in _bootstrap_inner\n    self.run()\n  File \"testtornado.rb\", line 20, in run\n    application.listen(12345)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/web.py\", line 1986, in listen\n    server.listen(port, address)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/tcpserver.py\", line 145, in listen\n    self.add_sockets(sockets)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/tcpserver.py\", line 159, in add_sockets\n    sock, self._handle_connection)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/netutil.py\", line 219, in add_accept_handler\n    io_loop = IOLoop.current()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/ioloop.py\", line 282, in current\n    loop = asyncio.get_event_loop()\n  File \"/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/events.py\", line 694, in get_event_loop\n    return get_event_loop_policy().get_event_loop()\n  File \"/usr/local/Cellar/python/3.6.5/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/events.py\", line 602, in get_event_loop\n    % threading.current_thread().name)\nRuntimeError: There is no current event loop in thread 'Thread-1'.\nAny ideas?\nI'm using tornado (5.0.2) and Python 3.6.5.", "issue_status": "Closed", "issue_reporting_time": "2018-04-09T15:46:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "198": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2347", "issue_id": "#2347", "issue_summary": "python crash on importing tornado.gen on some windows installations", "issue_description": "jonathon-love commented on 7 Apr 2018\nhi,\ni'm debugging a very strange issue in our tornado using application, and what i'm finding on a small number of user's machines, is that after tornado is imported, the execution of the program stops. (i.e. subsequent imports don't take place).\ni've asked users to run the application with the -vvv flags, and have received this log:\nhttps://gist.github.com/jonathon-love/06eaf7433f7ee84b9d569f852bf0225e\n(if you scroll to the bottom of the log, i have a comment describing things with line numbers).\nwe had this issue with earlier versions of tornado, and so we tried updating to the 5.0 series, but have found the same issue (with multiple users).\nour application performs the following imports:\nimport tornado.ioloop\nimport tornado.netutil\nimport tornado.httpserver\n\nfrom tornado.web import RequestHandler\nfrom tornado.web import StaticFileHandler\nfrom tornado.web import stream_request_body\nfrom tornado.concurrent import Future\nfrom tornado import gen\n\n# this is never imported ... the execution seems to stop here ...\nfrom .clientconnection import ClientConnection\nis this something tornado related? or something else?\nwith thanks", "issue_status": "Closed", "issue_reporting_time": "2018-04-07T01:27:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "199": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2345", "issue_id": "#2345", "issue_summary": "FallbackHandler does not execute RequestHandler.on_finish()", "issue_description": "Contributor\nLiranLast commented on 6 Apr 2018 \u2022\nedited\nWhen using FallbackHandler for running a WSGI application using WSGIContainer the RequestHandler.on_finish() method is never called.\nModifying FallbackHandler.prepare() this way seems to fix the issue, but I may not be familiar enough with Tornado's internals.\n    def prepare(self):\n        self.fallback(self.request)\n        self._finished = True\n        self.on_finished()", "issue_status": "Closed", "issue_reporting_time": "2018-04-05T20:36:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "200": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2344", "issue_id": "#2344", "issue_summary": "Different versions of Tornado come out different results when running thread in coroutine", "issue_description": "huashengdun commented on 4 Apr 2018 \u2022\nedited\nHere is the demo code.\nimport threading\nimport time\nfrom tornado.concurrent import Future\nfrom tornado import gen, ioloop\n\n\n@gen.coroutine\ndef foo(url):\n    future = Future()\n    threading.Thread(target=fetch_url_wrapped, args=(url, future)).start()\n    res = yield future\n    print(res)\n\n\ndef fetch_url(url):\n    time.sleep(1)\n    return 'hello world'\n\n\ndef fetch_url_wrapped(url, future):\n    print('fetching {}'.format(url))\n    result = fetch_url(url)\n    future.set_result(result)\n    print('set result {}'.format(result))\n\nloop = ioloop.IOLoop.current()\nloop.run_sync(lambda: foo('http://bar.com'))\nBefore Tornado 5.0.0, it is ok.\nAfter version 5.0.0 (including 5.0.0), the program just blocks.", "issue_status": "Closed", "issue_reporting_time": "2018-04-04T13:30:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "201": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2343", "issue_id": "#2343", "issue_summary": "Exception in tornado iostream.", "issue_description": "cici-tan commented on 4 Apr 2018\nAnyone know why this happened?", "issue_status": "Closed", "issue_reporting_time": "2018-04-04T07:44:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "202": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2342", "issue_id": "#2342", "issue_summary": "torando import error", "issue_description": "cuckoo-linux commented on 3 Apr 2018\npip install -r ~/klara-github-repo/install/requirements.txt\nRequirement already satisfied: torndb in /usr/local/lib/python2.7/dist-packages (from -r /home/projects/klara-github-repo/install/requirements.txt (line 1))\nRequirement already satisfied: requests in /usr/local/lib/python2.7/dist-packages (from -r /home/projects/klara-github-repo/install/requirements.txt (line 2))\nCollecting tornado (from -r /home/projects/klara-github-repo/install/requirements.txt (line 3))\n/usr/local/lib/python2.7/dist-packages/pip/vendor/urllib3/util/ssl.py:339: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\nSNIMissingWarning\n/usr/local/lib/python2.7/dist-packages/pip/vendor/urllib3/util/ssl.py:137: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings\nInsecurePlatformWarning\n**Could not find a version that satisfies the requirement tornado (from -r /home/projects/klara-github-repo/install/requirements.txt (line 3)) (from versions: )\nNo matching distribution found for tornado (from -r /home/projects/klara-github-repo/install/requirements.txt (line 3))\n$ pip -V\npip 9.0.3 from /usr/local/lib/python2.7/dist-packages (python 2.7)", "issue_status": "Closed", "issue_reporting_time": "2018-04-03T06:10:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "203": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2341", "issue_id": "#2341", "issue_summary": "Websocket client memory overflow", "issue_description": "Contributor\nwillmcgugan commented on 2 Apr 2018\nAs far as I can tell, tornado has no 'flow control' for websockets. A websocket will receive data as fast as it can, and store the data in a deque. If that data is not consumed as fast as it is written, then that deque will grow in size indefinitely, ultimately leading to a memory error and killing the process.\nThis seems to be occurring in practice when we send large files over our Tornado websocket server. I also suspect that it makes a websocket server vulnerable to a DOS attack. A simple chat application for example, where one client is on a slow internet connection and the other is on a fast connection. If the client on the fast connection sends packets fast enough, it could kill the server.\nIs this a known issue? Are there any workarounds?\nI think the ideal solution may be to have no user space buffer at all, so that a websocket may only read as fast as the data is consumed.", "issue_status": "Closed", "issue_reporting_time": "2018-04-02T15:38:57Z", "fixed_by": "#2351", "pull_request_summary": "Fix out of memory issue with websocket client", "pull_request_description": "Contributor\nwillmcgugan commented on 9 Apr 2018\nReplaces the deque in the websocket client with a tornado Queue, as per @bdarnell 's suggestion.\nThis fixes #2341", "pull_request_status": "Merged", "issue_fixed_time": "2018-04-20T23:31:29Z", "files_changed": [["18", "tornado/websocket.py"]]}, "204": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2340", "issue_id": "#2340", "issue_summary": "Leaking file descriptors in 5.0 after loop.close", "issue_description": "Contributor\nmrocklin commented on 2 Apr 2018\nThe command loop.close(all_fds=True) seems to still leave some file descriptors open. This appears to be new.\n4.5.3\nIn [1]: import psutil\nIn [2]: from tornado.ioloop import IOLoop\nIn [3]: psutil.Process().num_fds()\nOut[3]: 14\n\nIn [4]: loop = IOLoop()\nIn [5]: psutil.Process().num_fds()\nOut[5]: 16\n\nIn [6]: loop.close(all_fds=True)\nIn [7]: psutil.Process().num_fds()\nOut[7]: 14\n\nIn [8]: import tornado\nIn [9]: tornado.version\nOut[9]: '4.5.3'\n5.0\nIn [1]: import psutil\nIn [2]: from tornado.ioloop import IOLoop\nIn [3]: psutil.Process().num_fds()\nOut[3]: 14\n\nIn [4]: loop = IOLoop()\nIn [5]: psutil.Process().num_fds()\nOut[5]: 20\n\nIn [6]: loop.close(all_fds=True)\nIn [7]: psutil.Process().num_fds()\nOut[7]: 17\n\nIn [8]: import tornado\nIn [9]: tornado.version\nOut[9]: '5.0'\nI've also tried this on master and get the same result", "issue_status": "Closed", "issue_reporting_time": "2018-04-02T13:35:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "205": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2339", "issue_id": "#2339", "issue_summary": "Release 5.0.2", "issue_description": "Member\nbdarnell commented on 1 Apr 2018\nWe've fixed a few regressions since 5.0.1, so it's about time for a new release. I think it should include\n#2326 (memory leak, especially with sync HTTPClient)\n#2327 (testing, improves compatibility with pytest-asyncio)\n#2338 (PeriodicCallback misbehaves when clock moves backwards)", "issue_status": "Closed", "issue_reporting_time": "2018-03-31T22:49:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "206": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2337", "issue_id": "#2337", "issue_summary": "creating basic server breaks in 5.0.1, but works in 4.5.2", "issue_description": "heppg commented on 31 Mar 2018 \u2022\nedited\nCreate a server in a thread (code shortened for clarity):\n1547 self.app = self.make_app()\n1548 self.app.listen( 8080)\n1549 if debug:\n1550 print(\"ServerThread tornado ioloop started\")\n1551 tornado.ioloop.IOLoop.current().start()\nSystem is Python 3.5.3 (default, Jan 19 2017, 14:11:04)\n[GCC 6.3.0 20170124] on linux\nIn 5.0.1, I get an exception in app.listen:\nTraceback (most recent call last):\nFile \"/home/pi/scratchClient/src/server/scratchClientServer.py\", line 1548, in run\nself.app.listen( 8080)\nFile \"/usr/local/lib/python3.5/dist-packages/tornado/web.py\", line 1986, in listen\nserver.listen(port, address)\nFile \"/usr/local/lib/python3.5/dist-packages/tornado/tcpserver.py\", line 145, in listen\nself.add_sockets(sockets)\nFile \"/usr/local/lib/python3.5/dist-packages/tornado/tcpserver.py\", line 159, in add_sockets\nsock, self._handle_connection)\nFile \"/usr/local/lib/python3.5/dist-packages/tornado/netutil.py\", line 219, in add_accept_handler\nio_loop = IOLoop.current()\nFile \"/usr/local/lib/python3.5/dist-packages/tornado/ioloop.py\", line 283, in current\nloop = asyncio.get_event_loop()\nFile \"/usr/lib/python3.5/asyncio/events.py\", line 671, in get_event_loop\nreturn get_event_loop_policy().get_event_loop()\nFile \"/usr/lib/python3.5/asyncio/events.py\", line 583, in get_event_loop\n% threading.current_thread().name)\nRuntimeError: There is no current event loop in thread 'GUIServerThread_0'.\nThe .IOLoop.current().start() is not executed.\nThe code runs with release 4.5.2. As a workaround, I changed the tornado version back to 4.5.2 in installation documentation.", "issue_status": "Closed", "issue_reporting_time": "2018-03-31T16:45:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "207": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2334", "issue_id": "#2334", "issue_summary": "on_finish() not being called when *server* finishes first; finish() called *twice*. (c.f. #517)", "issue_description": "sam-falvo commented on 31 Mar 2018\nThis is not a duplicate issue to #517, because I'm forcing the server to close the connection first. Apparently twice, but this is actually a separate issue.\nSo far as I'm able to tell by spelunking through the code in Tornado, it unconditionally is supposed to call on_finish. However, I'm showing no evidence this call is being made. None of my logs contains any on_finish or on_connection_close output.\nI'm running the following code in my web-app for testing purposes:\nclass HealthHandler(CorsMixin, V3Handler):                                                                                                                                                    \n                                                                                                                                                                                              \n    \"\"\"                                                                                                                                                                                       \n    This class handles GETs to /.  This serves two purposes:                                                                                                                                  \n    for programmers, it's a nice cheat-sheet to create your own handler                                                                                                                       \n    classes with; and, for operations, it's a convenient health-check.                                                                                                                        \n    If the server responds, we know that the V3 event loop is up.                                                                                                                             \n    \"\"\"                                                                                                                                                                                       \n                                                                                                                                                                                              \n    CORS_ORIGIN = '*'                                                                                                                                                                         \n    CORS_METHODS = 'GET'                                                                                                                                                                      \n                                                                                                                                                                                              \n    def get(self):                                                                                                                                                                            \n        LOG.info(\"Health checked\")\n        self._ok(\"Health check OK\")                                                                                                                                                           \nThe V3Handler class is defined like so:\nclass V3Handler(RequestHandler):                                                                                                                                                              \n    \"\"\"                                                                                                                                                                                       \n    This class provides a common handler base class for all V3 handlers.                                                                                                                      \n    It enhances RequestHandler with the following features:                                                                                                                                   \n                                                                                                                                                                                              \n    - Standard responses for API endpoints, including both error and success                                                                                                                  \n      methods.                                                                                                                                                                                \n                                                                                                                                                                                              \n    - Standardized request logging.                                                                                                                                                           \n    \"\"\"                                                                                                                                                                                       \n                                                                                                                                                                                              \n    # V3Handler-specific logic                                                                                                                                                                \n                                                                                                                                                                                              \n    def _log(self, meth, status, msg):                                                                                                                                                        \n        self.set_status(status)                                                                                                                                                               \n        self.write(msg)                                                                                                                                                                       \n        meth(\"{}\".format(msg))                                                                                                                                                                \n        self.finish()                                                                                                                                                                         \n                                                                                                                                                                                              \n    def _error(self, msg, status=404):                                                                                                                                                        \n        self._log(LOG.error, status, err(msg))                                                                                                                                                \n                                                                                                                                                                                              \n    def _exception(self, msg, status=500):                                                                                                                                                    \n        self._log(LOG.exception, status, err(msg))                                                                                                                                            \n                                                                                                                                                                                              \n    def _ok(self, msg=None):                                                                                                                                                                  \n        self.write(ok(msg))                                                                                                                                                                   \n        self.finish()                                                                                                                                                                         \n                                                                                                                                                                                              \n    def missing_field(self, term):                                                                                                                                                            \n        self._exception(missing_field(term))                                                                                                                                                  \n                                                                                                                                                                                              \n    def not_live_system(self):                                                                                                                                                                \n        self._error(                                                                                                                                                                          \n            \"The given serial or token combination \"                                                                                                                                          \n            \"is not associated with a live system.\"                                                                                                                                           \n        )                                                                                                                                                                                     \n                                                                                                                                                                                              \n    def no_data(self, qualifier=None):                                                                                                                                                        \n        self._error(                                                                                                                                                                          \n            \"No data found{}\".format(\" for {}\".format(qualifier) if qualifier else \"\")                                                                                                        \n        )                                                                                                                                                                                     \n                                                                                                                                                                                              \n    def method_not_allowed(self):                                                                                                                                                             \n        self._error(\"Method not allowed\", status=405)                                                                                                                                         \n                                                                                                                                                                                              \n    # overriding RequestHandler methods                                                                                                                                                       \n                                                                                                                                                                                              \n    def prepare(self):                                                                                                                                                                        \n        method = self.request.method                                                                                                                                                          \n        url = self.request.path                                                                                                                                                               \n        source = self.request.remote_ip                                                                                                                                                       \n        LOG.info(\"{} - {} {}\".format(source, method, url))                                                                                                                                    \n                                                                                                                                                                                              \n    def finish(self, *args, **kw_args):                                                                                                                                                       \n        print(\"FINISH!!\")                                                                                                                                                                     \n        self.on_finish()                                                                                                                                                                      \n        return super(V3Handler, self).finish(*args, **kw_args)                                                                                                                                \n                                                                                                                                                                                              \n    def on_finish(self):                                                                                                                                                                      \n        print(\"FINI\")                                                                                                                                                                         \n        LOG.info(\"FINI.\")                                                                                                                                                                     \nWhen I issue a curl command to GET the / endpoint, I receive back a response and the HTTP connection closes, as one would expect. I also find the following on the log output:\n2018-03-30 12:29:22,225 - __main__ - INFO - Health checked\nFINISH!!\nFINI\n2018-03-30 12:29:22,225 - src.server.generic_handler - INFO - FINI.\nFINISH!!\nFINI\n2018-03-30 12:29:22,231 - src.server.generic_handler - INFO - FINI.\nLooks like everything is working correctly; however, if I remove the invokation of self.on_finish() in my override of finish, the resulting logs are produced instead, clearly showing that on_finish is not being called by the finish method, and apparently contradicting the source listing:\n2018-03-30 12:28:54,339 - __main__ - INFO - Health checked\nFINISH!!\nFINISH!!\nIn my project's requirements.txt file, I have the following listed:\ntornado==4.5.3\ntornado_cors==0.6.0\nWhat steps must I take to reliably get on_finish called?\nThanks for any help you can provide. If you need more information from me, I'd be happy to help provide it if I can.", "issue_status": "Closed", "issue_reporting_time": "2018-03-30T19:40:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "208": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2333", "issue_id": "#2333", "issue_summary": "ioloop: PeriodicCallback executes too often on windows", "issue_description": "wanghongzhou commented on 30 Mar 2018 \u2022\nedited\nHere is the code:\nimport math\nimport logging\nfrom crontab import CronTab\nfrom tornado.ioloop import PeriodicCallback, IOLoop\nlogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nclass CronTabCallback(PeriodicCallback):\ndef __init__(self, callback, schedule):\n    self._callback = callback\n    self._crontab = CronTab(schedule)\n    super(CronTabCallback, self).__init__(self.run, self._calc_callbacktime())\n\ndef _calc_callbacktime(self, now=None):\n    return math.ceil(self._crontab.next(now)) * 1000.0\n\ndef run(self):\n    return self._callback()\n\ndef _schedule_next(self):\n    self.callback_time = self._calc_callbacktime()\n    logging.info('calc ---------------------')\n    logging.info('delay %s' % self.callback_time)\n    logging.info('last execute %s' % self._next_timeout)\n\n    last = self._next_timeout\n    super(CronTabCallback, self)._schedule_next()\n\n    if last == self._next_timeout:\n        logging.error('error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n\n    logging.info('current: %s' % self.io_loop.time())\n    logging.info('calc next: %s' % self._next_timeout)\n    logging.info('--------------------------\\n')\ndef crontab(schedule):\ndef decorator(func):\nCronTabCallback(func, schedule).start()\nreturn func\nreturn decorator\n@crontab('*/1 * * * *')\ndef run():\nlogging.info('execute ... \\n')\nif name == 'main':\nIOLoop.current().start()\nHere is the console log\n2018-03-30 11:33:00,311 - asyncio - DEBUG - Using selector: SelectSelector\n2018-03-30 11:33:00,316 - root - INFO - calc ---------------------\n2018-03-30 11:33:00,316 - root - INFO - delay 60000.0\n2018-03-30 11:33:00,316 - root - INFO - last execute 1522380780.3169544\n2018-03-30 11:33:00,316 - root - INFO - current: 1522380780.3169544\n2018-03-30 11:33:00,316 - root - INFO - calc next: 1522380840.3169544\n2018-03-30 11:33:00,316 - root - INFO - --------------------------\n2018-03-30 11:34:00,313 - root - INFO - execute ...\n2018-03-30 11:34:00,313 - root - INFO - calc ---------------------\n2018-03-30 11:34:00,313 - root - INFO - delay 60000.0\n2018-03-30 11:34:00,313 - root - INFO - last execute 1522380840.3169544\n2018-03-30 11:34:00,313 - root - ERROR - error !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n2018-03-30 11:34:00,313 - root - INFO - current: 1522380840.3139544\n2018-03-30 11:34:00,313 - root - INFO - calc next: 1522380840.3169544\n2018-03-30 11:34:00,313 - root - INFO - --------------------------\n2018-03-30 11:34:00,318 - root - INFO - execute ...\n2018-03-30 11:34:00,318 - root - INFO - calc ---------------------\n2018-03-30 11:34:00,318 - root - INFO - delay 60000.0\n2018-03-30 11:34:00,318 - root - INFO - last execute 1522380840.3169544\n2018-03-30 11:34:00,318 - root - INFO - current: 1522380840.3189545\n2018-03-30 11:34:00,318 - root - INFO - calc next: 1522380900.3169544\n2018-03-30 11:34:00,318 - root - INFO - --------------------------\nEnvironment:\nOS: windows 7\nPython: python 3.6\nDependent library: crontab 0.22.0\nTornado 4.5.1 python2 (ok) python3(ok)\nTornado 5.0.1 python2 (ok) python3 (linux ok, window has issue)", "issue_status": "Closed", "issue_reporting_time": "2018-03-30T03:48:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "209": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2331", "issue_id": "#2331", "issue_summary": "Installing tornado 5.0.1 with Python 2.7 causing ImportError: Tornado requires an up-to-date SSL module", "issue_description": "pramitkundu92 commented on 28 Mar 2018\nI am trying to install Tornado 5.0.1, getting this error -\npip install tornado\nCollecting tornado\nUsing cached tornado-5.0.1.tar.gz\nComplete output from command python setup.py egg_info:\nTraceback (most recent call last):\nFile \"\", line 1, in\nFile \"/tmp/pip-build-t2xMkH/tornado/setup.py\", line 146, in\nraise ImportError(\"Tornado requires an up-to-date SSL module. This means \"\nImportError: Tornado requires an up-to-date SSL module. This means Python 2.7.9+ or 3.4+ (although some distributions have backported the necessary changes to older versions).\nUpgraded python version from 2.7.5 to 2.7.13\nUpgraded openssl version from 1.0.1e 2013 to 1.0.2o 2018\nStill getting the same error.\nThe part of code in setup.py from where this error is raised, when i put that in a separate python script and run it, control is not even entering that block.\nPreviously had tornado 4.5 but needed an upgrade in order to use multiprocessing.\nAny help regarding this is deeply appreciated.\n7", "issue_status": "Closed", "issue_reporting_time": "2018-03-28T07:15:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "210": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2325", "issue_id": "#2325", "issue_summary": "'HTTPClient' object has no attribute '_closed' in tornado5.0", "issue_description": "DreamHackchosenone commented on 24 Mar 2018\nabout httpclient.HTTPClient()\nI can't execute http_client = httpclient.HTTPClient() in tornado==5.0\nrunning this will throw Exception this\uff1a\nTraceback (most recent call last):\nFile \"/Users/zhonghao/anaconda3/envs/tornado_test/lib/python3.6/site-packages/tornado/httpclient.py\", line 85, in del\nself.close()\nFile \"/Users/zhonghao/anaconda3/envs/tornado_test/lib/python3.6/site-packages/tornado/httpclient.py\", line 89, in close\nif not self._closed:\nAttributeError: 'HTTPClient' object has no attribute '_closed'\nbut in tornado==4.5.2\nit works fine, this issue on macOS\uff0ccan you tell me why\uff1f", "issue_status": "Closed", "issue_reporting_time": "2018-03-24T14:51:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "211": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2324", "issue_id": "#2324", "issue_summary": "Create AsyncIOLoop from existing asyncio event loop", "issue_description": "adamrothman commented on 24 Mar 2018\nCreating a new AsyncIOLoop always creates a new underlying asyncio event loop. I think this makes sense in most cases but it would be very helpful (especially for testing, read on) to be able to pass an existing asyncio event loop for Tornado to wrap.\nWe use pytest with the pytest-asyncio plugin to run our test suite for several Tornado applications. After upgrading one of these apps to Tornado 5 and improving our test hygiene to use a new event loop for each test, our test suite broke.\nOur unit tests are simple because they don't interact with or depend on tornado.testing.AsyncTestCase at all. Our integration tests do (because they make requests against the application), however, and this is where I ran into trouble. When I ran the tests, I would get a ton of errors due to Tasks getting Futures attached to a different loop, like this:\nRuntimeError: Task <Task pending coro=<test_get_targets() running at /Users/adam/Other/src/pusheen/tests/integration/application_api_test.py:279> cb=[IOLoop.add_future..() at /Users/adam/Other/src/pusheen/.tox/verbose/lib/python3.6/site-packages/tornado/ioloop.py:721]> got Future <Task pending coro=<AioBaseClient._make_api_call() running at /Users/adam/Other/src/pusheen/.tox/verbose/lib/python3.6/site-packages/aiobotocore/client.py:65>> attached to a different loop\npytest-asyncio creates a new event loop for each async test that it runs (which is a good thing). Previously we were overriding this behavior to always return the \"main\" loop via asyncio.get_event_loop() and explicitly not close the loop between tests. This worked under Tornado 4 because we were using AsyncIOMainLoop, and Tornado 4 did not close the underlying asyncio event loop in such a configuration. But this override has always felt kind of gross to me, so I resolved to remove it. After all, there's no reason it should be necessary; we are careful to pass the testing event loop to classes that require it so they don't grab the main loop by default. Plus, Tornado 5 does close the underlying loop when closing AsyncIOMainLoop.\nBut making this change borked our tests.\nWe have some setup code that is shared between the unit and integration tests. This setup is handled by pytest, so a number of async singletons (e.g. DB connectors) get configured to use the event loop created by pytest-asyncio for each test.\ntornado.testing.AsyncTestCase also creates a loop for each test \u2013 an IOLoop \u2013 by calling get_new_ioloop as part of setUp. This is still a good thing \u2013 but turned out to be the cause of my sadness. During the integration tests, our application logic is run by Tornado's loop, but per the above, the async singletons use pytest-asyncio's loop. When async code running on one loop tries to interact with async code on the other, people weep in the streets.\nBeing able to override AsyncTestCase.get_new_ioloop goes most of the way towards solving this issue. It's not difficult to expose pytest-asyncio's event loop to this function \u2013 the problem is that I can't use this existing asyncio event loop to instantiate the Tornado IOLoop get_new_ioloop is expected to return.\nFor now I'm working around this limitation by overriding pytest-asyncio's default behavior to first create an AsyncIOLoop and then using the underlying .asyncio_loop. This feels wrong, though. pytest shouldn't need to know about what's happening \"downstream\" as long as it implements a compatible test interface like unittest.TestCase.\nMine is just one (long-winded, sorry) case but I can imagine there are other situations in which users would want to provide an existing event loop to Tornado. What do you think @bdarnell?\n1", "issue_status": "Closed", "issue_reporting_time": "2018-03-23T22:29:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "212": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2323", "issue_id": "#2323", "issue_summary": "AsyncHTTPClient keeps request objects forever when fetching error responses", "issue_description": "fabiant7t commented on 23 Mar 2018 \u2022\nedited\nUsing Tornado as a proxy, I noticed that its memory usage increases.\nAsyncHTTPClient.fetch takes a request object and calls its URL. If the response is successful (2xx) or a redirection (3xx), this request object gets properly deleted/garbage collected.\nHowever, if the response is a client (4xx) or server error (5xx), the request is not being deleted and lives forever, eating RAM.\nTo reproduce in Python 3, spin up tornado_test.py and call\nhttp://localhost:8888/200\n-> You'll see 'Request object deleted' being printed to stdout right away\nhttp://localhost:8888/400\n-> You don't see 'Request object deleted' being printed to stdout. But you will after exiting the whole program with <Ctrl+C>.\nPython2 shows the same problem (see comment below).\n#!/usr/bin/python3\nimport weakref                                                                                                                                                                                                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \nimport tornado.httpclient                                                                                                                                                                                                                                                                                                                                                                                                                 \nimport tornado.ioloop                                                                                                                                                                                                                                                                                                                                                                                                                     \nimport tornado.gen                                                                                                                                                                                                                                                                                                                                                                                                                        \nimport tornado.web                                                                                                                                                                                                                                                                                                                                                                                                                        \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \nclass MainHandler(tornado.web.RequestHandler):                                                                                                                                                                                                                                                                                                                                                                                            \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n    @tornado.gen.coroutine                                                                                                                                                                                                                                                                                                                                                                                                                \n    def get(self, status):                                                                                                                                                                                                                                                                                                                                                                                                                \n        request = tornado.httpclient.HTTPRequest(                                                                                                                                                                                                                                                                                                                                                                                         \n            url='https://httpstat.us/{}'.format(status)                                                                                                                                                                                                                                                                                                                                                                                   \n        )                                                                                                                                                                                                                                                                                                                                                                                                                                 \n        weakref.finalize(request, lambda: print('Request object deleted'))                                                                                                                                                                                                                                                                                                                                                                          \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n        client = tornado.httpclient.AsyncHTTPClient()                                                                                                                                                                                                                                                                                                                                                                                     \n        response = yield client.fetch(request, raise_error=False)                                                                                                                                                                                                                                                                                                                                                                         \n        # client.close()                                                                                                                                                                                                                                                                                                                                                                                                                  \n        self.set_status(response.code)                                                                                                                                                                                                                                                                                                                                                                                                    \n        self.write('Status %d' % response.code)                                                                                                                                                                                                                                                                                                                                                                                           \n        self.finish()                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \ndef make_app():                                                                                                                                                                                                                                                                                                                                                                                                                           \n    return tornado.web.Application([                                                                                                                                                                                                                                                                                                                                                                                                      \n        (r\"/(?P<status>\\d{3})\", MainHandler),                                                                                                                                                                                                                                                                                                                                                                                               \n    ])                                                                                                                                                                                                                                                                                                                                                                                                                                    \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n                                                                                                                                                                                                                                                                                                                                                                                                                                          \nif __name__ == \"__main__\":                                                                                                                                                                                                                                                                                                                                                                                                                \n    app = make_app()                                                                                                                                                                                                                                                                                                                                                                                                                      \n    app.listen(8888)                                                                                                                                                                                                                                                                                                                                                                                                                      \n    tornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2018-03-22T21:31:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "213": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2322", "issue_id": "#2322", "issue_summary": "migrating tests from 4.5.2 to 5.0.1", "issue_description": "marcstreeter commented on 23 Mar 2018\nI've been trying to get my previously passing tests to pass under tornado 5.0.1\nI removed all uses of IOLoop (#2302) and also fixed an issue with define(#2146). I can't seem to figure out what would cause\nRuntimeWarning: coroutine 'Pool.release.<locals>._release_impl' was never awaited\nI'll attempt to recreate an offending test here unless there is a common issue that would cause the above (which I'm hoping).", "issue_status": "Closed", "issue_reporting_time": "2018-03-22T19:45:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "214": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2321", "issue_id": "#2321", "issue_summary": "Synchronous HTTPClient leaks memory in 5.0.1", "issue_description": "NicolasLM commented on 22 Mar 2018\nThe synchronous HTTPClient leaks memory for each request made since upgrading to Tornado 5.0.1.\nfrom tornado import httpclient\n\nwhile True:\n    try:\n        http_client = httpclient.HTTPClient()\n        response = http_client.fetch(\"http://localhost\")\n    except Exception:\n        pass\n    finally:\n        http_client.close()\nRunning this script for 3 minutes in docker (python:3.6-stretch):\ntornado==4.5.3: 18.52MiB / 1.952GiB\ntornado==5.0.1: 350.28MiB / 1.952GiB\nNote, I cannot seem to reproduce the issue on macOS.", "issue_status": "Closed", "issue_reporting_time": "2018-03-22T13:51:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "215": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2320", "issue_id": "#2320", "issue_summary": "strange behavior of AsyncHTTPClient while using streaming mode in tornado 5.x", "issue_description": "serg666 commented on 19 Mar 2018 \u2022\nedited\nHi!\nI have the following (tornado==4.5.3):\nimport logging\nimport asyncio\nimport tornado.httpclient\n\nimport tornado.platform.asyncio\n\n\nFORMAT='%(asctime)s,%(msecs)03d %(name)s [%(threadName)s] %(levelname)s: %(message)s'\nlog = logging.getLogger(__name__)\nlogging.basicConfig(format=FORMAT, datefmt='%Y-%m-%d %H:%M:%S%Z',\n                    level = logging.DEBUG)\n\nclass Download(object):\n    def streaming_callback(self, data):\n        log.debug('get chunk')\n\n    def async_callback(self, response):\n        log.debug('final response: {}'.format(response))\n\n    async def run(self):\n        await tornado.platform.asyncio.to_asyncio_future(\n            tornado.httpclient.AsyncHTTPClient().fetch(\n                tornado.httpclient.HTTPRequest('https://ya.ru/', streaming_callback=self.streaming_callback),\n                self.async_callback\n            )\n        )\n        log.debug('fetch done')\n\n\ntornado.platform.asyncio.AsyncIOMainLoop().install()\nloop = asyncio.get_event_loop()\nloop.run_until_complete(Download().run())\nlog.debug('Exit')\nIf I run the code above under tornado==4.5.3, I see something like this:\n2018-03-19 18:38:58MSK,807 asyncio [MainThread] DEBUG: Using selector: EpollSelector\n2018-03-19 18:38:58MSK,953 __main__ [MainThread] DEBUG: get chunk\n2018-03-19 18:38:58MSK,954 __main__ [MainThread] DEBUG: get chunk\n2018-03-19 18:38:58MSK,956 __main__ [MainThread] DEBUG: final response: HTTPResponse(_body=None,buffer=<_io.BytesIO object at 0x7f6258e49308>,code=200,effective_url='https://ya.ru/',error=None,headers=<tornado.httputil.HTTPHeaders object at 0x7f625941ad30>,reason='Ok',request=<tornado.httpclient.HTTPRequest object at 0x7f62593bfc88>,request_time=0.13659238815307617,time_info={})\n2018-03-19 18:38:58MSK,957 __main__ [MainThread] DEBUG: fetch done\n2018-03-19 18:38:58MSK,957 __main__ [MainThread] DEBUG: Exit\ne.g. we have called async_callback inside async def run and before log.debug('fetch done')\nDue to current documentation AsyncHTTPClient.fetch return asyncio future, so we do not need to use tornado.platform.asyncio directly.\nSo, I modify code like this:\nimport logging\nimport asyncio\nimport tornado.httpclient\n\n\nFORMAT='%(asctime)s,%(msecs)03d %(name)s [%(threadName)s] %(levelname)s: %(message)s'\nlog = logging.getLogger(__name__)\nlogging.basicConfig(format=FORMAT, datefmt='%Y-%m-%d %H:%M:%S%Z',\n                    level = logging.DEBUG)\n\nclass Download(object):\n    def streaming_callback(self, data):\n        log.debug('get chunk')\n\n    def async_callback(self, response):\n        log.debug('final response: {}'.format(response))\n\n    async def run(self):\n        await tornado.httpclient.AsyncHTTPClient().fetch(\n            tornado.httpclient.HTTPRequest('https://ya.ru/', streaming_callback=self.streaming_callback),\n            self.async_callback\n        )\n        log.debug('fetch done')\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(Download().run())\nlog.debug('Exit')\nAnd when I run the code above, I see something like this:\n2018-03-19 18:48:32MSK,943 asyncio [MainThread] DEBUG: Using selector: EpollSelector\n2018-03-19 18:48:33MSK,081 __main__ [MainThread] DEBUG: get chunk\n2018-03-19 18:48:33MSK,082 __main__ [MainThread] DEBUG: get chunk\n2018-03-19 18:48:33MSK,083 __main__ [MainThread] DEBUG: fetch done\n2018-03-19 18:48:33MSK,084 __main__ [MainThread] DEBUG: final response: HTTPResponse(_body=None,buffer=<_io.BytesIO object at 0x7f4d23d545c8>,code=200,effective_url='https://ya.ru/',error=None,headers=<tornado.httputil.HTTPHeaders object at 0x7f4d23d6c400>,reason='Ok',request=<tornado.httpclient.HTTPRequest object at 0x7f4d23d8aa90>,request_time=0.12746953964233398,time_info={})\n2018-03-19 18:48:33MSK,085 __main__ [MainThread] DEBUG: Exit\nThe problem is, that async_callback has not called inside async def run before log.debug('fetch done'), like under tornado 4.5.3\nSo, how can I get response inside async def run and before log.debug('fetch done')?", "issue_status": "Closed", "issue_reporting_time": "2018-03-19T15:55:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "216": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2314", "issue_id": "#2314", "issue_summary": "Mistake in official user guide?", "issue_description": "nicolinux commented on 17 Mar 2018 \u2022\nedited\nLooking at the official guide/async, the async example shows the method:\ndef asynchronous_fetch(url, callback):\nI wonder if the argument callback is correct since this would imply that calling the method would need to provide that callback.\nI am just starting out with Tornado so I admit that I have no clue about it, but looking at another example on StackOverflow which uses that same example, it makes way more sense to me for the async method to have this signature:\ndef asynchronous_fetch(url):\nStackOverflow example\nIf it is a small mistake, I'd suggest to fix it soon since this trips newbs big time when they try to wrap their head around the async concept in Tornado (speaking from experience :) )", "issue_status": "Closed", "issue_reporting_time": "2018-03-17T16:32:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "217": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2313", "issue_id": "#2313", "issue_summary": "AsyncHTTPTestCase block, and raise \"Async operation timed out after 5 seconds\"", "issue_description": "ityoung commented on 16 Mar 2018\nHello, I met an error \"Async operation timed out after 5 seconds\", and I did find some question in issue, but didn'd solve my problem.\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/unittest/case.py\", line 59, in testPartExecutor\n    yield\n  File \"/usr/lib/python3.5/unittest/case.py\", line 605, in run\n    testMethod()\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/home/yangxin/Geetest/server/gt-message/test/test_pre_gateway.py\", line 95, in test_post\n    res = self.fetch('/pre_gateway', method='POST', body=json.dumps(opsalt_origin))\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/testing.py\", line 406, in fetch\n    return self.wait()\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/testing.py\", line 336, in wait\n    self.__rethrow()\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/testing.py\", line 272, in __rethrow\n    raise_exc_info(failure)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/testing.py\", line 320, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\nthats my code below:\nfrom tornado.testing import AsyncHTTPTestCase\nfrom tornado.web import Application\n\nfrom index import init_redis\nfrom handler.find import FindHandler\n\nimport unittest\nimport json\n\nimport asyncio\n\nopsalt_origin = {\n    'dns': 'unknown'\n}\n\n\nclass TestPreGateway(AsyncHTTPTestCase):\n\n    def setUp(self):\n        super(TestPreGateway, self).setUp()\n\n    def get_app(self):\n        return Application([('/find', FindHandler)])\n\n    def test_post(self):\n        asyncio.get_event_loop().run_until_complete(init_redis())\n        res = self.fetch('/find', method='POST', body=json.dumps(opsalt_origin))\n        print(res.body)\n\n\nif __name__ == '__main__':\n    unittest.main()\nbecause my index.py is something like this, so I just move the initial func to my test code:\ndef initialize_utils():\n    asyncio.get_event_loop().run_until_complete(init_redis())\n\nif __name__ == \"__main__\":\n    ...\n    initialize_utils()\n    ...\nI'm really confuse that if I want to test a handler which need to connect to redis, I did need to initialize my redis right? Then how to init an async redis setting before I fetch the path?", "issue_status": "Closed", "issue_reporting_time": "2018-03-16T06:36:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "218": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2312", "issue_id": "#2312", "issue_summary": "Websockets with ThreadPoolExecutor - running messages on the same websocket sequentially", "issue_description": "ndvbd commented on 14 Mar 2018\nWhen using Tornado to handle websockets, how can we allow concurrency across different websockets (for example using ThreadPoolExecutor), while demanding that messages on the same websocket be run sequentially?\nSo it's kinda like some QoS (quality of service), so if I have 10000 clients, each is holding one websocket, I want to allow concurrency, that's why I will use ThreadPoolExecutor(8) to utilize my 8 processor cores, but I would like that every message from the same websocket be run sequentially, so that one websocket will not abuse the resources of the machine.\nOne solution may be to spawn 8 threads, and allocate for every websocket (out of the 10k) one thread that will handle this websocket.\nIs there anything like it?", "issue_status": "Closed", "issue_reporting_time": "2018-03-14T14:02:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "219": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2311", "issue_id": "#2311", "issue_summary": "Tornado subprocess works in macOS but not in centOS", "issue_description": "pivdets commented on 14 Mar 2018 \u2022\nedited\nupdate: I just remove the java part and use python to show the subprocess.\norigin:\nI post the same thread in SO, but got no answer, so I repost it here.\nI've a tornado program which uses async to call subprocess and return the result.\nimport tornado.ioloop\nimport tornado.web\nfrom tornado.process import Subprocess\nfrom tornado.gen import coroutine, Task, Return\nimport subprocess\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    @coroutine\n    def get(self):\n        appid = self.get_argument(\"appid\")\n        cmd = ['/usr/local/bin/python2.7', 'jarlib101.py', appid]\n\n        result, error = yield self.call_subprocess(cmd)\n\n        with open('defx.txt', 'r') as myfile:\n            data=myfile.read()\n\n        self.write(data)\n\n\n    @coroutine\n    def call_subprocess(self, cmd, stdin_data=None, stdin_async=True):\n        stdin = Subprocess.STREAM if stdin_async else subprocess.PIPE\n        sub_process = Subprocess(cmd,\n                                 stdin=stdin,\n                                 stdout=Subprocess.STREAM,\n                                 stderr=Subprocess.STREAM,)\n        if stdin_data:\n            if stdin_async:\n                yield Task(sub_process.stdin.write, stdin_data)\n            else:\n                sub_process.stdin.write(stdin_data)\n\n        if stdin_async or stdin_data:\n            sub_process.stdin.close()\n\n        result, error = yield [Task(sub_process.stdout.read_until_close),\n                               Task(sub_process.stderr.read_until_close),]\n\n        raise Return((result, error))\n\n\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/webmini\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8845)\n    tornado.ioloop.IOLoop.current().start()\nHere's the source code of the jarlib101.py:\nfrom time import sleep\nimport sys\n\nsleep(5)\n\nappid = sys.argv[1]\n\nwith open('defx.txt', 'w') as myfile:\n    myfile.write(appid)\nThe python code works well on my MacBook laptop:\n$ /usr/local/bin/python2 webmini2.py\nI test it in a browser as follows:\nBut when I upload my code to centOS and start the server\n$ /usr/local/bin/python2.7 webmini2.py\nI got an empty response from the browser, but there's an deft.txt on the server folder with content\n$cat defx.txt\n1299w", "issue_status": "Closed", "issue_reporting_time": "2018-03-14T13:10:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "220": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2309", "issue_id": "#2309", "issue_summary": "Tornado 5.0 request handler hangs when executing method `get` in thread pool", "issue_description": "MrP4p3r commented on 13 Mar 2018 \u2022\nedited\nI try to decorate get method in request handler to execute it in separate thread (via thread pool) by using tornado.concurrent.Future.\nCode:\nhttps://gist.github.com/MrP4p3r/8d0e7ff0ab4bd42af7f1fd5b12c65ea1\nI tried five similar decorators. Two of them wrap request handler method with tornado.gen.coroutine decorated wrapper. They always work with tornado 4.5.3. But with tornado 5.0.0 request handler hangs almost in all cases until I refresh the page. Browser does not receive data.\nOther two decorators is an attempt to use asyncio.Future and async def wrapper for request handler method. They do not work in 5.0.0 as well.\nThe last one starts separate thread and executes method get in separate thread. It works in both 4.5.3 and 5.0.0. But is not suitable in my case since I have to use thread pool.\nHow it looks:", "issue_status": "Closed", "issue_reporting_time": "2018-03-13T11:37:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "221": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2308", "issue_id": "#2308", "issue_summary": "Starting server in separate thread gives... RuntimeError: There is no current event loop in thread 'Thread-4'", "issue_description": "wroscoe commented on 13 Mar 2018 \u2022\nedited\nIn the 5.0.0 the following code no longer works and throws the error shown below. Is there still a way to start a tornado server in separate thread? For context, I'm using this for the (a self driving car project)[https://github.com/wroscoe/donkey] its web controller. This still works in v4.5.3.\nimport tornado.web\n\nclass WebServer(tornado.web.Application):\n\n    def __init__(self):\n        handlers = [ (r\"/test\", TestHandler), ]\n        settings = {'debug': True}\n        super().__init__(handlers, **settings)\n        \n    def run(self, port=8886):\n        self.listen(port)\n        tornado.ioloop.IOLoop.instance().start()\n        \nclass TestHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"test success\")\n        \nws = WebServer()\n\n\nfrom threading import Thread\nt = Thread(target=ws.run, args=())\nt.daemon = True\nt.start()\nException in thread Thread-4:\nTraceback (most recent call last):\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/threading.py\", line 916, in _bootstrap_inner\n    self.run()\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/threading.py\", line 864, in run\n    self._target(*self._args, **self._kwargs)\n  File \"<ipython-input-1-65816933cb20>\", line 12, in run\n    super().__init__(self.handlers, **self.settings)\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/site-packages/tornado/web.py\", line 1961, in __init__\n    autoreload.start()\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/site-packages/tornado/autoreload.py\", line 118, in start\n    io_loop = ioloop.IOLoop.current()\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/site-packages/tornado/ioloop.py\", line 283, in current\n    loop = asyncio.get_event_loop()\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/asyncio/events.py\", line 694, in get_event_loop\n    return get_event_loop_policy().get_event_loop()\n  File \"/home/wroscoe/miniconda3/envs/donkey/lib/python3.6/asyncio/events.py\", line 602, in get_event_loop\n    % threading.current_thread().name)\nRuntimeError: There is no current event loop in thread 'Thread-4'.", "issue_status": "Closed", "issue_reporting_time": "2018-03-13T04:59:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "222": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2304", "issue_id": "#2304", "issue_summary": "RuntimeError: There is no current event loop in thread 'ThreadPoolExecutor-1_0'", "issue_description": "jayanth1991 commented on 10 Mar 2018\nOS: Windows 10\nTornado: 5.0\nPython: 3.6.4\nimport tornado.web\nimport tornado.gen\nimport time\nfrom tornado.ioloop import IOLoop\n\n\nclass TestHandler(tornado.web.RequestHandler):\n\n    def _call_later_something(self):\n        pass\n\n    def _get(self, var1):\n        # Does some time consuming call\n        # Mocking it\n        time.sleep(2)\n        IOLoop.current().call_later(10, self._call_later_something)\n        resp_dict = {}\n        resp_dict['blah'] = \"blah\"\n\n        return resp_dict\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, *args, **kwargs):\n        var1 = self.get_argument('var1', None)\n        resp_dict = yield IOLoop.current().run_in_executor(None,\n                                                           self._get,\n                                                           var1)\n        self.write(resp_dict)\n        self.finish()\n\n\nclass MyApp(tornado.web.Application):\n    def __init__(self, test=False):\n        handlers = [\n            (r\"/api/sometest\", TestHandler),\n        ]\n        tornado_settings = dict(\n            debug=True,\n            serve_traceback=True,\n        )\n\n        tornado.web.Application.__init__(self, handlers, **tornado_settings)\n\n\nif __name__ == \"__main__\":\n    # Hard code this so that jarvis and ironman can be in sync\n    port_number = 9999\n\n    http_server = MyApp()\n    http_server.listen(port_number)\n    IOLoop.instance().start()\nThis works completely fine on Python2.7, throws the error\nRuntimeError: There is no current event loop in thread 'ThreadPoolExecutor-1_0'\nNot sure what I am doing wrong.", "issue_status": "Closed", "issue_reporting_time": "2018-03-10T18:28:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "223": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2302", "issue_id": "#2302", "issue_summary": "Async operation timed out when unit testing HTTPServer creation", "issue_description": "k4ppa commented on 7 Mar 2018\nI'm trying to unit test a Tornado application.\nThe goal of my test (test_POST_empty_json_in_do_nothing) is now only to send a POST request of an empty zipped json. When it receive the request the HTTPServer must only return an HTTP code 200.\nFollowing this example I overrided get_http_server to return my HTTPServer.\nBut doing this both tests fail with:\nAssertionError: Async operation timed out after 5 seconds\nAs far as I understand the tips found online about this issue (for example here and here), this problem is generated by the use of the wrong ioloop. A workaround is to override the function get_new_ioloop to return IOLoop.instance().\nI did it as you can see in the code below.\necomtranslatorSrv.py\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        pass\n\nclass NewBasketHandler(tornado.web.RequestHandler):\n    def post(self):\n        pass\n\n\ndef make_app():\n    return tornado.web.Application([\n        (MAIN_HANDLER, MainHandler),\n        (NEW_BASKET, NewBasketHandler)\n    ])\n\n\ndef make_server(app, io_loop=None):\n    return tornado.httpserver.HTTPServer(app, io_loop=io_loop, decompress_request=True)\ntest_translator_server.py\nclass TestTranslatorServer(AsyncHTTPSTestCase):\n\n    def setUp(self):\n        super(TestTranslatorServer, self).setUp()\n\n    def tearDown(self):\n        super(TestTranslatorServer, self).tearDown()\n\n    def get_app(self):\n        return ecomtranslatorSrv.make_app()\n\n    def get_http_server(self):\n        return ecomtranslatorSrv.make_server(self._app, self.io_loop)\n\n    def get_new_ioloop(self):\n        return IOLoop.instance()\n\n    def test_GET_main_handler(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 200)\n\n    def test_POST_empty_json_in_do_nothing(self):\n        headers = tornado.httputil.HTTPHeaders({\"Content-Type\": \"application/json\", 'Content-Encoding': 'gzip'})\n        body = zlib.compress('{}')\n        response = self.fetch(method='POST', path='/basket/json_in', headers=headers, body=body)\n        self.assertEqual(response.code, 200)\n\n\ndef main():\n    tornado.testing.main()\n\n\nif __name__ == '__main__':\n    main()\nBut the result did not change: both tests fail after the 5 seconds timeout.\nThe only way to get rid of the issue is to not override get_http_server. But I don't want to use the HTTPServer created by default by the test module, since I'm trying to use TDD and I don't want to write code that is not used in the tests.\nSo how can I test the creation of an HTTPServer without incurring in a time out error?\nPython 2.7.12\ntornado 4.5.1", "issue_status": "Closed", "issue_reporting_time": "2018-03-07T12:56:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "224": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2301", "issue_id": "#2301", "issue_summary": "asyncio's ensure_future for Python versions <3.4.4", "issue_description": "christippett commented on 6 Mar 2018\nVersion\nPython: 3.4.3\nTornado: 5.0\nIssue\nI use the raven Python library that has Tornado as a requirement. When installing raven in a new environment, a newer version of Tornado was installed (5.0) which resulted in the following exception:\n  File \"/opt/python/run/venv/local/lib/python3.4/site-packages/raven/transport/tornado.py\", line 17, in <module>\n    from tornado.httpclient import AsyncHTTPClient, HTTPClient\n  File \"/opt/python/run/venv/local/lib64/python3.4/site-packages/tornado/httpclient.py\", line 49, in <module>\n    from tornado import gen, httputil, stack_context\n  File \"/opt/python/run/venv/local/lib64/python3.4/site-packages/tornado/gen.py\", line 1295, in <module>\n    _wrap_awaitable = asyncio.ensure_future\nAttributeError: 'module' object has no attribute 'ensure_future'\nThe previous version of Tornado I was using (4.5.3) does not have this error. Downgrading Tornado from 5.0 to 4.5.3 resolves the problem.\nLooking into the issue, I believe it's caused by Tornado's incompatibility with using an older version of Python's asyncio. Should the import for ensure_future for Python version <3.4.4\nbe from asyncio import async as ensure_future ?", "issue_status": "Closed", "issue_reporting_time": "2018-03-06T10:28:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "225": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2295", "issue_id": "#2295", "issue_summary": "AssertionError in write_ping (Python 3)", "issue_description": "Nagidal commented on 3 Mar 2018 \u2022\nedited\nI was trying to run the sample code for the websocket of SeismicPortal (http://www.seismicportal.eu/realtime.html). The code in question is shown on their webiste. I installed Tornado 4.5.3 in my Python 3.6, but when running SeismicPortal's script, I was periodically getting this error:\nINFO:root:trying connection to ws://www.seismicportal.eu/standing_order/websocket\nINFO:root:connected, waiting for messages\nERROR:tornado.application:Exception in callback functools.partial(<function wrap.<locals>.wrapped at 0x0000000002F7ED90>)\nTraceback (most recent call last):\n  File \"C:\\Python36\\lib\\site-packages\\tornado\\ioloop.py\", line 605, in _run_callback\n    ret = callback()\n  File \"C:\\Python36\\lib\\site-packages\\tornado\\stack_context.py\", line 345, in wrapped\n    raise_exc_info(exc)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"C:\\Python36\\lib\\site-packages\\tornado\\stack_context.py\", line 316, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"example.py\", line 27, in dokeepalive\n    self.conn.protocol.write_ping(\"\")\n  File \"C:\\Python36\\lib\\site-packages\\tornado\\websocket.py\", line 797, in write_ping\n    assert isinstance(data, bytes)\nAssertionError\nI was debugging this for a while until I found svisser's post that assert isinstance(..., ...) works different in Python 3.\nSeismicPortal's websocket is sending String type, but tornado's function write_ping in websocket.py needs it as bytes. I made a quick workaround this by converting the data to bytes, adding a line of code just before the assertion:\n    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        # Workaround for Python 3 AssertionError\n        # Need to convert String type to bytes\n        data = data.encode(encoding=\"utf-8\", errors=\"strict\") \n        # End of workaround for Python 3 AssertionError\n        assert isinstance(data, bytes)\n        self._write_frame(True, 0x9, data)\nRunning SeismicPotal's websocket sample code with this hotfix in websocket.py produced the desired results, i.e. JSONs with data of current earthquake events (one of which occurs and is sent by the websocket server every few minutes):\nINFO:root:trying connection to ws://www.seismicportal.eu/standing_order/websocket \nINFO:root:connected, waiting for messages                                         \n>> {\"action\":\"update\",\"data\":{                                                    \n  \"geometry\": {                                                                   \n    \"type\": \"Point\",                                                              \n    \"coordinates\": [                                                              \n      40.05,                                                                      \n      39.95,                                                                      \n      -1.0                                                                        \n    ]                                                                             \n  },                                                                              \n  \"type\": \"Feature\",                                                              \n  \"id\": \"20180303_0000038\",                                                       \n  \"properties\": {                                                                 \n    \"lastupdate\": \"2018-03-03T09:18:00.0Z\",                                       \n    \"magtype\": \"ml\",                                                              \n    \"evtype\": \"ke\",                                                               \n    \"lon\": 40.05,                                                                 \n    \"auth\": \"EMSC\",                                                               \n    \"lat\": 39.95,                                                                 \n    \"depth\": 1.0,                                                                 \n    \"unid\": \"20180303_0000038\",                                                   \n    \"mag\": 4.1,                                                                   \n    \"time\": \"2018-03-03T09:05:48.1Z\",                                             \n    \"source_id\": \"652117\",                                                        \n    \"source_catalog\": \"EMSC-RTS\",                                                 \n    \"flynn_region\": \"EASTERN TURKEY\"                                              \n  }                                                                               \n}}                                                                                \nI am sure that this workaround may only work for my particular example with SeismicPortal's websocket and may make tornado incompatible with other websocket servers or Python 2.x versions.\nPlease implement a proper clean and elegant handling of the differentiation between bytes and string in Python 3. I am looking forward for your update.\n1", "issue_status": "Closed", "issue_reporting_time": "2018-03-03T09:47:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "226": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2294", "issue_id": "#2294", "issue_summary": "WSGI adapter introduces unavoidable buffering", "issue_description": "Contributor\nlerks commented on 27 Feb 2018\nWe're using Tornado on top of the WSGI server provided by gevent. We've recently realized that, when downloading large files, they would first be fully read from disk to memory and only then be sent on the HTTP connection. Since we're copying them (from the file to the connection) in small chunks and flushing after every write, we were surprised by this. We traced it down to Tornado's _WSGIConnection simply adding the chunk to its _write_buffer when calling the write method, and the whole buffer being only sent at the very end of WSGIAdapter's __call__ method, all at once. This is quite problematic. Could anyone have a look at this and attempt a fix?", "issue_status": "Closed", "issue_reporting_time": "2018-02-27T13:08:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "227": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2291", "issue_id": "#2291", "issue_summary": "The Hello World example does not work", "issue_description": "kzhdev commented on 25 Feb 2018 \u2022\nedited\nI'm new to tornado. The first thing I tried is the Hello World example, but it gave me an Uncaught Exception. I am using python 3.6.4 and tornado-4.5.3\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/http1connection.py\", line 238, in _read_message\n    delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/routing.py\", line 251, in finish\n    self.delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2097, in finish\n    self.execute()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2117, in execute\n    **self.handler_kwargs)\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 192, in __init__\n    self.initialize(**kwargs)\nTypeError: initialize() missing 1 required positional argument: 'url'\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/http1connection.py\", line 238, in _read_message\n    delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/routing.py\", line 251, in finish\n    self.delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2097, in finish\n    self.execute()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2117, in execute\n    **self.handler_kwargs)\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 192, in __init__\n    self.initialize(**kwargs)\nTypeError: initialize() missing 1 required positional argument: 'url'\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/http1connection.py\", line 238, in _read_message\n    delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/routing.py\", line 251, in finish\n    self.delegate.finish()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2097, in finish\n    self.execute()\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 2117, in execute\n    **self.handler_kwargs)\n  File \"/Users/kzhao/anaconda/envs/learning_fun/lib/python3.6/site-packages/tornado/web.py\", line 192, in __init__\n    self.initialize(**kwargs)\nTypeError: initialize() missing 1 required positional argument: 'url'", "issue_status": "Closed", "issue_reporting_time": "2018-02-25T17:59:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "228": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2290", "issue_id": "#2290", "issue_summary": "Knowing response code in streaming_callback", "issue_description": "Contributor\nlegnaleurc commented on 24 Feb 2018\nI was using a RESTful API to download a file, so I did this (simplified):\nresponse = await client.fetch(url, streaming_callback=fn_to_write_file)\nBut the problem is, even if the response code is not 200, the streaming_callback will still be called anyway, no matter raise_error is true or not.\nFor example, Google Drive API will put error detail as a JSON in the body, so this will cause serious problem when trying to resume downloading. The real content and error message may interleave in the output file.\nProbably #2209 could solve the root cause.", "issue_status": "Closed", "issue_reporting_time": "2018-02-24T10:25:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "229": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2289", "issue_id": "#2289", "issue_summary": "AssertionError: Python 2.6+ and OpenSSL required for SSL", "issue_description": "wanghaiqing2015 commented on 24 Feb 2018\nconfig the application:\nssl_options={\n\"certfile\": os.path.join(os.path.abspath(\".\"), \"static/server.crt\"),\n\"keyfile\": os.path.join(os.path.abspath(\".\"), \"static/server.key\"),\n},\nreport error, it worked good on python2.7.5 , but failed on python3.6\nTraceback (most recent call last):\n  File \"/opt/python3/lib/python3.6/site-packages/tornado/ioloop.py\", line 888, in start\n    handler_func(fd_obj, events)\n  File \"/opt/python3/lib/python3.6/site-packages/tornado/stack_context.py\", line 277, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/opt/python3/lib/python3.6/site-packages/tornado/netutil.py\", line 277, in accept_handler\n    callback(connection, address)\n  File \"/opt/python3/lib/python3.6/site-packages/tornado/tcpserver.py\", line 259, in _handle_connection\n    assert ssl, \"Python 2.6+ and OpenSSL required for SSL\"\nAssertionError: Python 2.6+ and OpenSSL required for SSL", "issue_status": "Closed", "issue_reporting_time": "2018-02-24T06:36:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "230": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2287", "issue_id": "#2287", "issue_summary": "When will support http2 protocol?", "issue_description": "nihao commented on 23 Feb 2018\nHi,\ntornado is a perfect frame for http1 and websocket, we used it in many our current project.\nnow, we are planing to try http2 in new project, but not found any documents.\nwhen will support http2?\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2018-02-23T03:52:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "231": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2286", "issue_id": "#2286", "issue_summary": "Keeping request object for a second", "issue_description": "imirzadeh commented on 22 Feb 2018 \u2022\nedited\nWhen a new request comes, I put the request object in a hashmap and when the result of external service comes, I call .write() method of that request.\nHowever when server loads at start everything is ok but after a while although it prints \"going to send response\" but nothing goes to the client!\nDoes anyone know why?\ndef post(self):\n  self._auto_finish = False\n                 key = get_new_key_for_request()\n                 global my map\n                 my_map[key] =  self\n                 ... send request data to external source with key and wait for result\n\ndef ready(key):\n           global my_map\n           req = my_map.pop(key)\n           print(\"going to send response\")\n           req.write(\"OK\")\nOS: Ubuntu 16.04\nPython: Python 3.5.2\ntornado: 4.5.2", "issue_status": "Closed", "issue_reporting_time": "2018-02-22T15:15:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "232": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2285", "issue_id": "#2285", "issue_summary": "exception when calling finish()", "issue_description": "imirzadeh commented on 22 Feb 2018\nSometimes when I call finish method of http response I get this exception, anyone can help?:\nFile \"/home/sokhan/nava/src/gateways/http_server/server.py\", line 47, in send_response\n    reference.finish()\n  File \"/home/sokhan/nava_env/lib/python3.5/site-packages/tornado/web.py\", line 991, in finish\n    self.flush(include_footers=True)\n  File \"/home/sokhan/nava_env/lib/python3.5/site-packages/tornado/web.py\", line 947, in flush\n    start_line, self._headers, chunk, callback=callback)\n  File \"/home/sokhan/nava_env/lib/python3.5/site-packages/tornado/http1connection.py\", line 400, in write_headers\n    self._pending_write = self.stream.write(data)\n  File \"/home/sokhan/nava_env/lib/python3.5/site-packages/tornado/iostream.py\", line 406, in write\n    self._handle_write()\n  File \"/home/sokhan/nava_env/lib/python3.5/site-packages/tornado/iostream.py\", line 872, in _handle_write\n    del self._write_buffer[:self._write_buffer_pos]\nTypeError: 'NoneType' object does not support item deletion\nOS: Ubuntu 16.04\nPython: Python 3.5.2\ntornado: 4.5.2", "issue_status": "Closed", "issue_reporting_time": "2018-02-22T13:49:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "233": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2283", "issue_id": "#2283", "issue_summary": "Typo in documentation", "issue_description": "BaloneyGeek commented on 21 Feb 2018\ntornado/tornado/ioloop.py\nLine 247 in 4adf5ec\n            `clear_instance()` is an alias for `clear_instance()`. \nShouldn't this line be:\nclear_instance() is an alias for clear_current()", "issue_status": "Closed", "issue_reporting_time": "2018-02-21T13:28:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "234": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2281", "issue_id": "#2281", "issue_summary": "WebSocketHandler.select_subprotocol() is always invoked", "issue_description": "staticglobal commented on 21 Feb 2018\nThe WebSocketHandler.select_subprotocol() callback is invoked for every client connection, even clients that do not send (or send an empty) Sec-WebSocket-Protocol header. For these clients, the callback is invoked with (subprotocols=['']), which is probably never useful. In addition, both the documentation and the code seem to indicate that the intent is for this callback to only be invoked if the client submits some non-empty value for Sec-WebSocket-Protocol.\nclass WebSocketProtocol13(WebSocketProtocol):\n    def _accept_connection(self):\n        subprotocols = self.request.headers.get(\"Sec-WebSocket-Protocol\", '')\n        subprotocols = [s.strip() for s in subprotocols.split(',')]\n        if subprotocols:\n            selected = self.handler.select_subprotocol(subprotocols)\n            ...\nFor cases when Sec-WebSocket-Protocol is empty, subprotocols evaluates to [''] before being tested in the conditional. Unfortunately, [''] == True, which means this if subprotocols: always evaluates True.\nOptions I see:\nIf we can assume that self.request.headers is always an instance of HTTPHeaders, we can use get_list() like so:\nsubprotocols = [s.strip() for s in self.request.headers.get_list(\"Sec-WebSocket-Protocol\")] instead of get() and split(). This will result in subprotocols = [], which evaluates False. This feels like the cleaner solution and I will work on a PR for this. Is there a reason for us to access our headers using only basic dict operations?\nEvaluate if subprotocols: immediately after get() while it is still a string, before calling split() / strip() to turn it into a list.", "issue_status": "Closed", "issue_reporting_time": "2018-02-21T02:13:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "235": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2280", "issue_id": "#2280", "issue_summary": "\"tornado\\httputil.py\", line 188, in parse_line", "issue_description": "m41nt41n3r commented on 20 Feb 2018 \u2022\nedited\nHello. It's a pity but I can't provide test data, but sometimes a see next error (Python 2.7):\nERROR:tornado.general:Uncaught exception\nTraceback (most recent call last):\nFile \"\\tornado\\http1connection.py\", line 730, in _server_request_loop\nFile \"\\tornado\\gen.py\", line 1088, in run\nFile \"\\tornado\\concurrent.py\", line 255, in result\nFile \"\\tornado\\gen.py\", line 1102, in run\nFile \"\\tornado\\http1connection.py\", line 172, in _read_message\nFile \"\\tornado\\http1connection.py\", line 524, in _parse_headers\nFile \"\\tornado\\httputil.py\", line 205, in parse\nFile \"\\tornado\\httputil.py\", line 188, in parse_line\nKeyError: None\nIt seems that sometimes add routine of HTTPHeaders class sets None to the self._last_key:\n    def add(self, name, value):\n        # type: (str, str) -> None\n        \"\"\"Adds a new value for the given key.\"\"\"\n        norm_name = _normalized_headers[name]\n        self._last_key = norm_name\nThanks for attention.", "issue_status": "Closed", "issue_reporting_time": "2018-02-20T00:59:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "236": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2279", "issue_id": "#2279", "issue_summary": "web: document that `xsrf_token` is bytes", "issue_description": "wanghaiqing2015 commented on 18 Feb 2018\nHi, i just got a problem here please help me thanks.\nthis caused when i send a post request.\ni have not a form\uff0c use requests.post to post requests .\nError: _xsrf' argument has invalid format\napplication setting:\ncookie_secret=os.urandom(64),\nxsrf_cookies=True,\nclass JsonHandler(BaseHandler):\ndef initialize(self):\nself.request.headers['X-Xsrftoken'] = self.xsrf_token\npython 2.7.14 worked ok, but python 3.6 not work. show error: _xsrf' argument has invalid format.", "issue_status": "Closed", "issue_reporting_time": "2018-02-18T16:24:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "237": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2278", "issue_id": "#2278", "issue_summary": "null pointer in iostream for tornado 4.x and python 3.6.3", "issue_description": "vane commented on 14 Feb 2018\nI use tornado with some wsgi and observed following case when invoking GET request.\nIn ioloop.py write_buffer is becoming null that causes _handle_write nullpointer\na)\ntornado/tornado/iostream.py\nLine 475 in 8e9e755\n self._write_buffer = None \n\nHow it happened :\nI got context switch between socked read and write.\nfrom this line socket write:\nb)\ntornado/tornado/iostream.py\nLine 861 in 8e9e755\n num_bytes = self.write_to_fd( \n\nto this line socket read:\nc)\ntornado/tornado/iostream.py\nLine 1059 in 8e9e755\n self.close() \nAnd then code continues from b) that causes null pointer cause there is no _write_buffer\nCouldn't find the issue so I will submit pull request if someone observed such behavior.\nI cannot replicate this on my environment every time so some rough logs from what is happening:\nDEBUG 2018-02-14 13:14:17 _handle_write 1\nDEBUG 2018-02-14 13:14:17 _handle_write 2\nDEBUG 2018-02-14 13:14:17 BaseIOStream write_to_fd self.socket.send\nDEBUG 2018-02-14 13:14:17 BaseIOStream read_from_fd self.socket.recv\nDEBUG 2018-02-14 13:14:17 close\nDEBUG 2018-02-14 13:14:17 problem\nDEBUG 2018-02-14 13:14:17 BaseIOStream close_fd self.socket.close\nDEBUG 2018-02-14 13:14:17 close _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _handle_read\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _maybe_add_error_listener\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _maybe_add_error_listener\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _maybe_add_error_listener\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _maybe_add_error_listener\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _maybe_add_error_listener\nDEBUG 2018-02-14 13:14:17 invoked _maybe_run_close_callback\nDEBUG 2018-02-14 13:14:17 _handle_write 3\nThanks", "issue_status": "Closed", "issue_reporting_time": "2018-02-14T12:16:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "238": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2276", "issue_id": "#2276", "issue_summary": "async/await syntax does not work with run_on_executor decorated functions", "issue_description": "icu0755 commented on 12 Feb 2018\nHow to reproduce:\nMacOS 10.12.6\nPython 3.6.1\nTornado 4.5.3\nclass Handler(tornado.web.RequestHandler):\n    executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)\n\n    @run_on_executor\n    def background_task(self, i):\n        \"\"\" This will be executed in `executor` pool. \"\"\"\n        time.sleep(3)\n        return i\n\n    async def get(self):\n        \"\"\" Request that asynchronously calls background task. \"\"\"\n        res = await self.background_task('hello world')\n        self.write(res)\nraises TypeError: object Future can't be used in 'await' expression.\nI found a workaround proposal to use tornado.gen.convert_yielded\nhere\nhttps://mail.python.org/pipermail//python-list/2017-February/719519.html\nand in the documentation here\nhttp://www.tornadoweb.org/en/stable/guide/coroutines.html?highlight=submit#python-3-5-async-and-await\nBut apparently it does not work due to the native future being returned untouched here\ntornado/tornado/gen.py\nLine 1297 in 15e350a\n return yielded ", "issue_status": "Closed", "issue_reporting_time": "2018-02-11T19:45:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "239": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2274", "issue_id": "#2274", "issue_summary": "Traceback binding socket", "issue_description": "stevegrubb commented on 8 Feb 2018\nThe code in netutil.py around line 163 calls sock.bind(sockaddr). This can raise an exception when the address family is not supported. When using getaddrinfo, you are supposed to try each address returned until it's successful or the addresses are exhausted. The code appears to be written to loop, but success should only be considered if sock.bind() doesn't cause an exception.\nWhen starting jupyter-notebook on a system that does not have IPv6 enabled, I get the following traceback:\n$ jupyter notebook\nTraceback (most recent call last):\nFile \"/usr/bin/jupyter-notebook\", line 6, in\nmain()\nFile \"/usr/lib/python3.6/site-packages/jupyter_core/application.py\", line 267, in launch_instance\nreturn super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)\nFile \"/usr/lib/python3.6/site-packages/traitlets/config/application.py\", line 657, in launch_instance\napp.initialize(argv)\nFile \"\", line 2, in initialize\nFile \"/usr/lib/python3.6/site-packages/traitlets/config/application.py\", line 87, in catch_config_error\nreturn method(app, *args, **kwargs)\nFile \"/usr/lib/python3.6/site-packages/notebook/notebookapp.py\", line 1368, in initialize\nself.init_webapp()\nFile \"/usr/lib/python3.6/site-packages/notebook/notebookapp.py\", line 1188, in init_webapp\nself.http_server.listen(port, self.ip)\nFile \"/usr/lib64/python3.6/site-packages/tornado/tcpserver.py\", line 141, in listen\nsockets = bind_sockets(port, address=address)\nFile \"/usr/lib64/python3.6/site-packages/tornado/netutil.py\", line 196, in bind_sockets\nsock.bind(sockaddr)\nOSError: [Errno 99] Cannot assign requested address\nAdding a print(sockaddr) before sock.bind(sockaddr) gives the following:\n('::1', 8888, 0, 0)\nand\nping ::1\nconnect: Network is unreachable\nI think the answer is wrap the sock.bind in a try/catch and continuing to iterate on error.", "issue_status": "Closed", "issue_reporting_time": "2018-02-08T18:14:50Z", "fixed_by": "#2684", "pull_request_summary": "netutil: Ignore EADDRNOTAVAIL when binding to localhost ipv6", "pull_request_description": "Member\nbdarnell commented on 22 Jun 2019\nThis happens in docker with default configurations and is generally\nharmless.\nFixes #2274\nThe first commit turns out to be unrelated; I thought it would streamline the second commit but there's no exception type for EADDRNOTAVAIL. With the third commit, the tests run cleanly in docker.", "pull_request_status": "Merged", "issue_fixed_time": "2019-06-22T17:08:37Z", "files_changed": [["4", "tornado/ioloop.py"], ["68", "tornado/iostream.py"], ["49", "tornado/netutil.py"], ["14", "tornado/process.py"], ["9", "tornado/test/iostream_test.py"], ["14", "tornado/test/tcpclient_test.py"]]}, "240": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2273", "issue_id": "#2273", "issue_summary": "How to set a fixed interval of IOLoop.add_callback?", "issue_description": "ljwkevinz commented on 8 Feb 2018\nI am using tornado-celery for web's callback, and it depends on tornado.IOLoop.add_callback.\nAs I know IOLoop.add_timeout comes with a specific interval, and how about IOLoop.add_callback? does it have a fixed interval set by Tornado? or IOLoop.add_callback comes with no interval and is based on IO events?\nI just can't find detailed information from Tornado documentation.\nI just want to set a fixed interval of IOLoop.add_callback.", "issue_status": "Closed", "issue_reporting_time": "2018-02-08T09:17:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "241": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2271", "issue_id": "#2271", "issue_summary": "BufferError: Existing exports of data: object cannot be re-sized", "issue_description": "jeffreydwalter commented on 6 Feb 2018 \u2022\nedited\nOS: Darwin 17.4.0 Darwin Kernel Version 17.4.0: Sun Dec 17 09:19:54 PST 2017; root:xnu-4570.41.2~1/RELEASE_X86_64 x86_64\nPython Version: 3.6.0\ntornado==4.5.3\nSo, I have a little websocket server that serves video streams. And I am getting this error:\n$ python3 test.py \n*** Websocket Server Started at 192.168.119.1***\nwebsocket opened\nmessage received: start data stream\nspawning subprocess to generate data stream\nERROR:tornado.application:Uncaught exception GET /ws (127.0.0.1)\nHTTPServerRequest(protocol='http', host='localhost:8888', method='GET', uri='/ws', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Host': 'localhost:8888', 'Connection': 'Upgrade', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', 'Upgrade': 'websocket', 'Origin': 'http://localhost:8888', 'Sec-Websocket-Version': '13', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36', 'Dnt': '1', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'en-US,en;q=0.9', 'Sec-Websocket-Key': 'ZAug6WtdtAp7g1RYx2/m9Q==', 'Sec-Websocket-Extensions': 'permessage-deflate; client_max_window_bits'})\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.6/site-packages/tornado/web.py\", line 1468, in _stack_context_handle_exception\n    raise_exc_info((type, value, traceback))\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/usr/local/lib/python3.6/site-packages/tornado/stack_context.py\", line 316, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/websocket.py\", line 502, in <lambda>\n    self.stream.io_loop.add_future(result, lambda f: f.result())\n  File \"/usr/local/lib/python3.6/site-packages/tornado/concurrent.py\", line 238, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/usr/local/lib/python3.6/site-packages/tornado/gen.py\", line 1063, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"test.py\", line 87, in on_message\n    yield executor.submit(self.stream_data)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/gen.py\", line 1055, in run\n    value = future.result()\n  File \"/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/concurrent/futures/_base.py\", line 398, in result\n    return self.__get_result()\n  File \"/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/concurrent/futures/_base.py\", line 357, in __get_result\n    raise self._exception\n  File \"/usr/local/Cellar/python3/3.6.0/Frameworks/Python.framework/Versions/3.6/lib/python3.6/concurrent/futures/thread.py\", line 55, in run\n    result = self.fn(*self.args, **self.kwargs)\n  File \"test.py\", line 79, in stream_data\n    self.write_message(data)#, binary=True)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/websocket.py\", line 252, in write_message\n    return self.ws_connection.write_message(message, binary=binary)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/websocket.py\", line 793, in write_message\n    return self._write_frame(True, opcode, message, flags=flags)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/websocket.py\", line 776, in _write_frame\n    return self.stream.write(frame)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/iostream.py\", line 395, in write\n    self._write_buffer += data\nBufferError: Existing exports of data: object cannot be re-sized\n^CTraceback (most recent call last):\n  File \"test.py\", line 105, in <module>\n    ioloop.IOLoop.instance().start()\n  File \"/usr/local/lib/python3.6/site-packages/tornado/ioloop.py\", line 863, in start\n    event_pairs = self._impl.poll(poll_timeout)\n  File \"/usr/local/lib/python3.6/site-packages/tornado/platform/kqueue.py\", line 66, in poll\n    kevents = self._kqueue.control(None, 1000, timeout)\nI have put together a little gist which reproduces the problem.\nIt seems to be related to the amount (rate?) of data being processed.\nIf I change line 72 p = subprocess.Popen(['/usr/bin/tr', '-dc', 'A-Za-z0-9'], stdin=dev_rand.stdout, stdout=subprocess.PIPE, env=new_env)\nto p = subprocess.Popen(['/usr/bin/tr', '-dc', 'A-Z'], stdin=dev_rand.stdout, stdout=subprocess.PIPE, env=new_env)\nthe problem seems to go away. I surmise that this change \"fixes\" the problem because it reduces the amount (rate?) of the data being generated by the subprocess.\nI'm new to tornado, so any insight into this would be tremendously helpful. If I'm doing it wrong, please let me know the correct way to do what I'm after.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2018-02-05T21:07:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "242": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2269", "issue_id": "#2269", "issue_summary": "AttributeError: module 'tornado.options' has no attribute 'mockable'", "issue_description": "danielkiedrowski commented on 3 Feb 2018\nHello.\nI am getting this error trying to mock an option value.\nI am using tornado 4.5.3 and python 3.6\nfrom tornado import options\noptions.mockable()\nThe documentation states, that this should be possible: http://www.tornadoweb.org/en/stable/options.html#tornado.options.OptionParser.mockable\nThank you", "issue_status": "Closed", "issue_reporting_time": "2018-02-02T22:33:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "243": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2267", "issue_id": "#2267", "issue_summary": "Unexpected uncaught exception using AsyncHTTPClient", "issue_description": "kleptog commented on 2 Feb 2018\nTornado: 4.5.2 (but the code it the same in current versions)\nWe internally have implemented proxy support for the AsyncHTTPClient. The standard advice is to use the Curl HTTP client but on the platform we were using it had some issues with the client EC certificates, which the Tornado client has no problems with. Anyway, we're running into a problem with uncaught exceptions and think there is a bug in the tornado code.\nIn tornado/simple_httpclient.py the code looks at follows:\nclass _HTTPConnection(httputil.HTTPMessageDelegate):\n    [...]\n    def __init__(self, io_loop, client, request, release_callback,\n                 final_callback, max_buffer_size, tcp_client,\n                 max_header_size, max_body_size):\n        [...]\n        with stack_context.ExceptionStackContext(self._handle_exception):\n            [...]\n            self.tcp_client.connect(host, port, af=af,\n                                    ssl_options=ssl_options,\n                                    max_buffer_size=self.max_buffer_size,\n                                    callback=self._on_connect)\nNote that self.tcp_client is an instance of the TCPClient class and TCPClient.connect is marked @gen.coroutine. Note that instead of yielding on the connect it uses the callback argument which the wrapper handles for you.\nThe problem is that if the connect method throws an exception, sometimes but not always (it apparently depends on where the exception is thrown) becomes an uncaught exception. The stack trace is as follows:\n2018-02-01 15:16:29,792 ERROR    testprogram Exiting due to uncaught exception in  <functools.partial object at 0x7f193956a368>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 605, in _run_callback\n    ret = callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 345, in wrapped\n    raise_exc_info(exc)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 316, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 289, in <lambda>\n    future, lambda future: callback(future.result()))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 238, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 1069, in run\n    yielded = self.gen.send(value)\n  File \"/usr/local/lib/python2.7/dist-packages/shared-0.1-py2.7.egg/shared/connect.py\", line 47, in connect\n    raise HTTPError(start_line.code, start_line.reason)\nHTTPError: HTTP 503: Service Unavailable\nThe callback passed to connect (self._on_connect) does not expect to be passed an exception tuple, and the with ExceptionStackContext won't catch it either if it is not in the first part of the connect method. You are apparently not allowed to yield within a with StackContext block, so that explains the lack of yield. But then I don't understand how exceptions in the connect are supposed to propagate from TCPClient.connect. I've also tried other things like setting stream.error to the exception and simply returning the stream, but cause strange effects (double stack traces, and still the unexpected exception).\nWhat am I missing?\nFor reference, the proxy support we wrote is here:\nfrom tornado.simple_httpclient import SimpleAsyncHTTPClient\n\n\nclass ProxiedAsyncHTTPClient(SimpleAsyncHTTPClient):\n\n    def initialize(self, io_loop, proxy_host, proxy_port, *args, **kwargs):\n        super(ProxiedAsyncHTTPClient, self).initialize(io_loop, *args, **kwargs)\n        self.tcp_client = ProxiedTCPClient(io_loop, proxy_host, proxy_port)\n\nclass ProxiedTCPClient(object):\n    \"\"\" Copy from TCPClient with support for HTTP proxies \"\"\"\n\n    def __init__(self, io_loop, proxy_host, proxy_port):\n        self.io_loop = io_loop\n        self.proxy_host = proxy_host\n        self.proxy_port = proxy_port\n        self.resolver = ThreadedResolver(io_loop=io_loop)\n\n    def close(self):\n        self.resolver.close()\n\n    @coroutine\n    def connect(self, host, port, af=socket.AF_UNSPEC, ssl_options=None,\n                max_buffer_size=None):\n        addrinfo = yield self.resolver.resolve(self.proxy_host, self.proxy_port, af)\n        connector = _Connector(\n            addrinfo, self.io_loop, functools.partial(self._create_stream, max_buffer_size))\n        af, addr, stream = yield connector.start()\n\n        # Do the proxy stuff (note that timeouts are checked at a higher level)\n        yield stream.write(\"CONNECT {}:{} HTTP/1.0\\r\\n\\r\\n\".format(host, port))\n        response = yield stream.read_until_regex(b\"\\r?\\n\\r?\\n\", max_bytes=65536)\n\n        data = native_str(response.decode('latin1')).lstrip(\"\\r\\n\")\n        eol = data.find(\"\\n\")\n        start_line = parse_response_start_line(data[:eol].rstrip(\"\\r\"))\n        if start_line.code != 200:\n            stream.close()\n            raise HTTPError(start_line.code, start_line.reason)\n\n# Uncomment these lines to get double stacktraces\n#        stream.error = Exception(\"Test\")\n#        stream.close()\n#        raise Return(stream)\n        if ssl_options is not None:\n            stream = yield stream.start_tls(False, ssl_options=ssl_options,\n                                            server_hostname=host)\n\n        raise Return(stream)\n\n    def _create_stream(self, max_buffer_size, af, addr):\n        stream = IOStream(socket.socket(af),\n                          max_buffer_size=max_buffer_size)\n        return stream.connect(addr)", "issue_status": "Closed", "issue_reporting_time": "2018-02-02T13:44:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "244": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2265", "issue_id": "#2265", "issue_summary": "IOLoop.make_current under forked process", "issue_description": "Contributor\nmrocklin commented on 31 Jan 2018\nThis used to work under 4.5.2 and now fails under 5.0\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\ndef f():\n    IOLoop.clear_instance()\n    IOLoop.clear_current()\n    loop = IOLoop()\n    loop.make_current()\n    print(IOLoop.current() is loop)\n\nimport multiprocessing\nmultiprocessing.Process(target=f).start()  # prints True\n\nasync def g():\n    multiprocessing.Process(target=f).start()\n\nIOLoop.current().run_sync(g)  # prints True in 4.5.2, False in master", "issue_status": "Closed", "issue_reporting_time": "2018-01-31T13:06:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "245": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2264", "issue_id": "#2264", "issue_summary": "creating futures in one thread to be used in another", "issue_description": "Contributor\nminrk commented on 31 Jan 2018\nOne hiccup I've encountered working with the new asyncio support is that I have some applications where I instantiate Future objects in one thread to be used in an IOLoop that's in a background thread. It's a basic pattern of building a blocking API with tornado in the background. This works fine with concurrent.futures, which don't hold a reference to the loop, but it doesn't work anymore now that tornado uses asyncio.Future, which create a reference to the ioloop at construction time, and I believe aren't threadsafe in general. Specifically, I found that it's my calls to gen.multi_future, where I'm getting Futures created by tornado wrapping my concurrent.futures that result in hangs. I've managed to fix the problem in my application by shipping a copy of multi_future that only changes _create_future to return concurrent.futures.Future instead of asyncio.Future.\nI'm doing something akin to:\nloop = IOLoop(make_current=False)\n\ndef ioloop_thread():\n    loop.make_current()\n\ndef other_thread():\n    future = Future()\n    loop.add_callback(lambda : something_that_will_resolve(future))\nI can get in situations where the future never resolves, because of code like this, since future._loop isn't running.\nWith tornado 5, I can create Futures attached to a specific loop with loop.asyncio_loop.create_future(), but gen.multi_future() doesn't give me the option to specify a loop.\nMy real question is: what's the best way to construct Futures in one thread when the IO is happening in another, or backing up a bit, what's the best way to do a blocking API with tornado handling events in the background?", "issue_status": "Closed", "issue_reporting_time": "2018-01-31T11:32:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "246": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2262", "issue_id": "#2262", "issue_summary": "StaticFileHandler returns 304 despite etag mismatch", "issue_description": "Contributor\npolygon commented on 29 Jan 2018 \u2022\nedited\nI am not sure if this is an actual issue in the code or with my deployment, but it caused me some head-scratching.\nI am using Tornado as an API webserver for an embedded system. It also serves a small web application using the StaticFileHandler. To fix issues with caching browsers, I subclassed the StaticFileHandler to send Cache-Control headers like so:\nclass NoCacheStaticFileHandler(tornado.web.StaticFileHandler):\n    def set_extra_headers(self, path):\n        self.set_header('Cache-control', 'no-cache, must-revalidate, max-age=0')\nThe problem I am seeing is that, despite the browser sending a different Etag than the server calculates, the server still sends a 304. I dug a bit into the code and found the following:\ndef should_return_304(self):\n    \"\"\"Returns True if the headers indicate that we should return 304.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    if self.check_etag_header():\n        return True\n\n    # Check the If-Modified-Since, and don't send the result if the\n    # content has not been modified\n    ims_value = self.request.headers.get(\"If-Modified-Since\")\n    if ims_value is not None:\n        date_tuple = email.utils.parsedate(ims_value)\n        if date_tuple is not None:\n            if_since = datetime.datetime(*date_tuple[:6])\n            if if_since >= self.modified:\n                return True\n\n    return False\nEssentially, this seems to return 304 if either Etag headers match or the If-Modified-Since date the client sent is later than the file on the server. Is this how it should be? The browser sends a different hash, the server knows that the versions do not match but still sends a 304 because the date is newer? It feels like the server should not send a 304 when one property does not match.\nThe issue might be specific to the system here since the dates there are not very reliable. But I had it several times now that the data on the server was updated but it kept sending 304 despite an Etag mismatch because of the If-Modified-Since headers.", "issue_status": "Closed", "issue_reporting_time": "2018-01-29T11:04:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "247": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2261", "issue_id": "#2261", "issue_summary": "Celery + Tornado + Python generators: list changed size during iteration.", "issue_description": "salar-khan-symc commented on 29 Jan 2018 \u2022\nedited\nTornado version: 4.2.1\nHi! I'm using tornado for making parallel async requests to some APIs to avoid serially waiting for each request to come in. To do this what I have done is I have created the following generator:\ndef parallelize(requests, batch_size=100, timeout=120, log=None):\n    if timeout==None or timeout<=0:\n    \u00a6   timeout = 120 # this to assure the generator won't wait on result_queue forever\n\n    http_client = AsyncHTTPClient(max_clients=batch_size)\n    # http_client.configure(None, defaults=dict(connect_timeout=45, request_timeout=60))\n    sendTotal = 0\n    recvTotal = 0\n    wind = batch_size\n    '''\n    \u00a6   parallelize return as a generator, which should be used like a lazy collection.\n    \u00a6   result_queue is used to collect http response, and yield the response into the lazy collection\n    '''\n    result_queue = Queue.Queue()\n    iterable = iter(requests or [])\n\n    threading.Thread(target=tornado.ioloop.IOLoop.instance().start).start()\n    try:\n    \u00a6   while True:\n    \u00a6   \u00a6   # send as many requests asynchronously\n    \u00a6   \u00a6   has_more = False\n    \u00a6   \u00a6   for req in iterable:\n    \u00a6   \u00a6   \u00a6   if not req:\n    \u00a6   \u00a6   \u00a6   \u00a6   continue\n    \u00a6   \u00a6   \u00a6   http_client.fetch(req.http_request, callback=partial(req.response_callback_handler, result_queue))\n    \u00a6   \u00a6   \u00a6   wind -= 1\n    \u00a6   \u00a6   \u00a6   sendTotal += 1\n    \u00a6   \u00a6   \u00a6   has_more = True\n    \u00a6   \u00a6   \u00a6   if wind <= 0:\n    \u00a6   \u00a6   \u00a6   \u00a6   break;\n    \u00a6   \u00a6   # wait for the asynchronous responses\n    \u00a6   \u00a6   if recvTotal >= sendTotal:\n    \u00a6   \u00a6   \u00a6   if log:\n    \u00a6   \u00a6   \u00a6   \u00a6   log('received %d' % recvTotal)\n\n    \u00a6   \u00a6   if has_more and sendTotal % batch_size == 0 and log:\n    \u00a6   \u00a6   \u00a6   log('sent %d' % sendTotal)\n\n    \u00a6   \u00a6   \u00a6   \u00a6\n    \u00a6   \u00a6   try:\n    \u00a6   \u00a6   \u00a6   result = result_queue.get(timeout=timeout)\n    \u00a6   \u00a6   \u00a6   result_queue.task_done()\n    \u00a6   \u00a6   except Exception, ex:\n    \u00a6   \u00a6   \u00a6   result = ex\n    \u00a6   \u00a6   \u00a6   result.request = 'Unknown'\n    \u00a6   \u00a6   \u00a6\n    \u00a6   \u00a6   yield result\n    \u00a6   \u00a6   recvTotal += 1\n    \u00a6   \u00a6   wind += 1\n    \u00a6   \u00a6   if recvTotal % batch_size == 0 and log:\n    \u00a6   \u00a6   \u00a6   log('received %d' % recvTotal)\n    finally:\n    \u00a6   tornado.ioloop.IOLoop.instance().stop()\nI've removed the non-issue-related code from this - just some loggers and book keeping. The problem is I'm getting the following exception:\n[2018-01-29 07:10:18,411: WARNING/28947] Exception in thread Thread-5: \nTraceback (most recent call last): \nFile \"/usr/lib/python2.7/threading.py\", line 801, in __bootstrap_inner self.run() \nFile \"/usr/lib/python2.7/threading.py\", line 754, in run self.__target(*self.__args, **self.__kwargs) \nFile \"/home/madmin/venv/connectors/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 794, in start heapq.heappop(self._timeouts) \nRuntimeError: list changed size during iteration\nTo provide more information: this code piece runs as a task, inside a celery worker.\nWhat I cannot get my head around is that the exact problem is arising in ioloop.py at a place which deals with timeouts, even though there is no place in my code base which calls 'add_timeout' on the main thread. I'm only using AsyncHTTPClient.fetch - which internally uses add_callback, only if I'm not wrong! This works fine on my local setup, but this exception throws up when I deploy to the could. I've been looking into this since days, I haven't figured out exactly why this is so, any help would be greatly appreciated. Thank you!", "issue_status": "Closed", "issue_reporting_time": "2018-01-29T07:52:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "248": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2260", "issue_id": "#2260", "issue_summary": "Are there any plans to implement router in trie or radix-tree?", "issue_description": "jiajunhuang commented on 28 Jan 2018\nit seems that tornado use a list to store rules:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/routing.py#L302\nby using a tree-like data structure, the complexity of process find handler will speed up. there need less space to store URIs, too.", "issue_status": "Closed", "issue_reporting_time": "2018-01-28T10:03:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "249": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2258", "issue_id": "#2258", "issue_summary": "How it work ?", "issue_description": "chemostafa commented on 27 Jan 2018\nSorry I new in programmes\nI tray\nsh runtests.sh\nruntests.sh\n.............................................................................ssssssssssssssssssssssssssssssssss.............................................................................................................................................................................................................................................................................................................................ss................sss..................................................................................................................................................................................................................ss...........ss.....................................................................................................s.....................................................................................F......................................ss...s................................................s.............................ssssssssssssss.........s.............................................................s...................................................................................................................................s.................................s...................................s..........................................................................................................................s........................................................................................\nFAIL: test_request_timeout (tornado.test.simple_httpclient_test.SimpleHTTPSClientTestCase)\nTraceback (most recent call last):\nFile \"/data/data/com.termux/files/home/tornado/tornado/testing.py\", line 118, in call\nresult = self.orig_method(*args, **kwargs)\nFile \"/data/data/com.termux/files/home/tornado/tornado/test/simple_httpclient_test.py\", line 268, in test_request_timeout\nself.assertEqual(str(response.error), \"HTTP 599: Timeout during request\")\nAssertionError: 'HTTP 599: Timeout while connecting' != 'HTTP 599: Timeout during request'\nHTTP 599: Timeout while connecting\nHTTP 599: Timeout during request\nRan 1483 tests in 160.757s\nFAILED (failures=1, skipped=68)\nSome tests were skipped because: IOLoop configuration not available,\ncurl client accepts invalid headers, localhost does not resolve to\nipv6, needs fix, no testable future imports, non-windows platform,\npycares module not present, pycurl module not present,\ntornado.speedups module not present, twisted module not present\nSo I go to\ncd home/tornado/demos/facebook\nAnd I tray\npython Facebook.py\nTraceback (most recent call last):\nFile \"facebook.py\", line 18, in\nimport tornado.auth\nModuleNotFoundError: No module named 'tornado'\nAny help plz ?", "issue_status": "Closed", "issue_reporting_time": "2018-01-27T17:07:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "250": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2256", "issue_id": "#2256", "issue_summary": "Tornado security vulnerabilities with respect to DNS Rebinding", "issue_description": "gripedthumbtacks commented on 26 Jan 2018\nHello,\nCan some language be added to the security page regarding DNS rebinding attacks on Tornado apps? There is no mention of this issue, and by default, any app running on Tornado is likely to be vulnerable to DNS rebinding since this issue is not mentioned and the framework does not actively encourage protections against it.\nhttp://www.tornadoweb.org/en/stable/guide/security.html\nhttps://en.wikipedia.org/wiki/DNS_rebinding\nA good base fix is pretty simple. Simply ensure that the default Host handler is at least somewhat restrictive. Perhaps default to localhost. If a developer or configuration wants to override this, they can refer to the security risks with allowing any domain in the HTTP Host header for their application. The risk of allowing * means that the app is likely vulnerable to DNS rebinding. Encouraging developers to choose safe defaults here could protect millions of users. A default regex that is not * would go a long way :) But I know fixing thousands of apps already built is impossible, so adding the language to the docs and thinking about the next major release changes to protect this might be the best way forward to protect new apps being created atop Tornado.", "issue_status": "Closed", "issue_reporting_time": "2018-01-26T00:49:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "251": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2255", "issue_id": "#2255", "issue_summary": "a error occured when use tornado in circus", "issue_description": "zhangjianpinghik commented on 25 Jan 2018\nTraceback (most recent call last):\nFile \"/usr/local/lib/python3.4/dist-packages/tornado/web.py\", line 1468, in _stack_context_handle_exception\nraise_exc_info((type, value, traceback))\nFile \"\", line 4, in raise_exc_info\nFile \"/usr/local/lib/python3.4/dist-packages/tornado/web.py\", line 1670, in wrapper\nresult = method(self, *args, **kwargs)\nFile \"/usr/local/lib/python3.4/dist-packages/TornadIO2-0.0.3-py3.4.egg/tornadio2/polling.py\", line 148, in get\nself.session = self._get_session(session_id)\nFile \"/usr/local/lib/python3.4/dist-packages/TornadIO2-0.0.3-py3.4.egg/tornadio2/polling.py\", line 54, in _get_session\nraise HTTPError(401, 'Invalid session')\ntornado.web.HTTPError: HTTP 401: Unauthorized (Invalid session)", "issue_status": "Closed", "issue_reporting_time": "2018-01-25T12:05:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "252": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2254", "issue_id": "#2254", "issue_summary": "Tornado templates render syntax problems.", "issue_description": "ZHDeveloper commented on 24 Jan 2018\nmy html code:\n<div class=\"pageCont lph-article-comView \">\n    {{article.content}}\n</div>\nconsole log\ncontent\uff1a<p>&nbsp; &nbsp;&nbsp;<span style=\"color: rgb(51, 51, 51); font-family: arial; font-size: 16px; text-align: justify;\">\u3010</span><span style=\"color: rgb(51, 51, 51); font-family: arial; font-size: 16px; text-align: justify;\">\u73af\u7403\u7f51\u7efc\u5408\u62a5\u9053\u301123\u65e5\u4e0a\u5348\uff0c\u4e2d\u56fd\u94f6\u6cb3\u8bc1\u5238\u5728\u4eac\u4e3e\u529eA\u80a1\u4e0a\u5e02\u4e00\u5468\u5e74\u5e86\u5178\u66a8\u667a\u80fdAPP3.0\u53d1\u5e03\u4f1a\uff0c\u5e76\u4e0e\u963f\u91cc\u4e91\u7b7e\u7f72\u4e86\u5168\u9762\u5408\u4f5c\u6846\u67b6\u534f\u8bae\u3002\u4e2d\u56fd\u94f6\u6cb3\u8bc1\u5238\u526f\u603b\u88c1\u7f57\u9ece\u660e\u8868\u793a\uff0c\u5c06\u4ee5\u201c\u6280\u672f\u667a\u80fd\u5408\u4f5c\u201d\u4e3a\u5951\u673a\uff0c\u5168\u9762\u63d0\u5347\u94f6\u6cb3\u8bc1\u5238\u7efc\u5408\u8fd0\u8425\u670d\u52a1\u80fd\u529b\u3002</span></p>\nHow can I solve this problem? Can you help me? Thank you!", "issue_status": "Closed", "issue_reporting_time": "2018-01-24T10:18:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "253": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2247", "issue_id": "#2247", "issue_summary": "Using vpn causes address assigning error when deploy locally", "issue_description": "Takkoona commented on 12 Jan 2018\nHi,\nKind of new to web developing and tornado here (using version 4.5.3 and web hosting is done by nginx). I was just freaked out by a peculiar error. First, just let me have a little bit explanation on my situation. I'm in a area where extremely strict internet censorship is applied, which blocks some websites that I need for my work. So I bought a commercial vpn to get access to those sites. When I'm not on vpn, tornado works fine with 'localhost'. But, when vpn is on, Debian 9.2 (or 9.3?) doesn't allow me to deploy:\nTraceback (most recent call last):\nFile \"/home/xxxx/.PyCharmCE2017.3/config/scratches/tornatorial.py\", line 45, in <module>\nhttp_server.listen(8888, address='localhost')\nFile \"/home/xxxx/PycharmProjects/xxxxx/venv/lib/python3.5/site-packages/tornado/tcpserver.py\", line 142, in listen\nsockets = bind_sockets(port, address=address)\nFile \"/home/xxxx/PycharmProjects/xxxx/venv/lib/python3.5/site-packages/tornado/netutil.py\", line 197, in bind_sockets\nsock.bind(sockaddr)\nOSError: [Errno 99] Cannot assign requested address\nI thought I would have to turn on and off vpn back and forth to keep work on, which really sucks. But I didn't give up and finally found out that when I'm not using the 'address' argument in 'http_server.listen', it strangely works out!? Basically I just did the following change:\nfrom:\nhttp_server.listen(8888, address='localhost')\nto:\nhttp_server.listen(8888)\nThe issue is already fixed. I'm just so interested in what the hell was happening there and I was so freaked out! Can someone help me out. I appreciate it.\nThank you in advance!", "issue_status": "Closed", "issue_reporting_time": "2018-01-12T07:51:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "254": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2246", "issue_id": "#2246", "issue_summary": "Different behavior with RequestHandler#flush() using callback or Future", "issue_description": "rmedaer commented on 10 Jan 2018\nHere is two handlers which should IMO (and if I well understood) do the same result.\nThe example's purpose is to send (write + flush) chunks one by one in order to handle simultaneous requests.\nThe first one yield the result of flush() method which is a Future.\nThe second create an instance of Future and use it set_result method as callback for flush().\nThe issue demo is available here.\ndef mygenerator():\n    for i in range(0, 10):\n        yield 'data'\n\nclass WithFutureHandler(RequestHandler):\n    @gen.coroutine\n    def get(self):\n        log('Start request', current_id)\n\n        for chunk in mygenerator():\n            log('Writing from request', current_id)\n            self.write(chunk)\n\n            yield self.flush()\n\n        self.finish()\n\nclass WithCallbackHandler(RequestHandler):\n    @gen.coroutine\n    def get(self):\n        log('Start request', current_id)\n\n        for chunk in mygenerator():\n            log('Writing from request', current_id)\n            self.write(chunk)\n\n            f = Future()\n            self.flush(callback=functools.partial(f.set_result, None))\n            yield f\n        \n        self.finish()\nHere is the behavior I'm observing:\nUsing Future: I guess the IOLoop is not releasing context of first request during the flush.\nStart request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nWriting from request 1\nStart request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nWriting from request 2\nUsing callback + my own future: At each flush I have the context switching I want !\nStart request 1\nWriting from request 1\nStart request 2\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nWriting from request 1\nWriting from request 2\nI hope my issue description is clear enough ! Many thanks in advance.", "issue_status": "Closed", "issue_reporting_time": "2018-01-10T14:29:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "255": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2240", "issue_id": "#2240", "issue_summary": "IOLoop.clear_instance() and IOLoop.clear_current() broken", "issue_description": "Contributor\npitrou commented on 3 Jan 2018 \u2022\nedited\nThis is on git master:\n>>> from tornado.ioloop import IOLoop\n>>> IOLoop.clear_current()\nTraceback (most recent call last):\n  File \"<ipython-input-4-59b136f0bd53>\", line 1, in <module>\n    IOLoop.clear_current()\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 322, in clear_current\n    old = IOLoop._current.instance\nAttributeError: '_thread._local' object has no attribute 'instance'\n\n>>> IOLoop.clear_instance()\nTraceback (most recent call last):\n  File \"<ipython-input-5-cf608ef320e5>\", line 1, in <module>\n    IOLoop.clear_instance()\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 263, in clear_instance\n    IOLoop.clear_current()\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 322, in clear_current\n    old = IOLoop._current.instance\nAttributeError: '_thread._local' object has no attribute 'instance'\nCompare with v4.5.2:\n>>> from tornado.ioloop import IOLoop\n>>> IOLoop.clear_current()\n>>> IOLoop.clear_instance()", "issue_status": "Closed", "issue_reporting_time": "2018-01-03T10:03:52Z", "fixed_by": "#2248", "pull_request_summary": "ioloop,gen,asyncio: Improvements to IOLoop GC", "pull_request_description": "Member\nbdarnell commented on 14 Jan 2018\nEnsure that after an IOLoop is closed, any coroutines running on it are able to be GC'd. Improve management of the \"current\" IOLoop and correspondence with the asyncio loop to ensure that we don't orphan an asyncio event loop without closing it (or leaving it as current).\nIncludes a rebase of #2230\nCloses #2230\nFixes #2229\nFixes #2240", "pull_request_status": "Merged", "issue_fixed_time": "2018-01-14T15:16:58Z", "files_changed": [["32", "tornado/gen.py"], ["15", "tornado/ioloop.py"], ["37", "tornado/platform/asyncio.py"], ["7", "tornado/test/concurrent_test.py"], ["90", "tornado/test/gen_test.py"], ["11", "tornado/test/ioloop_test.py"]]}, "256": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2239", "issue_id": "#2239", "issue_summary": "release: 5.0", "issue_description": "Member\nbdarnell commented on 1 Jan 2018 \u2022\nedited\nA companion to #2234, this issue is a place to track or suggest issues/PRs that aren't yet fixed/merged in master but should be included in the 5.0 release.\n(The fact that this is empty doesn't mean that I'm planning to take master as it is for 5.0. I haven't done a pass over the queue yet to see what makes my list. I'm just opening this up to suggestions before I finish that)", "issue_status": "Closed", "issue_reporting_time": "2018-01-01T01:50:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "257": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2234", "issue_id": "#2234", "issue_summary": "release: 4.5.3", "issue_description": "Member\nbdarnell commented on 31 Dec 2017 \u2022\nedited\nThe following PRs have been nominated for inclusion in a 4.5.3 release:\n#2225\n#2020\n#2236 (fixes issue introduced by #2225)\n#1949 (fixes tests for tornado_http2)", "issue_status": "Closed", "issue_reporting_time": "2017-12-30T19:48:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "258": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2231", "issue_id": "#2231", "issue_summary": "httputil.py parse_response_start_line() raise HTTPInputError when ResponseStartLine tuple missing \"reason\" key in response header", "issue_description": "layer3switch commented on 29 Dec 2017 \u2022\nedited\nWhile most HTTP server response will provide \"version\", \"code\" and \"reason\" in response header string such as \"HTTP/1.1 200 OK\", it is also not necessary to include \"OK\" as reason key value. Some http servers will not include reason in its header response.\nWhen \"reason\" key value is missing in the header, tornado.httputil.parse_response_start_line() will raise HTTPInputError and fails to parse rest of response header.\nAs shown below when \"OK\" is missing in the first header line;\n>>> tornado.httputil.parse_response_start_line(\"HTTP/1.1 200\")\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python2.7/site-packages/tornado/httputil.py\", line 854, in parse_response_start_line\n    raise HTTPInputError(\"Error parsing response start line\")\ntornado.httputil.HTTPInputError: Error parsing response start line\nIn parse_response_start_line() definition, re.match expects exactly 3 keys assigned from line string due to space as delimiter;\ntornado/tornado/httputil.py\nLine 853 in c60c7f0\n match = re.match(\"(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)\", line) \nMy proposal to fix this, remove space between 2nd and 3rd match case.\n    match = re.match(\"(HTTP/1.[0-9]) ([0-9]+)([^\\r]*)\", line)", "issue_status": "Closed", "issue_reporting_time": "2017-12-29T18:06:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "259": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2229", "issue_id": "#2229", "issue_summary": "Reference cycle through Future and Runner can create leak", "issue_description": "Contributor\npitrou commented on 29 Dec 2017\nI'm having an infinite coroutine (basically a while True: ... wrapped in a @gen.coroutine) that seems to create a leak somewhere, even though all external references get cleared. I was scratching my head a bit and came to the following hypothesis: the existence of the _futures_to_runners mapping keeps the Runner alive until its Future gets destroyed. However, if the Future itself is for some reason kept alive by the Runner (through an arbitrarily complex reference chain), then the cyclic collector isn't able to make out the reference cycle and break it.\nDoes that sound like a reasonable explanation? Does it mean that moving to await and async def would clear the reference leak (as an external mapping is not needed anymore)?", "issue_status": "Closed", "issue_reporting_time": "2017-12-28T18:35:40Z", "fixed_by": "#2248", "pull_request_summary": "ioloop,gen,asyncio: Improvements to IOLoop GC", "pull_request_description": "Member\nbdarnell commented on 14 Jan 2018\nEnsure that after an IOLoop is closed, any coroutines running on it are able to be GC'd. Improve management of the \"current\" IOLoop and correspondence with the asyncio loop to ensure that we don't orphan an asyncio event loop without closing it (or leaving it as current).\nIncludes a rebase of #2230\nCloses #2230\nFixes #2229\nFixes #2240", "pull_request_status": "Merged", "issue_fixed_time": "2018-01-14T15:16:58Z", "files_changed": [["32", "tornado/gen.py"], ["15", "tornado/ioloop.py"], ["37", "tornado/platform/asyncio.py"], ["7", "tornado/test/concurrent_test.py"], ["90", "tornado/test/gen_test.py"], ["11", "tornado/test/ioloop_test.py"]]}, "260": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2226", "issue_id": "#2226", "issue_summary": "Error applying scope param during OAuth login", "issue_description": "jpolchlo commented on 27 Dec 2017\nI came across a small problem when attempting to authenticate through an OAuth server that required a scope param to be supplied while obtaining an authorization code. Currently, a scope argument will have its characters interleaved with spaces due to this line in auth.py:\nargs['scope'] = ' '.join(scope)\ncurrently at line 600 (found in OAuth2Mixin.authorize_redirect). I locally altered my tornado version to remove the spaces and my login succeeded.", "issue_status": "Closed", "issue_reporting_time": "2017-12-26T20:36:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "261": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2222", "issue_id": "#2222", "issue_summary": "Improve options' document", "issue_description": "Sraw commented on 22 Dec 2017\nThere is no document about store true action in options. But after reading source code, I find it is supported by default. For example:\npython app.py --debug will set options.debug to True if define(\"debug\", type=bool, default=False).\nSo why it isn't documented?", "issue_status": "Closed", "issue_reporting_time": "2017-12-22T03:19:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "262": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2216", "issue_id": "#2216", "issue_summary": "How to keep reference of HTTP request in logging ?", "issue_description": "rmedaer commented on 15 Dec 2017\nI'm using (a lot) logging through tornado.log. Each time I implement a little bit more complex handler, I'm adding some tornado.log.gen_log.debug(\"I'm doing some stuff\"); to keep trace of what I'm doing and obviously to help maintenance and debugging.\nHowever, since tornado has a great asynchronous pattern, I have logs mixed across simultaneous requests. It makes debugging impossible !\nThe easiest solution would be to add reference of HTTP request concerned by the log line. The question is then: how to do it ?", "issue_status": "Closed", "issue_reporting_time": "2017-12-15T13:26:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "263": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2215", "issue_id": "#2215", "issue_summary": "Tornado service works well, but many warnings are logged.", "issue_description": "WisZhou commented on 14 Dec 2017\nOS: Ubuntu 14.04.1\nKernel: Linux 3.13.0-105-generic\nPython: 2.7.6\nTornado: 4.4.2\nNginx: 1.4.6\nI start a tornado service on my server. Each request can be handled correctly.\nBut I found a lot of warnings in the tornado log. They only appear when no request is received within a period of time.\nWhat do these warnings mean?\nHow do I deal with them?\nWarning log:\n[WARNING][2017-12-14 12:29:42,372] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED\n[WARNING][2017-12-14 12:29:43,610] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED\n[WARNING][2017-12-14 12:29:44,165] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED\n[WARNING][2017-12-14 12:29:45,329] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED\n[WARNING][2017-12-14 12:29:45,330] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED\n[WARNING][2017-12-14 12:29:46,498] tornado.general iostream.py:_handle_connect:1186 | Connect error on fd 7: ECONNREFUSED", "issue_status": "Closed", "issue_reporting_time": "2017-12-14T04:44:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "264": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2214", "issue_id": "#2214", "issue_summary": "await get on an empty asyncio.Queue doesn't resolve when used with Tornado's ioloop.", "issue_description": "bhch commented on 13 Dec 2017 \u2022\nedited\nDoing await queue.get() on a empty asyncio.Queue never resolves even though something is put in the queue later.\nThis only happens when using asyncio.Queue with Tornado's event loop and using await queue.get() when queue is empty.\nThis doesn't happen when using asyncio's event loop or when using tornado.queues.Queue.\nI'm using Python 3.6.3 and Tornado 4.5.2", "issue_status": "Closed", "issue_reporting_time": "2017-12-13T14:04:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "265": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2211", "issue_id": "#2211", "issue_summary": "set_close_exec in bind_sockets()", "issue_description": "asynchronoust commented on 8 Dec 2017\nWhy is there set_close_exec function in bind_sockets()?\nIn multi-process http server in tornado, the exec does not be called after os.fork(), so it is no need to call set_close_exec to close the fd opened in parent process after child processes start. And the sockets are be used in child process to handle request.\nSo what is the reason to call set_close_exec() after socket.socket()?\nThanks !!", "issue_status": "Closed", "issue_reporting_time": "2017-12-08T15:43:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "266": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2206", "issue_id": "#2206", "issue_summary": "Web Socket Disconnecting With Small Files", "issue_description": "RenFinkle commented on 3 Dec 2017\nWeb socket disconnects on messages with < 2 mb of base64. Some smaller files will work tested up to 300 kb will work. Otherwise it will just disconnect the client.\nRelevant code:\nClient (using websockets):\nwith open(\"private/\" + file, \"rb\") as f:\n    responsef = base64.b64encode(f.read()).decode()\n    responsej = json.dumps({\"file\": responsef})\n    await websocket.send(\"22::\" + responsej + \"||\" + client)\nServer:\nmh, mb = message.split(\"::\")\nresponse, client = mb.split(\"||\")\nself.clientd[client + \".client\"].write_message(\"22::\" + response)", "issue_status": "Closed", "issue_reporting_time": "2017-12-02T19:55:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "267": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2203", "issue_id": "#2203", "issue_summary": "Exception in callback functools.partial() when running jupyter console on Mac OS X", "issue_description": "avigan commented on 24 Nov 2017\nI recently started to have a problem running jupyter console on Mac OS X 10.12.8, which appears to be linked to tornado. Here is the output:\n[18:33] ~ > jupyter console\nERROR:tornado.application:Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0x10f33f400>)\nTraceback (most recent call last):\n  File \"/Users/avigan/anaconda3/lib/python3.6/site-packages/tornado/ioloop.py\", line 605, in _run_callback\n    ret = callback()\n  File \"/Users/avigan/anaconda3/lib/python3.6/site-packages/tornado/stack_context.py\", line 277, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/Users/avigan/anaconda3/lib/python3.6/site-packages/ipykernel/kernelbase.py\", line 265, in enter_eventloop\n    self.eventloop(self)\n  File \"/Users/avigan/anaconda3/lib/python3.6/site-packages/ipykernel/eventloops.py\", line 277, in loop_cocoa\n    show.mainloop()\nAttributeError: 'function' object has no attribute 'mainloop'\nJupyter console 5.2.0\nI do not have much knowledge of tornado but I can provide additional inputs if needed.", "issue_status": "Closed", "issue_reporting_time": "2017-11-24T17:38:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "268": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2202", "issue_id": "#2202", "issue_summary": "every child process use different memory in tornado multi-process", "issue_description": "asynchronoust commented on 23 Nov 2017\ni use httpserver.start(n) to start multiprocess to handle request. multiprocess share the one socket to get request data.\nbut i find one stange thing than these children processes use different memory between them. Why? It is so strange.\ni check these processes, the process using large memory has a great many opened files, but other process that using small memory has very few opened files.\nfrom above, i can find, a lots of request are been handled by large memory process\nso why? the children should be same.\nthese processes are:\nPID | CPU percent | memory usage| io util\n26286 | 53.90% | 5.3 GB | 0.00%\n26285 | 61.10% | 4.1 GB | 0.00%\n26284 | 54.80% | 2.9 GB | 0.00%\n26283 | 44.80% | 1.9 GB | 0.00%\n26287 | 44.80% | 1007.3 MB | 0.00%\n26282 | 39.00% | 502.8 MB | 0.00%\n26281 | 31.80% | 41.7 MB | 0.00%\n26280 | 25.10% | 37.7 MB | 0.00%\n26279 | 19.20% | 34.3 MB | 0.00%\n26278 | 15.40% | 32.1 MB | 0.00%\n26257 | 4.70% | 31.1 MB | 0.00%\n26277 | 12.50% | 30.9 MB | 0.00%\n26263 | 6.20% | 30.2 MB | 0.00%\n26259 | 5.40% | 30.2 MB | 0.00%\n26255 | 3.60% | 30.0 MB | 0.00%\n26274 | 8.30% | 30.0 MB | 0.00%\n26272 | 8.60% | 30.0 MB | 0.00%\n26275 | 7.70% | 29.9 MB | 0.00%\n26262 | 6.20% | 29.7 MB | 0.00%\n26273 | 7.40% | 29.6 MB | 0.00%\n26270 | 6.80% | 29.6 MB | 0.00%\n26260 | 5.60% | 29.6 MB | 0.00%\n26268 | 8.90% | 29.6 MB | 0.00%\n26269 | 10.70% | 29.4 MB | 0.00%\n26267 | 7.10% | 29.3 MB | 0.00%\n26271 | 6.50% | 29.3 MB | 0.00%\n26176 | 0.00% | 29.3 MB | 0.00%\n26261 | 5.90% | 29.3 MB | 0.00%\n26266 | 8.00% | 29.3 MB | 0.00%\n26276 | 9.60% | 29.2 MB | 0.00%\n26264 | 7.50% | 29.2 MB | 0.00%\n26256 | 4.00% | 29.1 MB | 0.00%\n26258 | 4.90% | 29.1 MB | 0.00%\n26265 | 7.10% | 29.0 MB | 0.00%", "issue_status": "Closed", "issue_reporting_time": "2017-11-23T15:48:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "269": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2196", "issue_id": "#2196", "issue_summary": "Address family support in OverrideResolver", "issue_description": "Contributor\nrisboo6909 commented on 14 Nov 2017\nI was trying to write tests for my code which uses ThreadedResolver to resolve ip addrs of a list of hosts. Each host may have both ipv4 and ipv6 addrs simultaneously or just one of them, so the goal of the tests was to ensure that my code, which uses ThreadedResolver to obtain those addrs, behaves as expected.\nIf I understand the docs right, OverrideResolver is the right tool to test code that uses various kinds of resolvers. But it appears that I can't easily assign both addrs to one host using OverrideResolver because it lacks of addr family parameter. My solution is to copypaste the code of OverrideResolver into a separate file in my project and add an additional family parameter to resolve method so it can map triplets of (host, port, family) into (host, port). And it works as expected now.\nI propose to add family parameter into OverriderResolver's resolve method for it to cover wider range of use cases.", "issue_status": "Closed", "issue_reporting_time": "2017-11-14T13:47:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "270": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2191", "issue_id": "#2191", "issue_summary": "Inconsistency in add_callback() between PollIOLoop and AsyncIOLoop", "issue_description": "Contributor\npitrou commented on 7 Nov 2017\nWhen the loop is closed, add_callback returns quietly in PollIOLoop but raises RuntimeError in AsyncIOLoop. I don't have an opinion on what the best behavior is (I do find the RuntimeError mildly irritating, especially as you can't easily inspect the loop to know whether it is closed already -- perhaps add a is_closed() method? :-)), but IMHO it would be better if the two were consistent with each other.", "issue_status": "Closed", "issue_reporting_time": "2017-11-07T17:32:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "271": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2189", "issue_id": "#2189", "issue_summary": "asyncio Futures can hang if created from the wrong thread", "issue_description": "Contributor\npitrou commented on 6 Nov 2017\nThis snippet: https://gist.github.com/pitrou/d0ed381729ef9045491263774311e9f0 worked before changeset ac13ee5, but fails afterwards. The reason is asyncio sets the ._loop attribute on its Future objects when said future is created, depending on the current thread's loop. If you create an asyncio Future from a thread and use it from another one, it will never awaken the proper event loop.\nThis seems to be biting us hard and is also very hard to debug, unfortunately. @mrocklin", "issue_status": "Closed", "issue_reporting_time": "2017-11-06T17:02:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "272": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2188", "issue_id": "#2188", "issue_summary": "`set_result` can raise on cancelled future", "issue_description": "Contributor\npitrou commented on 6 Nov 2017\nIf some executing gen.coroutine has its future cancelled by some other code, a spurious error is logged when the generator finishes:\ntornado.application - ERROR - Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0x7fd9840a70d0>, <Future finished result=None>)\nTraceback (most recent call last):\n  File \"/home/antoine/tornado/tornado/gen.py\", line 1065, in run\n    yielded = self.gen.send(value)\nStopIteration\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 687, in _run_callback\n    ret = callback()\n  File \"/home/antoine/tornado/tornado/stack_context.py\", line 277, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/antoine/tornado/tornado/gen.py\", line 1155, in inner\n    self.run()\n  File \"/home/antoine/tornado/tornado/gen.py\", line 1084, in run\n    self.result_future.set_result(_value_from_stopiteration(e))\nasyncio.base_futures.InvalidStateError: invalid state\nThe following patch seems to be a quick fix, but perhaps there is a better resolution.\ndiff --git a/tornado/gen.py b/tornado/gen.py\nindex 533ccb7..18ef4de 100644\n--- a/tornado/gen.py\n+++ b/tornado/gen.py\n@@ -1080,7 +1080,8 @@ class Runner(object):\n                         raise LeakedCallbackError(\n                             \"finished without waiting for callbacks %r\" %\n                             self.pending_callbacks)\n-                    self.result_future.set_result(_value_from_stopiteration(e))\n+                    if not self.result_future.cancelled():\n+                        self.result_future.set_result(_value_from_stopiteration(e))\n                     self.result_future = None\n                     self._deactivate_stack_context()\n                     return\n@bdarnell", "issue_status": "Closed", "issue_reporting_time": "2017-11-06T14:56:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "273": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2186", "issue_id": "#2186", "issue_summary": "_INVALID_HEADER_CHAR_RE", "issue_description": "ghost commented on 4 Nov 2017 \u2022\nedited by ghost\nHello.\ntornado/web.py:356:\n_INVALID_HEADER_CHAR_RE = re.compile(r\"[\\x00-\\x1f]\")\nis used to raise error in:\n         # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request.\n        if RequestHandler._INVALID_HEADER_CHAR_RE.search(retval):\n          raise ValueError(\"Unsafe header value %r\", retval)\nBut some servers able to response unprintable chars, for example \\x01 in Set-Cookie response.\nFor example here is a result of tornado's request to doterra.com:\nHTTPServerRequest(protocol='https', host='www.doterra.com', method='GET', uri='/', version='HTTP/1.1', remote_ip='')\nTraceback (most recent call last):\n  File \"\\tornado\\web.py\", line 1532, in _execute\n  File \"\\tornado\\gen.py\", line 1049, in run\n  File \"\\tornado\\concurrent.py\", line 238, in result\n  File \"\\tornado\\gen.py\", line 1063, in run\n  File \"\\myproj\\request.py\", line 162, in request_handler\n  File \"\\myproj\\request.py\", line 51, in finish_response\n  File \"\\myproj\\request.py\", line 44, in write_headers\n  File \"\\tornado\\web.py\", line 345, in add_header\n  File \"\\tornado\\web.py\", line 385, in _convert_header_value\nValueError: ('Unsafe header value %r', '___utmvaFauNaIi=EnS\\x01okWd; path=/; Max-Age=900')\nAs a solution i do a monkeypatch in my RequestHandler as:\nweb.RequestHandler._INVALID_HEADER_CHAR_RE = re.compile(r\"[\\r\\n]\")\nIs it a bug or I don't understand something? :)", "issue_status": "Closed", "issue_reporting_time": "2017-11-03T19:57:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "274": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2183", "issue_id": "#2183", "issue_summary": "IOLoop.current() doesn't work in non-main thread with AsyncIOLoop configured", "issue_description": "Contributor\npitrou commented on 2 Nov 2017\n>>> loop = IOLoop.current()\n>>> loop\n<tornado.platform.asyncio.AsyncIOMainLoop at 0x7fba6ca64550>\n>>> def f():\n...:    l = IOLoop.current()\n...:    print(l, l is loop)\n...:    \n>>> threading.Thread(target=f).start()\n>>> Exception in thread Thread-572:\nTraceback (most recent call last):\n  File \"/home/antoine/miniconda3/envs/dask36/lib/python3.6/threading.py\", line 916, in _bootstrap_inner\n    self.run()\n  File \"/home/antoine/miniconda3/envs/dask36/lib/python3.6/threading.py\", line 864, in run\n    self._target(*self._args, **self._kwargs)\n  File \"<ipython-input-6-23395fe1f1eb>\", line 2, in f\n    l = IOLoop.current()\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 254, in current\n    current = AsyncIOMainLoop()\n  File \"/home/antoine/tornado/tornado/util.py\", line 306, in __new__\n    instance.initialize(*args, **init_kwargs)\n  File \"/home/antoine/tornado/tornado/platform/asyncio.py\", line 167, in initialize\n    super(AsyncIOMainLoop, self).initialize(asyncio.get_event_loop(),\n  File \"/home/antoine/miniconda3/envs/dask36/lib/python3.6/asyncio/events.py\", line 676, in get_event_loop\n    return get_event_loop_policy().get_event_loop()\n  File \"/home/antoine/miniconda3/envs/dask36/lib/python3.6/asyncio/events.py\", line 584, in get_event_loop\n    % threading.current_thread().name)\nRuntimeError: There is no current event loop in thread 'Thread-572'.\nThis is because the default asyncio event loop policy only automatically creates an event loop for the main thread.", "issue_status": "Closed", "issue_reporting_time": "2017-11-02T13:10:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "275": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2182", "issue_id": "#2182", "issue_summary": "Websocket buffer error", "issue_description": "empeeu commented on 2 Nov 2017\nI'm trying to write a websocket server that sends a good amount of point data for visualization in the browser (using THREE.js). I'm running tornado version 4.5.2.\nI found some issues suggesting I might be using threading incorrectly, but I couldn't find an example that showed me how to properly thread.\nHere's a stripped down example:\nserver.py\n#! /usr/bin/python                                                              \n#                                                                               \nimport tornado, tornado.websocket                                               \nimport threading                                                                \nimport numpy as np                                                              \nimport time                                                                     \n                                                                                \nlock = threading.Lock()                                                         \n                                                                                \nclass EchoWebSocket(tornado.websocket.WebSocketHandler):                        \n    t = 0                                                                       \n    streaming = False                                                           \n    last_message = ''                                                           \n    i = 0                                                                       \n              \n    def check_origin(self, origin):                                             \n        return True                                                             \n                                                                                \n    def open(self):                                                             \n        print(\"WebSocket opened\")                                               \n        self.write_message(\"Connected.\")                                        \n                                                                                \n    def on_message(self, message):                                              \n        if message.upper() == 'STREAM':                                         \n            if not self.streaming:                                              \n                self.streaming = True                                           \n                self.stream_data()                                              \n        elif message.upper() == \"STOP\":                                         \n            self.streaming = False                                              \n        self.last_message = message                                             \n                                                                                \n    def on_close(self):                                                         \n        self.streaming = False                                                  \n        print(\"WebSocket closed\")                                               \n        self.write_message(\"Disconnecting.\")                                    \n                                                                                \n    def stream_data(self):                                                      \n        if not self.streaming:                                                  \n            self.write_message('Streaming False Start.')                        \n            return                                                              \n        self.streaming = True                                                   \n        self.write_message('Streaming.')                                        \n        def stream():                                                           \n            while self.streaming:                                               \n                lock.acquire()                                                  \n                self.write_message(                                             \n                        (self.i * np.ones(2000, np.float32)).tobytes(),         \n                        binary=True)                                            \n                lock.release()                                                  \n                self. i += 1                                                    \n                                                                                \n            self.write_message(u'Stopping Streaming.')                          \n        tp = threading.Thread(target=stream)                                    \n        tp.daemon = True                                                        \n        tp.start()........                                                      \n                                                                                \ndef start_tornado():                                                            \n    tornado.ioloop.IOLoop.instance().start()                                    \n                                                                                \ndef stop_tornado():                                                             \n    tornado.ioloop.IOLoop.instance().stop()                                     \n                                                                                \nif __name__ == '__main__':                                                      \n    port = 8888                                                                 \n    handlers = [                                                                \n        (r'/ws', EchoWebSocket),                                                \n    ]                                                                           \n    app = tornado.web.Application(handlers, debug=True)                         \n    app.listen(port)                                                            \n    start_tornado()  \nindex.html\n<!DOCTYPE html>                                                                 \n<html>                                                                          \n<body>                                                                          \n                                                                                \n<h1>Websocket streaming test</h1>                                               \n                                                                                \n<script>                                                                        \nvar ws;                                                                         \nvar binData = 0;                                                                \nfunction openWS(){                                                              \n  ws = new WebSocket('ws://localhost:8888/ws');                                 \n  ws.binaryType = 'arraybuffer';                                                \n  var ii = 0;                                                                   \n  ws.onmessage = function (e) {                                                 \n    if (typeof e.data == 'string'){                                             \n      document.getElementById('wsString').innerHTML = e.data;                   \n    } else {                                                                    \n        // Do a lot of work to delay things                                     \n      var j = 0;                                                                \n      for (var i=0; i<1000000; i++){                                            \n        j = i * 2;                                                              \n      }                                                                         \n      document.getElementById('wsBinary').innerHTML = e.data + ' ' + j + \" \" + ii;\n      binData = e.data;                                                         \n      ii++;                                                                     \n    }                                                                           \n  }                                                                             \n}                                                                               \nfunction closeWS(){                                                             \n  ws.close();                                                                   \n}                                                                               \nopen()                                                                          \n</script>                                                                       \n<script>                                                                        \nfunction stop(){                                                                \n  ws.send('STOP');                                                              \n}                                                                               \nfunction stream(){                                                              \n  ws.send('STREAM');                                                            \n}                                                                               \n</script>                                                                       \n<p id='wsString'></p>                                                           \n<p id='wsBinary'></p>                                                           \n<input type='button' onclick=stream() value='Stream'></input>                   \n<input type='button' onclick=stop() value='Stop'></input>                       \n<input type='button' onclick=openWS() value='Open'></input>                     \n<input type='button' onclick=closeWS() value='Close'></input>                   \n</body>                                                                         \n</html> \nAnd this is what I get when I click stream:\npython server.py.                                                               \nWebSocket opened                                                                \nERROR:tornado.general:Uncaught exception, closing connection.                   \nTraceback (most recent call last):                                              \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 523, in _handle_ev>\n    self._handle_write()                                                        \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 847, in _handle_wr>\n    assert self._write_buffer_size >= 0                                         \nAssertionError                                                                  \nException in thread Thread-1:                                                   \nTraceback (most recent call last):                                              \n  File \"/home/<user>/anaconda3/lib/python3.6/threading.py\", line 916, in _bootstrap_inner\n    self.run()                                                                  \n  File \"/home/<user>/anaconda3/lib/python3.6/threading.py\", line 864, in run    \n    self._target(*self._args, **self._kwargs)                                   \n  File \"server.py\", line 48, in stream                                          \n    binary=True)                                                                \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/websocket.py\", line 252, in write_mes>\n    return self.ws_connection.write_message(message, binary=binary)             \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/websocket.py\", line 785, in write_mes>\n    return self._write_frame(True, opcode, message, flags=flags)                \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/websocket.py\", line 768, in _write_fr>\n    return self.stream.write(frame)                                             \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 406, in write\n    self._handle_write()                                                        \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 872, in _handle_wr>\n    del self._write_buffer[:self._write_buffer_pos]                             \nBufferError: Existing exports of data: object cannot be re-sized                \n                                                                                \nERROR:tornado.application:Exception in callback None                            \nTraceback (most recent call last):                                              \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/ioloop.py\", line 888, in start\n    handler_func(fd_obj, events)                                                \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/stack_context.py\", line 277, in null_>\n    return fn(*args, **kwargs)                                                  \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 523, in _handle_ev>\n    self._handle_write()                                                        \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/iostream.py\", line 847, in _handle_wr>\n    assert self._write_buffer_size >= 0                                         \nAssertionError                                                                  \nWebSocket closed                                                                \nERROR:tornado.application:Uncaught exception GET /ws (::1)                      \nHTTPServerRequest(protocol='http', host='localhost:8888', method='GET', uri='/ws', version='HTTP/1.1', r>\nTraceback (most recent call last):                                              \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/web.py\", line 1467, in _stack_context>\n    raise_exc_info((type, value, traceback))                                    \n  File \"<string>\", line 4, in raise_exc_info                                    \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/stack_context.py\", line 316, in wrapp>\n    ret = fn(*args, **kwargs)                                                   \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/websocket.py\", line 436, in on_connec>\n    self.on_close()                                                             \n  File \"server.py\", line 35, in on_close                                        \n    self.write_message(\"Disconnecting.\")                                        \n  File \"/home/<user>/anaconda3/lib/python3.6/site-packages/tornado/websocket.py\", line 249, in write_mes>\n    raise WebSocketClosedError()                                                \ntornado.websocket.WebSocketClosedError     \nSo basically what's happening is I'm sending data faster than the client can handle, so this happens.\nIf I put in a sleep in my python code, then all's well for this example, but I can't rely on that across the systems I'm working with.\nAll help much appreciated.", "issue_status": "Closed", "issue_reporting_time": "2017-11-02T02:59:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "276": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2181", "issue_id": "#2181", "issue_summary": "websocket: Define interface between protocol and handler/conn", "issue_description": "anonymousch commented on 28 Oct 2017\ntornado/tornado/websocket.py\nLine 497 in 5ee7f45\n getattr(self.request, 'path', None), exc_info=True) \nIn old version, this line use \"self.request.path\", but request no \"path\" attribute\uff0cso this line \"path\" maybe modified as \"url\".", "issue_status": "Closed", "issue_reporting_time": "2017-10-28T10:44:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "277": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2176", "issue_id": "#2176", "issue_summary": "Add IOStream.read_into()", "issue_description": "Contributor\npitrou commented on 22 Oct 2017\nFor better performance on large reads, it would be useful to expose a readinto or recv_into-like operation on IOStream. The API could read like:\n    def read_into(self, buf, callback=None, partial=False):\n        \"\"\"Asynchronously read a number of bytes.\n\n        ``buf`` must be a writable buffer into which data will be read.\n        If a callback is given, it will be run with the number of read\n        bytes as an argument; if not, this method returns a `.Future`.\n\n        If ``partial`` is true, the callback is run as soon as any bytes\n        have been read.  Otherwise, it is run when the ``buf`` has been\n        entirely filled with read data.\n        \"\"\"\n@bdarnell, what do you think? Is this something you would like to see? See performance analysis at https://mail.python.org/pipermail/async-sig/2017-October/000392.html", "issue_status": "Closed", "issue_reporting_time": "2017-10-22T14:08:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "278": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2174", "issue_id": "#2174", "issue_summary": "Cross platform template_path handling", "issue_description": "Contributor\nmrocklin commented on 22 Oct 2017\nI have a Tornado Application that uses Tornado templates to render HTML. These templates live in a templates/ directory within my application. On Linux and OSX I need to include the templates/ directory in extends blocks like the following:\n{% extends templates/main.html %}\nHowever on Windows I seem to need to do the following:\n{% extends main.html %}\nAll of my html files are in this same templates directory. From reading online it seems like I should be able to use just the relative path main.html without the added templates/ directory. Unfortunately Tornado looks in my root directory when I do this.\nTraceback (most recent call last):\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/web.py\", line 1509, in _execute\n    result = method(*self.path_args, **self.path_kwargs)\n  File \"/home/mrocklin/workspace/distributed/distributed/bokeh/scheduler_html.py\", line 24, in get\n    **toolz.merge(self.server.__dict__, ns))\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/web.py\", line 724, in render\n    html = self.render_string(template_name, **kwargs)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/web.py\", line 862, in render_string\n    t = loader.load(template_name)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 427, in load\n    self.templates[name] = self._create_template(name)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 455, in _create_template\n    template = Template(f.read(), name=name, loader=self)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 307, in __init__\n    self.code = self._generate_python(loader)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 355, in _generate_python\n    ancestors = self._get_ancestors(loader)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 373, in _get_ancestors\n    template = loader.load(chunk.name, self.name)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 427, in load\n    self.templates[name] = self._create_template(name)\n  File \"/home/mrocklin/Software/anaconda/envs/27/lib/python2.7/site-packages/tornado/template.py\", line 454, in _create_template\n    with open(path, \"rb\") as f:\nIOError: [Errno 2] No such file or directory: '/path/to/my/app/main.html'\nIf anyone has pointers on why I might be seeing this different behavior or ways in which to correct for it I would be grateful.\nI am doing things a little bit oddly, which might account for some deviation from expected results. I'm adding these request handlers to a running Tornado server after it is started by Bokeh as in this Stack Overflow answer", "issue_status": "Closed", "issue_reporting_time": "2017-10-21T20:14:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "279": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2170", "issue_id": "#2170", "issue_summary": "Split IOLoop and frields into its own package", "issue_description": "avrahamshukron commented on 20 Oct 2017\nThis is a rather unusual enhancement request:\nTornado has a very powerful IOLoop that is great for Aysnc IO, specially on python 2.7.\nThe ioloop can be used by itself for many application, not necessarily web-related.\nIt would be very nice to be able the get all the goodness of ioloop without the whopping 3.7MB of the entire package.\nThis is especially important for embedded systems where package size actually matters.\nUsing Namespace packages this change can be done quit elegantly and maybe even without breaking the API.", "issue_status": "Closed", "issue_reporting_time": "2017-10-19T19:56:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "280": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2168", "issue_id": "#2168", "issue_summary": "Tornado ThreadPoolExecutor is leaking resources", "issue_description": "truongdo commented on 19 Oct 2017\nWhen using tornador with ThreadPoolExecutor, it spawns one PID for every request, here is the code\nimport tornado.ioloop\nimport tornado.web\nfrom tornado.concurrent import futures\nfrom tornado.ioloop import IOLoop\nfrom tornado.concurrent import run_on_executor\nimport logging\nfrom tornado import gen\n\n\nclass TaskRunner(object):\n    def __init__(self, npool=40, loop=None):\n        self.executor = futures.ThreadPoolExecutor(npool)\n        self.loop = loop or IOLoop.instance()\n\n    @run_on_executor\n    def run(self, func, args=(), kwargs={}):\n        return func(*args, **kwargs)\n\ntask_runner = TaskRunner()\n\ndef hello_world():\n    return \"Hello world\"\n\nclass MainHandler(tornado.web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        output = yield task_runner.run(hello_world)\n        self.write(output)\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nCheck PID command pstree -sg PID\nOutput\nAfter server started:\nsystemd(1)\u2500\u2500\u2500lightdm(1162)\u2500\u2500\u2500lightdm(1162)\u2500\u2500\u2500upstart(2617)\u2500\u2500\u2500/usr/bin/x-term(2999)\u2500\u2500\u2500zsh(17892)\u2500\u2500\u2500python3(22675)\nAfter 3 requests\nsystemd(1)\u2500\u2500\u2500lightdm(1162)\u2500\u2500\u2500lightdm(1162)\u2500\u2500\u2500upstart(2617)\u2500\u2500\u2500/usr/bin/x-term(2999)\u2500\u2500\u2500zsh(17892)\u2500\u2500\u2500python3(22675)\u2500\u252c\u2500{python3}(22675)\n                                                                                                                 \u251c\u2500{python3}(22675)\n                                                                                                                 \u2514\u2500{python3}(22675)", "issue_status": "Closed", "issue_reporting_time": "2017-10-19T00:28:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "281": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2161", "issue_id": "#2161", "issue_summary": "X-Forwarded-Proto Multiple Values", "issue_description": "psyvision commented on 12 Oct 2017 \u2022\nedited\nI have been investigating an issue with AWS Application Load Balancers forwarding traffic to a JupyterHub instance (that uses Tornado) - and it appears that the AWS ALB can forward traffic with the following header:\nX-Forwarded-Proto: https,https\nHowever, Tornado only appears to be able to support a singular value:\ntornado/tornado/httpserver.py\nLine 286 in d4094a0\n # AWS uses X-Forwarded-Proto \nIt seems a similar issue affected ASP.NET at one point:\naspnet/BasicMiddleware#18\nAlthough Mozilla document it as only having a single value:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto", "issue_status": "Closed", "issue_reporting_time": "2017-10-12T13:29:05Z", "fixed_by": "#2162", "pull_request_summary": "handle multiple values in X-Forwarded-Proto", "pull_request_description": "Contributor\nminrk commented on 13 Oct 2017\nuse the first entry, which should be the outermost value\ncloses #2161\n1", "pull_request_status": "Merged", "issue_fixed_time": "2017-11-16T03:21:53Z", "files_changed": [["4", "tornado/httpserver.py"], ["10", "tornado/test/httpserver_test.py"]]}, "282": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2160", "issue_id": "#2160", "issue_summary": "In some cases it is impossible to make command line options to override config file options", "issue_description": "Contributor\nrisboo6909 commented on 5 Oct 2017 \u2022\nedited\nIt seems strange to me that I can't prioritize command line options (if any) over a config file options in tornado.options.\nOne situation in which this feature could be handy is when I wish to specify a path to the config file as a command line option because this path may change depending on where my app starts (i.e. path to the config file is not a constant). Parsing command line options first, getting a full path to the config file from there and then parsing the config file doesn't do the trick in this case, because it will overwrite all other command line options if they are also defined in the config file.", "issue_status": "Closed", "issue_reporting_time": "2017-10-05T13:48:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "283": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2159", "issue_id": "#2159", "issue_summary": "Connections stuck in CLOSE_WAIT", "issue_description": "bouke-nederstigt commented on 28 Sep 2017\nI have a tornado websocket server handling about 80 websocket connections. It seems tornado is not properly handling stale/closed connections. After a while lots of connections end up in tcp CLOSE_WAIT state.\nThis eventually seems to lead to lots of TCP listen overflows, and the server being completely frozen. Although I'm not completely sure if the TCP overflows and hanging server are related to the CLOSE_WAIT, it does seem to be the case.\nAny idea on what might be causing the issue, and how it might be resolved?", "issue_status": "Closed", "issue_reporting_time": "2017-09-28T09:48:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "284": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2156", "issue_id": "#2156", "issue_summary": "AttributeError if Websocket client misses required header", "issue_description": "Contributor\npjknkda commented on 21 Sep 2017\nIf the client misses required header for websocket handshake, the server raises AttributeError.\nMinimal code for reproduce\nClient\nimport socket\n\nREQ_1 = ('GET /ws HTTP/1.1\\r\\n'\n         'Host: example.com:9221\\r\\n'\n         'Upgrade: websocket\\r\\n'\n         'Connection: Upgrade\\r\\n'\n        #  'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n'\n         'Sec-WebSocket-Version: 13\\r\\n'\n         '\\r\\n')\nconn = socket.create_connection(('127.0.0.1', 9221))\nconn.send(REQ_1.encode('utf-8'))\nresp_1 = conn.recv(10 * 1024)\nServer\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\n\nclass WsHandler(tornado.websocket.WebSocketHandler):\n    pass\n\ndef make_app():\n    return tornado.web.Application([\n        (r'/ws', WsHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(9221)\n    tornado.ioloop.IOLoop.current().start()\nTraceback\nERROR:tornado.application:Uncaught exception GET /ws (127.0.0.1)\nHTTPServerRequest(protocol='http', host='example.com:8000', method='GET', uri='/ws', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Host': 'example.com:8000', 'Upgrade': 'websocket', 'Connection': 'Upgrade', 'Sec-Websocket-Version': '13'})\nTraceback (most recent call last):\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/websocket.py\", line 618, in accept_connection\n    self._handle_websocket_headers()\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/websocket.py\", line 634, in _handle_websocket_headers\n    raise ValueError(\"Missing/Invalid WebSocket headers\")\nValueError: Missing/Invalid WebSocket headers\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/web.py\", line 1467, in _stack_context_handle_exception\n    raise_exc_info((type, value, traceback))\n  File \"<string>\", line 4, in raise_exc_info\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/web.py\", line 1669, in wrapper\n    result = method(self, *args, **kwargs)\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/websocket.py\", line 196, in get\n    self.ws_connection.accept_connection()\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/websocket.py\", line 623, in accept_connection\n    self._abort()\n  File \"/home/pjknkda/test/ws-invalid/python-env/lib/python3.6/site-packages/tornado/websocket.py\", line 512, in _abort\n    self.stream.close()  # forcibly tear down the connection\nAttributeError: 'NoneType' object has no attribute 'close'\nERROR:tornado.access:500 GET /ws (127.0.0.1) 4.13ms\nIt seems that WebSocketProtocol13.accept_connection calls WebSocketProtocol._abort immediately if there is missing required headers, however, it is before the handshake, thus there is yet no self.stream whereas the _abort function tries to self.stream.close(). Also, the _abort function calls self.close() and there is also the same buggy code which calls self.stream.close() without checking the nullity of self.stream.", "issue_status": "Closed", "issue_reporting_time": "2017-09-21T17:00:49Z", "fixed_by": "#2157", "pull_request_summary": "websocket: fix missing websocket header causes an exception", "pull_request_description": "Contributor\npjknkda commented on 21 Sep 2017\nMissing web socket header causes an exception because _abort function tries to close stream if there is yet stream before the handshaking.\nThis PR changes _abort function to return HTTP 400 error when the handshaking is not completed (a.k.a stream is None).\nFixes #2156", "pull_request_status": "Merged", "issue_fixed_time": "2017-09-23T17:07:08Z", "files_changed": [["7", "tornado/test/websocket_test.py"], ["8", "tornado/websocket.py"]]}, "285": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2153", "issue_id": "#2153", "issue_summary": "IOStream loses SSH banner", "issue_description": "bindlock commented on 18 Sep 2017 \u2022\nedited\nHello guys. Please, explain to me where IOStream hides banner from SSH connection? I prepared code for test below.\nimport datetime\nimport socket\n\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.iostream\n\n\nHOST = ('127.0.0.1', 22)\n\n\ndef pure_socket():\n    sock = socket.socket()\n    sock.connect(HOST)\n    print(sock.recv(1024))\n\n\nasync def iostream():\n    stream = tornado.iostream.IOStream(socket.socket())\n    await stream.connect(HOST)\n\n    try:\n        data = await tornado.gen.with_timeout(\n            datetime.timedelta(seconds=5),\n            stream.read_bytes(1024)\n        )\n    except tornado.gen.TimeoutError:\n        print('Timeout')\n    else:\n        print(data)\n\n\nif __name__ == '__main__':\n    print('PURE SOCKET:')\n    pure_socket()\n\n    print('IOSTREAM:')\n    tornado.ioloop.IOLoop.current().run_sync(iostream)\nAnd output:\nPURE SOCKET:\nb'SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.8\\r\\n'\nIOSTREAM:\nTimeout\nPython 3.6.2\nTornado 4.5.2", "issue_status": "Closed", "issue_reporting_time": "2017-09-18T16:05:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "286": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2151", "issue_id": "#2151", "issue_summary": "A syntax error about \"(r'/', IndexHandler)\"!!!", "issue_description": "kevin-mega commented on 14 Sep 2017\nHas anybody come up with an idea about the question which showed below? Always shows the syntax error for [('r/', IndexHandler),]. Thanks for your attention!", "issue_status": "Closed", "issue_reporting_time": "2017-09-14T12:39:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "287": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2150", "issue_id": "#2150", "issue_summary": "using uwsgi to deploy the tornado application", "issue_description": "super1-chen commented on 11 Sep 2017 \u2022\nedited\nNow, We have a tornado web application need to be deployed by using uwsgi, I want to share my personal experience for other guys.\nI write a tornado web app named warriors, below is my python app code file which named\nstart.py\n import tornado.web\n import tornado.wsgi\n\n class MainHandler(tornado.web.RequestHandler):\n     def get(self):\n         self.write(\"Hello, world\")\n\n tornado_app = tornado.web.Application([\n     (r\"/\", MainHandler),\n ])\n application = tornado.wsgi.WSGIAdapter(tornado_app)\nthe file stored in path '/root/warrior' and python virtualenv path is '/root/py27'\nbelow is my uwsgi config file named\nuwsgi.ini\n[uwsgi]\nprocesses = 4\n\nsocket = /etc/uwsgi/warriors.sock\nchmod-socket = 666\n\npidfile = /etc/uwsgi/warriors.pid\n\nchdir = /root/warrior\nwsgi-file = start.py\n\ndaemonize = /var/logs/uwsgi/warriors.log\nlog-maxsize = 20000000\n\ndisable-logging = true\nvacuum = true\nvirtualenv = /root/py27\nnginx file\nserver {\n    listen  80;\n    server_name default_server;\n    access_log /var/logs/nginx/warriors.access.log main buffer=32k flush=5s;\n    error_log /var/logs/nginx/warriors.error.log;\n    client_max_body_size 200M;\n\n    location ~ / {\n        include uwsgi_params;\n        uwsgi_pass unix:////etc/uwsgi/warriors.sock;\n    }\n}\nIf you think my experience will help others, use it free, thanks", "issue_status": "Closed", "issue_reporting_time": "2017-09-11T16:34:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "288": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2147", "issue_id": "#2147", "issue_summary": "Zero copy send", "issue_description": "Contributor\nmrocklin commented on 6 Sep 2017\nIt would be convenient to reduce CPU use when sending large memoryviews of data. I've brought this up a couple of times\n#1685\n#1691\nAnd it has been raised by @bryevdv for websockets\n#2102\nPreviously I've closed my issues saying that this wasn't yet a bottleneck for my applications (dask). However now several users are using Dask on HPC systems with fast multi-GB interconnects and this has now become a bottleneck. I'd like to revisit the issue.\nAre there any objections or known challenges to handling memoryviews all the way from user input to system call? (other than developer time of course) I'm able to spend some cycles on this problem, but I'd like to verify that it's feasible and check in with core devs to see if there is anything that I should be aware of before starting.", "issue_status": "Closed", "issue_reporting_time": "2017-09-06T16:45:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "289": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2146", "issue_id": "#2146", "issue_summary": "Unit testing and tornado.options, Option already defined", "issue_description": "Contributor\npolygon commented on 5 Sep 2017\nWhat is the preferred way to combine unit testing and tornado.options? To give a minimal example, assume I want to test the following code:\nimport tornado.web\nfrom tornado.options import define, options\nimport tornado.ioloop\n\n\ndef define_options():\n    define('myoption', type=str, default='MyValue')\n\n\nclass ExampleHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write({\n            'myoption': options.myoption\n        })\n\n\ndef make_app():\n    ROUTES = [\n        (r'/', ExampleHandler)\n    ]\n    return tornado.web.Application(ROUTES)\n\n\ndef run():\n    define_options()\n    app = make_app()\n    app.listen(8080)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == '__main__':\n    run()\nI might write a test class like so:\nimport tornado.testing\nfrom simurray.optiondemo import define_options, make_app\n\nclass Test1(tornado.testing.AsyncHTTPTestCase):\n    def setUp(self):\n        define_options()\n        super().setUp()\n\n    def get_app(self):\n        return make_app()\n\n    def test1(self):\n        response = self.fetch('/')\n        print(response)\nUp to this point, everything is fine. However, once I add a second method:\n    def test2(self):\n        response = self.fetch('/')\n        print(response)\nI will start to see errors like:\ntornado.options.Error: Option 'myoption' already defined in demo.py\nSimilarly, when I move the call to setUpClass, I will have the same issue once I create a second class and when I move it to the module level, I will have this problem, when I add a second module that defines those options.\nIs there any way around this issue? Where should I define my options so that this does not happen? Furthermore, isolation between tests does not seem to be given. I assume that if the options persist over all tests, then when I want to test a certain combination of settings, these will also persist to the next test which takes away test isolation and I need to make sure to reset all options to default values.", "issue_status": "Closed", "issue_reporting_time": "2017-09-05T14:37:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "290": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2145", "issue_id": "#2145", "issue_summary": "Proxy Setting doesn't work for HTTPs", "issue_description": "cpointner commented on 4 Sep 2017\nCurrently the only option to have working proxy support is to use the CurlAsyncHTTPClient together with the proxy_host and proxy_port args. Unfortunately the way this is implemented is flawed which results in not working HTTPs Proxy support (using HTTP Connect). The curl library wants the option HTTPPROXYTUNNEL in that case.\nThe easiest way to fix this would be to simply remove this line as curl will then use the environment variables http_proxy and https_proxy and will set the HTTPPROXYTUNNEL option if needed. As stated in #754 using the well known environment variables is the standard way to configure proxies and they should imho be honored by tornado as well.", "issue_status": "Closed", "issue_reporting_time": "2017-09-04T08:50:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "291": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2144", "issue_id": "#2144", "issue_summary": "Accessing web request globally in Tornado", "issue_description": "serg666 commented on 28 Aug 2017\nHi!\nI have the following code:\nimport logging\nimport logging.config\nimport tornado.ioloop\nimport tornado.web\n\nconfig = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'verbose': {\n            'format': '%(asctime)s; %(process)d; %(threadName)s; %(levelname)s; %(name)s; %(message)s'\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'NOTSET',\n            'formatter': 'verbose',\n            'class': 'logging.StreamHandler',\n        },\n    },\n    'loggers': {\n        'app': {\n            'handlers': ['console'],\n            'level': 'DEBUG',\n            'propagate': True,\n        },\n        'tornado': {\n            'handlers': ['console'],\n            'level': 'DEBUG',\n            'propagate': True,\n        },\n    },\n}\n\nlogging.config.dictConfig(config)\n\nlog = logging.getLogger('app')\n\nclass MainHandler(tornado.web.RequestHandler):\n    async def get(self):\n        self.write(\"Hello, world\")\n        log.debug(\"message\")\n        await self.flush()\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nThen I make request:\ncurl -v http://127.0.0.1:8888/\nI can see logs like this:\n2017-08-27 21:08:07,435; 25640; MainThread; DEBUG; app; message\n2017-08-27 21:08:07,435; 25640; MainThread; INFO; tornado.access; 200 GET / (127.0.0.1) 1.10ms\nIf app receive more then one request in parallel it is very hard to know what messages belongs to particular request, because all requests are processing in single thread asynchronously.\nIn other frameworks requests are processed at its own thread, so we can know what messages belongs to particular request (by thread id on thread name).\nObviously, I need to modify the above code like this:\nimport logging\nimport logging.config\nimport tornado.ioloop\nimport tornado.web\n\n\nclass RequestFilter(logging.Filter):\n    def filter(self, record):\n        record.request_id = 64747675656 # -> somehow to get access to the current request that's being processed and get id of instance, like id(instance)\n        return super(RequestFilter, self).filter(record)\n\nconfig = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'filters': {\n        'request_filter': {\n            '()': RequestFilter,\n        },\n    },\n    'formatters': {\n        'verbose': {\n            'format': '%(asctime)s; %(process)d; %(request_id)d; %(levelname)s; %(name)s; %(message)s'\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': 'NOTSET',\n            'filters': ['request_filter'],\n            'formatter': 'verbose',\n            'class': 'logging.StreamHandler',\n        },\n    },\n    'loggers': {\n        'app': {\n            'handlers': ['console'],\n            'level': 'DEBUG',\n            'propagate': True,\n        },\n        'tornado': {\n            'handlers': ['console'],\n            'level': 'DEBUG',\n            'propagate': True,\n        },\n    },\n}\n\nlogging.config.dictConfig(config)\n\nlog = logging.getLogger('app')\n\nclass MainHandler(tornado.web.RequestHandler):\n    async def get(self):\n        self.write(\"Hello, world\")\n        log.debug(\"message\")\n        await self.flush()\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nBut how do I know which request it's processing at any given time (in RequestFilter.filter)?\nIs there some global information somewhere that I can use in Tornado to identify the current request that's being processed?\nSo if it's possible, I could see something like this in logs:\n2017-08-27 21:33:24,827; 26367; 64747675656; DEBUG; app; message\n2017-08-27 21:33:24,828; 26367; 64747675656; INFO; tornado.access; 200 GET / (127.0.0.1) 1.50ms\nAnd I could to know what messages belongs to particular request, if app execute two or more requests asynchronously.", "issue_status": "Closed", "issue_reporting_time": "2017-08-27T18:38:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "292": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2142", "issue_id": "#2142", "issue_summary": "function url_concat in httputil.py returns wrong data when url contains '#'", "issue_description": "angieduan commented on 24 Aug 2017\nPython 2.7.12\nTornado 4.5.1\nTest code:\nfrom tornado.httputil import url_concat\nurl_concat('http://1.1.1.1/#page', [(\"a\", \"a1\"), (\"b\", \"b1\")])\nOutput:\n'http://1.1.1.1/?a=a1&b=b1#page'\nExpected output should be:\n'http://1.1.1.1/#page?a=a1&b=b1'", "issue_status": "Closed", "issue_reporting_time": "2017-08-24T08:52:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "293": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2141", "issue_id": "#2141", "issue_summary": "routing exception when not find any handler", "issue_description": "hanbaga commented on 23 Aug 2017\n    def find_handler(self, request, **kwargs):\n        for rule in self.rules:\n            target_params = rule.matcher.match(request)\n            if target_params is not None:\n                if rule.target_kwargs:\n                    target_params['target_kwargs'] = rule.target_kwargs\n\n                delegate = self.get_target_delegate(\n                    rule.target, request, **target_params)\n\n                if delegate is not None:\n                    return delegate\n        return None\n    def headers_received(self, start_line, headers):\n        request = httputil.HTTPServerRequest(\n            connection=self.request_conn,\n            server_connection=self.server_conn,\n            start_line=start_line, headers=headers)\n\n        self.delegate = self.router.find_handler(request)\n        #the case self.delegate is None if not define rule\n        return self.delegate.headers_received(start_line, headers)\n\n    def data_received(self, chunk):\n        #the case self.delegate is None  if not define rule\n        return self.delegate.data_received(chunk)\n\n    def finish(self):\n        #the case self.delegate is None if not define rule\n        self.delegate.finish()\n\n    def on_connection_close(self):\n        self.delegate.on_connection_close()\nplease fix the bug when not find any handler.", "issue_status": "Closed", "issue_reporting_time": "2017-08-23T02:57:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "294": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2138", "issue_id": "#2138", "issue_summary": "Tornado.AsyncHTTPClient is skipping over urls some of the URLs I give it", "issue_description": "gabeorlanski commented on 20 Aug 2017 \u2022\nedited\nHi there. So I am having the issue where a my tornado handler for scraping is skipping over random urls in a list of urls I give it.\nHere is the code:\nimport sys\n\nfrom tornado import gen, ioloop\nfrom tornado.httpclient import AsyncHTTPClient, HTTPRequest\nfrom tornado.queues import Queue\n\n\nclass Scraper():\n def __init__(self, destinations=None, transform=None, headers={}, max_clients=50, maxsize=100, connect_timeout=1200, request_timeout=600):\n\n  \"\"\"Instantiate a tornado async http client to do multiple concurrent requests\"\"\"\n\n  if None in [destinations, transform]:\n   sys.stderr.write('You must pass both collection of URLS and a transform function')\n   raise SystemExit\n\n  self.max_clients = max_clients\n  self.maxsize = maxsize\n  self.connect_timeout = connect_timeout\n  self.request_timeout = request_timeout\n\n  AsyncHTTPClient.configure(\"tornado.simple_httpclient.SimpleAsyncHTTPClient\", max_clients=self.max_clients)\n\n  self.http_client = AsyncHTTPClient()\n  self.queue = Queue(maxsize=maxsize)\n  self .destinations = destinations\n  self.transform = transform\n  self.headers = headers\n  self.read(self.destinations)\n  self.get(self.transform, self.headers, self.connect_timeout, self.request_timeout, self.http_client)\n  self.loop = ioloop.IOLoop.current()\n  self.join_future = self.queue.join()\n  self.count = 1\n  def done(future):\n   self.loop.stop()\n\n  self.join_future.add_done_callback(done)\n  self.loop.start()\n\n @gen.coroutine\n def read(self, destinations):\n  for url in destinations:\n   yield self.queue.put(url)\n\n @gen.coroutine\n def get(self, transform, headers, connect_timeout, request_timeout, http_client):\n  while not self.queue.empty():\n   url = yield self.queue.get()\n\n   try:\n    request = HTTPRequest(url, connect_timeout=connect_timeout, request_timeout=request_timeout, method=\"GET\", headers=headers)\n   except Exception as e:\n    sys.stderr.write('Destination {0} returned error {1}'.format(url, str(e) + '\\n'))\n\n   future = self.http_client.fetch(request)\n\n   def done_callback(future):\n    print(\"--------------------------\")\n    print(\"Current: \"+str(self.count))\n                                    print(future.result().code)\n    self.count+=1\n    body = future.result().body\n    url = future.result().effective_url\n    transform(body, url=url)\n    self.queue.task_done()\n\n   try:\n    future.add_done_callback(done_callback)\n    yield gen.sleep(0.1)\n   except Exception as e:\n    sys.stderr.write(str(e))\n    self.queue.put(url)\nSo when it skips, say on number 37, the console output will look like:\n---------------------------------\nCurrent: 37\n---------------------------------\nCurrent: 38\n200\nI don't know what is going on with it that is making it skip over, I have tried putting try except around them to make it work but that did not tell me anything I did not already know\nAlso, for my sake, is this making requests asynchronously?", "issue_status": "Closed", "issue_reporting_time": "2017-08-19T23:16:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "295": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2134", "issue_id": "#2134", "issue_summary": "In other ways, can you call RequestHandler and then respond to the data, similar to the HttpResponse () method in Django?", "issue_description": "lettgers commented on 11 Aug 2017\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2017-08-11T11:23:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "296": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2133", "issue_id": "#2133", "issue_summary": "how can i send xml with AsyncHTTPClient\uff1f", "issue_description": "emaste-r commented on 11 Aug 2017\nnow i need to send post xml data...\nit is ok when i use requests...\n r = requests.post(url, headers=headers, data=send_xml, verify=False)\n prepay_result_dic = cls.trans_xml_to_dict(r.content)\nbut how can i change requests lib to tornado.httpclient.AsyncHTTPClient\n@tornado.gen.coroutine\ndef post_asyn_url(url, payload={}, headers={}):\n    \"\"\"\n    \u5f02\u6b65post url\uff0c\u4e3b\u8981\u662f\u4e3a\u4e86\u53d6\u4ee3requests\u5e93...\n    :param url: \"http://www.google.com/\"\n    :param payload: {'userId': user_id}\n    :return: response\n    \"\"\"\n    import urllib\n    http_client = tornado.httpclient.AsyncHTTPClient()\n    payload = urllib.urlencode(payload)\n    response = yield tornado.gen.Task(http_client.fetch, url, method=\"POST\", headers=headers, body=payload, validate_cert=False)\n    raise tornado.gen.Return(response)\nthe code above brings errror:\nTypeError: not a valid non-string sequence or mapping object", "issue_status": "Closed", "issue_reporting_time": "2017-08-11T09:27:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "297": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2131", "issue_id": "#2131", "issue_summary": "IOError: fd already registered", "issue_description": "chenasraf commented on 10 Aug 2017\nNot sure what's going on. Our code doesn't handle its own IO loop and relies on the implementations inside tornado's defaults - and I keep getting this error:\n2017-08-10 12:10:11,581 http1connection 67799:731 tornado.general ERROR Uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/http1connection.py\", line 722, in _server_request_loop\n    ret = yield conn.read_response(request_delegate)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 1055, in run\n    value = future.result()\n  File \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 238, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 1069, in run\n    yielded = self.gen.send(value)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/http1connection.py\", line 245, in _read_message\n    self.stream.set_close_callback(self._on_connection_close)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/iostream.py\", line 420, in set_close_callback\n    self._maybe_add_error_listener()\n  File \"/usr/local/lib/python2.7/site-packages/tornado/iostream.py\", line 941, in _maybe_add_error_listener\n    self._add_io_state(ioloop.IOLoop.READ)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/iostream.py\", line 971, in _add_io_state\n    self.fileno(), self._handle_events, self._state)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 728, in add_handler\n    self._impl.register(fd, events | self.ERROR)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/platform/kqueue.py\", line 40, in register\n    raise IOError(\"fd %s already registered\" % fd)\nIOError: fd 12 already registered\n2017-08-10 12:10:11,582 ioloop 67799:741 tornado.general DEBUG Error deleting fd from IOLoop\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 739, in remove_handler\n    self._impl.unregister(fd)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/platform/kqueue.py\", line 50, in unregister\n    self._control(fd, events, select.KQ_EV_DELETE)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/platform/kqueue.py\", line 63, in _control\n    self._kqueue.control([kevent], 0)\nOSError: [Errno 2] No such file or directory\nAnd I mean me, specifically, and I don't know where to start debugging.\nIt happens on one process which relies on other services that run similarly, each as its own process, but none of them give out this error.\nI'm not sure a de-facto solution is available but I'd at least like to find where I can even begin to find the source of this problem. Any ideas?", "issue_status": "Closed", "issue_reporting_time": "2017-08-10T09:19:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "298": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2129", "issue_id": "#2129", "issue_summary": "async on_close method", "issue_description": "felipefreitasweb commented on 9 Aug 2017\nI have a websocket class running asynchronously, and when a client exits I need to execute a query that is also asynchronous. But I get the error:\n/opt/python3/lib/python3.6/site-packages/tornado/websocket.py:436: RuntimeWarning: coroutine 'RocketHandler.on_close' was never awaited\n  self.on_close()\nPs .: async on_message works!\nasync def on_close(self):\n      response = await db.session.find_one({'uuid': {'$eq': 'xyz123'}})\nSorry for my English", "issue_status": "Closed", "issue_reporting_time": "2017-08-09T14:03:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "299": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2128", "issue_id": "#2128", "issue_summary": "why use CurlAsyncHTTPClient (but not add proxy) is much slower than use AsyncHTTPClient", "issue_description": "echoocking commented on 9 Aug 2017 \u2022\nedited by bdarnell\nthere is my press test result\n++++++++no curl++++++++++++\n7854 fetches, 170 max parallel, 0 bytes, in 40.004 seconds\n0 mean bytes/connection\n196.331 fetches/sec, 0 bytes/sec\nmsecs/connect: 0.504572 mean, 118.261 max, 0.071 min\nmsecs/first-response: 839.064 mean, 2459.74 max, 203.249 min\nHTTP response codes:\ncode 200 -- 7853\n+++++++++curl++++++++and set max_clients=500+++++++\n2985 fetches, 170 max parallel, 0 bytes, in 40.0036 seconds\n0 mean bytes/connection\n74.6184 fetches/sec, 0 bytes/sec\nmsecs/connect: 1.20356 mean, 116.502 max, 0.065 min\nmsecs/first-response: 2213.71 mean, 4751.15 max, 0.402 min\nHTTP response codes:\ncode 200 -- 2908\nmy testing code\nclass CommentsHandler(tornado.web.RequestHandler):\n   @coroutine\n   def get(self):\n        client = AsyncHTTPClient()\n        req_pre = time.time()\n        response = yield client.fetch(COMMENT_URL.format(product_id='1070843', sort_type='6', page=0), headers=headers)  # COMMENT_URL.format(product_id='1070843', sort_type='6', page=0)\n        req_get = time.time()\n        self.finish()\n\nif __name__ == \"__main__\":\n    application = tornado.web.Application([\n        (r'/jdapi/sku/comments/', CommentsHandler),\n    ])\n    AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\", max_clients=500) # when no curl,this sentence will be commented out\n    application.listen(8200)\n    tornado.ioloop.IOLoop.current().start()\nThanks for your notice :)", "issue_status": "Closed", "issue_reporting_time": "2017-08-09T07:22:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "300": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2126", "issue_id": "#2126", "issue_summary": "autoreload: doesn't close connections in Tornado 4.5", "issue_description": "hellflame commented on 6 Aug 2017 \u2022\nedited\nproblems\nwhen I first open the webpage from tornado, everything is fine, but when I change the code, trigger the auto reload, refreshing the page will be extremely slow (I can even wait all day long), while opening another browser to visit the page, everything is fine again, but after auto reload, it stuck again too.\nafter refreshing the page, there will be many half closed TCP connections. they won't be closed until I shut down the tornado project.\nproof:\n(after autoreload, I refreshed twice)\nif check with wireshark, tornado really is not sending FIN to close the connection, is it intentionally ? or there is other reason to cause this\npython version: 2.7.10\ntornado version: 4.5.1\nos: mac os 10.12.6\nafter some little test, the problems starts at v4.5.0, and it is ok in v4.4.0 (I Just checked that two version)\ntest code:\nimport tornado.ioloop as ioloop\nimport tornado.web as web\nimport sys\n\nclass HelloService(web.RequestHandler):\n    def get(self):\n        return self.write(\"Check\")\n\nroutes = [(r'/', HelloService)]\nsettings = {\n        'debug': True,\n        'autoreload': True,\n        'serve_traceback': True,\n    }\n\napp = web.Application(handlers=routes, **settings)\n\nif __name__ == '__main__':\n    port = 5000\n    if len(sys.argv) == 2 and sys.argv[1].isdigit():\n        port = int(sys.argv[1])\n    address = '127.0.0.1'\n    app.listen(port, address=address)\n    ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2017-08-06T06:03:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "301": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2125", "issue_id": "#2125", "issue_summary": "Why CurlAsyncHTTPClient consum huge memory in HTTPS request", "issue_description": "zpoint commented on 4 Aug 2017 \u2022\nedited\nMy handler file\n# -*- coding:utf-8 -*-\nimport sys\nfrom tornado import gen, web, httpclient\n\nurl = \"https://mdetail.tmall.com/templates/pages/desc?id=527485572414\"\n\nclass SearchHandler(web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        async_client = httpclient.AsyncHTTPClient()\n        print sys.getrefcount(async_client) # The first time less than 10, then always bigger than 200\n        req = httpclient.HTTPRequest(url, \"GET\", headers=headers)\n        req_lists = [async_client.fetch(req) for _ in range(200)]\n        r = yield req_lists\n        print sys.getrefcount(async_client) # always bigger than 200\n        # The longer req_lists, the more memory will be consumed, and never decrease\nconfigure file\ntornado.httpclient.AsyncHTTPClient.configure(client, max_clients=1000)\nif my client is \"tornado.curl_httpclient.CurlAsyncHTTPClient\", Then when I visit my handler in broswer, htop shows memory increase about 6GB,as long as the process running, memory usage never decrease\nIf I set range(200) to range(500) or higher, Memory usage grows higher\nif my cline is None, memory barely increase\nI found only fetch the https:// will have memory issue\nHow can I slove the momory problem with CurlAsyncHTTPClient?\nEnvironment:\nUbuntu 16.10 x64\npython2.7.12\nTornado 4.5.1", "issue_status": "Closed", "issue_reporting_time": "2017-08-04T06:18:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "302": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2124", "issue_id": "#2124", "issue_summary": "Tornado doesn't respect the connect timeout when using proxy with curl_httpclient", "issue_description": "hus787 commented on 3 Aug 2017 \u2022\nedited\nTo replicate use\nspawn a proxy server (e.g. tinyproxy)\npip2 install tornado\nvi foo.py\nAdd 5. to it\n# lifted mostly from https://stackoverflow.com/a/14830911\nimport tornado.httpserver                                                    \nimport tornado.ioloop                                                        \nimport tornado.options                                                       \nimport tornado.web                                                           \nimport tornado.httpclient                                                    \n\nfrom tornado.options import define, options                                  \ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)         \n\nconfig = {\"request_timeout\":5,\"connect_timeout\":1,  \"proxy_host\":\"localhost\", \"proxy_port\":8888}                                                                           \nturl=\"http://image.shutterstock.com:8092/z/photo-slug-467388059.jpg\"\ntornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n\n\nclass IndexHandler(tornado.web.RequestHandler):                          \n    @tornado.web.asynchronous                                                \n    def get(self):                                                           \n        client = tornado.httpclient.AsyncHTTPClient()                        \n        client.fetch(turl, self.handle_request, **config)   \n    def handle_request(self, response):                                      \n        if response.error:                                                   \n            print(\"Error:\", response.error)                                  \n        else:                                                                \n            self.write(response.body)                                        \n        self.finish()                                                        \n\n\nif __name__ == \"__main__\":                                                   \n    tornado.options.parse_command_line()                                     \n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler)], debug=True)\n    httpserver = tornado.httpserver.HTTPServer(app)\n    httpserver.listen(8000) \n    tornado.ioloop.IOLoop.instance().start()\npython foo.py &\ncurl localhost:8000/\nResult:\nroot@320a5f66940a:/# curl localhost:8000/\n('Error:', HTTP 599: Operation timed out after 5001 milliseconds with 0 bytes received)\nroot@320a5f66940a:/# [I 170803 00:22:28 web:2063] 200 GET / (127.0.0.1) 5007.07ms\nI think it's because of the initial connection to the proxy that overrides the connection timeout.\nCan it be fixed?", "issue_status": "Closed", "issue_reporting_time": "2017-08-03T00:39:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "303": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2123", "issue_id": "#2123", "issue_summary": "Tornado yield [ <list of futures> ] performs only 10 requests simultaneously", "issue_description": "zxwild commented on 2 Aug 2017 \u2022\nedited\nHi,\nI want to perform 100 requests at the same time by easy way with yield [ <list of futures> ].\nBut this method performs only 10 requests at the time!\nI prepared a short example which demostrates it, just run and you'll see requests which are performed by portions of 10 requests at the time.\nTested with debian stretch and ubuntu 16.04 with the same results.\nPython 3.6.1,\ntornado==4.5.1\nfrom datetime import datetime\nimport tornado.ioloop\nimport tornado.gen\nimport tornado.web\nfrom tornado.httpclient import AsyncHTTPClient\n\n\n# the same for tornado and curl clients\n# AsyncHTTPClient.configure('tornado.curl_httpclient.CurlAsyncHTTPClient')\nhttp_client = AsyncHTTPClient()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    @tornado.gen.coroutine\n    def get(self, **kwargs):\n        yield self.write('<html><pre>')\n        yield tornado.gen.sleep(5)\n        yield self.finish('long page test</pre></html>')\n\n\ndef make_app():\n    return tornado.web.Application([\n        tornado.web.url('^/test', MainHandler),\n    ])\n\n\n@tornado.gen.coroutine\ndef long_request(n):\n    print('long_request {n} start'.format(n=n))\n\n    response = yield http_client.fetch('http://127.0.0.1:8000/test')\n    yield tornado.gen.sleep(5)\n\n    print('{date} long_request {n} finish, size {size}'.format(\n        date=datetime.now(), n=n, size=len(response.body))\n    )\n\n\n@tornado.gen.coroutine\ndef requests_handler():\n    print('Requests handler started')\n    yield [long_request(n) for n in range(100)]\n    print('Requests handler finished')\n\n\napp = make_app()\napp.listen(8000, '127.0.0.1')\n\ntornado.ioloop.IOLoop.current().add_callback(callback=requests_handler)\ntornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2017-08-02T08:46:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "304": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2122", "issue_id": "#2122", "issue_summary": "SSL: DECRYPTION_FAILED_OR_BAD_RECORD_MAC", "issue_description": "jayanth1991 commented on 29 Jul 2017 \u2022\nedited\nI see these warnings in my tornado logs when a client is attempt to send some data over a websocket to the server using a CA authorized certificate.\nHere is the full error:\nWARNING iostream.py:659: error on read: [SSL: DECRYPTION_FAILED_OR_BAD_RECORD_MAC] decryption failed or bad record mac (_ssl.c:1754)\nWhen this happens my connection is dropped immediately.\nI am running Ubuntu 16.04 on AWS with kernel:\nLinux ip-[MASKED] 4.4.0-1022-aws #31-Ubuntu SMP Tue Jun 27 11:27:55 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\nOpenSSL version:\nOpenSSL 1.0.2g 1 Mar 2016\nShould I be concerned?", "issue_status": "Closed", "issue_reporting_time": "2017-07-29T03:45:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "305": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2121", "issue_id": "#2121", "issue_summary": "Websocket ping_interval < ping_timeout", "issue_description": "jayanth1991 commented on 28 Jul 2017 \u2022\nedited\nSo we are facing a baffling problem with regards to the our websockets timing out for our client connections ALL at once from our Tornado Websocket server.\nThe Tornado server doesn't run behind Nginx or any Proxy server. We are seeing this odd behavior where the client's which are using websocket-client all timeout due to the same reason of ping/pong timing out and being forced to reconnect.\nSo what I don't understand is why the timeout grace period needs < the ping interval. Based on the source code it says it will try to do max of 3 pings or 30 seconds before it times out. Not sure why we have to do wait for 3 pings when the underlying protocol is using TCP.\nThe websocket-client works under the premise of if a single ping hasn't been acknowledged with a pong. It times out immediately. Which is the way it should be. Unless I am missing something (which I probably am).\nThe sockets timing out all at once might be something else. But just curious if someone can explain this to me.", "issue_status": "Closed", "issue_reporting_time": "2017-07-27T23:32:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "306": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2120", "issue_id": "#2120", "issue_summary": "When refresh web pages, wait too long", "issue_description": "Iflier commented on 27 Jul 2017\nHello, everyone.\nI'm a little confused. When I try to refresh web pages, after post one form, I have to wait for a long time, what's the reason? However, even for a long time, there is still no refresh. So, I try to press CTRL + C, after this, it seems everything goes well.(Tornado Ver: 4.5.1, Python Ver: 3.5.2)", "issue_status": "Closed", "issue_reporting_time": "2017-07-27T13:55:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "307": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2118", "issue_id": "#2118", "issue_summary": "tornado.TCPClient.connect call hangs indefinitely, regardless of timeout", "issue_description": "radiantone commented on 25 Jul 2017\nTornado 4.5.1\nMy repeatable test uses the dask.distributed package. Easy to produce. Steps below.\nubuntu@ip-10-186-18-141:$ virtualenv --python=python2.7 dask\nubuntu@ip-10-186-18-141:$ dask/bin/pip install distributed\nTerminal Window 1\nubuntu@ip-10-186-18-141:$ dask/bin/dask-scheduler\ndistributed.scheduler - INFO - -----------------------------------------------\ndistributed.scheduler - INFO - Scheduler at: tcp://10.186.18.141:8786\ndistributed.scheduler - INFO - http at: 0.0.0.0:9786\ndistributed.scheduler - INFO - Local Directory: /tmp/scheduler-4EtKTp\ndistributed.scheduler - INFO - -----------------------------------------------\nTerminal Window 2\nubuntu@ip-10-186-18-141:$ dask/bin/python\nfrom distributed import Client\nfrom distributed import Client\nc = Client(\"localhost:8786\")\nhangs forever\nThe problem occurs only when the import statement \"from distributed import Client\" occurs twice.\nPerhaps some tornado module is not re-entrant?\nHere is where it hangs:\ntornado.TCPClient.connect call in distributed/comm/tcp.py", "issue_status": "Closed", "issue_reporting_time": "2017-07-25T14:37:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "308": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2117", "issue_id": "#2117", "issue_summary": "socket.gaierror: [Errno -2] Name or service not known", "issue_description": "LJSthu commented on 24 Jul 2017\nTraceback (most recent call last):\nFile \"client.py\", line 111, in\nioloop.IOLoop.current().run_sync(lambda: method(filenames))\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 458, in run_sync\nreturn future_cell[0].result()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 238, in result\nraise_exc_info(self._exc_info)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 1063, in run\nyielded = self.gen.throw(*exc_info)\nFile \"client.py\", line 97, in put\nbody_producer=producer)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 1055, in run\nvalue = future.result()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 238, in result\nraise_exc_info(self._exc_info)\nFile \"\", line 3, in raise_exc_info\nsocket.gaierror: [Errno -2] Name or service not known", "issue_status": "Closed", "issue_reporting_time": "2017-07-24T15:00:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "309": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2115", "issue_id": "#2115", "issue_summary": "Tornado multiprocess does not work for tensorflow", "issue_description": "alexwongdl commented on 22 Jul 2017 \u2022\nedited\nI try to write a simple frame for tornado + tensorflow server, code is as following:\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nfrom tornado.options import define\nimport os\nos.environ[\"CUDA_VISIBLE_DEVICES\"] = \"\"\n\ndefine(\"port\", default=18015, help=\"run on the given port\", type=int)\n\nimport tensorflow as tf\na = tf.placeholder(tf.int32, shape=(), name=\"input\")\nasquare = tf.multiply(a, a, name=\"output\")\nconfig = tf.ConfigProto(device_count={\"CPU\": 20}, inter_op_parallelism_threads=10, intra_op_parallelism_threads=10)\nsess = tf.Session(config=config)\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def initialize(self, thesess):\n        self.sess = thesess\n\n    def get(self):\n        num = self.get_argument('num', 2)\n        for i in range (100):\n            ret = self.sess.run([asquare], feed_dict={a: num})\n        self.write( 'result:' + str(ret))\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[(r\"/\", IndexHandler,dict(thesess=sess))])\n    http_server = tornado.httpserver.HTTPServer(app)\n    # http_server.listen(18824)\n    # tornado.ioloop.IOLoop.current().start()\n\n    http_server.bind(18825)\n    http_server.start(10)\n    tornado.ioloop.IOLoop.current().start()\nsubprocess starts succeed, however, the program is stuck and does not process any request. How could I make it work please. When I use simple process or multithread, the program also works.\nEnvironment:\ntensorflow 1.2\ntornado 4.4.1\npython 3.5.2", "issue_status": "Closed", "issue_reporting_time": "2017-07-22T10:40:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "310": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2113", "issue_id": "#2113", "issue_summary": "Tornado is not exposing \"password\" argument in SSLContext.load_cert_chain", "issue_description": "charlie718y commented on 21 Jul 2017 \u2022\nedited\nHi,\nI'm currently trying to pass the PEM passphrase into the SSLContext, however, Tornado only allow to pass in the \"certfile\" and \"keyfile\" arguments, however, cannot pass in the \"password\" argument. The keyfile is PEM passphrase protected, therefore, I want to pass the passphrase in. In the latest python offers the SSLContext.load_cert_chain(certfile, keyfile=None, password=None) , I was wondering if this can be added?\nhttps://docs.python.org/2/library/ssl.html\nSSLContext.load_cert_chain(certfile, keyfile=None, password=None)\nLoad a private key and the corresponding certificate. The certfile string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate\u2019s authenticity. The keyfile string, if present, must point to a file containing the private key in. Otherwise the private key will be taken from certfile as well. See the discussion of Certificates for more information on how the certificate is stored in the certfile.\n\nThe password argument may be a function to call to get the password for decrypting the private key. It will only be called if the private key is encrypted and a password is necessary. It will be called with no arguments, and it should return a string, bytes, or bytearray. If the return value is a string it will be encoded as UTF-8 before using it to decrypt the key. Alternatively a string, bytes, or bytearray value may be supplied directly as the password argument. It will be ignored if the private key is not encrypted and no password is needed.\n\nIf the password argument is not specified and a password is required, OpenSSL\u2019s built-in password prompting mechanism will be used to interactively prompt the user for a password.\nThanks,\nCharlie", "issue_status": "Closed", "issue_reporting_time": "2017-07-21T16:05:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "311": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2112", "issue_id": "#2112", "issue_summary": "RequestHandler.log_exception writes Authorization headers to application log", "issue_description": "Contributor\nfelliott commented on 21 Jul 2017 \u2022\nedited\nHello all!\nWhen tornado logs an exception it writes out the repr of the HTTPServerRequest to the application log. The repr includes all of the headers in the request including Authorization and Cookie headers. Writing user secrets to logs is probably not a good idea. What's the right way to solve this at the framework level?\nDon't include any headers in the repr of HTTPServerRequest.\nFilter out sensitive headers from the repr.\nDon't log the repr of HTTPServerRequest at all in log_exception(). Without the headers, it just restates the content of RequestHandler._request_summary().\nDo nothing, it's not a big deal and/or it's a back-compat issue.\nSomething else?\nI can submit a patch, but I'm curious how the community feels about this.\nCheers,\nFitz", "issue_status": "Closed", "issue_reporting_time": "2017-07-21T14:21:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "312": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2111", "issue_id": "#2111", "issue_summary": "TypeError on exception handling", "issue_description": "akayunov commented on 20 Jul 2017\nJun 26 05:17:34 devfmua-ire-1 locator_v1.error[14686]: [tornado.application] ERROR: Uncaught exception GET /locator/v1.0/users/Usercra%40imqauto1uxeq22f.test (127.0.0.1)\nHTTPServerRequest(protocol='http', host='locator_v1', method='GET', uri='/locator/v1.0/users/Usercra%40imqauto1uxeq22f.test', version='HTTP/1.0', remote_ip='127.0.0.1', headers={'Host': 'locator_v1', 'Connection': 'close', 'Accept': '/', 'User-Agent': 'curl/7.26.0'})\nTraceback (most recent call last):\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/web.py\", line 1511, in _execute\nresult = yield result\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/gen.py\", line 1055, in run\nvalue = future.result()\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 238, in result\nraise_exc_info(self._exc_info)\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/gen.py\", line 1063, in run\nyielded = self.gen.throw(*exc_info)\nFile \"/opt/securisync/be-2.26.4/lib/ss/tornado2/handlers/locatorservice.py\", line 298, in get\nresponse = yield self.do_hp_request(request)\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/gen.py\", line 1055, in run\nvalue = future.result()\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 238, in result\nraise_exc_info(self._exc_info)\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/gen.py\", line 1063, in run\nyielded = self.gen.throw(*exc_info)\nFile \"/opt/securisync/be-2.26.4/lib/ss/tornado2/handlers/locatorservice.py\", line 119, in do_hp_request\nresponse = yield tornado.httpclient.AsyncHTTPClient().fetch(request)\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/gen.py\", line 1055, in run\nvalue = future.result()\nFile \"/opt/securisync/virtualenv-2.24.0/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 238, in result\nraise_exc_info(self._exc_info)\nFile \"\", line 3, in raise_exc_info\nTypeError: cannot concatenate 'str' and 'NoneType' objects", "issue_status": "Closed", "issue_reporting_time": "2017-07-20T10:58:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "313": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2108", "issue_id": "#2108", "issue_summary": "Robust way to clean up resources", "issue_description": "z0u commented on 14 Jul 2017\nWhat is the best (most robust) way to clean up resources used by a RequestHandler? Suppose I get a resource in prepare and store it as a member of self - how can it be released?\nThe documentation says that resources can be cleaned up in on_finish and on_connection_close, but:\nI'm not sure if the intention is that those methods are always called, and\nfinish (source) has no exception handling to ensure that on_finish is called\nHere's a more detailed example showing why I'm interested in this on Stack Overflow. Related: #1968, #517.", "issue_status": "Closed", "issue_reporting_time": "2017-07-14T03:48:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "314": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2105", "issue_id": "#2105", "issue_summary": "Problems with the startransfer timing using pycurl+AsyncHTTPClient", "issue_description": "oprietop commented on 10 Jul 2017\nThe startransfer timing is giving me wrong values under pycurl+tornado:\nCode example:\nimport tornado, pycurl, subprocess                                                                                                                                                                                               \nfrom tornado import httpclient, gen, ioloop                                                                                                                                                                                      \n                                                                                                                                                                                                                                 \n@tornado.gen.coroutine                                                                                                                                                                                                           \ndef main():                                                                                                                                                                                                                      \n    tornado.httpclient.AsyncHTTPClient.configure( \"tornado.curl_httpclient.CurlAsyncHTTPClient\")                                                                                                                                 \n    http_client = tornado.httpclient.AsyncHTTPClient()                                                                                                                                                                           \n                                                                                                                                                                                                                                 \n    url = {'url':'http://httpbin.org/post','method':'POST','body':'ONE=1&TWO=2'}                                                                                                                                                 \n                                                                                                                                                                                                                                 \n    http_request = tornado.httpclient.HTTPRequest( **url )                                                                                                                                                                       \n    response = yield http_client.fetch(http_request)                                                                                                                                                                             \n                                                                                                                                                                                                                                 \n    print('startransfer: ', response.time_info['starttransfer'])                                                                                                                                                                 \n                                                                                                                                                                                                                                 \nif __name__ == '__main__':                                                                                                                                                                                                       \n    print(\"# Tornado with Pycurl\")                                                                                                                                                                                               \n    for _ in range (10):                                                                                                                                                                                                         \n        tornado.ioloop.IOLoop.instance().run_sync(main)                                                                                                                                                                          \n                                                                                                                                                                                                                                 \n    print(\"# Curl Binary\")                                                                                                                                                                                                       \n    cmd = [ 'curl', '-vo', '/dev/null', 'http://httpbin.org/post', '--data', 'ONE=1&TWO=2',  '-w',  'startransfer: %{time_starttransfer}' ]                                                                                      \n    for _ in range (10):                                                                                                                                                                                                         \n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)                                                                                                                                                \n        out, err = p.communicate()                                                                                                                                                                                               \n        print(out.decode())\nResult:\n# Tornado with Pycurl                                                                                                                                                                                                            \nstartransfer:  0.080873                                                                                                                                                                                                          \nstartransfer:  0.0001                                                                                                                                                                                                            \nstartransfer:  0.000104                                                                                                                                                                                                          \nstartransfer:  0.00012                                                                                                                                                                                                           \nstartransfer:  0.00013                                                                                                                                                                                                           \nstartransfer:  0.000109                                                                                                                                                                                                          \nstartransfer:  8.8e-05                                                                                                                                                                                                           \nstartransfer:  0.000187                                                                                                                                                                                                          \nstartransfer:  8.8e-05                                                                                                                                                                                                           \nstartransfer:  0.000117                                                                                                                                                                                                          \n# Curl Binary                                                                                                                                                                                                                    \nstartransfer: 0.161381                                                                                                                                                                                                           \nstartransfer: 0.160101                                                                                                                                                                                                           \nstartransfer: 0.161324                                                                                                                                                                                                           \nstartransfer: 0.170570                                                                                                                                                                                                           \nstartransfer: 0.170397                                                                                                                                                                                                           \nstartransfer: 0.165819                                                                                                                                                                                                           \nstartransfer: 0.168934                                                                                                                                                                                                           \nstartransfer: 0.165027                                                                                                                                                                                                           \nstartransfer: 0.154728                                                                                                                                                                                                           \nstartransfer: 0.164264\u00b4\nIs there anything i'm missing? Timings using pycurl only are also fine.\nMore info:\n# curl -V                                                                                                                                                                                                  \ncurl 7.54.1 (x86_64-pc-linux-gnu) libcurl/7.54.1 OpenSSL/1.1.0f zlib/1.2.11 libpsl/0.17.0 (+libicu/59.1) libssh2/1.8.0 nghttp2/1.23.1                                                                                            \nRelease-Date: 2017-06-14                                                                                                                                                                                                         \nProtocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp                                                                                                              \nFeatures: AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL                                                                                                       \n# python -V                                                                                                                                                                                                \nPython 3.6.1                                                                                                                                                                                                                     \n[root@li579-34 python]# pip list | grep pycurl                                                                                                                                                                                   \npycurl (7.43.0)                                                                                                                                                                                                                  \n# pip list | grep tornado                                                                                                                                                                                               \ntornado (4.5.1) ", "issue_status": "Closed", "issue_reporting_time": "2017-07-10T13:23:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "315": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2104", "issue_id": "#2104", "issue_summary": "\"WARNING:tornado.access:405 OPTIONS\" error will not allow POST", "issue_description": "SephReed commented on 4 Jul 2017\nTesting with js, if I use an ajax call with \"GET,\" it receives what it should. If I change it to \"POST\" an error is thrown on both client and server side.\nThe server side error is as follows WARNING:tornado.access:405 OPTIONS / (127.0.0.1) 2.12ms\nI have tried running the ajax call both from file://index.html and localhost:8000/index.html with the same result in both cases.", "issue_status": "Closed", "issue_reporting_time": "2017-07-04T07:23:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "316": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2097", "issue_id": "#2097", "issue_summary": "Content-Length included in response with code 101", "issue_description": "Contributor\nsebbov commented on 27 Jun 2017 \u2022\nedited\nI am seeing Jupyter notebooks, which use Tornado, include a Content-Length: 0 on a websocket connection request. The .NET websocket client doesn't appreciate that.\nI believe this is the issue:\ntornado/tornado/web.py\nLine 1000 in c2c0f38\n elif \"Content-Length\" not in self._headers: \nPer RFC7230, section 3.3.2 (https://tools.ietf.org/html/rfc7230#section-3.3.2):\nA server MUST NOT send a Content-Length header field in any response\nwith a status code of 1xx (Informational) or 204 (No Content). A\nserver MUST NOT send a Content-Length header field in any 2xx\n(Successful) response to a CONNECT request (Section 4.3.6 of\n[RFC7231]).", "issue_status": "Closed", "issue_reporting_time": "2017-06-27T00:14:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "317": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2093", "issue_id": "#2093", "issue_summary": "Unable to handle C-Ares exception.", "issue_description": "alvassin commented on 20 Jun 2017 \u2022\nedited\nCurrently i can't find way to divide DNS errors from another, when getting exceptions from CaresResolver\nI just get Exception(\"C-Ares returned error 11: Could not contact DNS servers while resolving example.com\"). In newer versions of tornado i see Exception is replaced with IOError. But anyway, this does not help in general.\nCan you advice right way to handle it? Currently i can just parse error message to detect such errors.\nPerhaps it is possible to replace this exception with inherited class to provide ability to handle C-Ares exceptions?", "issue_status": "Closed", "issue_reporting_time": "2017-06-20T08:54:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "318": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2092", "issue_id": "#2092", "issue_summary": "tornado.testing.AsyncHTTPTestCase: Avoid make Application every times", "issue_description": "Contributor\ncoldnight commented on 20 Jun 2017\nI have a lot tests that inherited tornado.testing.AsyncHTTPTestCase, recently I find the testing is very slow and I find the AsyncHTTPTestCase make Application for every tests.\nPS. I've override the Application and put some heavy jobs.", "issue_status": "Closed", "issue_reporting_time": "2017-06-20T07:24:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "319": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2091", "issue_id": "#2091", "issue_summary": "Method Render Doesn't keep indentation", "issue_description": "felipetesc commented on 18 Jun 2017 \u2022\nedited\nHello there. I'm opening this issue because I'm currently trying to keep the html file's indentation with no success. It's not a bug, it's not even a problem. The reason to keep the indentation is quite simple I'm embedding python code inside html thanks to Brython library, and since Python needs indentation i am receiving \"IndentationError: expected an indented block\".\nThe workaround can be quite simple as defining a new argument such as i.e. self.render('index.html', identation=True).\nCan someone give me some tip, or help to allow me to use Brython/Python ?", "issue_status": "Closed", "issue_reporting_time": "2017-06-18T01:19:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "320": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2089", "issue_id": "#2089", "issue_summary": "There is no way to convey GET parameters using RedirectHandler", "issue_description": "Contributor\nyiliangt5 commented on 16 Jun 2017\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2017-06-16T14:12:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "321": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2088", "issue_id": "#2088", "issue_summary": "Edit On Gitlab link return 404", "issue_description": "realsby commented on 15 Jun 2017\nhttp://www.tornadoweb.org/en/stable/_modules/tornado/platform/asyncio.html#AsyncIOMainLoop", "issue_status": "Closed", "issue_reporting_time": "2017-06-15T12:27:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "322": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2087", "issue_id": "#2087", "issue_summary": "A question about close event when using asyncio", "issue_description": "yuwenyong commented on 15 Jun 2017\nI configure to use asyncio loop.Can the close event triggered when i don't register read event on IOLoop?Sometimes server connection has received the complete HTTPRequest, so don't care the read event.At this time client connection closed. Can server connection close callback triggered?And how to implement it?", "issue_status": "Closed", "issue_reporting_time": "2017-06-15T10:44:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "323": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2086", "issue_id": "#2086", "issue_summary": "js\u4e2d\u5982\u4f55\u83b7\u5f97html\u6a21\u677f\u4e2d{{xx}}\u7684\u53d8\u91cf\u503c\uff0c\u6c42\u5927\u795e\u544a\u77e5", "issue_description": "smalldarks commented on 15 Jun 2017\n<textarea name=\"alipay_gold_wechat\" id=\"jKih64_8\" class=\"jX1hdl\">{{ alipay_str_wechat }}</textarea>\njs\u4e2d\u5982\u4f55\u63d0\u524d\u83b7\u5f97alipay_str_wechat \u7684\u503c\uff0c\u8bd5\u4e86\u597d\u4e9b\u65b9\u6cd5\u6ca1\u7528\u3002\n7", "issue_status": "Closed", "issue_reporting_time": "2017-06-15T10:17:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "324": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2079", "issue_id": "#2079", "issue_summary": "KeyError in IOLoop if IOStream.close() was called in the meantime", "issue_description": "Contributor\npitrou commented on 8 Jun 2017\nTypical symptom is the following:\ntornado.application - ERROR - Exception in callback None\nTraceback (most recent call last):\n  File \"/home/antoine/miniconda3/envs/dask27/lib/python2.7/site-packages/tornado/ioloop.py\", line 886, in start\n    fd_obj, handler_func = self._handlers[fd]\nThis happens whenever a IO handler calls IOStream.close(), while another event is pending on that IOStream's socket. IOStream.close() removes and closes the socket immediately and, when the queued event is processed by the IOLoop, it can't find the relevant handler in its internal table.", "issue_status": "Closed", "issue_reporting_time": "2017-06-08T12:10:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "325": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2078", "issue_id": "#2078", "issue_summary": "Different TimeoutErrors", "issue_description": "Contributor\npitrou commented on 8 Jun 2017\nIt does not seem useful (and is potentially confusing) for Tornado to have two different TimeoutError classes:\n>>> from tornado import ioloop, gen\n>>> gen.TimeoutError is ioloop.TimeoutError\nFalse", "issue_status": "Closed", "issue_reporting_time": "2017-06-08T09:40:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "326": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2076", "issue_id": "#2076", "issue_summary": "Not working through IP interfaces.", "issue_description": "Cosmos19 commented on 6 Jun 2017 \u2022\nedited\nHello,\nI want to host tornado application from my computer so that other computers which is connected to my network can access.\nHere is my code.\nhttp_server = tornado.httpserver.HTTPServer(application)\nhttp_server.listen(8888, address='xx.xx.xx.xx')\ntornado.ioloop.IOLoop.instance().start()\nI could not able to access through IP address. Its working only with localhost.\nconsole : tornado.access:404 GET /favicon.ico (xx.xx.xx.xx) 8.00ms\nIs there something am missing in this config.?", "issue_status": "Closed", "issue_reporting_time": "2017-06-06T11:43:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "327": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2071", "issue_id": "#2071", "issue_summary": "http1connection: Send `Connection: close` before closing connection", "issue_description": "Member\nbdarnell commented on 3 Jun 2017\nFrom #1963 (comment)\nWhen the client sends Connection: close, Tornado (correctly) responds by closing the connection after sending the response. RFC 7230 section 6.6 says that a server SHOULD set the Connection: close header in the response when it does so.", "issue_status": "Closed", "issue_reporting_time": "2017-06-03T15:50:01Z", "fixed_by": "#2074", "pull_request_summary": "http1connection: add \"Connection: close\" header if appropriate", "pull_request_description": "Contributor\nploxiln commented on 5 Jun 2017\nWhen HTTP1Connection acts as the server, it closes the connection\nafter writing the response if the client includes the\n\"Connection: close\" header in the request, or if the no_keep_alive\noption is set to True in the constructor.\nAccording to https://tools.ietf.org/html/rfc7230#section-6.6\nThe server SHOULD send a \"close\" connection option in its final\nresponse on that connection.\nIt was possible for an Application to set the Connection header\nappropriately. But it is very helpful for tornado to take care of\nthis automatically, particularly if \"close\" was specified in a\nrequest header.\nfixes #2071", "pull_request_status": "Merged", "issue_fixed_time": "2017-06-10T21:20:15Z", "files_changed": [["6", "tornado/http1connection.py"], ["1", "tornado/httpserver.py"], ["1", "tornado/test/httpserver_test.py"]]}, "328": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2070", "issue_id": "#2070", "issue_summary": "Public function to determine if we are inside a running event loop", "issue_description": "Contributor\nmrocklin commented on 2 Jun 2017\nI found myself needing and using the following utility function in Dask\ndef in_ioloop():\n    \"\"\" Are we running within the current IOLoop? \"\"\"\n    return IOLoop.current()._running and IOLoop.current()._thread_ident == threading.get_ident()\nHowever in the future I would prefer to avoid depending on private API. This leads to two questions:\nIs this the right way to check if our code is currently running within a Tornado event loop?\nIs it reasonable for something like this enter the public Tornado API?", "issue_status": "Closed", "issue_reporting_time": "2017-06-02T13:52:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "329": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2069", "issue_id": "#2069", "issue_summary": "EBADF in accept() handler if TCPServer.stop() was called in the meantime", "issue_description": "Contributor\npitrou commented on 1 Jun 2017\nWe've had sporadic issues where a EBADF error when calling accept() was being logged. See example here:\nhttps://travis-ci.org/dask/distributed/jobs/238031120#L1596-L1607\nAfter some debugging, I've come to the conclusion that this happens whenever a IO handler calls TCPServer.stop(), while another handler is pending for a connection request on that TCPServer's listening socket(s). TCPServer.stop() closes the listening socket immediately and, when the queued accept handler is called, it finds a closed socket fd.", "issue_status": "Closed", "issue_reporting_time": "2017-06-01T14:08:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "330": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2065", "issue_id": "#2065", "issue_summary": "Issue with GZIP Content-Encoding while using CurlAsyncHTTPClient", "issue_description": "krishnanms commented on 29 May 2017\nExperiencing content-encoding issues while sending GZIP content with CurlAsyncHTTPClient configuration.\nTornado version: 4.4.1\nPycurl version: 7.43.0\nUsed:\ntornado.httpclient.AsyncHTTPClient.configure('tornado.curl_httpclient.CurlAsyncHTTPClient')\nHTTP Response headers:\nContent-Encoding: gzip\nX-Http-Reason: OK\nVary: Accept-Language, Accept-Encoding\nEtag: \"499f294a5c4d50afe7f9bd2297e68624d7666edc\"\nPragma: no-cache\nCache-Control: no-cache, no-store, max-age=0\nDate: Mon, 29 May 2017 16:34:41 GMT\nP3p: CP=\"None specified\"\nContent-Type: text/html; charset=UTF-8\nHTTP Body (redacted):\n52dd\n<!DOCTYPE html>\n\n\n<html...\nLooks like tornado already has decompressed the response, but has not removed the Content-Encoding: gzip header. This doesn't happen if I don't configure tornado to use the CurlAsyncHTTPClient. I see the X-Consumed-Content-Encoding: gzip header correctly being set.", "issue_status": "Closed", "issue_reporting_time": "2017-05-29T17:51:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "331": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2061", "issue_id": "#2061", "issue_summary": "RequestHandler.finish should return a Future", "issue_description": "Member\nbdarnell commented on 27 May 2017\nRequestHandler.finish may call flush(), which returns a Future, but this Future is simply discarded. The main reason for that Future is flow control in streaming responses, which is no longer relevant by the time we are closing the connection, but it also contains errors if the stream is closed while the response is streamed. This error will be logged as a stack trace if left uncaught, so some applications may wish to await their calls to finish() to be able to catch it.\nThis logic also extends to render(), which calls finish().\nFrom #2055 (comment)\n3", "issue_status": "Closed", "issue_reporting_time": "2017-05-27T14:39:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "332": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2060", "issue_id": "#2060", "issue_summary": "coroutine doesn't work", "issue_description": "huchhong commented on 27 May 2017\nI am new to tornado. I want to build a web app using tornado's asynchronous function. I tried the following simple code:\nfrom tornado.ioloop import IOLoop\nfrom tornado import gen\nfrom datetime import datetime\n\n\nclass TestHandler(tornado.web.RequestHandler):\n    @gen.coroutine\n    def get(self):\n        print('get /test at {}'.format(datetime.now()))\n        yield gen.sleep(10)\n        print('sleep end at {}'.format(datetime.now()))\n        self.finish()\n\n\napplication = tornado.web.Application([\n    (r\"/test\", TestHandler),\n    ])\n\napplication.listen(9999)\nIOLoop.instance().start()\nEvery time i send two request at almost same time, the later one would block for 10 seconds after the first request finished which seems that coroutine does not work at all.\nI know maybe i missed something, so what do i need to modify to let coroutine work?", "issue_status": "Closed", "issue_reporting_time": "2017-05-27T08:41:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "333": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2059", "issue_id": "#2059", "issue_summary": "SimpleAsyncHTTPClient caches DNS errors", "issue_description": "ntrrgc commented on 27 May 2017 \u2022\nedited\nSteps to reproduce\nCopy this script:\nfrom datetime import timedelta\n\nfrom tornado.ioloop import IOLoop\nfrom tornado.simple_httpclient import SimpleAsyncHTTPClient\n\nclient = SimpleAsyncHTTPClient()\n\n\ndef print_initial_result(result):\n    print(result)\n    print(\"Now connect to the Internet.\")\n    IOLoop.instance().add_timeout(timedelta(seconds=10), make_second_request)\n\n\ndef make_second_request():\n    print(\"Making a second request...\")\n    client.fetch(\"http://imgur.com\", print_second_result)\n\n\ndef print_second_result(result):\n    print(result)\n\n\nclient.fetch(\"http://imgur.com\", print_initial_result)\n\nIOLoop.instance().start()\nDisconnect from the Internet and run the script.\nA failed HTTP response is printed. Now, connect to the Internet before 10 seconds pass. A second request will be made then.\nExpected result\nThe first request must fail (no connection). The second request should succeed (there is a working connection).\nActual result\nIf the first request failed, any subsequent request to the same host will fail.\nHTTPResponse(_body=None,buffer=None,code=599,effective_url='http://imgur.com',error=gaierror(-2, 'Name or service not known'),headers=<tornado.httputil.HTTPHeaders object at 0x7f4d51612e10>,reason='Unknown',request=<tornado.httpclient.HTTPRequest object at 0x7f4d51db2630>,request_time=0.0012538433074951172,time_info={})\nNow connect to the Internet.\nMaking a second request...\nHTTPResponse(_body=None,buffer=None,code=599,effective_url='http://imgur.com',error=gaierror(-2, 'Name or service not known'),headers=<tornado.httputil.HTTPHeaders object at 0x7f4d512d4048>,reason='Unknown',request=<tornado.httpclient.HTTPRequest object at 0x7f4d56232208>,request_time=0.0005753040313720703,time_info={})", "issue_status": "Closed", "issue_reporting_time": "2017-05-26T19:09:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "334": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2057", "issue_id": "#2057", "issue_summary": "autoreload: Request will be always loading after auto reload", "issue_description": "Contributor\ncoldnight commented on 24 May 2017 \u2022\nedited\nThis commit fa809ed removes the code that closes the IOLoop on reload, that will not close the keep alive connections too. Once the code changed and auto reload done, I refresh the browser it will be always loading.\nI close the IOLoop on reload manually and it works well.\nOS: macOS 10.12.4\nPython 2.7.13\nTornado 4.5.1", "issue_status": "Closed", "issue_reporting_time": "2017-05-24T10:56:02Z", "fixed_by": "#2064", "pull_request_summary": "tcpclient,netutil: Set FD_CLOEXEC on all sockets created by Tornado", "pull_request_description": "Member\nbdarnell commented on 29 May 2017\nPR #1984 was based on the mistaken belief that we were already\ndoing this (and in python 3.4+, it's true, thanks to PEP 446). This\nfixes a regression introduced in Tornado 4.5 in which autoreload would\nleak file descriptors and leave client connections hanging.\nFixes #2057", "pull_request_status": "Merged", "issue_fixed_time": "2017-05-29T15:23:04Z", "files_changed": [["1", "tornado/netutil.py"], ["4", "tornado/platform/common.py"], ["2", "tornado/tcpclient.py"]]}, "335": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2056", "issue_id": "#2056", "issue_summary": "The `replace_callback` argument of `tornado.gen.coroutine`", "issue_description": "Contributor\nJZQT commented on 24 May 2017\ndef coroutine(func, replace_callback=True):\n    # Why not `_make_coroutine_wrapper(func, replace_callback)`\n    return _make_coroutine_wrapper(func, replace_callback=True)", "issue_status": "Closed", "issue_reporting_time": "2017-05-24T09:19:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "336": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2055", "issue_id": "#2055", "issue_summary": "StreamClosedError", "issue_description": "serg666 commented on 23 May 2017\nHi!\nI have the following code:\nimport tornado.ioloop\nimport tornado.web\nimport tornado.gen\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\nclass MainHandler(tornado.web.RequestHandler):\n    async def get(self):\n        await tornado.gen.sleep(30)\n        self.write(\"Hello, world\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nThen I make request with timeout of 20 seconds, for example,\ncurl -v -m 20  http://127.0.0.1:8888\nclient close connection before server reply, and due to the code https://github.com/tornadoweb/tornado/blob/master/tornado/http1connection.py in write_headers the exception should be appear\n...\n        if self.stream.closed():\n            future = self._write_future = Future()\n            future.set_exception(iostream.StreamClosedError())\n            future.exception()\n...\nbut I can not catch it. How can I catch this exception or why it does not appear at all?", "issue_status": "Closed", "issue_reporting_time": "2017-05-23T15:39:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "337": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2053", "issue_id": "#2053", "issue_summary": "Transfer-Encoding:chunked", "issue_description": "neo-hu commented on 22 May 2017 \u2022\nedited by ajdavis\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        self.set_header(\"Transfer-Encoding\", \"chunked\")\n\n        for v in range(1, 3):\n            self.write(\"5\\r\\n11bbb\\r\\n\") # TODO How self.write(\"5\\r\\n<br/>11\\r\\n\") \n            yield self.flush(include_footers=True)\n            yield tornado.gen.sleep(1)\nHow self.write(\"7\\r\\n\n11\\r\\n\") error", "issue_status": "Closed", "issue_reporting_time": "2017-05-22T15:22:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "338": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2044", "issue_id": "#2044", "issue_summary": "Autoreload fails for __main__ module with relative imports", "issue_description": "Contributor\nnoyainrain commented on 20 May 2017 \u2022\nedited\nLet's assume we have a Tornado app with the following structure\ntestapp/\n  __init__.py\n  __main__.py\n  foo.py\n  ...\nwhere __main__ contains a relative import like from .foo import Bar.\nRunning the app with python -m testapp will work as expected. If autoreload is enabled, a reload will however fail with the following exception:\nSystemError: Parent module '' not loaded, cannot perform relative import\nAs explained in the source of autoreload, this happens because the command line arguments are transformed by Python from -m testapp to testapp/__main__.py. On reload, __main__ will be run as a script, preventing relative imports.\nAccording to http://bugs.python.org/msg289874 it is now possible to detect if __main__ has been invoked with -m and reconstruct the original command line for reloading.\nPS: Thanks for your awesome work on Tornado!", "issue_status": "Closed", "issue_reporting_time": "2017-05-20T11:01:15Z", "fixed_by": "#2081", "pull_request_summary": "Fix module autoreload for __main__ with relative imports", "pull_request_description": "Contributor\nnoyainrain commented on 9 Jun 2017\nThe fix works for Python >= 3.4, keeping the current workaround for previous\nversions. Also introduce a first unit test for autoreload. Close #2044.", "pull_request_status": "Merged", "issue_fixed_time": "2017-06-18T02:24:50Z", "files_changed": [["44", "tornado/autoreload.py"], ["48", "tornado/test/autoreload_test.py"], ["1", "tornado/test/runtests.py"]]}, "339": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2042", "issue_id": "#2042", "issue_summary": "How to handle message from lisnten socket client", "issue_description": "zhiephie commented on 15 May 2017\nThis is the point, How to handle global message In class ClientWSConnection(websocket.WebSocketHandler):\nself.atg = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nself.atg.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nself.atg.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\nself.atg.connect((atghost, atgport))\nclass ClientWSConnection(websocket.WebSocketHandler):\n\n    def initialize(self, room_handler):\n        \"\"\"Store a reference to the \"external\" RoomHandler instance\"\"\"\n        self.__rh = room_handler\n        self.atg = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.atg.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.atg.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n        self.atg.connect((atghost, atgport))\n\n    def open(self):\n        self.__clientID =  self.get_cookie(\"ftc_cid\")\n        self.__rh.add_client_wsconn(self.__clientID, self)\n        logger.info(\"| WS_OPENED | %s\" % self.__clientID)\n\n    def on_message(self, message):\n        msg = json.loads(message)\n        mlen = len(msg['payload'])\n        msg['username'] = self.__rh.client_info[self.__clientID]['nick']", "issue_status": "Closed", "issue_reporting_time": "2017-05-15T07:04:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "340": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2041", "issue_id": "#2041", "issue_summary": "The custom error page", "issue_description": "wh836627932 commented on 9 May 2017 \u2022\nedited\nAlways look for custom error pages\nfound so the error All in RequestHandler write_error()\nSo I changed the source code\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            try:\n                self.render(str(status_code) + '.html')\n            except IOError:\n                self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                            \"<body>%(code)d: %(message)s</body></html>\" % {\n                                \"code\": status_code,\n                                \"message\": self._reason,\n                            })\nBut I'm not sure that the source code is available for a solution that doesn't change the source code", "issue_status": "Closed", "issue_reporting_time": "2017-05-09T02:35:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "341": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2039", "issue_id": "#2039", "issue_summary": "Unable to use non-ascii characters in user/password for basic auth in curl_httpclient", "issue_description": "Contributor\nptylenda commented on 8 May 2017\nSteps to reproduce (Python 3.4):\nCreate tornado.httpclient.HTTPRequest with auth_username or auth_password which contains non-ascii (lower range, 0-128), for example pound sterling \u00a3 (which is 153 in ascii).\nExecute curl_httpclient fetch using that request\nExpected result:\nThe request is successfully completed\nActual result:\n2. HTTP 599 is returned and internal exception is:\n'ascii' codec can't encode character '\\xa3' in position 55: ordinal not in range(128)\nI am not sure if I am not aware of the proper solution, but I have tried providing bytes as auth_password, but it does not solve the issue because https://github.com/tornadoweb/tornado/blob/master/tornado/curl_httpclient.py#L438 internally uses string formatting. Reading through pycurl docs (http://pycurl.io/docs/latest/unicode.html) suggests that for Python3 bytes array should be used when using curl setopt. It seems like Python3 vs Python2 issue?\n1", "issue_status": "Closed", "issue_reporting_time": "2017-05-08T18:24:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "342": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2036", "issue_id": "#2036", "issue_summary": "on_message not always send the current time", "issue_description": "zhiephie commented on 6 May 2017\nTornado: as server and client\nTornado send to client not problem and not slow\nbut Tornado write event from another server is slow\nthis is function on_message\nclass ClientWSConnection(websocket.WebSocketHandler):\n\n    def initialize(self, room_handler):\n        self.__rh = room_handler\n        self.atg = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.atg.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.atg.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n        self.atg.connect((atghost, atgport))\n\n    def open(self, client_id):\n        self.__clientID = client_id\n        self.__rh.add_client_wsconn(client_id, self)\n        logger.info(\"[REQ-CLIENT] >> ClientID = %s connected\" %\n                    self.__clientID)\n\n    def on_message(self, message):\n        msg = json.loads(message)\n        logger.info(\"[REQ-CTI] >> ClientID %s request %s\" %\n                    (msg['userid'], msg['payload']))\n        msg['username'] = self.__rh.client_info[self.__clientID]['nick']\n\n        # query data profile agent\n        userid = msg['userid']\n        try:\n            conn = MySQLdb.connect(host=mysqlhost,\n                                   user=mysqluser,\n                                   passwd=mysqlpass,\n                                   db=mysqldbnm)\n            dbconn = conn.cursor()\n\n            dbconn.execute(\n                \"SELECT cti_agentpabx, cti_password, cti_extension, cti_afterstatus, cti_vdn FROM m_user WHERE muser_id = %s\", ([userid]))\n            for i in range(dbconn.rowcount):\n                row = dbconn.fetchone()\n                pabx_agent = row[0]\n                pabx_pass = row[1]\n                pabx_ext = row[2]\n                pabx_afsta = row[3]\n                pabx_vdn = row[4]\n        except MySQLdb.Error:\n            print (\"Error %d: %s\" % (e.args[0], e.args[1]))\n            sys.exit(1)\n        finally:\n            if dbconn:\n                dbconn.close()\n\n        varcommand = msg['payload']\n\n        if varcommand == 'login':\n            msg_do_login = msg['userid'] + ';do_user_login;' + \\\n                pabx_agent + ';' + pabx_pass + ';' + pabx_ext + ';' + pabx_vdn\n            self.atg.send(msg_do_login)\n            call_do_login = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> Login to device %s\" % (msg_do_login))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_do_login))\n\n            msg_do_run_device = pabx_ext + ';do_run_device'\n            self.atg.send(msg_do_run_device)\n            call_do_run_device = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> Run to device %s\" % (msg_do_run_device))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_do_run_device))\n\n            # msg_acd_login = msg['userid'] + ';do_ag_login;' + pabx_ext + \\\n            #     ';' + pabx_agent + ';' + pabx_pass + ';' + pabx_afsta\n            # self.atg.send(msg_acd_login)\n            # call_acd_login = self.atg.recv(1024)\n            # logger.info(\"[MSG-CTI] >> ACD Login %s\" % (msg_acd_login))\n            # logger.info(\"[RES-CTI] >>  %s\" % (call_acd_login))\n\n            msg_replay = {\n                \"msgtype\": \"login\", \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            pmessage2 = json.dumps(msg_replay)\n\n            # query insert to agent activity\n            #dbconn.execute(\"INSERT INTO Writers(Name) VALUES('Jack London')\")\n\n        elif varcommand == 'ready':\n            msg_acd_ready = msg['userid'] + ';do_ag_ready;' + \\\n                pabx_ext + ';' + pabx_agent + ';' + pabx_pass + ';0'\n            self.atg.send(msg_acd_ready)\n            call_acd_ready = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> ACD Ready %s\" % (msg_acd_ready))\n            # logger.info(\"[REP-CTI] >>  %s\" % (call_do_run_device))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_acd_ready))\n\n            msg_replay = {\n                \"msgtype\": \"ready\", \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            pmessage2 = json.dumps(msg_replay)\n\n        elif varcommand == 'notready':\n            msg_acd_not_ready = msg['userid'] + ';do_ag_aux;' + \\\n                pabx_ext + ';' + pabx_agent + ';' + pabx_pass + ';0'\n            self.atg.send(msg_acd_not_ready)\n            call_acd_not_ready = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> ACD Not Ready %s\" % (msg_acd_not_ready))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_acd_not_ready))\n\n            msg_replay = {\"msgtype\": \"not ready\",\n                          \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            pmessage2 = json.dumps(msg_replay)\n\n        elif varcommand == 'logout':\n            # msg_do_shutdown = pabx_ext + ';do_user_shutdown'\n            # self.atg.send(msg_do_shutdown)\n            # call_do_shutdown = self.atg.recv(1024)\n            # logger.info(\"[MSG-CTI] >> Run to device %s\" % (msg_do_shutdown))\n            # logger.info(\"[RES-CTI] >>  %s\" % (call_do_shutdown))\n\n            msg_acd_shutdown = msg['userid'] + ';do_ag_logout;' + \\\n                pabx_ext + ';' + pabx_agent + ';' + pabx_pass + ';0'\n            self.atg.send(msg_acd_shutdown)\n            call_acd_shutdown = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> ACD Not Ready %s\" % (msg_acd_shutdown))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_acd_shutdown))\n\n            msg_replay = {\"msgtype\": \"shutdown\",\n                          \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            pmessage2 = json.dumps(msg_replay)\n\n        elif varcommand == 'makecall':\n            msg_do_make_call = msg['userid'] + ';do_dev_make_call;' + '202'\n            self.atg.send(msg_do_make_call)\n            call_do_make_call = self.atg.recv(1024)\n            logger.info(\"[MSG-CTI] >> Make Call %s\" % (msg_do_make_call))\n            logger.info(\"[RES-CTI] >>  %s\" % (call_do_make_call))\n\n            msg_replay = {\"msgtype\": \"makecall\",\n                          \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            pmessage2 = json.dumps(msg_replay)\n            \n        # elif varcommand  == 'hangup':\n        #     msg_do_hangup = msg['userid'] + ';do_dev_hangup_call'\n        #     self.atg.send(msg_do_hangup)\n        #     res_do_hangup = self.atg.recv(1024)\n        #     logger.info(\"[MSG-CTI] >> Hangup Call %s\" % (msg_do_hangup))\n        #     logger.info(\"[RES-CTI] >>  %s\" % (res_do_hangup))\n\n            # msg_replay = {\"msgtype\": \"hangup\",\n            #             \"sec\": msg['userid'], \"agent_id\": pabx_agent, \"agent_ext\": pabx_ext}\n            # pmessage2 = json.dumps(msg_replay)\n\n        else:\n            msg2 = {\"msgtype\": \"text\", \"username\": 'sss',\n                    \"payload\": 'message not define'}\n            pmessage2 = json.dumps(msg2)\n\n        # atg.send('4;do_user_login;107;109;107;7100')\n        #data = atg.recv(size)\n\n        rconns = self.__rh.roomate_cwsconns(self.__clientID)\n        for conn in rconns:\n            # conn.write_message(pmessage)\n            conn.write_message(pmessage2)\n            logger.info(\"[RPY-CLIENT] >>  %s\" % (pmessage2))\n            # conn.write_message(data)", "issue_status": "Closed", "issue_reporting_time": "2017-05-06T10:46:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "343": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2035", "issue_id": "#2035", "issue_summary": "ioloop.PeriodicCallback does not work after changing system time backwards", "issue_description": "saosir commented on 5 May 2017 \u2022\nedited\nrun the code:\nfrom tornado import ioloop\n\ni = 0\n\n\ndef fun():\n    global i\n    print \"time %d\" % i\n    i += 1\n\n\nio = ioloop.IOLoop()\nioloop.PeriodicCallback(fun, 1000, io).start()\n\nio.start()\nthen always print the log:\ntime 0\ntime 1\ntime 2\n...\nbut if I change my system time 2017-5-5 to 2017-5-4, the code will stop print log.\nI think tornado should add the feature like libevent that auto correct timer after time running backwards:\nstatic void\ntimeout_correct(struct event_base *base, struct timeval *tv)\n{\n struct event **pev;\n unsigned int size;\n struct timeval off;\n\n if (use_monotonic)\n  return;\n\n /* Check if time is running backwards */\n gettime(base, tv);\n if (evutil_timercmp(tv, &base->event_tv, >=)) {\n  base->event_tv = *tv;\n  return;\n }\n\n event_debug((\"%s: time is running backwards, corrected\",\n      __func__));\n evutil_timersub(&base->event_tv, tv, &off);\n\n /*\n  * We can modify the key element of the node without destroying\n  * the key, beause we apply it to all in the right order.\n  */\n pev = base->timeheap.p;\n size = base->timeheap.n;\n for (; size-- > 0; ++pev) {\n  struct timeval *ev_tv = &(**pev).ev_timeout;\n  evutil_timersub(ev_tv, &off, ev_tv);\n }\n /* Now remember what the new time turned out to be. */\n base->event_tv = *tv;\n}", "issue_status": "Closed", "issue_reporting_time": "2017-05-05T09:53:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "344": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2033", "issue_id": "#2033", "issue_summary": "Unable to Install Tornado on Python 2.7.11", "issue_description": "joshuamcginnis commented on 3 May 2017\nI'm trying to install Flower which requires Tornado==4.2.0, but the build keeps failing on backports.ssl_match_hostname-3.5.0.1.\nCollecting backports.ssl_match_hostname (from tornado==4.2.0)\n  Downloading backports.ssl_match_hostname-3.5.0.1.tar.gz\n    Complete output from command python setup.py egg_info:\n    Traceback (most recent call last):\n      File \"<string>\", line 1, in <module>\n      File \"/home/ubuntu/virtualenvs/venv-system/lib/python2.7/site-packages/setuptools/__init__.py\", line 11, in <module>\n        from setuptools.extern.six.moves import filterfalse, map\n      ...\n      File \"/home/ubuntu/virtualenvs/venv-system/lib/python2.7/site-packages/pkg_resources/__init__.py\", line 2193, in sort_key\n        return sys_path.index(_normalize_cached(os.sep.join(parts)))\n    ValueError: '/tmp/pip-build-A_Hurp/backports.ssl-match-hostname' is not in list\n    \n    ----------------------------------------\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-A_Hurp/backports.ssl-match-hostname/\nIt seems installing a later version Tornado fixes this issue, but I cannot guarantee that the Flower team will bump the version anytime soon.\nIs there any workaround for this error?", "issue_status": "Closed", "issue_reporting_time": "2017-05-03T17:40:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "345": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2032", "issue_id": "#2032", "issue_summary": "I want to post binary file use multipart params,but exception raised", "issue_description": "yuwenyong commented on 3 May 2017\n[E 170503 10:22:24 ioloop:629] Exception in callback <functools.partial object at 0x139ac00>\nTraceback (most recent call last):\nFile \"/usr/lib64/python2.7/site-packages/tornado/ioloop.py\", line 600, in _run_callback\nret = callback()\nFile \"/usr/lib64/python2.7/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\nreturn fn(*args, **kwargs)\nFile \"/usr/lib64/python2.7/site-packages/tornado/ioloop.py\", line 615, in\nself.add_future(ret, lambda f: f.result())\nFile \"/usr/lib64/python2.7/site-packages/tornado/concurrent.py\", line 232, in result\nraise_exc_info(self._exc_info)\nFile \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 1014, in run\nyielded = self.gen.throw(*exc_info)\nFile \"/home/yuwenyong/scp_backend/scpbackend/trainer/views.py\", line 217, in publish_skill\nresponse = yield post_multipart(resource_url, params, files)\nFile \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 1008, in run\nvalue = future.result()\nFile \"/usr/lib64/python2.7/site-packages/tornado/concurrent.py\", line 232, in result\nraise_exc_info(self._exc_info)\nFile \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 282, in wrapper\nyielded = next(result)\nFile \"/home/yuwenyong/scp_backend/scpbackend/common/utils.py\", line 692, in post_multipart\nrequest = HTTPRequest(url, \"POST\", headers=headers, body=body, validate_cert=False)\nFile \"/usr/lib64/python2.7/site-packages/tornado/httpclient.py\", line 430, in init\nself.body = body\nFile \"/usr/lib64/python2.7/site-packages/tornado/httpclient.py\", line 475, in body\nself._body = utf8(value)\nFile \"/usr/lib64/python2.7/site-packages/tornado/escape.py\", line 203, in utf8\n\"Expected bytes, unicode, or None; got %r\" % type(value)\nTypeError: Expected bytes, unicode, or None; got <type 'bytearray'>", "issue_status": "Closed", "issue_reporting_time": "2017-05-03T02:31:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "346": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2031", "issue_id": "#2031", "issue_summary": "How do you tell if you have received a binary blob over websocket?", "issue_description": "drafter250 commented on 2 May 2017 \u2022\nedited\nBackground\nHello Thanks for Tornado!\nI am in the middle of trying to develop a single page app for some data-processing stuff where i work. One of the things I need to do is upload a Microsoft excel file and load it to a pandas DataFrame.\nProblem\nI have been trying to figure out how to tell if a \"message\" that comes through the WebsocketHandler.on_message(message) method is binary or text. I found this article on the websocket protocol https://hpbn.co/websocket/ which says the first few bits of the message frame tells whether it is binary or text.\nI have seen some tutorials for base64encoding the file first but i would rather not as this would make the already large files even larger.\nSo I have some questions:\nQuestions\nWhat is the object type for \"message\" that is passed to the on_message method of a WebSocketHandler?\nCan i query whatever object type comes through as the \"message\" for whether it is binary or text?\nIf you can't directly query the \"message\", does it contain the full frame of the message so that I can manually check the bits in question or has that part been stripped out and only the blob payload left?\n(optional) receiving a binary file is great but if I wan't to do different things based on say the file type I can't tell my app what to do with it. can someone point me to some resources on how to setup an extension protocol to add some metadata to the binary message?\nOnce I figure all this out I would be happy to write something up for the docs or will at least put it on my GitHub.\nI would have asked this on SO but like i said if I can figure this out I would be happy to contribute to the docs if permitted.\nThanks for your time!", "issue_status": "Closed", "issue_reporting_time": "2017-05-02T17:02:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "347": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2030", "issue_id": "#2030", "issue_summary": "UnicodeDecodeError: 'utf-8' codec can't decode byte 0x89 in position 0: invalid start byte", "issue_description": "YvesZHI commented on 2 May 2017\n[from tornado.options import define, options\ndefine(\"port\", default=80, help=\"run on the given port\", type=int)\n\nclass IndexHandler(tornado.web.RequestHandler):\n  def get(self, param):\n   print(\"\\n\\nthis is a get request from indexhandler:\")\n   if param:\n    self.render(\"frontend/\" + param)\n   else:\n    self.render(\"index.html\")\n\nclass Application(tornado.web.Application):\n def __init__(self):\n  handlers = [\n    (r\"/(.*)\", IndexHandler)\n  ]\n  super(Application, self).__init__(handlers, **settings)\n\nif __name__ == \"__main__\":\n tornado.options.parse_command_line()\n http_server = tornado.httpserver.HTTPServer(Application())\n http_server.listen(options.port)\n tornado.ioloop.IOLoop.instance().start()\n](url)\nThis is my backend part. When I execute it and use a browser to visit my website, all of png files can't be shown.\n\nHere is the error message:\n[E 170501 22:53:19 web:1590] Uncaught exception GET /images/main-img1.jpg (X.X.X.X)\n    HTTPServerRequest(protocol='http', host='X.X.X.X', method='GET', uri='/images/main-img1.jpg', version='HTTP/1.1', remote_ip='X.X.X.X', headers={'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'fr-FR,fr;q=0.8,en-US;q=0.6,en;q=0.4', 'Accept': 'image/webp,image/*,*/*;q=0.8', 'Host': 'X.X.X.X', 'Referer': 'http://X.X.X.X/html/country.html', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'})\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python3.5/site-packages/tornado/web.py\", line 1509, in _execute\n        result = method(*self.path_args, **self.path_kwargs)\n      File \"tmp.py\", line 20, in get\n        self.render(\"frontend/\" + param)\n      File \"/usr/local/lib/python3.5/site-packages/tornado/web.py\", line 724, in render\n        html = self.render_string(template_name, **kwargs)\n      File \"/usr/local/lib/python3.5/site-packages/tornado/web.py\", line 862, in render_string\n        t = loader.load(template_name)\n      File \"/usr/local/lib/python3.5/site-packages/tornado/template.py\", line 427, in load\n        self.templates[name] = self._create_template(name)\n      File \"/usr/local/lib/python3.5/site-packages/tornado/template.py\", line 455, in _create_template\n        template = Template(f.read(), name=name, loader=self)\n      File \"/usr/local/lib/python3.5/site-packages/tornado/template.py\", line 304, in __init__\n        reader = _TemplateReader(name, escape.native_str(template_string),\n      File \"/usr/local/lib/python3.5/site-packages/tornado/escape.py\", line 218, in to_unicode\n        return value.decode(\"utf-8\")\n    UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte\n[E 170501 22:53:19 web:2063] 500 GET /images/main-img1.jpg (X.X.X.X) 2.07ms", "issue_status": "Closed", "issue_reporting_time": "2017-05-02T01:22:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "348": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2027", "issue_id": "#2027", "issue_summary": "DELETE handler calling flush leads to a 599 due to Transfer-Encoding chunked", "issue_description": "stefanoborini commented on 26 Apr 2017\nI encountered a weird behavior I am unable to say if it's a bug or expected behavior. I am using tornado 4.4.2.\nI have a delete handler in which I perform an operation and then issue a 204 as a response. I also clear Content-Type and called flush().\nIt turns out that my client was getting 599 errors with the following error\nMalformed HTTP message from None: Response with code 204 should not have body.\nI investigated the content, and it turns out that this message is generated because the following entry is in the header of the response.\nTransfer-Encoding: chunked\nThis header is added in http1connection.write_headers, only if a series of conditions apply. In my case, calling flush apparently removed the Content-Length header. Without flush, it is kept as Content-Length: 0. The result is that no Transfer-Encoding header is added, and the 204 response is accepted.\nIs this a bug or intended behavior?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2017-04-26T16:53:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "349": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2021", "issue_id": "#2021", "issue_summary": "Websocket, if yield on on_message, will block ping, pong", "issue_description": "awong1900 commented on 21 Apr 2017\nWebsocket, if yield on on_message, will block ping, pong.\nI have read this PR #1909.\nDo I need use spawn_callback instead it?\nTest code:\nimport logging\nimport tornado.escape\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.websocket\nimport os.path\nimport uuid\nfrom tornado import gen\n\nfrom tornado.options import define, options\n\ndefine(\"port\", default=3000, help=\"run on the given port\", type=int)\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            # (r\"/\", MainHandler),\n            (r\"/websocket\", EchoWebSocket)\n        ]\n        settings = dict(\n            debug=True,\n            websocket_ping_interval=5\n        )\n        super(Application, self).__init__(handlers, **settings)\n        \n        \n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        # self.render(\"index.html\", messages=ChatSocketHandler.cache)\n        print \"..\"\n        self.finish()\n\nclass EchoWebSocket(tornado.websocket.WebSocketHandler):\n    def open(self):\n        print(\"WebSocket opened\")\n\n    @gen.coroutine\n    def on_message(self, message):\n        self.write_message(u\"You said: \" + message)\n        yield gen.sleep(40)\n            \n    def on_pong(self, data):\n        print \"on_pong\"\n\n    def on_close(self):\n        print(\"WebSocket closed\")\n        \n        \ndef main():\n    tornado.options.parse_command_line()\n    app = Application()\n    app.listen(options.port)\n    tornado.ioloop.IOLoop.current().start()\n\n\nif __name__ == \"__main__\":\n    main()", "issue_status": "Closed", "issue_reporting_time": "2017-04-21T02:22:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "350": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2020", "issue_id": "#2020", "issue_summary": "Redefining options that contain an underscore do not raise exceptions, from 4.3.0", "issue_description": "robertbetts commented on 21 Apr 2017 \u2022\nedited\nFrom the release notes in 4.3.0: Dashes and underscores are now fully interchangeable in option names.\nDiscovered issue using Tornado 4.4.1 in Python 2.7 on Mac OS and Linux.\nInternally all options with underscores are converted to dashes e.g. genoa_smtp_host is converted to genoa-smtp-host.\nlooking at the following code one would expect this to raise an exception:\noptions.define(\"genoa_smtp_host\", 'localhost', help=\"SMTP server address\")\noptions.define(\"genoa_smtp_host\", 'localhost', help=\"SMTP server address\")\nHowever it does not, running the next two lines does raise an exception:\noptions.define(\"genoa_smtp_host\", 'localhost', help=\"SMTP server address\")\noptions.define(\"genoa-smtp-host\", 'localhost', help=\"SMTP server address\")\nProposed solution:\nThe first few lines in OptionParser.define() are:\n        if name in self._options:\n            raise Error(\"Option %r already defined in %s\" %\n                        (name, self._options[name].file_name))\nI suggest the following:\n        normalized = self._normalize_name(name)\n        if normalized in self._options:\n            raise Error(\"Option %r already defined in %s\" %\n                        (name, self._options[normalized].file_name))\nOne consideration for the implementor of the solution to this issue, is the description of the error. It could be confusing to a developer/user of Tornado to see an error description as \"Option 'genoa-smtp-host' already defined in my_module.py\" when the option name they are using is genoa_smtp_host.", "issue_status": "Closed", "issue_reporting_time": "2017-04-20T22:10:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "351": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2017", "issue_id": "#2017", "issue_summary": "how to set `SO_RCVTIMEO` in tornado ?", "issue_description": "shotgunner commented on 19 Apr 2017 \u2022\nedited\nIn my Tornado app in some situation some clients disconnect from server but they can't send close event to the server. I currently use ping to find out if client is disconnected.\nnow I want to set SO_RCVTIMEO in tornado instead of using ping pong method.\nsomething like this :\nsock.setsockopt(socket.SO_RCVTIMEO)\nIs it possible to set SO_RCVTIMEO in Tornado for close clients from server after specific time out ?", "issue_status": "Closed", "issue_reporting_time": "2017-04-19T11:34:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "352": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2015", "issue_id": "#2015", "issue_summary": "tornado 4.5 Breaks `jupyter notebook`", "issue_description": "EvanOman commented on 19 Apr 2017\nI am not 100% about the integrity of my python installation but after upgrading to Tornado 4.5 I get the following error:\n\u03bb evan [~] \u2192 jupyter notebook                              \nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/site-packages/traitlets/traitlets.py\", line 528, in get\n    value = obj._trait_values[self.name]\nKeyError: 'log'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/bin/jupyter-notebook\", line 11, in <module>\n    sys.exit(main())\n  File \"/usr/lib/python3.4/site-packages/jupyter_core/application.py\", line 267, in launch_instance\n    return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 657, in launch_instance\n    app.initialize(argv)\n  File \"<decorator-gen-7>\", line 2, in initialize\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"/usr/lib/python3.4/site-packages/notebook/notebookapp.py\", line 1290, in initialize\n    super(NotebookApp, self).initialize(argv)\n  File \"<decorator-gen-6>\", line 2, in initialize\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"/usr/lib/python3.4/site-packages/jupyter_core/application.py\", line 239, in initialize\n    self.parse_command_line(argv)\n  File \"/usr/lib/python3.4/site-packages/notebook/notebookapp.py\", line 1007, in parse_command_line\n    super(NotebookApp, self).parse_command_line(argv)\n  File \"<decorator-gen-4>\", line 2, in parse_command_line\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 536, in parse_command_line\n    flags=flags, log=self.log)\n  File \"/usr/lib/python3.4/site-packages/traitlets/traitlets.py\", line 556, in __get__\n    return self.get(obj, cls)\n  File \"/usr/lib/python3.4/site-packages/traitlets/traitlets.py\", line 535, in get\n    value = self._validate(obj, dynamic_default())\n  File \"/usr/lib/python3.4/site-packages/traitlets/config/application.py\", line 226, in _log_default\n    _log_formatter = self._log_formatter_cls(fmt=self.log_format, datefmt=self.log_datefmt)\n  File \"/usr/lib64/python3.4/site-packages/tornado/log.py\", line 154, in __init__\n    raise RuntimeError(\"No supported color terminal library\")\nRuntimeError: No supported color terminal library\nAfter downgrading to 4.4.3 like so:\n\u03bb evan [~] \u2192 sudo pip3 install --ignore-installed tornado==4.4.3 \nJupyter runs just fine.\nThis SO answer suggested the downgrade: http://stackoverflow.com/a/43444780/2661491\nSpecifics:\nopenSuse 42.2\nPython 3.4.5\nJupyter 4.3.0", "issue_status": "Closed", "issue_reporting_time": "2017-04-19T03:39:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "353": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2013", "issue_id": "#2013", "issue_summary": "windows: No supported color terminal library", "issue_description": "Member\nbdarnell commented on 18 Apr 2017\nSome windows users are reporting \"No supported color terminal library\" errors at startup (the reports so far are by jupyter users; I don't know whether there's something about jupyter that is linked to this error or if that's just a large source of tornado-on-windows users). It looks like this can occur if colorama is installed but colorama.init has not been called.\nSource: https://stackoverflow.com/questions/43443974/no-supported-color-terminal-library-python-jupyter\nCC @mivade\n1", "issue_status": "Closed", "issue_reporting_time": "2017-04-18T01:28:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "354": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2012", "issue_id": "#2012", "issue_summary": "Tornado v4.5 is incompatible with Bokeh Server application implementation", "issue_description": "canavandl commented on 18 Apr 2017\nBokeh uses tornado.web.Application to implement Bokeh Server applications, a two-way server/client visualization framework. The new v4.5 release breaks our implementation and we haven't been able to diagnose.\nHere's the Bokeh issue: bokeh/bokeh#6152\nPlatform: macOS and Ubuntu 14.04 (we haven't tested Windows yet)", "issue_status": "Closed", "issue_reporting_time": "2017-04-17T23:07:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "355": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2010", "issue_id": "#2010", "issue_summary": "websocket demo exception", "issue_description": "enomineCN commented on 13 Apr 2017\ntornado/demos/websocket/chatdemo.py\nchat[\"html\"] = tornado.escape.to_basestring(\n            self.render_string(\"message.html\", message=chat))\n[E 170412 12:04:47 websocket:487] Uncaught exception in /chatsocket\n    Traceback (most recent call last):\n      File \"/Users/crane/Projects/tornado/tornado/websocket.py\", line 484, in _run_callback\n        result = callback(*args, **kwargs)\n      File \"/Users/crane/Projects/tornado/demos/websocket/chatdemo.py\", line 92, in on_message\n        self.render_string(\"message.html\", message=chat))\n      File \"/Users/crane/Projects/tornado/tornado/web.py\", line 863, in render_string\n        namespace = self.get_template_namespace()\n      File \"/Users/crane/Projects/tornado/tornado/web.py\", line 887, in get_template_namespace\n        namespace.update(self.ui)\n    TypeError: 'NoneType' object is not iterable", "issue_status": "Closed", "issue_reporting_time": "2017-04-13T06:25:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "356": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2007", "issue_id": "#2007", "issue_summary": "`asyncio.as_completed` for Tornado coroutines", "issue_description": "vladcalin commented on 12 Apr 2017\nThis is more like a question, I am sorry if this isn't the right place to address it.\nIs there any way to get the asyncio.as_completed behavior but for Tornado coroutines?\nWhat I am trying to do is the following: let's assume I have some coroutines that make some network calls to various endpoints and there is no way to know in what order they will finish and I don't want to wait for each call to complete before initiating the next call.\nThe current solution would be by yielding for each coroutine in some order.\nfor running_coro in [make_network_call(url) for url in urls]:\n    result = yield running_coro\n    # do something with the result\nI would like to do something like this\nfor completed_coro in as_completed([make_network_call(url) for url in urls]):\n    result = yield completed_coro\n    # do something with the result\nThank you in advance!", "issue_status": "Closed", "issue_reporting_time": "2017-04-12T08:46:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "357": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2004", "issue_id": "#2004", "issue_summary": "Check _events and _handlers before start()", "issue_description": "cam72cam commented on 6 Apr 2017\nTraceback (most recent call last):\n    File \"/usr/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 887, in start\n     fd_obj, handler_func = self._handlers[fd]\n     KeyError: 16\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/ioloop.py#L883\nI ran into this issue when testing using multiple processes and threads. We sandbox our test processes using multiprocessing and were getting this cryptic error.\nI found a blog post @toumorokoshi wrote going over his own experiences with this issue: http://y.tsutsumi.io/keyerror-in-self_handlers-a-journey-deep-into-tornados-internals.html\nAt the very least it would be nice to have some documentation suggesting that you run IOLoop.clear_instance() and IOLoop.clear_current() after a fork()", "issue_status": "Closed", "issue_reporting_time": "2017-04-06T15:37:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "358": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2003", "issue_id": "#2003", "issue_summary": "loop.add_future(coroutine): assertion failed", "issue_description": "socketpair commented on 6 Apr 2017 \u2022\nedited\nWell,\nasync def xxx():\n    ...\n\n@gen.coroutine\ndef qwe():\n    yield xxx()\n\nasync def asd():\n    await xxx()\n\nIOLoop.current().add_future(qwe, lambda fut: (fut.exception() or fut.result()))  # success\nIOLoop.current().add_future(asd, lambda fut: (fut.exception() or fut.result()))  # failed. (yes, asd is not a future)\nSo what is the best way to run coroutine in background ? I wrote this:\n# See tornado.htt1connection.HTTP1ServerConnection.start_serving\ndef run_background_task(coroutine):\n    @gen.coroutine\n    def wrapper():\n        raise gen.Return((yield coroutine))\n\n    future = wrapper()\n    IOLoop.current().add_future(future, lambda fut: (fut.exception() or fut.result()))\n    return future\nExample of usage:\nclass MyModule:\n    def start(self):\n        self._cancelled = False\n        self._fut = run_background_task(self._endless())\n\n    async def _endless(self):\n        while not self._cancelled:\n            await gen.sleep(1)\n\n    async def stop(self):\n        self._cancelled = True\n        try:\n            await self._fut\n        except Exception:\n            pass\n\nmodule = MyModule()\nmodule.start()\n...\nawait module.stop()", "issue_status": "Closed", "issue_reporting_time": "2017-04-05T20:11:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "359": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2000", "issue_id": "#2000", "issue_summary": "Regression: HTTP Headers not JSON serializable", "issue_description": "jhihn commented on 4 Apr 2017\nIn Tornado 4.2, the HTTP headers were serializable. This is no longer the case.\nI have an application serializes these to JSON.\nUncaught exception: Object of type 'HTTPHeaders' is not JSON serializable.\nWe'd like to have the HTTPHeaders object continue to be JSON serializable.", "issue_status": "Closed", "issue_reporting_time": "2017-04-03T20:52:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "360": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1996", "issue_id": "#1996", "issue_summary": "Tests failed in Python 3.6 with DeprecationWarning", "issue_description": "Contributor\nfelixonmars commented on 1 Apr 2017\n======================================================================\nERROR: test_iterator_async_await (tornado.test.gen_test.WaitIteratorTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/testing.py\", line 529, in post_coroutine\n    timeout=timeout)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/ioloop.py\", line 457, in run_sync\n    return future_cell[0].result()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 1021, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/lib/python3.6/types.py\", line 184, in throw\n    return self.__wrapped.throw(tp, *rest)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/test/gen_test.py\", line 1358, in test_iterator_async_await\n    yield namespace['f']()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 1015, in run\n    value = future.result()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 285, in wrapper\n    yielded = next(result)\n  File \"<string>\", line 6, in _wrap_awaitable\n  File \"<string>\", line 6, in f\nDeprecationWarning: 'WaitIterator' implements legacy __aiter__ protocol; __aiter__ should return an asynchronous iterator, not awaitable\n\n======================================================================\nERROR: test_async_for (tornado.test.queues_test.QueueGetTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/testing.py\", line 136, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/testing.py\", line 529, in post_coroutine\n    timeout=timeout)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/ioloop.py\", line 457, in run_sync\n    return future_cell[0].result()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 1021, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/lib/python3.6/types.py\", line 184, in throw\n    return self.__wrapped.throw(tp, *rest)\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/test/queues_test.py\", line 174, in test_async_for\n    results = yield namespace['f']()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 1015, in run\n    value = future.result()\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/build/python-tornado/src/tornado-4.4.3/tmp_install/usr/lib/python3.6/site-packages/tornado/gen.py\", line 285, in wrapper\n    yielded = next(result)\n  File \"<string>\", line 6, in _wrap_awaitable\n  File \"<string>\", line 4, in f\nDeprecationWarning: 'Queue' implements legacy __aiter__ protocol; __aiter__ should return an asynchronous iterator, not awaitable\n\n----------------------------------------------------------------------\nRan 1445 tests in 13.083s\n\nFAILED (errors=2, skipped=14)", "issue_status": "Closed", "issue_reporting_time": "2017-04-01T09:05:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "361": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1995", "issue_id": "#1995", "issue_summary": "time out problem!", "issue_description": "cdj0311 commented on 31 Mar 2017 \u2022\nedited\nhi all,\nHow to set time out with tornado\uff1f\nMy code as follows:\n`import tornado.httpserver\nfrom tornado.options import define, options\ndefine(\"port\", default=8080, help=\"--port\", type=int)\nclass MainGetHandler(tornado.web.RequestHandler):\ndef get(self):\ntext = self.get_argument(\"text\", \"\")\nresult = MyProgram(text)\nself.write(result)\nif name == \"main\":\napplication = tornado.web.Application([(r\"/test\", MainGetHandler)])\nhttp_server = tornado.httpserver.HTTPServer(application)\nhttp_server.listen(options.port)\ntornado.ioloop.IOLoop.instance().start()`", "issue_status": "Closed", "issue_reporting_time": "2017-03-31T05:44:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "362": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1994", "issue_id": "#1994", "issue_summary": "Use AsyncHttpClient to replace requests got problem", "issue_description": "ihjmh commented on 31 Mar 2017\nI'm trying to use AsyncHttpClient to replace requests in a third party SDK, code like this:\nclass SDKRuquest(object):\n        ......\n        def request(self,method,url,**kwargs):\n              r = requests.request(\n                                   method=method,\n                                   url=url,\n                                  **kwargs\n                                                        )\n              return r.json()\n        .......\nhere is what i'm trying to do:\nclass SDKRuquest(object):\n        ......\n        def request(self,method,url,**kwargs):\n              #r=self.async_request(method,url,**kwargs)\n              #return r\n              # of course it does not work ,have to use gen.corountine and yield \n\n        @gen.corountine\n        def async_request(self,method,url,**kwargs):\n              r=yield AsyncHTTPClient().fetch(......)\n              return response.body  \n        .......\nNow you can see, I have to change the all the related functions in order to use AsyncHTTPClient(),I just wanna know if there is a method that don't need the change too much other code of the SDK ,only make async_request work, thanks", "issue_status": "Closed", "issue_reporting_time": "2017-03-31T03:10:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "363": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1993", "issue_id": "#1993", "issue_summary": "Unintuitive cookie behavior", "issue_description": "sbly commented on 29 Mar 2017\nCalling get_cookie does not return the value of a cookie previously set in the same request.\nExample:\nself.set_cookie(\"some_new_cookie\", \"value\")\nself.get_cookie(\"some_new_cookie\")  # returns None", "issue_status": "Closed", "issue_reporting_time": "2017-03-29T17:43:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "364": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1992", "issue_id": "#1992", "issue_summary": "FacebookGraphMixin not handling access_token JSON", "issue_description": "devsupportman commented on 29 Mar 2017\nTornado expects the Facebook OAuth access_token response body to be URL-encoded parameters (https://github.com/tornadoweb/tornado/blob/master/tornado/auth.py#L981).\nThis was changed in v2.3 of the Graph API, see https://developers.facebook.com/docs/apps/changelog/#v2_3:\n[Oauth Access Token] Format - The response format of https://www.facebook.com/v2.3/oauth/access_token returned when you exchange a code for an access_token now return valid JSON instead of being URL encoded. The new format of this response is {\"access_token\": {TOKEN}, \"token_type\":{TYPE}, \"expires_in\":{TIME}}. We made this update to be compliant with section 5.1 of RFC 6749.\nAt present, using the FacebookGraphMixin results in a KeyError like the one in #229.\nI think that instead of args = urlparse.parse_qs(escape.native_str(response.body)), something along the lines args = tornado.escape.json_decode(response.body) should be used.", "issue_status": "Closed", "issue_reporting_time": "2017-03-29T17:10:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "365": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1991", "issue_id": "#1991", "issue_summary": "method==HEAD in StaticFileHandler cause not able to disconnect connection", "issue_description": "max32002 commented on 29 Mar 2017 \u2022\nedited\nMy environment:\nOS: Mac OSX 10.12.3\nPython: Python 2.7.10\nTornado: 4.4.2\ncurl 7.51.0 (x86_64-apple-darwin16.0)\nI am developing a streaming feature on tornado web framework, I copy whole StaticFileHandler to modify. I use curl to test my API, with method==GET everything is correct, but when I\ntest method==HEAD, I need manually press Ctrl + C to break the http connection in client side.\neven I add self.finish or assert when method==HEAD, but the connection still keep connected.\nclass StaticFileHandler(RequestHandler):\n\n    def head(self, path):\n        return self.get(path, include_body=False)\n\n    @gen.coroutine\n    def get(self, path, include_body=True):\nHere is my whole source code:\nhttps://github.com/max32002/dropboxlike-server/blob/master/app/controller/temp_link.py", "issue_status": "Closed", "issue_reporting_time": "2017-03-28T19:38:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "366": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1990", "issue_id": "#1990", "issue_summary": "Leaking socket objects", "issue_description": "sbonar commented on 28 Mar 2017\nHoping you can provide me some pointers.\nI have a fairly simple HTTPServer but when the server closes the connection I never see the socket object dealloc'd/GC'd. I've instrumented the socket.py code to show when the objects go through init and exit and for these particular objects I never see the exit called.\nCould this be because it was only a half close on the other side is holding the socket open? Is there anything I can do in the IOStream or TCPServer code?\nThanks in advance", "issue_status": "Closed", "issue_reporting_time": "2017-03-28T03:38:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "367": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1983", "issue_id": "#1983", "issue_summary": "autoreload: Fix argv preservation", "issue_description": "Member\nbdarnell commented on 25 Mar 2017\nautoreload currently has a wrapper mode (e.g. python -m tornado.autoreload -m tornado.test) for scripts, and an in-process mode (enabled by Application(..., debug=True)). It's useful to combine these, since the wrapper can catch syntax errors that cause the process to abort before entering its IOLoop. However, this doesn't work as well as it should, because the main wrapper only restores sys.argv if the process exits, meaning the -m tornado.autoreload flags are lost if the inner autoreload fires. The original argv needs to be stored in a global when autoreload is __main__, so that it can be used in _reload().\n2", "issue_status": "Closed", "issue_reporting_time": "2017-03-25T17:45:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "368": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1982", "issue_id": "#1982", "issue_summary": "Implement IOLoop.run_in_executor", "issue_description": "Member\nbdarnell commented on 25 Mar 2017\nconcurrent.futures integration doesn't work with await, and the tricks that we use for compatibility in yield-based coroutines don't apply to native coroutines. To bridge the gap, we should follow asyncio's lead and offer a run_in_executor method (and set_default_executor).\n1", "issue_status": "Closed", "issue_reporting_time": "2017-03-25T16:32:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "369": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1980", "issue_id": "#1980", "issue_summary": "websocket `yield connection.write_message()` throws BadYieldError", "issue_description": "kupuguy commented on 24 Mar 2017\nAt present code such as:\n    yield connection.write_message(data)\nwill throw BadYieldError if called on a closed connection.\nDocumentation for WebSocketHandler.write_message says it was changed in 4.3 so that it \" Returns a .Future which can be used for flow control.\" In fact it can return either a Future or None. It actually returns the result from the method WebSocketProtocol13._write_frame, and that ends with:\n    try:\n        return self.stream.write(frame)\n    except StreamClosedError:\n        self._abort()\nso in the case where the stream is closed it will return None. It should instead use gen.Return() to send back None as the result.:\n    try:\n        return self.stream.write(frame)\n    except StreamClosedError:\n        self._abort()\n    raise gen.Return()", "issue_status": "Closed", "issue_reporting_time": "2017-03-24T15:05:29Z", "fixed_by": "#2045", "pull_request_summary": "websocket: Don't swallow exceptions in _write_frame", "pull_request_description": "Member\nbdarnell commented on 20 May 2017\nSwallowing the exception violated the method's interface (by returning\nNone instead of a Future), and differs from stream-closed behavior in\nother contexts in Tornado.\nFixes #1980", "pull_request_status": "Merged", "issue_fixed_time": "2017-05-21T02:49:47Z", "files_changed": [["14", "tornado/test/websocket_test.py"], ["15", "tornado/websocket.py"]]}, "370": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1978", "issue_id": "#1978", "issue_summary": "Future exception was never retrieved for yielded future", "issue_description": "ayamnikov commented on 22 Mar 2017 \u2022\nedited\nHi!\nI am using tornado 4.4.2 on Python 2.7.6\nAnd I am trying to make some synchronous code work in asynchronous manner. So I widely using futures and callbacks.\nHere is a simple code that shows the problem:\nimport sys\nimport functools\n\nfrom tornado import gen\nfrom tornado import ioloop\nfrom tornado.httpclient import AsyncHTTPClient\n\n\nclass DummyException(Exception):\n    pass\n\n\nclass Client(object):\n    def __init__(self):\n        self._future = None\n\n    def _parse_response(self, response):\n        if response.code == 418:\n            raise DummyException\n        return response.body\n\n    def _parse_response_wrapper(self, response):\n        try:\n            result = self._parse_response(response)\n            self._future.set_result(result)\n        except Exception as exc:\n            self._future.set_exception(exc)\n            self._future.set_exc_info(sys.exc_info())\n\n    def get(self, url):\n        self._future = gen.Future()\n        AsyncHTTPClient().fetch(\n            url, method='GET', callback=self._parse_response_wrapper)\n        return self._future\n\n\n@gen.coroutine\ndef make_request(url):\n    try:\n        yield Client().get(url)\n    except Exception as exc:\n        print repr(exc)\n\n\nioloop.IOLoop.current().run_sync(\n    functools.partial(make_request, 'http://httpbin.org/status/418'))\nAnd here is its output:\nDummyException()\nERROR:tornado.application:Future exception was never retrieved: DummyException\nERROR:tornado.application:Exception in callback <functools.partial object at 0x7f602cc720a8>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 604, in _run_callback\n    ret = callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/andrey/projects/snippets/future_exc.py\", line 29, in parse_response\n    self._future.set_exc_info(sys.exc_info())\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 306, in set_exc_info\n    self._set_done()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 320, in _set_done\n    for cb in self._callbacks:\nTypeError: 'NoneType' object is not iterable\nFirst of all I am worried about \"Future exception was never retrieved\" error. I thought it should never happen for yielded futures inside a coroutine. I know about the trick with future.add_done_callback(lambda f: f.exception()). But is there a more correct way to fix this?\nThe second is this \"TypeError: 'NoneType' object is not iterable\". What is wrong here?", "issue_status": "Closed", "issue_reporting_time": "2017-03-22T13:26:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "371": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1976", "issue_id": "#1976", "issue_summary": "Is there an ETA for the next release?", "issue_description": "Contributor\nmirceaulinic commented on 20 Mar 2017\nHi,\nJust wanted to ask if there's an ETA for the next release? Nothing critical, for sure, but it would be nice to get the new features / bugfixes / enhancements since the current stable has been released (September 2016).\nThanks!\n-Mircea", "issue_status": "Closed", "issue_reporting_time": "2017-03-20T00:00:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "372": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1975", "issue_id": "#1975", "issue_summary": "Performance difference between gen.coroutine and gen.engine", "issue_description": "jean553 commented on 15 Mar 2017\nHello,\nI have one handler method decorated with @gen.coroutine:\nclass MyHandler(tornado.web.RequestHandler):\n\n    @gen.coroutine\n    def post(self):\n        ...\nWhen I execute performance test on this API, my service is able to execute 3 or 4 requests per second maximum.\nIf I simply change @gen.coroutine to @gen.engine and I execute exactly the same performance test, the service is able to handle around 50 requests per second.\nWhat is the reason for this performance difference between the two decorators ? Is my @gen.engine usage wrong ?\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2017-03-15T12:12:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "373": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1974", "issue_id": "#1974", "issue_summary": "Tornado WebSocket connection is not closed inside a test suite", "issue_description": "gsmafra commented on 14 Mar 2017\nI'm trying to test this WebSocket handler built with Tornado which I'm calling main.py\nimport tornado.websocket\n\nclass SocketHandler(tornado.websocket.WebSocketHandler):\n\n    def open(self):\n        print(' [T] Websocket connection open')\n\n    def on_message(self, message):\n        print(' [T] Websocket message received: %s' % message)\n\n    def on_close(self):\n        print(' [T] Websocket connection closed')\nusing the builtin module tornado.testing with some adaptations from a simple AsyncHTTPTestCase example:\nimport tornado.testing\nimport tornado.web\nimport tornado.websocket\n\nfrom main import SocketHandler\n\nclass TestWebSockets(tornado.testing.AsyncHTTPTestCase):\n\n    def get_app(self):\n        return tornado.web.Application([(r'/', SocketHandler)])\n\n    @tornado.testing.gen_test\n    async def test_async_client(self):\n\n        url = \"ws://localhost:\" + str(self.get_http_port()) + \"/\"\n        client = await tornado.websocket.websocket_connect(url)\n        client.write_message('message')\n        client.close()\nThis test passes. However, when I run pytest --cov-report term-missing --cov=. it points out that the last line of main.py was not reached, i.e. the server was not closed.\nAnyone knows what's happening? I already tried adding a delay after closing but with no success.\nSame question in Stack Overflow", "issue_status": "Closed", "issue_reporting_time": "2017-03-14T17:41:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "374": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1973", "issue_id": "#1973", "issue_summary": "Using tornado 4.1 above gives error \"_execute() missing 1 required positional argument: 'transforms'", "issue_description": "jdk2588 commented on 11 Mar 2017\nI am using tornado 4.1 above gives error. Traceback:\nFuture <tornado.concurrent.Future object at 0x104e7d2e8> exception was never retrieved: Traceback (most recent call last):\nFile \"/usr/local/lib/python3.5/site-packages/tornado/gen.py\", line 215, in wrapper\nresult = func(*args, **kwargs)\nTypeError: _execute() missing 1 required positional argument: 'transforms\nWhat could be the possible reason behind it ?", "issue_status": "Closed", "issue_reporting_time": "2017-03-11T07:12:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "375": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1970", "issue_id": "#1970", "issue_summary": "Question about RequestHandler.initialize signature", "issue_description": "davidshen84 commented on 7 Mar 2017\nHi,\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L194\nThe definition of the initialize method does not have the **kwargs argument. However, it is expected to be invoked in the derived class with key-value arguments.\nIs it a good practice that we omit the **kwargs argument in the method definition?\nI am asking because the PyCharm IDE think it is wrong, even though my code works well so far.", "issue_status": "Closed", "issue_reporting_time": "2017-03-07T06:16:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "376": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1967", "issue_id": "#1967", "issue_summary": "Logging an error for unconsumed futures", "issue_description": "coldeasy commented on 27 Feb 2017\nIs there a mechanism to log an error or even raise an exception when a future is not waited for?\nFor instance, if I accidentally left out a yield like\n@coroutine\ndef c():\n     tornado.gen.sleep(10) # missing yield\n     yield 1\nI considered adding another check in tornado.concurrent that acted towards a result similarly to when an exception is not consumed. However I quickly noticed that there are times in the http request where a coroutine is not yielded (e.g. web.py#L2123).", "issue_status": "Closed", "issue_reporting_time": "2017-02-27T15:05:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "377": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1965", "issue_id": "#1965", "issue_summary": "set_status does not check its argument types", "issue_description": "arefiev commented on 25 Feb 2017\nThis code:\nself.set_status(http.client.BAD_REQUEST)\n, when being executed in a query made by curl, produces this HTTP status line:\nHTTP/1.1 HTTPStatus.NOT_FOUND Not Found\nThis is caused by enum.Enum's working as ints in most contexts (such as being used as list indices) but not when being cast to str.\nVersion 4.2.1", "issue_status": "Closed", "issue_reporting_time": "2017-02-25T12:59:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "378": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1962", "issue_id": "#1962", "issue_summary": "ssl with ValueError: file descriptor cannot be a negative integer (-1)", "issue_description": "fuchaoqun commented on 24 Feb 2017\nhttps proxy (OWTF mitm) throws a ValueError, but response well.\n@gen.coroutine\ndef connect(self):\n    host, port = self.request.uri.split(':')\n    client = self.request.connection.stream\n    yield client.write(b'HTTP/1.0 200 Connection established\\r\\n\\r\\n')\n\n    ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n    ctx.verify_mode = ssl.CERT_NONE\n    ctx.check_hostname = False\n    ctx.load_cert_chain('/path/to/crt', '/path/to/key')\n    socket_ssl = ctx.wrap_socket(client.socket, server_side = True, do_handshake_on_connect = False)\n\n    cs = tornado.iostream.SSLIOStream(socket_ssl)\n    yield cs.wait_for_handshake()\n    raw_headers = yield cs.read_until(b'\\r\\n\\r\\n')\n    content = b'HTTP/1.x 200 ok\\r\\nContent-Type: text/html\\r\\n\\r\\nTEST DONE\\r\\n\\r\\n'\n    yield cs.write(content)\n    cs.close()\na ValueError occurs:\nERROR:tornado.general:Uncaught exception\nTraceback (most recent call last):\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/http1connection.py\", line 721, in _server_request_loop\n    ret = yield conn.read_response(request_delegate)\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/gen.py\", line 1015, in run\n    value = future.result()\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/gen.py\", line 1024, in run\n    yielded = self.gen.send(value)\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/http1connection.py\", line 245, in _read_message\n    self.stream.set_close_callback(self._on_connection_close)\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/iostream.py\", line 412, in set_close_callback\n    self._maybe_add_error_listener()\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/iostream.py\", line 901, in _maybe_add_error_listener\n    self._add_io_state(ioloop.IOLoop.READ)\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/iostream.py\", line 931, in _add_io_state\n    self.fileno(), self._handle_events, self._state)\n  File \"/path/to/anaconda3/lib/python3.5/site-packages/tornado/ioloop.py\", line 725, in add_handler\n    self._impl.register(fd, events | self.ERROR)\nValueError: file descriptor cannot be a negative integer (-1)\n2", "issue_status": "Closed", "issue_reporting_time": "2017-02-24T09:10:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "379": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1961", "issue_id": "#1961", "issue_summary": "Passing a query parameter along with 'next' parameter in login url", "issue_description": "srivignes commented on 23 Feb 2017\nHi,\nI'm having a question regarding passing an additional query parameter along with 'next' during login in order to load the page based on the user logging in.\nFor ex:\nIf a user 'A' is getting into an application and page1.html is loaded for him, then he is navigating to page2.html, suppose if the session is expired, he will be redirected to login page and after logging in, he will be redirected to page2.html using next parameter.\nNow, after session expiry, if user 'B' is trying to logging in, he is being redirected to page2.html directly because of the 'next' parameter.\nSo, is there any option available to pass an additional query parameter along with 'next' parameter in login url ?", "issue_status": "Closed", "issue_reporting_time": "2017-02-23T11:54:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "380": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1960", "issue_id": "#1960", "issue_summary": "The `tornado.log.LogFormatter` is not compatible with logging.config.dictConfig.", "issue_description": "Contributor\nJZQT commented on 22 Feb 2017\nRun the following code will raise exception.\n#!/usr/bin/env python3\n# coding: utf-8\n\nimport logging\nimport logging.config\n\nlogging.config.dictConfig({\n    'version': 1,\n    'incremental': False,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'default': {\n            'class': 'tornado.log.LogFormatter',\n            'format': '[%(levelname)1.1s %(asctime)s %(module)s:%(lineno)d] %(message)s',\n        },\n    },\n    'handlers': {\n        'default': {\n            'class': 'logging.StreamHandler',\n            'formatter': 'default',\n        },\n    },\n    'root': {   # settings of root logger.\n        'level': 'DEBUG',\n        'handlers': ['default'],\n        'propagate': False,\n    },\n})\n\nlogging.root.info(\"message\")\n--- Logging error ---\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/logging/__init__.py\", line 981, in emit\n    msg = self.format(record)\n  File \"/usr/lib/python3.5/logging/__init__.py\", line 831, in format\n    return fmt.format(record)\n  File \"/usr/local/lib/python3.5/dist-packages/tornado/log.py\", line 164, in format\n    formatted = self._fmt % record.__dict__\nTypeError: unsupported operand type(s) for %: 'NoneType' and 'dict'\nCall stack:\n  File \"/home/jzqt/Code/Python/1.py\", line 30, in <module>\n    logging.root.info(\"message\")\nMessage: 'message'\nArguments: ()\nWhy self._fmt is None? I found the answer in the logging.config.DictConfigurator.configure_formatter.\nclass DictConfigurator(BaseConfigurator):\n    ......\n    def configure_formatter(self, config):\n        \"\"\"Configure a formatter from a dictionary.\"\"\"\n        if '()' in config:\n            ......\n        else:\n            fmt = config.get('format', None)\n            dfmt = config.get('datefmt', None)\n            style = config.get('style', '%')\n            cname = config.get('class', None)\n            if not cname:\n                c = logging.Formatter\n            else:\n                c = _resolve(cname)\n            result = c(fmt, dfmt, style)    # answer\n        return result\n    ......\nBecause tornado.log.LogFormatter.__init__ method is as follows\nclass LogFormatter(logging.Formatter):\n    ......\n    def __init__(self, color=True, fmt=DEFAULT_FORMAT,\n                 datefmt=DEFAULT_DATE_FORMAT, colors=DEFAULT_COLORS):\n        ......\nI think that can change tornado.log.LogFormatter.__init__ as follows\nclass LogFormatter(logging.Formatter):\n    ......\n    def __init__(self, fmt=DEFAULT_FORMAT, datefmt=DEFAULT_DATE_FORMAT,\n                 style='%', color=True, colors=DEFAULT_COLORS):\n        ......", "issue_status": "Closed", "issue_reporting_time": "2017-02-22T09:27:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "381": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1958", "issue_id": "#1958", "issue_summary": "Download link not working on main page", "issue_description": "ghost commented on 21 Feb 2017\nhttp://www.tornadoweb.org/en/stable/\nThis download link does not work: https://pypi.python.org/packages/source/t/tornado/tornado-4.4.2.tar.gz", "issue_status": "Closed", "issue_reporting_time": "2017-02-21T06:03:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "382": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1953", "issue_id": "#1953", "issue_summary": "asyncio.wait_for not working", "issue_description": "argaen commented on 14 Feb 2017\nHi, I know there are some incompatibilities with asyncio and I'm writing here to double check. I have the following code that is hanging indefinitely in python3.5.2 and also in python3.6.0b3:\nimport asyncio\nimport tornado.web\nimport tornado.ioloop\nfrom datetime import datetime\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    async def time(self):\n        return datetime.now().isoformat()\n\n    async def get(self):\n        await asyncio.wait_for(self.time(), 5)     # Here I'll hang\n        self.write(await self.time())\n\n\nif __name__ == \"__main__\":\n    tornado.ioloop.IOLoop.configure('tornado.platform.asyncio.AsyncIOLoop')\n    app = tornado.web.Application([(r\"/\", MainHandler)])\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nis this expected behavior? I'm maintaining https://github.com/argaen/aiocache and would like to support asyncio Tornado too.\nThanks", "issue_status": "Closed", "issue_reporting_time": "2017-02-14T16:19:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "383": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1951", "issue_id": "#1951", "issue_summary": "Maintain order of JavaScript files about the render UIModule.", "issue_description": "Contributor\nJZQT commented on 12 Feb 2017\nThis is a example code.\n#!/usr/bin/env python3\n# coding: utf-8\n\nimport os.path\n\nimport tornado.web\nimport tornado.ioloop\n\n\nclass IndexHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        base_dir = os.path.abspath(os.path.dirname(__file__))\n        self.render(os.path.join(base_dir, \"test.html\"))\n\n    pass\n\n\nclass UIModuleA(tornado.web.UIModule):\n\n    def render(self):\n        return \"\"\n\n    def javascript_files(self):\n        return [\"1.js\", \"2.js\", \"4.js\"]\n\n    pass\n\n\nclass UIModuleB(tornado.web.UIModule):\n\n    def render(self):\n        return \"\"\n\n    def javascript_files(self):\n        return [\"2.js\", \"3.js\", \"4.js\"]\n\n    pass\n\n\nif __name__ == \"__main__\":\n    settings = {\n        \"ui_modules\": {\n            \"UIModuleA\": UIModuleA,\n            \"UIModuleB\": UIModuleB,\n        },\n        \"static_path\": \"/\",\n    }\n\n    app = tornado.web.Application([(r\"/\", IndexHandler)], **settings)\n    app.listen(8000)\n    tornado.ioloop.IOLoop.current().start()\nthis is code of test.html.\n<!DOCTYPE HTML>\n<html>\n<head></head>\n<body>\n{% module UIModuleA() %}\n{% module UIModuleB() %}\n</body>\n</html>\nThe rendering order of these JavaScript files are 1.js, 2.js, 4.js 3.js or 2.js, 3.js, 4.js, 1.js.\nBut the correct rendering order is 1.js, 2.js, 3.js, 4.js.\nThis is a code snippet of tornado.web about this issue.\nclass RequestHandler(object):\n    ......\n    def render(self, template_name, **kwargs):\n        ......\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            paths = []\n            unique_paths = set()\n            for path in js_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            js = ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                         '\" type=\"text/javascript\"></script>'\n                         for p in paths)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        ......\nIf this code implement by topological sorting, maybe able to solve this problem.\nOf course, this problem also contain css files.", "issue_status": "Closed", "issue_reporting_time": "2017-02-12T12:43:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "384": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1947", "issue_id": "#1947", "issue_summary": "some question in uploading files", "issue_description": "congfairy commented on 9 Feb 2017\nHi\nI would like to upload some files(each around 500MB ) from client to server in chunks .\nIn the client code,the file is separated in chunks and then the client would send the request ,is there something wrong with me to send the files in chunk?\nwhen I execute my code,here comes this problem:\nclient:\n\nserver:\n\nthe code is here :https://github.com/congfairy/leaf_upload.git.\nwhen you run the code,you could use the command:\nclient:\ng++ -shared -fPIC -o libuploadclient.so uploadclient.cpp -I/root/Python-3.5.0/Include/ -lpython3.5m -L/usr/local/lib/\ng++ main.cpp -o main -I/root/Python-3.5.0/Include/ -lpython3.5m ./libuploadclient.so\n./main\nserver:\npython3 server.py\nI am so eager to know the answer,thanks!\nbest regards,\ncong", "issue_status": "Closed", "issue_reporting_time": "2017-02-09T01:14:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "385": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1946", "issue_id": "#1946", "issue_summary": "Tornado should follow HTTP 308 redirects", "issue_description": "Contributor\njeffhunter commented on 9 Feb 2017 \u2022\nedited\nTornado does not currently follow HTTP 308 redirects, even if the HTTPRequest follow_redirects parameter is True.\nMore info about HTTP 308 redirects can be found here:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308\nThe New York Times is using HTTP 308 redirects to redirect some requests from HTTP to HTTPS, you will see a 308 redirect if you attempt to fetch this page:\nhttp://cooking.nytimes.com/recipes/1017766-pureed-winter-squash-and-red-lentil-soup\nThe fix is to check for a 308 status code in _HTTPConnection._should_follow_redirect.", "issue_status": "Closed", "issue_reporting_time": "2017-02-09T01:13:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "386": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1944", "issue_id": "#1944", "issue_summary": "Tornado for long request", "issue_description": "vladimircape commented on 8 Feb 2017\nAs i read in Wiki, Tornado is not good solution if you have request which process data(from 5-10sec) for long time.\nAm i right?", "issue_status": "Closed", "issue_reporting_time": "2017-02-08T12:42:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "387": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1943", "issue_id": "#1943", "issue_summary": "lots of websocket connection closed sametime....", "issue_description": "hareshowin commented on 8 Feb 2017\nour project is using python as serverside, and import tornado for connection manager.\nas we found and reported, when totally 1000+ clients connected on server, it may trigger issue:\nlots of websocket connections are closed at the same time. clients all offline....\nclients detect it and re-connection... and re-offline ....\nit lasts for about 10-15 minutes, then recovered..\ni've no idea how this triggered?\nand it becomes more frequently after we use https and wss.\nany suggestions?\nmany thanks!!!!!", "issue_status": "Closed", "issue_reporting_time": "2017-02-08T03:22:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "388": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1942", "issue_id": "#1942", "issue_summary": "AsyncHTTPClient fetch hangs when client is attached to self", "issue_description": "tab1293 commented on 7 Feb 2017 \u2022\nedited\nWhen assigning an instance of AsyncHTTPClient to a class variable, calling fetch on it just hangs. In the code below, the google_request responds with a 200 but google_request_self does not respond at all. Is this a bug or an intended side effect?\nfrom tornado.ioloop import IOLoop\nfrom tornado.gen import coroutine, Return\nfrom tornado.httpclient import AsyncHTTPClient\n\nclass GoogleGetter:\n    def __init__(self):\n        self.url = \"http://google.com\"\n        self.http_client = AsyncHTTPClient()\n\n    @coroutine\n    def google_request_self(self):\n        resp = yield self.http_client.fetch(self.url)\n        print resp.code\n        raise Return(resp)\n\n    @coroutine\n    def google_request(self):\n        http_client = AsyncHTTPClient()\n        resp = yield http_client.fetch(self.url)\n        print resp.code\n        raise Return(resp)\n\ngg = GoogleGetter()\nioloop = IOLoop()\nioloop.run_sync(gg.google_request)\nioloop.run_sync(gg.google_request_self)", "issue_status": "Closed", "issue_reporting_time": "2017-02-06T20:28:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "389": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1941", "issue_id": "#1941", "issue_summary": "about the max_clients", "issue_description": "avayayu commented on 6 Feb 2017\nAsyncHTTPClient.configure(\n        None, max_clients=1000)\n\n    http_client = AsyncHTTPClient(max_clients=1000)\n\n    for i in range(1, 85, 1):\n        url = 'http://vip.stock.finance.sina.com.cn/quotes_service/api/json_v2.php/Market_Center.getHQNodeData?page=' + \\\n            str(i + 1) + '&num=80&sort=changepercent&asc=0&node=hs_a&symbol=&_s_r_a=setlen'\n        req = HTTPRequest(url)\n        response = http_client.fetch(request=req, callback=handle_response)\n    http_client.close()\nthis code still get DEBUG max_clients limit reached, request queued. 10 active, 21 queued requests.Why?\nI using py3.5 on windows7", "issue_status": "Closed", "issue_reporting_time": "2017-02-06T06:33:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "390": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1940", "issue_id": "#1940", "issue_summary": "Unexpected exception when handling malformed response header", "issue_description": "jxskiss commented on 4 Feb 2017\nSome http server response without status message, like \"HTTP/1.1 200\",\nin the following line, \"parse_response_start_line\" expects an space after the status code, as the docstring says \"HTTP/1.1 200 OK\".\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/httputil.py#L849\nBut the regular expression is written as \"(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)\", which can match \"HTTP/1.1 200 \" but not \"HTTP/1.1 200\", and HTTPInputError(\"Error parsing response start line\") is raised.\nMake the space optional with ? gives the expected result.", "issue_status": "Closed", "issue_reporting_time": "2017-02-04T07:02:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "391": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1939", "issue_id": "#1939", "issue_summary": "Behaviour on StreamBufferFullError", "issue_description": "aagarwal-optumsoft commented on 3 Feb 2017 \u2022\nedited\nby default max_write_buffer_size is none that means no limit. Now suppose if limit is set then what is the expected behaviour. As per my understanding the exception is not caught and hence no proper action is taken. By proper I meant whether you decide to close the connection or let it be like this.", "issue_status": "Closed", "issue_reporting_time": "2017-02-03T08:53:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "392": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1937", "issue_id": "#1937", "issue_summary": "\"IndexError: deque index out of range\" tornado ioloop", "issue_description": "playablebox commented on 28 Jan 2017 \u2022\nedited\nI'm developing a web game with the latest version of Tornado.\nIt consists of 1 thread for tornado and 1 thread for the game loop.\nThe issue below happens sometimes when I leave the clients (around 100 of them) running for by themselves for a few minutes (The clients are updated at 60 times per second).\nIf I refresh the page, it acquires a new connection and everything works fine until it happens again.\nAny ideias?\nBTW I'm not doing any IO calls myself yet (DB, flies, etc).\n[E 170128 14:34:30 iostream:546] Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/iostream.py\", line 515, in _handle_events\n        self._handle_write()\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/iostream.py\", line 837, in _handle_write\n        num_bytes = self.write_to_fd(self._write_buffer[0])\n    IndexError: deque index out of range\n[E 170128 14:34:30 ioloop:633] Exception in callback None\n    Traceback (most recent call last):\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/ioloop.py\", line 887, in start\n        handler_func(fd_obj, events)\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/iostream.py\", line 515, in _handle_events\n        self._handle_write()\n      File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/iostream.py\", line 837, in _handle_write\n        num_bytes = self.write_to_fd(self._write_buffer[0])\n    IndexError: deque index out of range", "issue_status": "Closed", "issue_reporting_time": "2017-01-28T14:53:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "393": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1934", "issue_id": "#1934", "issue_summary": "TypeError: __init__() takes 1 positional argument but 3 were given - ERROR:tornado.application:Uncaught exception", "issue_description": "FlorianSteenbuck commented on 25 Jan 2017\nI got only that error and a empty https response:\nERROR:tornado.application:Uncaught exception\nTraceback (most recent call last):\n  File \"C:\\Users\\floxen\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\tornado\\http1connection.py\", line 238, in _read_message\n    delegate.finish()\n  File \"C:\\Users\\floxen\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\tornado\\httpserver.py\", line 289, in finish\n    self.delegate.finish()\n  File \"C:\\Users\\floxen\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\tornado\\web.py\", line 2047, in finish\n    self.execute()\n  File \"C:\\Users\\floxen\\AppData\\Local\\Programs\\Python\\Python35\\lib\\site-packages\\tornado\\web.py\", line 2067, in execute\n    **self.handler_kwargs)\nTypeError: __init__() takes 1 positional argument but 3 were given", "issue_status": "Closed", "issue_reporting_time": "2017-01-25T10:48:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "394": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1933", "issue_id": "#1933", "issue_summary": "stream_request_body documentation bug", "issue_description": "Contributor\najdavis commented on 24 Jan 2017\nThe docs say, \"The first call to data_received may occur at any point after the call to prepare has returned or yielded.\"\nhttp://www.tornadoweb.org/en/stable/web.html#tornado.web.stream_request_body\nBut a test proves this false, the first call to data_received may occur only after prepare has returned:\nfrom tornado import gen, ioloop, web\n\n@web.stream_request_body\nclass Handler(web.RequestHandler):\n    @gen.coroutine\n    def prepare(self):\n        print('start')\n        yield gen.sleep(5)\n        print('finish')\n\n    @gen.coroutine\n    def data_received(self, chunk):\n        print('received')\n\n    def post(self):\n        print('post')\n\napplication = web.Application([(r'/', Handler)])\napplication.listen(8888)\nioloop.IOLoop.current().start()\nRun this and curl --data \"foo\" localhost:8888, it prints:\nstart\nfinish\nreceived\npost\nWe'd expect this instead:\nstart\nreceived\nfinish\npost\nThis appears to be by design, see _read_message. I propose changing the documentation, \"Tornado begins calling data_received with chunks of data after prepare has returned.\"", "issue_status": "Closed", "issue_reporting_time": "2017-01-24T13:56:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "395": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1931", "issue_id": "#1931", "issue_summary": "`TCPClient` connect using specific source IP address", "issue_description": "Contributor\nmirceaulinic commented on 23 Jan 2017\nHello,\nI was looking at the connect method in the TCPClient and my understanding is that it does not support the source IP Address (or source interface): https://github.com/tornadoweb/tornado/blob/master/tornado/tcpclient.py#L157-L158\nBut default, a socket without a bind will use the loopback IP. But there are needs when the environment (i.e. firewalls etc.) requires using a certain source/interface to connect.\nAs my tornado understanding is very limited so far, I think it should only require adding the necessary binding in: https://github.com/tornadoweb/tornado/blob/master/tornado/iostream.py#L1071-L1073\nand somehow in https://github.com/tornadoweb/tornado/blob/master/tornado/tcpclient.py#L164 - but I'm not sure about the resolver part.\nSome guidance would be much appreciated & happy to submit a PR for a new optional argument to cover that need.\nThanks,\nMircea", "issue_status": "Closed", "issue_reporting_time": "2017-01-23T00:22:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "396": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1930", "issue_id": "#1930", "issue_summary": "CurlAsyncHTTPClient exited without any error", "issue_description": "avayayu commented on 21 Jan 2017 \u2022\nedited by ajdavis\nmy code is\uff1a\ndef handle_response(response):\n    if response.error:\n        print(\"Error: \" + str(response))\n    else:\n\n        print(response.body)\n\n        con = db.getConnection()\n        df = pd.read_sql(\n            'select max(tradingdate) as begindate from tradingdate_sina', con=con)\n\n        tradingdate = str(df.begindate[0])\n\n        \n\n        if response.body != \"\":\n            print('no error')\n            result = response.text.split(\",\")[-3]\n            if result != tradingdate:\n                cursor = con.cursor()\n                cursor.execute(\n                    'insert into tradingdate_sina values (\\'' + result + '\\')')\n                con.commit()\n        con.close()\n\n\ndef crawl_tradingdate():\n    print(\"in crawl_tradingdate()\")\n    http_client = CurlAsyncHTTPClient()\n    request = HTTPRequest(\n        'http://hq.sinajs.cn/list=sh000001')\n    try:\n        http_client.fetch(request, handle_response)\n    except CurlError:\n        print(CurlError.msg)\n\n    print('crawl_tradingdate finished')\n\nif __name__ == \"__main__\":\n    application.listen(8222)\n\n    scheduler = myScheduler.init()\n    scheduler.start()\n\n    try:\n        IOLoop.instance().start()\n    except (KeyboardInterrupt, SystemExit):\n        pass\nscheduler work well. But IOLoop always exits when cral_traidingdate runs. But there is no error no except.What's wrong?\nPS. this is based on windows py3.5,tornado4.3.,and pycurl works well.", "issue_status": "Closed", "issue_reporting_time": "2017-01-21T18:14:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "397": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1929", "issue_id": "#1929", "issue_summary": "Too many TimeoutErrors", "issue_description": "Contributor\npitrou commented on 13 Jan 2017\nThis would probably warrant unifying.\n>>> ioloop.TimeoutError\ntornado.ioloop.TimeoutError\n>>> gen.TimeoutError\ntornado.gen.TimeoutError\n>>> gen.TimeoutError is ioloop.TimeoutError\nFalse", "issue_status": "Closed", "issue_reporting_time": "2017-01-13T12:46:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "398": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1925", "issue_id": "#1925", "issue_summary": "Bridging tornado and asyncio fails when debug or autoreload are set to True.", "issue_description": "khajvahmac commented on 9 Jan 2017 \u2022\nedited\nSETTINGS = {\n    'debug': True,\n    'autorelaod': True,\n    'cookie_secret': \"234kjsaldkf234kljasdfkl90ugdfoigjm,x.bn,mszdf8g923\"\n}\n\n\nif __name__ == \"__main__\":\n    application = tornado.web.Application(urls.urls, **SETTINGS)\n    tornado.platform.asyncio.AsyncIOMainLoop().install()\n    application.listen(8880)\n    asyncio.get_event_loop().run_forever()\nThis code fails with the following traceback:\nTraceback (most recent call last):\n  File \"webapp/main.py\", line 23, in <module>\n    tornado.platform.asyncio.AsyncIOMainLoop().install()\n  File \"/home/khajvah/Personal/orisma/venv/lib/python3.5/site-packages/tornado/ioloop.py\", line 180, in install\n    assert not IOLoop.initialized()\nAssertionError\nAs I understand, if any or both of those options are present, it creates an IOLoop which causes .install() to fail.\nThe docstring of install() talks about it but one has to look deep to realize what's going on.\nMaybe the docs of AsyncIOMainLoop should talk about it, as this can potentially waste many people's time?", "issue_status": "Closed", "issue_reporting_time": "2017-01-08T21:05:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "399": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1923", "issue_id": "#1923", "issue_summary": "AssertionError: queue non-empty, why are getters waiting?", "issue_description": "leobocao commented on 5 Jan 2017\nHi,\nI'm getting this error when playing with tornando queues module.\nError at: \"/usr/local/lib/python3.4/site-packages/tornado/queues.py\", line 179\nIt seems this error was fixed already into python 3.4.4 but it was not applied into Tornado. Issue has been discussed at:\npython/asyncio#268\nAnd the fix is posted here:\ngvanrossum/asyncio@76d9d17\nAny idea when or if the tornado queue module will be upgrade?\nI'm running tornado 4.3 however I see there is no change into 4.4.2 version.\nThanks,\nLeo", "issue_status": "Closed", "issue_reporting_time": "2017-01-04T18:55:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "400": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1922", "issue_id": "#1922", "issue_summary": "how download multi-images from tornado web server using handler?", "issue_description": "tonyshare commented on 3 Jan 2017\nI am store images in mariadb, and I want to download the images using handler's get method. how can i set the http header and the multipart body?\nthanks ahead!", "issue_status": "Closed", "issue_reporting_time": "2017-01-03T15:13:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "401": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1921", "issue_id": "#1921", "issue_summary": "an error occurred in python3.5", "issue_description": "nickhell commented on 28 Dec 2016\nI wish to start a multi-process in python3.5 by tornado4.4.2 like this:\nhttp_server = tornado.httpserver.HTTPServer(app)\nhttp_server.bind(tornado.options.options.port)\nhttp_server.start(0)\ntornado.ioloop.IOLoop.instance().start()\nBut got an error in File \"D:\\Program Files\\Python35\\lib\\site-packages\\tornado\\process.py\", line 137, pid = os.fork()\nThe error is AttributeError: module 'os' has no attribute 'fork'.\nThere is no os.fork() attribute in python3.\nIs this a bug? Or what method shold i follow?", "issue_status": "Closed", "issue_reporting_time": "2016-12-28T03:34:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "402": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1919", "issue_id": "#1919", "issue_summary": "The PeriodicCallback in for loop", "issue_description": "GuoHongke commented on 21 Dec 2016 \u2022\nedited\nwhen I do this:\n@gen.coroutine\ndef fetch(url):\nprint url\nclient = AsyncHTTPClient()\nresponse = yield gen.Task(client.fetch, url)\nif response.code == 200:\nresp = {\"url\": url, \"message\": response.body}\nelse:\nresp = {\"url\": url, \"message\": \"fetch client error\"}\nprint resp\nif name == 'main':\nfor url in url_list:\ntornado.ioloop.PeriodicCallback(lambda: fetch(url), 2000).start()\ninstance = tornado.ioloop.IOLoop.instance()\ninstance.start()\nI just got the response of the last url in url_list\nwhen I change the main like this:\nif name == 'main':\ntornado.ioloop.PeriodicCallback(lambda: fetch('http://www.google.com'), 2000).start()\ntornado.ioloop.PeriodicCallback(lambda: fetch('https://www.python.org'), 2000).start()\ninstance = tornado.ioloop.IOLoop.instance()\ninstance.start()\nI got both the massage from the tow url. Is there any magic?\nthanks", "issue_status": "Closed", "issue_reporting_time": "2016-12-21T07:45:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "403": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1918", "issue_id": "#1918", "issue_summary": "ThreadPoolExecutor stuck", "issue_description": "984958198 commented on 21 Dec 2016 \u2022\nedited\nPart of my code:\n#-*- coding:utf-8 -*-\n\n__version__ = \"1.0\"\nfrom bs4 import BeautifulSoup\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import RequestHandler, Application\nfrom concurrent.futures import ThreadPoolExecutor\nfrom pyquery import PyQuery\nimport datetime, time, tornado, requests, urllib, redis, base64\nimport logging, logging.handlers, json, threading, re, demjson, platform, xmltodict\nfrom gevent import monkey\nfrom gevent.pool import Pool\nmonkey.patch_all()\n\nif platform.system() != 'Windows':\n    r = redis.Redis(host='192.168.2.140', port=6479, db=1)\nelse:\n    r = redis.Redis(host='127.0.0.1', port=6379, db=1)\n\nexecutor = ThreadPoolExecutor(100)  #\u6700\u5927\u5e76\u53d1\u6570\n\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(funcName)s - %(message)s\",\n)\nhandler = logging.handlers.RotatingFileHandler(\"/home/guozx/log/weibo_zhihu.log\", maxBytes=1024 * 1024 * 5, backupCount=5) if platform.system() != 'Windows' else logging.StreamHandler()\nformatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(funcName)s - %(message)s\")\nhandler.setFormatter(formatter)\nmylog = logging.getLogger('x')\nmylog.propagate = 0\nmylog.addHandler(handler)\n\ntornadolog = logging.getLogger(\"tornado\")\ntornadolog.propagate = 0\ntornadolog.addHandler(handler)\n\nasc = threading.Thread(target=error_alert_thread)\nasc.setName('error_alert_thread')\nasc.setDaemon(True)\nasc.start()\n\nclass MainHandler(RequestHandler):\n    def get(self, path):\n        data = \"hello word\"\n        if path == '1':\n            data = ', '.join([v.name for v in threading._active.values()])\n        self.write(data)\n\nclass BaseHandler(RequestHandler):\n    def set_default_headers(self):\n        self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n        self.set_header(\"Access-Control-Allow-Headers\", \"accept, origin, content-type, content-length\")\n        self.set_header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')\n        #self.set_header(\"Access-Control-Allow-Credentials\", True)\n\n        self.set_header('Content-Type', 'application/json; charset=UTF-8')\n\nclass GetWeiboDebugHandler(BaseHandler):\n    @tornado.gen.coroutine\n    def get(self):\n        mylog.info('111111111111111111111111111')\n        q = self.get_argument('q')\n        num = self.get_argument('num', None)\n        res = yield executor.submit(self.get_weibo, q, int(num) if num else 1)\n        mylog.info(\"666666666666666666666666666666\")\n        self.finish(\"%s(%s)\" % (self.get_argument('callback'), res) if self.get_argument('callback', None) else res)\n        mylog.info(\"7777777777777777777777777777777777\")\n\n    def get_weibo(self, names, num=1):\n        mylog.info(\"2222222222222222222222222222222222\")\n        try:\n            nameList = json.loads(names)\n            assert type(nameList) == list\n        except:\n            nameList = [names]\n        def _x(name, num):\n            mylog.info('3333333333333333333333333333333333')\n            if not name:\n                return {}\n            key = \"wb_%s_%s\" % (name, num)\n            data = r.get(key)\n            mylog.info('4444444444444444444444444444444444')\n            if data:\n                data = json.loads(data)\n            else:\n                data = _get_weibo(name, num)\n                r.set(key, json.dumps(data), weibo_cache_timeout)\n            return data\n        dataList, error = _gevent_dispose(_x, [(n, num) for n in nameList], max_pool=5)\n        mylog.info('5555555555555555555555555555555555')\n        return json.dumps(dataList)\n\n\n\npathList = [\n    (r\"/(\\d*)\", MainHandler),\n    (r\"/get_weibo_debug\", GetWeiboDebugHandler),\n]\nif __name__ == \"__main__\":\n    host, port = '0.0.0.0', 9092\n    mylog.info(\"%s:%s service start...\" % (host, port))\n    application = Application(pathList)\n    application.listen(port, host, idle_connection_timeout=180)\n    IOLoop.instance().start()\nRun for a period of time occasionally be stuck\nWhen I call /get_weibo_debug, Only the output to '111111111111111111111111111'\nPython 2.7.5 (default, Jun 17 2014, 18:11:42) \n[GCC 4.8.2 20140120 (Red Hat 4.8.2-16)] on linux2\npip list:\nBabel (2.3.4)\nbacklash (0.1.1)\nbackports-abc (0.4)\nbackports.ssl-match-hostname (3.5.0.1)\nBeaker (1.8.0)\nbeautifulsoup4 (4.5.1)\nbs4 (0.0.1)\ncertifi (2016.8.8)\ncrank (0.8.0)\ncssselect (0.9.2)\ndecorator (4.0.10)\ndemjson (2.2.4)\nFormEncode (1.3.0)\nfuncsigs (1.0.2)\nfutures (3.0.5)\ngearbox (0.1.1)\nGenshi (0.7)\ngevent (1.1.2)\ngreenlet (0.4.10)\nlxml (3.6.4)\nMarkupSafe (0.23)\nMing (0.5.4)\nmock (2.0.0)\nmyproj (0.1, /home/guozx/myproj)\nnumpy (1.11.1)\npandas (0.18.1)\nPasteDeploy (1.5.2)\npbr (1.10.0)\npip (8.1.2)\nprotobuf (3.1.0)\npymongo (2.9.3)\npyquery (1.2.13)\npython-dateutil (2.5.3)\npytz (2016.4)\nredis (2.10.5)\nrepoze.lru (0.6)\nrepoze.who (2.3)\nrequests (2.10.0)\nsetuptools (23.0.0)\nsingledispatch (3.4.0.3)\nsix (1.10.0)\nspeaklater (1.3)\nsprox (0.10.2)\nTempita (0.5.2)\ntensorflow (0.12.0rc1)\ntg.devtools (2.3.8)\ntgext.admin (0.7.3)\ntgext.crud (0.8.2)\nTGScheduler (1.7.0)\ntornado (4.4.1)\nTurboGears2 (2.3.8)\ntw2.core (2.2.4)\ntw2.forms (2.2.5)\nWebHelpers2 (2.0)\nWebOb (1.6.1)\nWebTest (1.4.3)\nwheel (0.29.0)\nxmltodict (0.10.2)\nzope.interface (4.2.0)", "issue_status": "Closed", "issue_reporting_time": "2016-12-21T03:16:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "404": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1914", "issue_id": "#1914", "issue_summary": "Writing tests for tornado app, which uses momoko for postgres DB", "issue_description": "judeaugustinej commented on 14 Dec 2016\nhello.py\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpserver import HTTPServer\nfrom tornado.options import parse_command_line\nfrom tornado import web\n\nimport psycopg2\nimport momoko\n\n\nclass BaseHandler(web.RequestHandler):\n    @property\n    def db(self):\n        return self.application.db\n\n\nclass TutorialHandler(BaseHandler):\n    def get(self):\n        self.write('Some text here!')\n        self.finish()\n\ndef create_app():\n    application = web.Application([\n        (r'/', TutorialHandler)\n    ], debug=True)\n\n    ioloop = IOLoop.instance()\n\n    application.db = momoko.Pool(\n        dsn='dbname=postgres user=devstack password=root',\n        size=1,\n        ioloop=ioloop,\n    )\n\n    # this is a one way to run ioloop in sync\n    future = application.db.connect()\n    ioloop.add_future(future, lambda f: ioloop.stop())\n    ioloop.start()\n    future.result()  # raises exception on connection error\n    return application, ioloop\n\nif __name__ == \"__main__\":\n    parse_command_line()\n    application, ioloop = create_app()\n    http_server = HTTPServer(application)\n    http_server.listen(8888, 'localhost')\n    ioloop.start()\ntest_hello.py\nimport unittest\n\nimport tornado.ioloop\nfrom tornado.httpclient import HTTPRequest\nfrom tornado.testing import AsyncHTTPTestCase, gen_test, bind_unused_port\nfrom tornado.httpserver import HTTPServer\n\nfrom hello import create_app\n\nclass SimpleTest(AsyncHTTPTestCase):\n\n    def get_app(self):\n        ioloop, application = create_app()\n        return application\n\n    def get_new_ioloop(self):\n        ioloop, _ = create_app()\n        return ioloop\n\n    def test_endpoint_status_code(self):\n        response = self.fetch(\"/\", method='GET')\n        self.assertEqual(response.code, 200)\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)\nerror msg\npython test_hello.py\n/simple_momko_app$ python test_hello.py \ntest_endpoint_status_code (__main__.SimpleTest) ... ERROR\n\n======================================================================\nERROR: test_endpoint_status_code (__main__.SimpleTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/home/devstack/Desktop/tornado_learning/learn_testing_in_tornado/simple_momko_app/env/local/lib/python2.7/site-packages/tornado/testing.py\", line 375, in setUp\n    super(AsyncHTTPTestCase, self).setUp()\n  File \"/home/devstack/Desktop/tornado_learning/learn_testing_in_tornado/simple_momko_app/env/local/lib/python2.7/site-packages/tornado/testing.py\", line 232, in setUp\n    self.io_loop.make_current()\nAttributeError: 'Application' object has no attribute 'make_current'\n\n----------------------------------------------------------------------\nRan 1 test in 0.004s\n\nFAILED (errors=1)", "issue_status": "Closed", "issue_reporting_time": "2016-12-14T09:56:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "405": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1913", "issue_id": "#1913", "issue_summary": "tornado/demos/appengine/ ImportError: No module named tornado.escape", "issue_description": "chrisamow commented on 13 Dec 2016 \u2022\nedited\nafter doing the symbolic link in the README:\n(note: I can go into ipython and do an \"import tornado.escape\" so I'm not sure how the appengine dev_appserver environment changes things...)\n  $ dev_appserver.py .\n\nINFO     2016-12-13 03:58:49,992 devappserver2.py:769] Skipping SDK update check.\nWARNING  2016-12-13 03:58:50,059 simple_search_stub.py:1146] Could not read search indexes from /tmp/appengine.tornado-appengine.chris/search_indexes\nINFO     2016-12-13 03:58:50,062 api_server.py:205] Starting API server at: http://localhost:49168\nINFO     2016-12-13 03:58:50,067 dispatcher.py:197] Starting module \"default\" running at: http://localhost:8080\nINFO     2016-12-13 03:58:50,068 admin_server.py:116] Starting admin server at: http://localhost:8000\nERROR    2016-12-13 03:59:00,381 wsgi.py:263]\nTraceback (most recent call last):\n  File \"/home/chris/cloud/google-cloud-sdk/platform/google_appengine/google/appengine/runtime/wsgi.py\", line 240, in Handle\n    handler = _config_handle.add_wsgi_middleware(self._LoadHandler())\n  File \"/home/chris/cloud/google-cloud-sdk/platform/google_appengine/google/appengine/runtime/wsgi.py\", line 299, in _LoadHandler\n    handler, path, err = LoadObject(self._handler)\n  File \"/home/chris/cloud/google-cloud-sdk/platform/google_appengine/google/appengine/runtime/wsgi.py\", line 85, in LoadObject\n    obj = __import__(path[0])\n  File \"/home/chris/cloud/projects/tornadodemo/blog.py\", line 20, in <module>\n    import tornado.escape\nImportError: No module named tornado.escape\nINFO     2016-12-13 03:59:00,384 module.py:788] default: \"GET / HTTP/1.1\" 500 -", "issue_status": "Closed", "issue_reporting_time": "2016-12-13T04:08:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "406": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1907", "issue_id": "#1907", "issue_summary": "Some bugs when using jupyter notebook with tornado", "issue_description": "QingGo commented on 5 Dec 2016\nI have intall python3, anaconda2 and anaconda3 in my window8.1 system, but i can only open jupyter notebook with anaconda2. when using jupyter notebook with anaconda3 or python3, it will jump out an \"OSError: [WinError 10013 Attempts to access the socket are made in a way that access is not allowed.(translated)\"\nC:\\Windows\\system32>where anaconda\nE:\\Users\\Zeng\\Anaconda2\\Scripts\\anaconda.exe\nE:\\Users\\Zeng\\Anaconda3\\Scripts\\anaconda.exe\n\nC:\\Windows\\system32>where jupyter\nE:\\Users\\Zeng\\Anaconda2\\Scripts\\jupyter.exe\nE:\\Users\\Zeng\\Anaconda3\\Scripts\\jupyter.exe\nC:\\Users\\Zeng\\AppData\\Local\\Programs\\Python\\Python35\\Scripts\\jupyter.exe\n\nC:\\Windows\\system32>E:\\Users\\Zeng\\Anaconda2\\Scripts\\jupyter.exe notebook\n[I 16:37:46.539 NotebookApp] [nb_conda_kernels] enabled, 2 kernels found\n[I 16:37:48.627 NotebookApp] \u9241?nbpresent HTML export ENABLED\n[W 16:37:48.628 NotebookApp] \u9241?nbpresent PDF export DISABLED: No module named n\nbbrowserpdf.exporters.pdf\n[I 16:37:48.644 NotebookApp] [nb_conda] enabled\n[I 16:37:49.030 NotebookApp] [nb_anacondacloud] enabled\n[I 16:37:49.696 NotebookApp] Serving notebooks from local directory: C:\\Windows\\\nsystem32\n[I 16:37:49.697 NotebookApp] 0 active kernels\n[I 16:37:49.697 NotebookApp] The Jupyter Notebook is running at: http://localhos\nt:38888/\n[I 16:37:49.698 NotebookApp] Use Control-C to stop this server and shut down all\n kernels (twice to skip confirmation).\n[I 16:38:19.703 NotebookApp] Interrupted...\n[I 16:38:19.703 NotebookApp] Shutting down kernels\n\nC:\\Windows\\system32>E:\\Users\\Zeng\\Anaconda3\\Scripts\\jupyter.exe notebook\n[I 16:38:34.727 NotebookApp] [nb_conda_kernels] enabled, 2 kernels found\nTraceback (most recent call last):\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\platform\\common.py\", l\nine 44, in __init__\n    self.writer.connect(connect_address)\nOSError: [WinError 10013] \u4ee5\u4e00\u79cd\u8bbf\u95ee\u6743\u9650\u4e0d\u5141\u8bb8\u7684\u65b9\u5f0f\u505a\u4e86\u4e00\u4e2a\u8bbf\u95ee\u5957\u63a5\u5b57\u7684\u5c1d\u8bd5\u3002\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"E:\\Users\\Zeng\\Anaconda3\\Scripts\\jupyter-notebook-script.py\", line 5, in\n<module>\n    sys.exit(notebook.notebookapp.main())\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\jupyter_core\\application.py\",\nline 267, in launch_instance\n    return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\traitlets\\config\\application.p\ny\", line 652, in launch_instance\n    app.initialize(argv)\n  File \"<decorator-gen-7>\", line 2, in initialize\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\traitlets\\config\\application.p\ny\", line 87, in catch_config_error\n    return method(app, *args, **kwargs)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\notebook\\notebookapp.py\", line\n 1071, in initialize\n    self.init_webapp()\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\notebook\\notebookapp.py\", line\n 919, in init_webapp\n    self.http_server.listen(port, self.ip)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\tcpserver.py\", line 12\n7, in listen\n    self.add_sockets(sockets)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\tcpserver.py\", line 13\n9, in add_sockets\n    self.io_loop = IOLoop.current()\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\ioloop.py\", line 213,\nin current\n    return IOLoop.instance()\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\ioloop.py\", line 161,\nin instance\n    IOLoop._instance = IOLoop()\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\util.py\", line 278, in\n __new__\n    instance.initialize(*args, **init_kwargs)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\zmq\\eventloop\\ioloop.py\", line\n 133, in initialize\n    super(ZMQIOLoop, self).initialize(impl=impl, **kwargs)\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\ioloop.py\", line 705,\nin initialize\n    self._waker = Waker()\n  File \"E:\\Users\\Zeng\\Anaconda3\\lib\\site-packages\\tornado\\platform\\common.py\", l\nine 48, in __init__\n    detail[0] != errno.WSAEADDRINUSE):\nTypeError: 'OSError' object is not subscriptable\nI have tried to close the windows firewall but the result is same and have not found the port 8888 being occupied with command \"netstat -na\". Form the traceback I guess maybe there are some bugs in tornado? I have no idea what is wrong.", "issue_status": "Closed", "issue_reporting_time": "2016-12-05T12:10:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "407": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1904", "issue_id": "#1904", "issue_summary": "RuntimeError: list changed size during iteration . Segmentation fault", "issue_description": "LiliumYang commented on 3 Dec 2016\nWhen I was running tornado, at first it works fine. Then I left the program running over night. Then the next morning I got the following error:\nAny thought?\nE 161129 22:48:32 ioloop:629] Exception in callback <functools.partial object at 0x2c22e450>\nTraceback (most recent call last):\n  File \"./appfiles.zip/tornado/ioloop.py\", line 600, in _run_callback\n    ret = callback()\n  File \"./appfiles.zip/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/digi/user/server/dist/deviceServices.py\", line 305, in <lambda>\n    DDP.addCallback(lambda: DeviceConfigManager._asyncGlobalHandlerCallback(configManagerXmlMsg))\n  File \"/home/digi/user/server/dist/deviceServices.py\", line 313, in _asyncGlobalHandlerCallback\n    DeviceConfigManager.asyncGlobalHandlerTimer = DDP.addTimeout(.1, DeviceConfigManager._asyncGlobalHandlerProcessor)\n  File \"/home/digi/user/server/dist/ddp.py\", line 542, in addTimeout\n    return DDP.ioloop.call_later(secDelay, fn, *args)\n  File \"./appfiles.zip/tornado/ioloop.py\", line 515, in call_later\n    return self.call_at(self.time() + delay, callback, *args, **kwargs)\n  File \"./appfiles.zip/tornado/ioloop.py\", line 916, in call_at\n    heapq.heappush(self._timeouts, timeout)\nRuntimeError: list changed size during iteration\n\nSegmentation fault\nException in thread Thread-1:", "issue_status": "Closed", "issue_reporting_time": "2016-12-02T18:39:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "408": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1903", "issue_id": "#1903", "issue_summary": "windows_test.py crashes under Python 2.6: AttributeError: 'module' object has no attribute 'skipIf'", "issue_description": "Contributor\ngward commented on 2 Dec 2016\nwindows_test.py assumes that unittest is from Python 2.7:\n$ python -V\nPython 2.6.6\n\n$ ./runtests.sh \nTraceback (most recent call last):\n  File \"/usr/lib64/python2.6/runpy.py\", line 122, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/lib64/python2.6/runpy.py\", line 34, in _run_code\n    exec code in run_globals\n  File \"/fs/mfs/home1/home/gward/src/tornado/tornado/test/runtests.py\", line 188, in <module>\n    main()\n  File \"/fs/mfs/home1/home/gward/src/tornado/tornado/test/runtests.py\", line 177, in main\n    tornado.testing.main(**kwargs)\n  File \"tornado/testing.py\", line 730, in main\n    unittest.main(defaultTest=\"all\", argv=argv, **kwargs)\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 89, in __init__\n    self.parseArgs(argv)\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 135, in parseArgs\n    self.createTests()\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 142, in createTests\n    self.module)\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 245, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 230, in loadTestsFromName\n    test = obj()\n  File \"/fs/mfs/home1/home/gward/src/tornado/tornado/test/runtests.py\", line 62, in all\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 245, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 172, in loadTestsFromName\n    module = __import__(module_name)\n  File \"tornado/test/windows_test.py\", line 8, in <module>\n    skipIfNonWindows = unittest.skipIf(os.name != 'nt', 'non-windows platform')\nAttributeError: 'module' object has no attribute 'skipIf'", "issue_status": "Closed", "issue_reporting_time": "2016-12-01T23:04:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "409": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1901", "issue_id": "#1901", "issue_summary": "Reading IOStream not registered with IOLoop", "issue_description": "Contributor\npitrou commented on 30 Nov 2016\nI'm getting this weird situation while trying to debug some sporadic hang in one of our tests. An IOStream is busy reading but its fd is not registered with the IOLoop. Consequently, incoming data is not handled.\nThis might be an issue on our side (though it looks unlikely at this point), but I'm posting the debugger session below in case this is a known oddity:\n(Pdb) pp s1\n<tornado.iostream.IOStream object at 0x7f0780708630>\n(Pdb) pp s1.closed()\nFalse\n(Pdb) p s1._read_bytes\n8\n(Pdb) p s1._read_future\n<tornado.concurrent.Future object at 0x7f0780662828>\n(Pdb) pp s1._state\n25\n(Pdb) pp s1._state == s1.io_loop.ERROR | s1.io_loop.READ\nTrue\n(Pdb) pp s1.fileno()\n<socket.socket fd=35, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('127.0.0.1', 35300), raddr=('127.0.0.1', 60520)>\n(Pdb) pp s1.io_loop._running\nTrue\n(Pdb) pp s1.io_loop._closing\nFalse\n(Pdb) pp s1.io_loop._handlers[35]\n*** KeyError: 35\n(Pdb) pp s1.io_loop\n<tornado.platform.epoll.EPollIOLoop object at 0x7f078103f0f0>\n(Pdb) p list(s1.io_loop._handlers)\n[12, 14, 15, 22, 23, 24, 28, 29, 30, 36, 40, 41, 42, 43, 44, 45, 48, 50, 52, 54, 55, 58, 64, 65, 69, 70, 74, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91]\n(Pdb) p s1.io_loop._impl.modify(35, s1._state)\n*** FileNotFoundError: [Errno 2] No such file or directory", "issue_status": "Closed", "issue_reporting_time": "2016-11-30T14:29:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "410": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1900", "issue_id": "#1900", "issue_summary": "twitter_request() garbling url string", "issue_description": "xenophonReal commented on 28 Nov 2016 \u2022\nedited\nThe method seems to append .json to the end of the url and so doesn't allow for extra parameters E.g.\nhttps://api.twitter.com/1.1/account/verify_credentials.json?include_email=true\nNot sure if there's a way around this without making a httpclient request?", "issue_status": "Closed", "issue_reporting_time": "2016-11-28T12:08:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "411": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1897", "issue_id": "#1897", "issue_summary": "Ship LICENSE in pypi tarball", "issue_description": "opoplawski commented on 23 Nov 2016\npypi package does not contain the LICENSE file", "issue_status": "Closed", "issue_reporting_time": "2016-11-22T20:15:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "412": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1896", "issue_id": "#1896", "issue_summary": "`twitter_request` return Error response 'SSLContext' object has no attribute 'get'", "issue_description": "philipskokoh commented on 21 Nov 2016\nI want to get user profile information using twitter_request function, but it returns\nError response 'SSLContext' object has no attribute 'get' fetching https://api.twitter.com/1.1/users/show.json?screen_name=...&oauth_nonce=...&oauth_timestamp=...&oauth_consumer_key=....&oauth_signature_method=HMAC-SHA1&oauth_version=1.0&oauth_token=....&oauth_signature=...&include_entities=False\nHowever, the URL works, if I copy that URL and run curl -XGET https://api.twitter.com/1.1/users/show.json?screen_name=...&oauth_nonce=...&oauth_timestamp=...&oauth_consumer_key=....&oauth_signature_method=HMAC-SHA1&oauth_version=1.0&oauth_token=....&oauth_signature=...&include_entities=False\nIs there any bugs in the twitter_request function?\nbtw, this function worked before (in older version, but I cannot recall which version).", "issue_status": "Closed", "issue_reporting_time": "2016-11-21T03:44:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "413": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1895", "issue_id": "#1895", "issue_summary": "Revert #1893 when coverage.py 4.3 is released", "issue_description": "Member\nbdarnell commented on 20 Nov 2016\n#1893 works around a bug in coverage versions < 4.3; once 4.3 is released (and we require it in our CI configs), we can revert that PR.", "issue_status": "Closed", "issue_reporting_time": "2016-11-20T12:14:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "414": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1894", "issue_id": "#1894", "issue_summary": "Testing example in demos folder", "issue_description": "mehmetkose commented on 17 Nov 2016\n(Python 3.5)\nI can't find anywhere well written testing example and I'm totally confused with\nself.fetch or self.http_client.fetch\n@testing.gen_test or @gen.coroutine\nAsyncHTTPTestCase based self.io_loop\nand more too many things.\nMy GET requests working as I expected but PUT, DELETE etc requests broken and I don't why.\nI think demos folder should be included well described, actual testing example. If I got this point, I can add some test, thats why Im opening new Issue.", "issue_status": "Closed", "issue_reporting_time": "2016-11-17T13:35:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "415": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1892", "issue_id": "#1892", "issue_summary": "How to ignore get/post method and json.loads(self.request.body) can't work in prepare", "issue_description": "631068264 commented on 16 Nov 2016 \u2022\nedited\nI want to collect data from query_arguments or body_arguments and validate them. But I have some doubts about RequestHandler .\nWhen the data is invalid how to ignore get/post/etc method ( finish the request early ) and just return error message ?\nHow to give the valid data as the args to get/post/etc method\nIn the prepare method json.loads(self.request.body) can\u2018t run because the type of self.request.body is bytes not str . And I think this a bug in python3.", "issue_status": "Closed", "issue_reporting_time": "2016-11-16T10:39:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "416": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1891", "issue_id": "#1891", "issue_summary": "Is there a way to delay reading the body?", "issue_description": "mohanson commented on 16 Nov 2016 \u2022\nedited\nI want to achieve a function: received binary data from body, and just skip if data is not an image.\nclass MainHandler(tornado.web.RequestHandler):\n\n    def put(self):\n        if self.request.headers.get('Content-Type') ! = 'image/jpeg':\n            return\n        data = self.request.body\n        # my codes\n        # ...\n        return\nI tested it:\nhttp PUT :8080 < 100M_size.xxx\nThe question is: I realized that when I do if self.request.headers.get('Content-Type') ! = 'image/jpeg':, the body has been completely read into memory, which creates a huge amount of memory and time wasted.", "issue_status": "Closed", "issue_reporting_time": "2016-11-16T08:18:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "417": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1887", "issue_id": "#1887", "issue_summary": "Add a way to typecheck coroutine functions", "issue_description": "Contributor\npitrou commented on 14 Nov 2016\nCurrently, a gen.coroutine wrapped function looks like just a regular nested function. Perhaps there should be a way to determine it's a Tornado coroutine.", "issue_status": "Closed", "issue_reporting_time": "2016-11-14T09:14:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "418": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1885", "issue_id": "#1885", "issue_summary": "tornado.web.RequestHandler does not support cooperative inheritance", "issue_description": "nagylzs commented on 12 Nov 2016\nLet's suppose I want to add a custom parameter to a websockethandler like this:\nclass WebSocket(tornado.websocket.WebSocketHandler):\n    def initialize(self, appserver, **kwargs):\n        self.appserver = appserver\n        super().initialize(**kwargs)\nThe handler is added to the server with this handler argument:\n        (r\"/websocket\", WebSocket, dict(appserver=self.appserver))\nThe problem is that super().initialize(**kwargs) call fails because tornado.web.RequestHandler.initialize does not have keyword arguments (formally). Although its documentations says specifically that \"A dictionary passed as the third argument of a url spec will be supplied as keyword arguments to initialize().\"\nSummary: cannot use multiple inheritance with RequestHandler.initialize()\nSuggested fix: add *args and **kwargs to RequestHandler.initialize()", "issue_status": "Closed", "issue_reporting_time": "2016-11-12T11:57:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "419": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1884", "issue_id": "#1884", "issue_summary": "concurrent threadpoolexecutor", "issue_description": "GeorgeXia1828 commented on 11 Nov 2016 \u2022\nedited by ajdavis\nI am new to tornado, I am trying to use the threadpoolexecutor, found the example code running error\nIn [2]: import tornado\n\nIn [3]: from tornado import concurrent\n\nIn [4]: concurrent.futures.ThreadPoolExecutor\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-4-13ee7079db29> in <module>()\n----> 1 concurrent.futures.ThreadPoolExecutor\n\nAttributeError: 'NoneType' object has no attribute 'ThreadPoolExecutor'\ncan anyone explain it? I am using python 2.7", "issue_status": "Closed", "issue_reporting_time": "2016-11-11T03:31:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "420": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1883", "issue_id": "#1883", "issue_summary": "Problem with transform tornado Future into Asyncio Future", "issue_description": "bucketzxm commented on 10 Nov 2016\nI have a function like this:\n@asyncio.coroutine\ndef fetchDatabase():\n    ans = self._httpClient.fetch(request, callback, raise_error)\n    ans = yield from asyncio.ensure_future( platform.asyncio.to_asyncio_future(ans))\n    return ans\nI call this function by using:\nresponse = yield from fetchDatabase()\nIn tornado 4.1 , this can work properly and I got the http response, but in tornado 4.4 I got an error which complain about\nFile \"/opt/lib/python3.5/asyncio/futures.py\", line 362, in __iter__\n    assert self.done(), \"yield from wasn't used with future\"\nAssertionError: yield from wasn't used with future\nI am not sure what is the correct way when I want to use asyncio library to yield from tornado Future...", "issue_status": "Closed", "issue_reporting_time": "2016-11-10T06:14:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "421": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1882", "issue_id": "#1882", "issue_summary": "StreamClosedError", "issue_description": "btdlin commented on 5 Nov 2016\nHi, seeing this stream closed error in a non-blocking call. I think the data has been sent back, but for some reason stream is not closed and then caused timeout. Any idea? Thanks in advance.\nTraceback (most recent call last):\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/tornado.py\", line 103, in io_exception_context\n    yield\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/tornado.py\", line 145, in flush\n    return self.stream.write(frame_length + frame)\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/tornado/iostream.py\", line 377, in write\n    self._check_closed()\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/tornado/iostream.py\", line 885, in _check_closed\n    raise StreamClosedError(real_error=self.error)\ntornado.iostream.StreamClosedError: Stream is closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/tornado.py\", line 191, in handle_stream\n    self._processor.send_result(oprot, api, result, seqid)\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/thrift.py\", line 280, in send_result\n    oprot.trans.flush()\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/tornado.py\", line 145, in flush\n    return self.stream.write(frame_length + frame)\n  File \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/contextlib.py\", line 77, in __exit__\n    self.gen.throw(type, value, traceback)\n  File \"/Users/dlin/virtualenvs/realtime-recs-1/lib/python3.5/site-packages/thriftpy/tornado.py\", line 107, in io_exception_context\n    message=str(e))\nthriftpy.transport.TTransportException: TTransportException(type=4, message='Stream is closed')\n2016-11-04 21:49:20 INFO     thriftpy.tornado: client disconnected 127.0.0.1:55021```", "issue_status": "Closed", "issue_reporting_time": "2016-11-05T05:17:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "422": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1879", "issue_id": "#1879", "issue_summary": "Will tornado support protobuffer?", "issue_description": "leafjungle commented on 4 Nov 2016 \u2022\nedited\nThe size of protobuffer message is much smaller than that of json (About 1:5 ). Transfer pb data will be faster.\nI mean, tornado client will automatically convert json into pb, and server will automatically convert pb into json.", "issue_status": "Closed", "issue_reporting_time": "2016-11-04T02:36:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "423": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1877", "issue_id": "#1877", "issue_summary": "get_body_argument with Content-Type: application/json", "issue_description": "IchordeDionysos commented on 3 Nov 2016\nI wondered why a call to self.get_body_argument(\"key\") in the RequestHandler class returns None.\nSo I looked how this was solved internally in Tornado and I found this:\nA call to get_body_argument uses the self.request.body_arguments dictionary.\nThis is constructed in the function _parse_body of httputil.HTTPServerRequest class\nThe _parse_body function calls the httputil.parse_body_arguments function and there you can see, that the body is only parsed if the content_type.startswith(\"application/x-www-form-urlencoded\") or content_type.startswith(\"multipart/form-data\")\nHere I would suggest adding something like this:\nelif content_type.startswith(\"application/json\"):\n        try:\n            uri_arguments = json.load(body)\n        except Exception as e:\n            gen_log.warning('Invalid json body: %s', e)\n            uri_arguments = {}\n        for name, values in uri_arguments.items():\n            if values:\n                arguments.setdefault(name, []).extend(values)", "issue_status": "Closed", "issue_reporting_time": "2016-11-03T16:33:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "424": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1874", "issue_id": "#1874", "issue_summary": "add_callback() isn't safe against reentrancy", "issue_description": "Contributor\npitrou commented on 2 Nov 2016\nadd_callback() can occasionally being called in a reentrant way, if a destructor triggers some non-trivial resource cleanup code.\nYou can find an occurrence here:\nleporo/tornado-redis#59\nand another here:\ndask/distributed#599 (comment)\nIt seems a possible fix would be to temporarily disable the gc before taking the callback lock.", "issue_status": "Closed", "issue_reporting_time": "2016-11-02T17:14:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "425": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1872", "issue_id": "#1872", "issue_summary": "Possible memory leak", "issue_description": "ezdev128 commented on 31 Oct 2016 \u2022\nedited\nHi,\nI have memory leaks even in \"hello, world\" example listed here http://www.tornadoweb.org/en/stable/\nCode of tornado_memory_test.py: http://pastebin.com/BfG7Na9Z\nHere is an example of a problem:\n$ python tornado_memory_test.py\nNo memory leaks found!\nNo memory leaks found!\n[I 161031 18:00:54 web:1946] 200 GET /test (127.0.0.1) 0.87ms\nMemory garbage detected\n[gc stat]: 73 objects in garbage\nMemory garbage detected\n[gc stat]: 73 objects in garbage\nMemory garbage detected\n[gc stat]: 73 objects in garbage\n[I 161031 18:01:11 web:1946] 200 GET /test (127.0.0.1) 0.73ms\nMemory garbage detected\n[gc stat]: 146 objects in garbage\nHere is a verbose output of garbage: http://pastebin.com/BzXudRXd\n$ pip freeze | grep -i tor\ntornado==4.4.2\n$ python -V\nPython 2.7.12\nAlso tried on:\n$ pip freeze | grep tor\ntornado==4.5.dev1\n$ python -V\nPython 2.7.12", "issue_status": "Closed", "issue_reporting_time": "2016-10-31T15:10:41Z", "fixed_by": "#1936", "pull_request_summary": "Break circular reference to exc_info when exception is thrown", "pull_request_description": "Contributor\nhomm commented on 27 Jan 2017\nThis fixes #1872\nI also updated tested script, it is much easier to find circular references:\nhttps://gist.github.com/homm/c20a7dc74f78d393f6ffac537532fd93\nWithout fix:\n$ ab -c 100 -n 10000 http://localhost:8888/dummy/\nRequests per second:    1265.13 [#/sec] (mean)\nPercentage of the requests served within a certain time (ms)\n  50%     80\n  66%     81\n  75%     82\n  80%     83\n  90%     88\n  95%    102\n  98%    106\n  99%    111\n 100%    197 (longest request)\n\n$ time curl http://localhost:8888/collect/\nCollected: 690000\nreal 0m0.477s\nWith fix:\n$ ab -c 100 -n 10000 http://localhost:8888/dummy/\nRequests per second:    1346.77 [#/sec] (mean)\nPercentage of the requests served within a certain time (ms)\n  50%     76\n  66%     77\n  75%     78\n  80%     79\n  90%     82\n  95%     88\n  98%     91\n  99%     92\n 100%     94 (longest request)\n\n$ time curl http://localhost:8888/collect/\nCollected: 0\nreal 0m0.020s\n3", "pull_request_status": "Merged", "issue_fixed_time": "2017-03-26T18:03:51Z", "files_changed": [["5", "tornado/concurrent.py"], ["17", "tornado/gen.py"], ["1", "tornado/http1connection.py"], ["25", "tornado/test/gen_test.py"], ["6", "tornado/util.py"]]}, "426": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1871", "issue_id": "#1871", "issue_summary": "get_body_arguments doesn't seem to work", "issue_description": "Slater-Victoroff commented on 31 Oct 2016\nI'm sure I'm missing something here since it seems like such a basic issue, but here's what I'm running into. In short, the body of a request is coming across just fine, but for some reason RequestHandler's built-in get_arguments seems to be non-functional. Code is below:\nclass CreateUserHandler(tornado.web.RequestHandler):\n    def post(self):\n        print self.request.headers.get(\"Content-Type\")\n        print self.request.body\n        print self.request.body_arguments\n        print self.get_body_argument(\"email\")\nThis then prints the following:\napplication/json;charset=UTF-8\n{\"email\":\"slater@indico.io\",\"password\":\"password\"}\n{}\nWARNING:tornado.general:400 POST /user/create/ (::1): Missing argument email\nWARNING:tornado.access:400 POST /user/create/ (::1) 1.66ms\nHow is it possible that the body comes along fine, but body_arguments can't be found? I added the Content-Type header since I see that's relied on pretty heavily when processing body args, but I wasn't able to find the spot in the codebase where this might be happening.\nSO question here: http://stackoverflow.com/questions/40333280/tornado-has-correct-request-body-but-cannot-find-correct-arguments", "issue_status": "Closed", "issue_reporting_time": "2016-10-30T20:36:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "427": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1870", "issue_id": "#1870", "issue_summary": "About the environment", "issue_description": "leafjungle commented on 30 Oct 2016\nI find in the official docs that: I have to \"python setup.py build; sudo python setup.py install\" to install the tornado env. I think that is not friendly enough, and that is troubesome to deploy the tornado to the server clusters(decaeds of machines and they are not allowed to connect to the outer network).\nIs there a way to setup the tornado by just copying the directory, (and editing the user profile)?", "issue_status": "Closed", "issue_reporting_time": "2016-10-30T07:15:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "428": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1869", "issue_id": "#1869", "issue_summary": "SSL Socket Error on Write", "issue_description": "bennettaur commented on 28 Oct 2016\nI commented on #438 but since it's closed I'm not sure it's getting visibility. I also think some of the issues related to the original issue have been fixed, but this might be an edge case.\nThe issue is that occasionally when writing to an SSL socket (using an SSLIOStream) I hit this error:\nWrite error on <ssl.SSLSocket object at 0x00007ff88c0462f8>: [Errno 14] Bad address\nBased on some research it may potentially be related to a buffer being moved when writing to the SSL socket. Tornado handles it by closing the down the stream and reporting an error but based on some digging, I don't think the connection is dead, just that the write should be attempted again.\nI'm running into this issue quite a bit. We use tornado on pypy but have seen the error on both pypy and python. I believe pypy triggers it more because it has a tendency to move objects around in memory more.\nBased on my digging, these all appear to be related:\nhttp://stackoverflow.com/questions/9260937/unix-socket-error-14-efault-bad-address\nhttp://bugs.python.org/issue8240\nhttps://bitbucket.org/pypy/pypy/issues/1238/bad-write-retry-from-ssl-sockets\n(I realize that @bdarnell opened and fixed the PyPy issue)\nand it's documented in the tornado code itself:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/iostream.py/#L839\nHowever I don't think tornado handles the error appropriately here:\nhttps://github.com/tornadoweb/tornado/blob/master/tornado/iostream.py/#L857\nThe think the right approach for the error should be catching it and then setting write_buffer_frozen =True, like it does for other cases and the write retried. I'll likely be experimenting with a fix soon, but reproducing can be somewhat random.\nDigging into it some more, this appears to be a bug in OpenSSL 1.0.2 on Mac OSX. This ruby thread appears to be related: excon/excon#467\nThey're solution was to simply warn about the issue and downgrade OpenSSL to 1.0.1\nI can confirm I still see this issue in \"OpenSSL 1.0.1f 6 Jan 2014\" running with \"PyPy 5.3.1 with GCC 4.8.2\" using the PyPy Docker image pypy:2\nAs well as 'OpenSSL 1.0.2j 26 Sep 2016' on Mac OS X Version 10.11.6 (15G1004)", "issue_status": "Closed", "issue_reporting_time": "2016-10-28T16:05:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "429": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1866", "issue_id": "#1866", "issue_summary": "tornado logging prints the same line multiple times", "issue_description": "zguangyu commented on 26 Oct 2016\nI'm trying to call options.parse_config_file() and then options.parse_command_line(). I define log_to_stderr=True in the config file. Both of these functions will call the enable_pretty_logging function so that they will add two handlers into the logger. I think that's a bug even though I can configure the logger manually. It should check if there is another StreamHandler in the logger.handlers list before it adds a new one.\nIf I don't define the log_to_stderr=True, parse_config_file will create a file handler and parse_command_line will not create a stream handler since the logger.handlers is not empty. I don't want to call parse_command_line before parse_config_file because I want to override the config file in command line.", "issue_status": "Closed", "issue_reporting_time": "2016-10-26T13:25:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "430": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1865", "issue_id": "#1865", "issue_summary": "Clarify affected versions re: 4.4.2 security fix", "issue_description": "dol-sen commented on 23 Oct 2016\nThe release notes are not clear which versions are vulnerable for the cookie parser security fix.\nquote: (older versions of Tornado would reject the entire header for a single invalid cookie)\nDoes that infer that only previous 4.4 releases were vulnerable? What about 4.2 and 4.3 releases, are any of those vulnerable? older...?\nAs a package maintainer, but not a tornado coder, I need to know the extent of the vulnerability. If I need to fastrack stabilization of the 4.4.2 release and remove which older versions, etc...\nhttps://bugs.gentoo.org/show_bug.cgi?id=597740\nThank you.\nBrian", "issue_status": "Closed", "issue_reporting_time": "2016-10-23T17:15:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "431": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1861", "issue_id": "#1861", "issue_summary": "RedirectHandler re substitution doesn't work", "issue_description": "sljeff commented on 15 Oct 2016\nCode\nimport tornado.web\nfrom tornado.web import url\nimport tornado.ioloop\n\napp = tornado.web.Application([\n    url(r\"/pictures/(.*)\", tornado.web.RedirectHandler,\n        dict(url=r\"/photos/\\1\")),\n])\n\napp.listen(8765)\ntornado.ioloop.IOLoop.current().start()\nvisit localhost:8765/picture/1 will raise TypeError: get() takes 1 positional argument but 2 were given\nERROR:tornado.application:Uncaught exception GET /pictures/1 (::1)\nHTTPServerRequest(protocol='http', host='localhost:8765', method='GET', uri='/pictures/1', version='HTTP/1.1', remote_ip='::1', headers={'Host': 'localhost:8765', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Dnt': '1', 'Upgrade-Insecure-Requests': '1', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.59 Safari/537.36', 'Cookie': 'Pycharm-73b7632f=f7202b97-d898-4046-8aae-ae6536d1d931; _xsrf=2|ca7ba18c|041b228c03a99e0221d548c50c478a96|1476528491', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Accept-Encoding': 'gzip, deflate, sdch, br'})\nTraceback (most recent call last):\n  File \"C:\\Users\\Jeff\\AppData\\Local\\Programs\\Python\\Python35-32\\lib\\site-packages\\tornado\\web.py\", line 1467, in _execute\n    result = method(*self.path_args, **self.path_kwargs)\nTypeError: get() takes 1 positional argument but 2 were given\nERROR:tornado.access:500 GET /pictures/1 (::1) 1532.03ms", "issue_status": "Closed", "issue_reporting_time": "2016-10-15T11:18:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "432": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1860", "issue_id": "#1860", "issue_summary": "bind_sockets sporadically fails with EADDRINUSE", "issue_description": "rgbyrnes commented on 13 Oct 2016\ntornado.netutil.bind_sockets attempts to use the same port on IPv4 and IPv6 if port=None.\nIt does this by first letting the kernel assign a port for one protocol, and then explicitly requesting the same port for the other protocol. However, I think the port space for IPv4 and IPv6 is independent, so there is no reason to assume that the same port is necessarily available for the other protocol. The second bind can (and occasionally does) fail with EADDRINUSE.\nWhat's the rationale for using the same port?\nThe behavior was added in this commit: 151eef7", "issue_status": "Closed", "issue_reporting_time": "2016-10-12T21:06:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "433": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1859", "issue_id": "#1859", "issue_summary": "add_timeout optimization", "issue_description": "mayflaver commented on 7 Oct 2016\nTo call add_timeout function, you need to call time.time sys function, that's heavy, when has a lot of time-based events, It is a heavy burden for cpu.\nhttps://github.com/mayflaver/tornado/blob/master/tornado/ioloop.py#L759 I think we can store the timestamp in every ioloop, when call add_timeout, we can use it.", "issue_status": "Closed", "issue_reporting_time": "2016-10-07T06:58:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "434": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1854", "issue_id": "#1854", "issue_summary": "dictionary is empty exception when poping ioloop event.", "issue_description": "why2pac commented on 1 Oct 2016\nI got below exception intermittently.\nTraceback (most recent call last):\n  File \"/test/__init__.py\", line 23, in <Module>\n    bootstrap.run(**kwargs)\n  File \"/test/venv/python2.7/site-packages/dp-tornado/__init__.py\", line 136, in run\n    instance.start()\n  File \"/test/venv/python2.7/site-packages/tornado/ioloop.py\", line 880, in start\n    fd, events = self._events.popitem()\nKeyError: 'popitem(): dictionary is empty'\nsuggest what if code fixes like this.\nOriginal Code\n                while self._events:\n                    fd, events = self._events.popitem()\n                    try:\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            # Happens when the client closes the connection\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        self.handle_callback_exception(self._handlers.get(fd))\nSuggest Code\n                while self._events:\n                    fd, events = None, None\n                    try:\n                        fd, events = self._events.popitem()\n                        fd_obj, handler_func = self._handlers[fd]\n                        handler_func(fd_obj, events)\n                    except (OSError, IOError) as e:\n                        if errno_from_exception(e) == errno.EPIPE:\n                            # Happens when the client closes the connection\n                            pass\n                        else:\n                            self.handle_callback_exception(self._handlers.get(fd))\n                    except Exception:\n                        if fd:\n                            self.handle_callback_exception(self._handlers.get(fd))", "issue_status": "Closed", "issue_reporting_time": "2016-10-01T02:28:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "435": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1853", "issue_id": "#1853", "issue_summary": "Need for a little clarification of the templating documentation", "issue_description": "protheine commented on 1 Oct 2016 \u2022\nedited\nInside https://github.com/tornadoweb/tornado/blob/stable/docs/guide/templates.rst, after the line\n\"If you saved this template as \"template.html\" and put it in the same directory as your Python file, you could render this template with:\"\nThere should be a little note to explain that the variable are not handled in a classic way when using\nrender\nUsually you intend to do variablename = othervariablename , in other words, othervariablename value goes inside variablename\nWhen you use render of tornado.web, the operation is reversed\nothervariablename = variablename, in otherwords, variablename push his value to othervariablename and only after that you can use othervariablename in your html file.\nGive the two variable the same name does not allow to understand this particular mechanism when you learn tornado until a painful learning from failure process", "issue_status": "Closed", "issue_reporting_time": "2016-09-30T20:58:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "436": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1851", "issue_id": "#1851", "issue_summary": "csrf token bypass via Google Analytics", "issue_description": "mywaiting commented on 29 Sep 2016\nref: https://hackerone.com/reports/26647\nTornado maybe, but I am too busy to make a test.\nSo create an issue to tell all", "issue_status": "Closed", "issue_reporting_time": "2016-09-29T17:03:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "437": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1850", "issue_id": "#1850", "issue_summary": "torando: ssl.SSLError: [SSL] PEM lib", "issue_description": "ghost commented on 29 Sep 2016 \u2022\nedited by ghost\nWhen the tornado project run.\nTraceback (most recent call last):\nFile \"C:\\Users\\Administrator\\Desktop\\USB\\data\\vhost\\bluedon\\project\\proxy_pyt\non\\src\\main.py\", line 29, in\nssl_ctx.load_cert_chain(crt_path, key_path)\nssl.SSLError: [SSL] PEM lib (_ssl.c:2580)\n# python_version: python2.7.10\n\n    app = Application()\n\n    ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    crt_path = os.path.join(globals.PROJECT_ABS_PATH, 'server.crt')\n    key_path = os.path.join(globals.PROJECT_ABS_PATH, 'server.key')\n    ssl_ctx.load_cert_chain(crt_path, key_path)\n\n    server =tornado.httpserver.HTTPServer(app, ssl_options=ssl_ctx)\n\n    server.listen(443)\n    tornado.ioloop.IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2016-09-29T08:06:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "438": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1848", "issue_id": "#1848", "issue_summary": "[ Address already in use] tornado can not start in Windows 10 linux subsystem (WSL), can anybody help?", "issue_description": "zhwei820 commented on 27 Sep 2016\nI got the error messages when I try to start helloworld demo.\nTraceback (most recent call last):\nFile \"helloworld.py\", line 43, in\nmain()\nFile \"helloworld.py\", line 38, in main\nhttp_server.listen(options.port)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/tcpserver.py\", line 126, in listen\nsockets = bind_sockets(port, address=address)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/netutil.py\", line 194, in bind_sockets\nsock.bind(sockaddr)\nFile \"/usr/lib/python2.7/socket.py\", line 224, in meth\nreturn getattr(self._sock,name)(*args)\nsocket.error: [Errno 98] Address already in use", "issue_status": "Closed", "issue_reporting_time": "2016-09-27T09:43:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "439": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1847", "issue_id": "#1847", "issue_summary": "Tornado PyPi package appears broken", "issue_description": "cachedout commented on 26 Sep 2016\nIt appears that it's no longer install-able as of this morning because it can't find the certifi package. This is likely due to a change in certifi, which was updated this morning as well. Possibly a naming change in that package?\nhttps://pypi.python.org/pypi/certifi\nI have contacted the maintainer of certifi as well but have not (yet) received a response.", "issue_status": "Closed", "issue_reporting_time": "2016-09-26T14:09:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "440": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1846", "issue_id": "#1846", "issue_summary": "Websocket file descriptor", "issue_description": "michaelimfeld commented on 26 Sep 2016\nHi\nIs it possible to do the websocket message receiving & parsing on my own?\nExample:\nclass WebSocket(websocket.WebSocketHandler):\n    def open(self):\n        ws_fd =  self.connection_fd()\n        while True:\n            readable, _, _ = select.select([ws_fd], [], [], 1.0)\n            for fd in readable:\n                data = self.recv_nb()\nThe reason why I want to do this:\nI need to forward all messages coming from the websocket client over a unix socket to a single threaded backend, therefore I need the websocket file descriptor to do a select over both the websocket fd and the unix socket fd.\nIs it possible to directly access the websocket file descriptor? Is there any other way of doing this?", "issue_status": "Closed", "issue_reporting_time": "2016-09-26T12:19:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "441": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1845", "issue_id": "#1845", "issue_summary": "RuntimeWarning: coroutine was never awaited", "issue_description": "quxiaowei commented on 25 Sep 2016\nI'm pretty new to tornado, I tried to write a simple socket server with tornado.\n@gen.coroutine worked well for me, then i tried native coroutine.\nit report error:\nTraceback (most recent call last):\n  File \"socket_server-tornado.py\", line 43, in <module>\n    ioloop.add_future(run(), empty)\n  File \"/usr/local/lib/python3.5/site-packages/tornado/ioloop.py\", line 593, in add_future\n    assert is_future(future)\nAssertionError\nsys:1: RuntimeWarning: coroutine 'run' was never awaited\ndoesn't add_future accept native coroutine? if not, how should i add coroutine into the loop.\nfrom tornado import gen\nfrom tornado import concurrent\nfrom tornado.ioloop import IOLoop\nfrom concurrent.futures import ThreadPoolExecutor\nimport socket\n\n_addr_ = ('', 50007)\n\nexecutor = ThreadPoolExecutor(10)\n\ndef empty():pass\n\nasync def run():\n    while True:\n        print(\"waiting for connecting\")\n        conn, addr = await concurrent.run_on_executor(s.accept, executor=executor)\n        print('connected', addr)\n        IOLoop.current().add_future(echo(conn), empty)\n\nasync def echo(conn):\n    with conn:\n        while True:\n            print(\"waiting for input:\")\n            data = await concurrent.run_on_executor(conn.recv, 1024, executor=executor)\n            print(\"recieved:\", data)\n            data = b'echo:'+data\n            await gen.Task(executor.submit, conn.send, data)\n\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n\n    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    s.bind(_addr_)\n    s.listen(1)\n\n    ioloop = IOLoop.current()\n    ioloop.add_future(run(), empty)\n    ioloop.start()", "issue_status": "Closed", "issue_reporting_time": "2016-09-25T16:43:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "442": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1841", "issue_id": "#1841", "issue_summary": "Support of PyFilesystem in StaticFileHandler", "issue_description": "JuniorJPDJ commented on 23 Sep 2016\nSupport of PyFilesystem will give us ability to use serve files from other filesystems.\nEg. from zip file, webdav, FTP, SMB or even DropBox.", "issue_status": "Closed", "issue_reporting_time": "2016-09-23T00:27:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "443": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1840", "issue_id": "#1840", "issue_summary": "X-Forwarded-For handling appears incorrect", "issue_description": "Contributor\nleynos commented on 22 Sep 2016 \u2022\nedited\nThe handling of the X-Forwarded-For header appears to be incorrect.\nSquid and Nginx append each new step in the chain to the end of the list. See the Wikipedia article, which cites the Squid documentation here (\"header values are iterated in reverse order\"). The format given on Wikipedia is:\nX-Forwarded-For: client, proxy1, proxy2\nThis is consistent with my experience of Nginx, which has passed the client IP as the first address in the chain.\nThe behaviour in question (line 229 of httpserver.py):\nip = ip.split(',')[-1].strip()\nA more correct implementation would be ip = ip.split(',')[0].strip()\nFurthermore, the value in question may contain a port number. This is handled by Nginx, for example (see here). Tornado strictly rejects this value if it not an ip address. It may be worth stripping off any port suffix, by, e.g.:\nif (ip.startswith('[') and not ip.endswith(']')) or ('.' in ip and ':' in ip):\n    ip = ip.rsplit(':', 1)[0]\nThe first clause of the \"if\" condition checks for IPv6 addresses with a port stated, and the second checks for IPv4 addresses with a port. An alternative might be to use urlparse.\nI believe this would provide a more useful implementation of the X-Forwarded-For handler where multiple proxies are chained.", "issue_status": "Closed", "issue_reporting_time": "2016-09-22T14:58:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "444": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1839", "issue_id": "#1839", "issue_summary": "tornado webspider (from demos) don't work correctly with sites with shadow-root tag.", "issue_description": "MkrV commented on 22 Sep 2016\ntornado webspider:\nhttps://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py https://raw.githubusercontent.com/tornadoweb/tornado/stable/demos/webspider/webspider.py\nHow to adapt this web spider\nto search the pages\non sites that contain shadow-root tag ?\nsites:\nhttp://www.cpasparks.com/\nhttp://www.highrockaccounting.com/\nhttp://www.steelecpas.com/\nhttp://www.superiorlinenlv.com/\nIt works good with almost all the sites except them.\nDo you know a better solution?", "issue_status": "Closed", "issue_reporting_time": "2016-09-21T22:58:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "445": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1837", "issue_id": "#1837", "issue_summary": "How can I make streaming_callback a coroutine?", "issue_description": "eliric commented on 21 Sep 2016\nHow can I write yield statement inside streaming_callback?", "issue_status": "Closed", "issue_reporting_time": "2016-09-21T05:40:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "446": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1835", "issue_id": "#1835", "issue_summary": "How to get detail of internal error 500?", "issue_description": "jie commented on 20 Sep 2016\nOne of my api raise this exception:\ntornado.httpclient.HTTPError: HTTP 500: Internal Server Error\nFile \"/usr/local/lib/python2.7/site-packages/tornado/httpclient.py\", line 102, in fetch (<class 'tornado.httpclient.HTTPError'>, HTTP 500: Internal Server Error, None) self._async_client.fetch, request, **kwargs)) File \"/usr/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 457, in run_sync return future_cell[0].result() File \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 239, in result raise_exc_info(self._exc_info) File \"<string>\", line 3, in raise_exc_info tornado.httpclient.HTTPError: HTTP 500: Internal Server Error\nbut using other http client works fine(such as requests).", "issue_status": "Closed", "issue_reporting_time": "2016-09-20T01:52:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "447": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1833", "issue_id": "#1833", "issue_summary": "HTTPRequest has default request_timeout", "issue_description": "serhatbolsu commented on 18 Sep 2016\nHi\nWhile developing a reserver proxy, I have realised that http requests times out while they should stay indefinitely.\nit seems like default request_timeout=20 .\nThis is better to be without internal default value or documentation should mention there is a default value", "issue_status": "Closed", "issue_reporting_time": "2016-09-18T10:11:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "448": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1831", "issue_id": "#1831", "issue_summary": "website error domain registration expired on 09/08/2016.", "issue_description": "23233 commented on 14 Sep 2016\nI am also the official website, I depend on API,\nYou can get a set up on github?", "issue_status": "Closed", "issue_reporting_time": "2016-09-14T06:42:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "449": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1830", "issue_id": "#1830", "issue_summary": "tornado offical web site domain has expired on 09/08/2016.", "issue_description": "Wall-ee commented on 14 Sep 2016 \u2022\nedited\nthe offical web site cannot be reached~~\nit says:\nThis domain registration expired on 09/08/2016.\nhttp://www.tornadoweb.org/", "issue_status": "Closed", "issue_reporting_time": "2016-09-14T03:35:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "450": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1829", "issue_id": "#1829", "issue_summary": "The domain name tornadoweb.org seem to be expired", "issue_description": "floostmodern commented on 13 Sep 2016\nAfternoon,\nI believe the domain name tornadoweb.org is expired. Here is what I get when I visit it\nCheers,\nFlorent\n12\n5", "issue_status": "Closed", "issue_reporting_time": "2016-09-13T16:06:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "451": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1828", "issue_id": "#1828", "issue_summary": "Possible memory leak", "issue_description": "bindlock commented on 13 Sep 2016 \u2022\nedited\nHello. I have a problem with web-crawler written on Tornado. It's simple version.\nUbuntu 14.04 (16.04)\nPython 3.5.2\nTornado 4.4.1\nTest links: https://gist.github.com/pyvim/ba9abc4ff0615a345b1c71e9d23735ea\nCode\n#!/usr/bin/env python\n# coding=utf-8\n\nimport time\n\nimport tornado.gen\nimport tornado.web\nimport tornado.ioloop\nfrom tornado.queues import Queue\nimport tornado.httpclient\n\n\nasync def main():\n    start = time.time()\n    q = Queue()\n    client = tornado.httpclient.AsyncHTTPClient()\n    results = {'results': []}\n\n    @tornado.gen.coroutine\n    def worker():\n        while True:\n            yield consumer()\n\n    async def consumer():\n        async for url in q:\n            try:\n                response = await client.fetch(url, raise_error=False)\n\n                if response.body:\n                    results['results'].append(response.body.decode('utf-8'))\n            finally:\n                q.task_done()\n\n\n    async def producer():\n        with open('urls') as f:\n            for link in f:\n                await q.put(link.strip())\n\n    for __ in range(10):\n        worker()\n\n    await producer()\n    await q.join()\n\n    print('Done in {} seconds'.format(time.time() - start))\n\n    del results  # Release memory (without memory up on 20MB per request)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    async def get(self):\n        await main()\n\n\nif __name__ == '__main__':\n    app = tornado.web.Application(\n        (tornado.web.url(r'/', MainHandler),), debug=True\n    )\n    app.listen(8000)\n\n    tornado.ioloop.IOLoop.current().start()\nTop statistics\nBefore first call:\nFirst call:\nSecond call:", "issue_status": "Closed", "issue_reporting_time": "2016-09-13T06:50:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "452": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1827", "issue_id": "#1827", "issue_summary": "How to write the code for http request and response?", "issue_description": "fw0037 commented on 13 Sep 2016\nHow to write the code for http request and response ? I did not find the relevant code in the demo tornado inside , who can give a sample for me? thanks.", "issue_status": "Closed", "issue_reporting_time": "2016-09-13T01:02:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "453": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1824", "issue_id": "#1824", "issue_summary": "Should the Blog example use bcrypt's checkpw instead of ==", "issue_description": "joshsziegler commented on 8 Sep 2016\nbcrypt 3.1.0 added checkpw which (I believe) is the recommended way to compare passwords to the hashed password now.\ncheckpw code here\ntornado's blog example using == here\nThe current example looks like this:\n    @gen.coroutine\n    def post(self):\n        # [...]\n        hashed_password = yield executor.submit(\n            bcrypt.hashpw, \n            tornado.escape.utf8(self.get_argument(\"password\")),\n            tornado.escape.utf8(author.hashed_password))\n        if hashed_password == author.hashed_password:\n            self.set_secure_cookie(\"blogdemo_user\", str(author.id))\n            self.redirect(self.get_argument(\"next\", \"/\"))\n        else:\n            self.render(\"login.html\", error=\"incorrect password\")\nBut maybe it should look like this?\n    @gen.coroutine\n    def post(self):\n        # [...]\n        password_equal = yield executor.submit(\n            bcrypt.checkpw, \n            tornado.escape.utf8(self.get_argument(\"password\")),\n            tornado.escape.utf8(author.hashed_password))\n        if password_equal:\n            self.set_secure_cookie(\"blogdemo_user\", str(author.id))\n            self.redirect(self.get_argument(\"next\", \"/\"))\n        else:\n            self.render(\"login.html\", error=\"incorrect password\")\n2", "issue_status": "Closed", "issue_reporting_time": "2016-09-08T14:30:12Z", "fixed_by": "#2783", "pull_request_summary": "Use bcrypt's checkpw instead of == in demo blog app", "pull_request_description": "Contributor\nkinow commented on 29 Nov 2019\nCloses #1824\nI think it was missing only a PR to apply @joshsziegler 's suggestion?\nCheers\nBruno", "pull_request_status": "Merged", "issue_fixed_time": "2019-12-08T21:01:27Z", "files_changed": [["7", "demos/blog/blog.py"]]}, "454": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1814", "issue_id": "#1814", "issue_summary": "CurlAsyncHTTPClient Proxy questions", "issue_description": "HatBoy commented on 26 Aug 2016\nI can use HTTP proxy in requests, But I can not use the same HTTP proxy in tornado.this is my code:\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\") request = HTTPRequest(url=url, proxy_host='XXX.XXX.XXX.XXX', proxy_port=8080) client = AsyncHTTPClient() response = yield client.fetch(request)\nWhy I can not use proxy in tornado?", "issue_status": "Closed", "issue_reporting_time": "2016-08-26T04:54:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "455": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1813", "issue_id": "#1813", "issue_summary": "use async/await instead gen.coroutine on python3.5 problem", "issue_description": "thisisx7 commented on 26 Aug 2016\nI want to use async/await in python3.5 instead gen.coroutine\nthe code works well\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nfrom datetime import timedelta\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado import ioloop, gen, queues\n\n\n@gen.coroutine\ndef fetch(url):\n    print('fetcing', url)\n    response = yield AsyncHTTPClient().fetch(url, raise_error=False)\n    return response\n\n_q = queues.Queue()\n\n\n@gen.coroutine\ndef run():\n    try:\n        url = yield _q.get()\n        res = yield fetch(url)\n        html = res.body\n        print(\"success\")\n    finally:\n        _q.task_done()\n\n\n@gen.coroutine\ndef worker():\n    while not _q.empty():\n        yield run()\n\n\n@gen.coroutine\ndef main():\n    for i in range(1000):    \n        # generate some url\n        url = \"\"\n        yield _q.put(url)\n    for _ in range(100):  \n        worker()\n    yield _q.join(timeout=timedelta(seconds=30))\n\n\nif __name__ == '__main__':\n    ioloop.IOLoop.current().run_sync(main)\nBut when I used async/await like this\n#!/usr/bin/env python\n# encoding: utf-8\n\n\nfrom datetime import timedelta\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado import ioloop, gen, queues\n\n\nasync def fetch(url):\n    print('fetcing', url)\n    response = await AsyncHTTPClient().fetch(url, raise_error=False)\n    return response\n\n_q = queues.Queue()\n\n\nasync def run():\n    try:\n        url = await _q.get()\n        res = await fetch(url)\n        html = res.body\n        # print(html)\n    finally:\n        _q.task_done()\n\n\nasync def worker():\n    while not _q.empty():\n        await run()\n\n\nasync def main():\n    for i in range(1000):\n        # generate some url\n        url = \"\"\n        await _q.put(url)\n    for _ in range(10):\n        worker()\n    await _q.join(timeout=timedelta(seconds=30))\n\n\nif __name__ == '__main__':\n    ioloop.IOLoop.current().run_sync(main)\nThen I got WARNING :test.py:38: RuntimeWarning: coroutine 'worker' was never awaited worker()\nIt seems that the worker didn't run correctly.\nIs there anything wrong?", "issue_status": "Closed", "issue_reporting_time": "2016-08-26T04:17:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "456": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1811", "issue_id": "#1811", "issue_summary": "tornado multiprocess problem", "issue_description": "liujian883 commented on 25 Aug 2016\nHi, I tried tornado `s multiprocess module,but it seems that just one subprocess handled the http request.\nEnvironment:\nPython 2.7.12 :: Anaconda 4.1.1 (64-bit)\ntornado 4.2\nforked 5 subprocess:\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\nimport os\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n         self.write(\"test\")\n         print (\"pid %s!\" % os.getpid())\napp = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n\n\n    sockets = tornado.netutil.bind_sockets(8888)    \n    server = tornado.httpserver.HTTPServer(app)\n\n    tornado.process.fork_processes(5)    \n    server.add_sockets(sockets)\n    tornado.ioloop.IOLoop.instance().start()\nthen I kill the process(26927),\nit always seems that just one subprocess handles the new request,\nwhy can `t I get the different PID output?\nthanks!!!", "issue_status": "Closed", "issue_reporting_time": "2016-08-25T06:29:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "457": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1810", "issue_id": "#1810", "issue_summary": "Tornado does not properly handle \"await asyncio.sleep(0)\"", "issue_description": "adamrothman commented on 25 Aug 2016\nIn python/asyncio#285, asyncio.sleep was optimized for calls where delay = 0. Similar to tornado.gen.moment, the idea is that sometimes you just want to yield control to the event loop without waiting for a prescribed amount of time. Tornado doesn't handle this correctly, however. Given the following simple demo server:\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport asyncio\n\nfrom tornado.httpserver import HTTPServer\nfrom tornado.platform.asyncio import AsyncIOMainLoop\nfrom tornado.web import Application\nfrom tornado.web import RequestHandler\n\n\nclass HelloHandler(RequestHandler):\n\n    async def get(self):\n        await asyncio.sleep(0)\n        self.write('hello')\n\n\nif __name__ == '__main__':\n    AsyncIOMainLoop().install()\n\n    app = Application(\n        handlers=[\n            ('/hello', HelloHandler),\n        ],\n        autoescape=None,\n        debug=True,\n    )\n    server = HTTPServer(app)\n    server.listen(8080)\n\n    asyncio.get_event_loop().run_forever()\nRequesting GET /hello always results in the following crash:\nTraceback (most recent call last):\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/web.py\", line 1469, in _execute\n    result = yield result\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/gen.py\", line 1015, in run\n    value = future.result()\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/gen.py\", line 1021, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"<string>\", line 6, in _wrap_awaitable\n  File \"./test.py\", line 14, in get\n    await asyncio.sleep(0)\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/asyncio/tasks.py\", line 506, in sleep\n    yield\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/gen.py\", line 1015, in run\n    value = future.result()\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/concurrent.py\", line 237, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/gen.py\", line 1097, in handle_yield\n    self.future = convert_yielded(yielded)\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/functools.py\", line 743, in wrapper\n    return dispatch(args[0].__class__)(*args, **kw)\n  File \"/Users/adam/.pyenv/versions/3.5.2/lib/python3.5/site-packages/tornado/gen.py\", line 1229, in convert_yielded\n    raise BadYieldError(\"yielded unknown object %r\" % (yielded,))\ntornado.gen.BadYieldError: yielded unknown object None", "issue_status": "Closed", "issue_reporting_time": "2016-08-24T18:50:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "458": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1809", "issue_id": "#1809", "issue_summary": "TCP connection fails on systems without IPv6 support when connecting to a host that has an IPv6 address", "issue_description": "Contributor\nlilydjwg commented on 24 Aug 2016\ngetaddrinfo will return IPv6 addresses when the system doesn't support it, and Tornado will then fail to connect to the IPv6 address with this error (I get a report for my project here):\nOSError: [Errno 97] Address family not supported by protocol\nI see in #593 AI_ADDRCONFIG was removed from bind_sockets, and in #823 Tornado just ignores the unsupported protocol. But this is about connect, not bind. What do you think, to use AI_ADDRCONFIG or just ignore the error? There's currently no way to pass the flags to resolvers though.", "issue_status": "Closed", "issue_reporting_time": "2016-08-24T14:48:02Z", "fixed_by": "#1821", "pull_request_summary": "tcpclient: try next address when protocol not supported", "pull_request_description": "Contributor\nlilydjwg commented on 5 Sep 2016\ne.g. trying to connect to IPv6 addresses on OSes with IPv6 disabled\nThis fixes #1809", "pull_request_status": "Merged", "issue_fixed_time": "2016-09-11T12:00:15Z", "files_changed": [["14", "tornado/tcpclient.py"]]}, "459": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1807", "issue_id": "#1807", "issue_summary": "it seems a bit hard to handle custom exception", "issue_description": "yuwenyong commented on 24 Aug 2016\nclass BaseHandler(tornado.web.RequestHandler):\ndef _handle_request_exception(self, e):\nif isinstance(e, ASNotLogin):\nself.error(e.code(), e.message(), 401)\nelif isinstance(e, ASError):\nself.error(e.code(), e.message())\nelse:\nsuper(BaseHandler, self)._handle_request_exception(e)\nI want handle my execption like this.But the method '_handle_request_exception' is not public.Can this method be public in future version?", "issue_status": "Closed", "issue_reporting_time": "2016-08-24T08:34:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "460": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1804", "issue_id": "#1804", "issue_summary": "Installing Tornado using latest pip+setuptools fails", "issue_description": "gbraad commented on 20 Aug 2016\nDoing the following on Fedora 24 will result in an error:\n$ pip3 install -U pip setuptools\n$ pip3 install tornado\nThe output/error is:\n[root@fd72cd1d9a71 /]# pip3 install -U pip setuptools                                                                                                                                                                          \nCollecting pip\n  Downloading pip-8.1.2-py2.py3-none-any.whl (1.2MB)\n    100% |################################| 1.2MB 318kB/s \nCollecting setuptools\n  Downloading setuptools-25.4.0-py2.py3-none-any.whl (459kB)\n    100% |################################| 462kB 855kB/s \nInstalling collected packages: pip, setuptools\n  Found existing installation: pip 8.0.2\n    Uninstalling pip-8.0.2:\n      Successfully uninstalled pip-8.0.2\n  Found existing installation: setuptools 20.1.1\n    Uninstalling setuptools-20.1.1:\n      Successfully uninstalled setuptools-20.1.1\nSuccessfully installed pip-8.0.2 setuptools-20.1.1\nYou are using pip version 8.0.2, however version 8.1.2 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n[root@fd72cd1d9a71 /]# pip3 install tornado\nCollecting tornado\n  Downloading tornado-4.4.1.tar.gz (456kB)\n    100% |################################| 460kB 2.1MB/s \n    Complete output from command python setup.py egg_info:\n    /usr/lib64/python3.5/distutils/dist.py:261: UserWarning: Unknown distribution option: 'install_requires'\n      warnings.warn(msg)\n    usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\n       or: -c --help [cmd1 cmd2 ...]\n       or: -c --help-commands\n       or: -c cmd --help\n\n    error: invalid command 'egg_info'\n\n    ----------------------------------------\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-anobhk9r/tornado/\nYou are using pip version 8.0.2, however version 8.1.2 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\nThis doesn't happen when only updating pip with:\n$ pip3 install -U pip\n$ pip3 install tornado", "issue_status": "Closed", "issue_reporting_time": "2016-08-20T02:02:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "461": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1803", "issue_id": "#1803", "issue_summary": "Excessive CPU load when returning empty collection", "issue_description": "Contributor\nmrocklin commented on 19 Aug 2016 \u2022\nedited\nThe following causes my CPU to stay pinned at 100% usage\nfrom tornado.ioloop import IOLoop\nfrom tornado import gen\nfrom threading import Thread\n\nloop = IOLoop.current()\nt = Thread(target=loop.start, daemon=True)\nt.start()\n\n@gen.coroutine\ndef f():\n    yield gen.sleep(0)\n    return {}\n\nloop.add_callback(f)\n\nfrom time import sleep  # just to stick around in case you run this in a script\nsleep(100)\nReplacing the empty dict {} with an empty list [] has the same effect. Replacing with None behaves as expected.\nRunning Python 3.5, Tornado 4.4.1, on Ubuntu 16.04", "issue_status": "Closed", "issue_reporting_time": "2016-08-19T16:30:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "462": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1802", "issue_id": "#1802", "issue_summary": "too many file descriptors in select()", "issue_description": "Wall-ee commented on 18 Aug 2016\nproblem:\ntoo many file descriptors in select()\nproblem describe:\ni use tornado as a http server and using the asynchronous/coroutine method.\ncode structer is like:\nclass RequestHandler:\n executor = ThreadPoolExecutor(8)\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def post(self,*****):\n\n     result = yield self.def1(*****)\n\n     self.write(result)\n     self.finish()\n\n     @run_on_executor\n     def def1(******):\n           return result\nand then we stress test the server capacity which make HTTP POST request 10 time per second.\nafter about 3 minutes: the server shut down and report:\ntoo many file descriptors in select()\n*** environment\nOS: windows 10\npython: Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32\ntornado: 4.2.1", "issue_status": "Closed", "issue_reporting_time": "2016-08-18T15:19:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "463": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1801", "issue_id": "#1801", "issue_summary": "Chunked response", "issue_description": "aShobhitSingh commented on 18 Aug 2016 \u2022\nedited\nHello,\nHow do I enable chunked response. I am facing problems while sending a response above certain bytes. Tornado is not sending the complete buffer to the client, so I thought of setting the response as chunked. Any idea how to do that. I am using version 4.4.1\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2016-08-18T10:34:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "464": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1799", "issue_id": "#1799", "issue_summary": "ERROR:tornado.application:Exception - Big Spool", "issue_description": "dovy commented on 17 Aug 2016\nUsing tornado to work against a remote API to grab a bunch of API calls. Every 40-100 URLs I get a spool of these, and I'd love to just re-add them to my backlog and continue forward.\nERROR:tornado.application:Exception in callback <functools.partial object at 0x177e4e68>\nTraceback (most recent call last):\n  File \"/usr/lib64/python2.7/site-packages/tornado/ioloop.py\", line 600, in _run_callback\n    ret = callback()\n  File \"/usr/lib64/python2.7/site-packages/tornado/stack_context.py\", line 343, in wrapped\n    raise_exc_info(exc)\n  File \"/usr/lib64/python2.7/site-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 264, in <lambda>\n    future, lambda future: callback(future.result()))\n  File \"/usr/lib64/python2.7/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/lib64/python2.7/site-packages/tornado/tcpclient.py\", line 174, in connect\n    server_hostname=host)\n  File \"/usr/lib64/python2.7/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/usr/lib64/python2.7/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\nSSLEOFError: EOF occurred in violation of protocol (_ssl.c:765)\nMy questions are, now can I avoid this, and is there a way to recover from this and re-run those URLs through?\nHere's an example of the code I'm using. :)\n#1400 (comment)\n@akellehe @dalloriam", "issue_status": "Closed", "issue_reporting_time": "2016-08-16T21:34:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "465": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1796", "issue_id": "#1796", "issue_summary": "Can't running well in ipython/jupyter notebook", "issue_description": "eromoe commented on 12 Aug 2016 \u2022\nedited\nI am using ipython 5.0 and jupyter 4.3\nmy code :\nimport tornado.ioloop\nimport tornado.httputil\nimport tornado.httpclient\nfrom tornado import gen\nimport pycurl\n\n@gen.coroutine\ndef foo():\n    tornado.httpclient.AsyncHTTPClient.configure(\n        \"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n    http_client = tornado.httpclient.AsyncHTTPClient()\n    http_request = tornado.httpclient.HTTPRequest(\n        \"http://sina.com\",\n        proxy_host=\"localhost\",\n        proxy_port=1920\n    )\n    response = yield http_client.fetch(http_request)\n    print response.code\n\ntornado.ioloop.IOLoop.instance().run_sync(foo)\nNo matter the foo raise Exception or not, it got error:\nRuntimeErrorTraceback (most recent call last)\n<ipython-input-4-2a54a0147edd> in <module>()\n----> 1 tornado.ioloop.IOLoop.instance().run_sync(foo)\n\nc:\\python27\\lib\\site-packages\\tornado\\ioloop.pyc in run_sync(self, func, timeout)\n    450         if timeout is not None:\n    451             timeout_handle = self.add_timeout(self.time() + timeout, self.stop)\n--> 452         self.start()\n    453         if timeout is not None:\n    454             self.remove_timeout(timeout_handle)\n\nc:\\python27\\lib\\site-packages\\zmq\\eventloop\\ioloop.pyc in start(self)\n    160     def start(self):\n    161         try:\n--> 162             super(ZMQIOLoop, self).start()\n    163         except ZMQError as e:\n    164             if e.errno == ETERM:\n\nc:\\python27\\lib\\site-packages\\tornado\\ioloop.pyc in start(self)\n    750     def start(self):\n    751         if self._running:\n--> 752             raise RuntimeError(\"IOLoop is already running\")\n    753         self._setup_logging()\n    754         if self._stopped:\n\nRuntimeError: IOLoop is already running\n\n## if request success  , here does print code  200\nthen cause:\nThe kernel appears to have died. It will restart automatically.", "issue_status": "Closed", "issue_reporting_time": "2016-08-12T07:09:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "466": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1793", "issue_id": "#1793", "issue_summary": "Simple example on Windows 7 / Python 3.4 does not behave as expected", "issue_description": "waynenilsen commented on 9 Aug 2016\nI raised this question on SO a few days ago and haven't gotten any answers so I thought that I would post it here as well.\nIf you want me to copy/paste the content here I can but for now I'll just leave the content on SO.", "issue_status": "Closed", "issue_reporting_time": "2016-08-09T14:50:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "467": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1790", "issue_id": "#1790", "issue_summary": "Demos require old version of jquery", "issue_description": "Member\nbdarnell commented on 6 Aug 2016\nThe chat and websocket demo apps use the jquery live() method, which was removed in jquery 1.9. The demos still work if used as-is because they load jquery 1.3 (which was the current version when the chat demo was first written), but they're now less useful as examples. Both demos should be updated to work with up-to-date dependencies.", "issue_status": "Closed", "issue_reporting_time": "2016-08-05T19:34:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "468": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1789", "issue_id": "#1789", "issue_summary": "Render template: typeerror unhashable type 'list'", "issue_description": "ldkxingzhe commented on 4 Aug 2016 \u2022\nedited\ncode like this:\n{% for item in items %} {% for tag in item.tags %} <li> {{tag}}</li> {% end %} {% end %}\nWhat i should do? some code snippet?", "issue_status": "Closed", "issue_reporting_time": "2016-08-04T07:28:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "469": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1788", "issue_id": "#1788", "issue_summary": "TCPClient docs way too brief", "issue_description": "ghost commented on 3 Aug 2016\nI've looked at http://www.tornadoweb.org/en/stable/tcpclient.html and it doesn't seem enough to actually start using TCPClient.\nIs there some example available somewhere?\nI mean, I run:\nt = TCPClient()\nt.connect('localhost', 1111)\ntornado.ioloop.IOLoop.instance().start()\nI see that connection is established and localhost:1111 sends data to t. Now, where do I put the async code which will be triggered when this data is received? I'm pretty-sure sure such a basic thing have been addressed already but I still have problem locating it at http://www.tornadoweb.org", "issue_status": "Closed", "issue_reporting_time": "2016-08-03T17:13:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "470": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1785", "issue_id": "#1785", "issue_summary": "Can not understand Interleaving pattern.", "issue_description": "eromoe commented on 2 Aug 2016 \u2022\nedited\nhttp://www.tornadoweb.org/en/stable/guide/coroutines.html#interleaving says:\nSometimes it is useful to save a Future instead of yielding it immediately, so you can start another operation before waiting:\n@gen.coroutine\ndef get(self):\n    fetch_future = self.fetch_next_chunk()\n    while True:\n        chunk = yield fetch_future\n        if chunk is None: break\n        self.write(chunk)\n        fetch_future = self.fetch_next_chunk()\n        yield self.flush()\nTo me, the normal yield use case is just to avoid load big data into memory. yield can be described as a pause and return mark. While looping generator, call next() function go into the generator, once touch yield , return the value and pause at here, then go to next call....\nBut the example code I can't understand.\nDoesn't self.fetch_next_chunk() return Future?\nIn Future example:\nfrom tornado.concurrent import Future\n\ndef async_fetch_future(url):\n    http_client = AsyncHTTPClient()\n    my_future = Future()\n    fetch_future = http_client.fetch(url)\n    fetch_future.add_done_callback(\n        lambda f: my_future.set_result(f.result()))\n    return my_future\nIt need f.result() to get the result. But chunk seems already be the fetch_future.result() , why ?\nchunk = yield fetch_future\nHow do tornado asign fetch_future to chunk, it is not the normal yield I known!\nI have write a test:\ndef test(x=3):\n    while x:\n        a = yield x\n        x-=1\n        print a\n\nfor i in test():\n    print 'x', i\noutput:\nx 3\nNone\nx 2\nNone\nx 1\nNone\nyield self.flush()\nWhat's the meaning of self.flush(), flush often point to write buffer to file/memory, would not return buffer itself .\nI just feel very confuse about the example code, because I have a strong imagine about yield would return someting (which touble me to understand that code I think.)", "issue_status": "Closed", "issue_reporting_time": "2016-08-02T06:44:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "471": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1784", "issue_id": "#1784", "issue_summary": "'_xsrf' argument missing from POST", "issue_description": "qwexvf commented on 31 Jul 2016\nHi, i just got a problem here please help me thanks.\nthis caused when i send a ajax post.\nError: '_xsrf' argument missing from POST\nSettings:\n        settings = dict(\n            cookie_secret=\"__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__\",\n            template_path=os.path.join(os.path.dirname(__file__), \"template\"),\n            static_path=os.path.join(os.path.dirname(__file__), \"static\"),\n            xsrf_cookies=True,\n            autoreload=True,\n            debug=True\n        )\nJavaScript:\n$.ajax({\n        url: \"/api/test\",\n        type: \"post\",\n        data: {'_xsrf':Cookies.get('_xsrf')}, // this one not worked.\n        success: function (data) {\n          if (data.success) {\n            console.log(data);\n          }\n          else {\n            console.log(\" Error!\");\n          }\n        }\n          return false;\n        }\n      });\nalso if i do console.log(Cookies.get('_xsrf'));\nit returns undefined.\nThank you all!", "issue_status": "Closed", "issue_reporting_time": "2016-07-31T14:31:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "472": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1780", "issue_id": "#1780", "issue_summary": "tornado 4.4.1 test failure", "issue_description": "opoplawski commented on 26 Jul 2016\nTrying to update the Fedora package to 4.4.1:\n======================================================================\nFAIL: test_parse_config_file (tornado.test.options_test.OptionsTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"tornado/test/options_test.py\", line 44, in test_parse_config_file\n    self.assertEqual(options.my_path, config_path)\nAssertionError: '/builddir/build/BUILD/tornado-4.4.1/tornado/test/options_test.cfg' != 'tornado/test/options_test.cfg'\n``\nOnly for python2.  python3 tests run fine.  See https://kojipkgs.fedoraproject.org//work/tasks/4339/15014339/build.log", "issue_status": "Closed", "issue_reporting_time": "2016-07-25T22:47:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "473": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1779", "issue_id": "#1779", "issue_summary": "Websocket is closed after exception in handler", "issue_description": "almarklein commented on 23 Jul 2016\nI am experiencing the closing of a websocket when an exception occurs in a handler. This happens in two cases:\nThe handler is called by WebSocketHandler.on_message.\nThe handler is invoked via ioloop.call_later.\nAs far as I remember, the behavior on an exception in a handler was to report the error, without any further action such as closing the websocket. I find the case where the websocket is closed after an exception in a handler invoked via call_later particularly surprising.\nContext (a hacky workaround): flexxui/flexx#163\nLet me know if you want me to try to create a simple example that demonstrates this issue.", "issue_status": "Closed", "issue_reporting_time": "2016-07-22T23:54:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "474": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1774", "issue_id": "#1774", "issue_summary": "Tornado hello_world test returns 599", "issue_description": "gbanas commented on 20 Jul 2016\nI am using Tornado 4.4 with CPython 2.7.\nI copied:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\ndef make_app():\n    return tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n\nif __name__ == \"__main__\":\n    app = make_app()\n    app.listen(8888)\n    tornado.ioloop.IOLoop.current().start()\nfrom http://www.tornadoweb.org/en/stable/guide/structure.html to hello.py and then:\nimport hello\n\nclass TestHelloApp(AsyncHTTPTestCase):\n    def get_app(self):\n        return hello.make_app()\n\n    def test_homepage(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 200)\n        self.assertEqual(response.body, 'Hello, world')\nfrom http://www.tornadoweb.org/en/stable/testing.html to test_hello.py\nAnd when I run:\npython -m tornado.test.runtests test_hello\nI am getting:\nAssertionError: 599 != 200.\nEither I am missing something or the Tornado docs/code need to be updated.", "issue_status": "Closed", "issue_reporting_time": "2016-07-20T12:05:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "475": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1773", "issue_id": "#1773", "issue_summary": "RuntimeError: list changed size during iteration", "issue_description": "viswamy commented on 20 Jul 2016 \u2022\nedited by bdarnell\nI am seeing this error in my project.\ntornado_version: 4.3\nAny thoughts?\n2016-07-19 23:59:49,872 clay_kafka INFO Moving INGEST -> INGEST for Topic: ezpzpass.views.0.\n  File \"/home/uber/torrent/env/bin/torrent-kafka-ingester\", line 9, in <module>\n    load_entry_point('torrent', 'console_scripts', 'torrent-kafka-ingester')()\n  File \"/home/uber/torrent/env/local/lib/python2.7/site-packages/clay_kafka/ingester_main.py\", line 128, in main\n    process_main()\n  File \"/home/uber/torrent/env/local/lib/python2.7/site-packages/clay_kafka/ingester_main.py\", line 90, in process_main\n    io_loop.start()\n  File \"/home/uber/torrent/env/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 814, in start\n    due_timeouts.append(heapq.heappop(self._timeouts))\nRuntimeError: list changed size during iteration", "issue_status": "Closed", "issue_reporting_time": "2016-07-20T00:07:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "476": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1771", "issue_id": "#1771", "issue_summary": "Protocols are not filtered in tornado.curl_httpclient", "issue_description": "Contributor\nstiletto commented on 20 Jul 2016\nTornado should set pycurl.PROTOCOLS option to pycurl.PROTO_HTTP|pycurl.PROTO_HTTPS.\nThere are many real-world applications using tornado HTTP client to fetch data from user-provided URLs.\nTornado doesn't filter protocols in provided URLs making it possible to abuse its HTTP client like this:\n#!/usr/bin/env python3\n# coding: utf-8\nimport tornado.ioloop, tornado.gen, tornado.httpclient, tornado.curl_httpclient\n\n@tornado.gen.coroutine\ndef main():\n    tornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n    for url in ('file:///etc/passwd','telnet://time-c.nist.gov:13'):\n        res = yield tornado.httpclient.AsyncHTTPClient().fetch(url, raise_error=False)\n        print(res.body.decode('utf-8','replace'))\n\nif __name__ == \"__main__\":\n    main().add_done_callback(lambda x: tornado.ioloop.IOLoop.current().stop())\n    tornado.ioloop.IOLoop.current().start()\n1", "issue_status": "Closed", "issue_reporting_time": "2016-07-19T20:29:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "477": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1769", "issue_id": "#1769", "issue_summary": "Runner objects can get GCed unexpectedly", "issue_description": "Contributor\nAaronOpfer commented on 13 Jul 2016 \u2022\nedited\nHi,\nThis is probably a little unusual and I am not sure I understand the whole object graph, but I believe I have reduced my production issue to this test case.\nIf a coroutine is waiting on a future, and the only hard references to that future are entirely inside the body of the inner generator of the coroutine, a garbage collection run can sweep away the in-progress coroutine and its runner object, leave the coroutine's future unresolved forever, and in some cases leave the application in a stuck state.\nRan on Python 3.4 with Tornado 4.3.\nfrom tornado.ioloop import IOLoop\nfrom tornado.gen import Future, coroutine\nimport weakref\nimport gc\n\nwr_fut = None\n\ndef count_runners():\n    runners = len([\n        x for x in gc.get_objects()\n        if x.__class__.__name__ == \"Runner\"\n    ])\n    print(\"There are\",runners,\"Runners\")\n\ndef resolve_fut():\n    count_runners()\n    gc.collect(2)\n    count_runners()\n    fut = wr_fut()\n    if not fut:\n        print('failure! The app is going to hang forever now')\n    else:\n        fut.set_result(1)\n\n@coroutine\ndef main():\n    global wr_fut\n    my_fut = Future()\n    wr_fut = weakref.ref(my_fut)\n    IOLoop.current().add_callback(resolve_fut)\n    yield my_fut\n    print('success!')\n\nIOLoop.current().run_sync(main)\nThis program hangs forever despite using run_sync. That's because the future returned by the coroutine in main() still exists, it just no longer has a Runner object to actually make the future do anything useful. This is very surprising behavior. I would expect the generator/coroutine/Runner/frame objects to be alive for as long as {{run_sync}} is waiting.\nAlso, note that explicit call to gc.collect(2) ; this bug actually requires the garbage collector to run for the bug to trigger, which made this bug very difficult to track down.\nI have managed hack tornado into making it so that the Runner cannot die while its Future is alive which causes my test case to work:\n# gen.py line 1241 tornado 4.3\n                except (StopIteration, Return) as e:\n                    future.set_result(_value_from_stopiteration(e))\n                except Exception:\n                    future.set_exc_info(sys.exc_info())\n                else:\n                    # this is the original code below:\n                    #Runner(result, future, yielded)\n                    # this hack makes the Runner not die and my test case work\n                    future._the_runner = Runner(result, future, yielded)\n                try:\n                    return future\nSo the real-world scenario: I have a proprietary networking library that is using weakrefs for event callbacks and a wrapper library that converts these events into futures. Because I have gone out of my way to avoid creating garbage collection cycles (so that my network client can be GCed when it is no longer in use, unlike a lot of async clients available to tornado), it appears I have discovered this issue.\nWhat is the most appropriate bugfix for this? I personally feel that Runner objects should have their lifecycle tied directly to the future they're driving so that Runners cannot die while their future is alive. However, an argument could also be made that Runner should have a __del__ method that marks the future as canceled (or .set_exception(RuntimeError(\"GCed\"))) instead so that developers can more clearly see that they hit this failure mode.\nPlease don't tell me the answer is \"don't use weakrefs\"! I believe it may be possible to create a test case that presents the same problem without using weakrefs but it would have to abuse certain behaviors of sockets, filenos and IOLoop's fd handlers to more closely emulate the actual workings of my network library.", "issue_status": "Closed", "issue_reporting_time": "2016-07-13T14:40:50Z", "fixed_by": "#1782", "pull_request_summary": "Tie Runner lifetime to lifetime of result future or coroutine function (whichever is GCed first)", "pull_request_description": "Contributor\nAaronOpfer commented on 27 Jul 2016 \u2022\nedited\nThis changeset fixes #1769 to my satisfaction (and I hope everyone else's).\nMy changeset causes the gen.coroutine (and gen.engine, I think) to keep a WeakKeyDictionary mapping result futures to Runner objects. This WeakKeyDictionary is closured to the coroutine generator function itself a global.\nThe resulting behavior is that, if there exists hard references to the result future object and to the coroutine function, the Runner object will not die.\nEverything below is no longer relevant but I'm keeping it for historical reasons\nIn addition, I added a __del__ method to the Runner object (In Python > 3.4 only) which causes it to \"cancel\" (load with an exception, since tornado's futures don't have cancel semantics) the result future if the Runner is collected before it is completed. This prevents applications from hanging forever waiting on futures that will never complete.\nThings I'm still concerned about:\nI am a little bit concerned about my last change with __del__ since it could cause \"working\" code to start spamming \"future exception never cleaned up\" notices if they somehow made a habit out of getting their Runner's collected. It is difficult to imagine a situation where Runners being garbage collected before the future has a result being a desired behavior, though.\nI'm also not entirely sure how this interacts with other code like WaitIterator where multiple futures' results are tied together (would their runners get GCed and give weird exceptions in the log instead of finishing?). But the unit tests pass so what could go wrong right?\nI copy and pasted _GC_CYCLE_FINALIZERS from tornado.concurrent. Maybe the symbol should have been imported instead, but the fact it is \"private\" made me a bit nervous about that.", "pull_request_status": "Merged", "issue_fixed_time": "2016-09-05T08:06:51Z", "files_changed": [["21", "tornado/gen.py"], ["25", "tornado/test/gen_test.py"]]}, "478": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1768", "issue_id": "#1768", "issue_summary": "HTTPError code 422 converted into 500 if reason is not present", "issue_description": "stefanoborini commented on 12 Jul 2016\nIn python 3.4, due to the lack of http.util.responses W3C sanctioned name for code 422 (Unprocessable Entity), tornado/web.py at line 1522 converts the exception into a 500, if reason is not specified.\nIf reason is specified, a 422 is raised, but the reason is actually never used, which is kind of unexpected.\nI would expect the code to raise a 422 regardless if the W3C sanctioned name is found.", "issue_status": "Closed", "issue_reporting_time": "2016-07-12T14:50:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "479": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1767", "issue_id": "#1767", "issue_summary": "read_lastest_message() for websocket client", "issue_description": "makerj commented on 12 Jul 2016\nIt would be nice if retrieving lastest message from websocket client message queue is possible.", "issue_status": "Closed", "issue_reporting_time": "2016-07-12T14:36:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "480": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1766", "issue_id": "#1766", "issue_summary": "Python 3.5.2 - not working", "issue_description": "Contributor\nonovy commented on 12 Jul 2016\nHi,\ntests is failing on Python 3.5.2. Details: https://bugs.python.org/issue27243\n======================================================================\nERROR: test_iterator_async_await (tornado.test.gen_test.WaitIteratorTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/tornado/testing.py\", line 132, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/usr/lib/python3/dist-packages/tornado/testing.py\", line 525, in post_coroutine\n    timeout=timeout)\n  File \"/usr/lib/python3/dist-packages/tornado/ioloop.py\", line 453, in run_sync\n    return future_cell[0].result()\n  File \"/usr/lib/python3/dist-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/lib/python3.5/types.py\", line 179, in throw\n    return self.__wrapped.throw(tp, *rest)\n  File \"/usr/lib/python3/dist-packages/tornado/test/gen_test.py\", line 1345, in test_iterator_async_await\n    yield namespace['f']()\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/usr/lib/python3/dist-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 282, in wrapper\n    yielded = next(result)\n  File \"<string>\", line 6, in _wrap_awaitable\n  File \"<string>\", line 6, in f\nPendingDeprecationWarning: 'WaitIterator' implements legacy __aiter__ protocol; __aiter__ should return an asynchronous iterator, not awaitable\n\n======================================================================\nERROR: test_async_for (tornado.test.queues_test.QueueGetTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/usr/lib/python3/dist-packages/tornado/testing.py\", line 132, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/usr/lib/python3/dist-packages/tornado/testing.py\", line 525, in post_coroutine\n    timeout=timeout)\n  File \"/usr/lib/python3/dist-packages/tornado/ioloop.py\", line 453, in run_sync\n    return future_cell[0].result()\n  File \"/usr/lib/python3/dist-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/lib/python3.5/types.py\", line 179, in throw\n    return self.__wrapped.throw(tp, *rest)\n  File \"/usr/lib/python3/dist-packages/tornado/test/queues_test.py\", line 174, in test_async_for\n    results = yield namespace['f']()\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/usr/lib/python3/dist-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/lib/python3/dist-packages/tornado/gen.py\", line 282, in wrapper\n    yielded = next(result)\n  File \"<string>\", line 6, in _wrap_awaitable\n  File \"<string>\", line 4, in f\nPendingDeprecationWarning: 'Queue' implements legacy __aiter__ protocol; __aiter__ should return an asynchronous iterator, not awaitable", "issue_status": "Closed", "issue_reporting_time": "2016-07-12T10:25:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "481": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1765", "issue_id": "#1765", "issue_summary": "Log time milliseconds", "issue_description": "tonal commented on 12 Jul 2016\nHow to add millisecinds to log line timestamp", "issue_status": "Closed", "issue_reporting_time": "2016-07-12T06:15:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "482": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1764", "issue_id": "#1764", "issue_summary": "Dasable color in log", "issue_description": "tonal commented on 12 Jul 2016\nHow to disable color in console log", "issue_status": "Closed", "issue_reporting_time": "2016-07-12T06:14:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "483": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1763", "issue_id": "#1763", "issue_summary": "Testing call_later callbacks in websocket handler", "issue_description": "DheerendraRathor commented on 11 Jul 2016 \u2022\nedited\nI'm using tornado for WebSockets. On websockets I'm periodically sending pings and waiting for pong from client. For this I'm using call_later method on ioloop. But during unit testing (AsyncHTTPTestCase) callbacks are not called after timeout.\nserver.py\nimport tornado.ioloop\nfrom tornado.options import define, parse_command_line, options\nimport tornado.websocket\nimport tornado.httpserver\nimport tornado.web\n\nfrom datetime import datetime\n\ndefine('addr', help='Address to start server', default='127.0.0.1')\ndefine('port', help='Port to start tornado', type=int, default=8081)\n\n\nclass WebSocketHandler(tornado.websocket.WebSocketHandler):\n\n    def __init__(self, application, request, **kwargs):\n        super().__init__(application, request, **kwargs)\n        self.io_loop = tornado.ioloop.IOLoop.instance()\n\n    def open(self, *args, **kwargs):\n        self.ping_timeout = self.io_loop.call_later(\n            delay=self.get_ping_timeout(initial=True),\n            callback=self._send_ping,\n        )\n\n        self.write_message('OK')\n\n    def check_origin(self, origin):\n        return True\n\n    def on_message(self, message):\n        self.write_message(message)\n\n    @staticmethod\n    def get_ping_timeout(initial: bool=False) -> int:\n        \"\"\"\n        Args:\n            initial: First is true when it is initial ping to be sent\n        \"\"\"\n        return 2\n\n    @staticmethod\n    def get_pong_timeout() -> int:\n        \"\"\"\n        Returns pong timeout for pong\n        \"\"\"\n        return 2\n\n    def on_pong(self, data):\n        print('Received pong')\n        if hasattr(self, 'ping_timeout'):\n            # clear timeout set by for ping pong (heartbeat) messages\n            self.io_loop.remove_timeout(self.ping_timeout)\n\n        # send new ping message after `get_ping_timeout` time\n        self.ping_timeout = self.io_loop.call_later(\n            delay=self.get_ping_timeout(),\n            callback=self._send_ping,\n        )\n\n    def _send_ping(self):\n        \"\"\"\n        Send ping message to client.\n\n        Creates a time out for pong message.\n        If timeout is not cleared then closes the connection.\n        \"\"\"\n        print('Sending ping')\n        self.ping(b'a')\n        self.ping_timeout = self.io_loop.call_later(\n            delay=self.get_pong_timeout(),\n            callback=self._connection_timeout,\n        )\n\n    def _connection_timeout(self):\n        \"\"\" If no pong message is received within the timeout then close the connection \"\"\"\n        print(\"Ping pong timeout\")\n        self.close(None, 'Connection Timeout')\n\n\ndef get_tornado_app():\n    \"\"\"\n    Return a tornado web application instance which includes url config\n    \"\"\"\n\n    return tornado.web.Application(\n        [\n            (r'/', WebSocketHandler),\n        ]\n    )\n\n\ndef main():\n    \"\"\"\n    Configure and start tornado server\n    \"\"\"\n    parse_command_line()\n    tornado_app = get_tornado_app()\n    server = tornado.httpserver.HTTPServer(tornado_app)\n    server.listen(options.port, options.addr)\n\n    quit_command = 'CONTROL-C'\n    print(datetime.now().strftime('%B %d, %Y - %X'))\n    print(\n        'Tornado Version: {tornado_version}\\n'\n        'Starting tornado server at {addr}:{port}\\n'\n        'Quit Server with {quit_command}'.format(\n            tornado_version=tornado.version,\n            addr=options.addr,\n            port=options.port,\n            quit_command=quit_command,\n        )\n    )\n\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == '__main__':\n    main()\nUnit test (test_server.py)\nimport tornado.ioloop\nfrom tornado import websocket, gen\n\nfrom server import get_tornado_app\n\nfrom tornado.testing import gen_test, AsyncHTTPTestCase\n\n\nclass TestPingPong(AsyncHTTPTestCase):\n\n    def get_app(self):\n        return get_tornado_app()\n\n    def tearDown(self):\n        tornado.ioloop.IOLoop.instance().stop()\n\n    def setUp(self):\n        super().setUp()\n\n    def test_http_on_ws(self):\n        response = self.fetch('/')\n        self.assertTrue(response.code, 400)\n\n    @gen_test(timeout=15)\n    def test_ping_pong(self):\n\n        url = 'ws://localhost:%d/' % self.get_http_port()\n\n        ws = yield websocket.websocket_connect(url, io_loop=self.io_loop)\n        msg = yield ws.read_message()\n\n        self.assertEqual(msg, 'OK')\n        yield gen.sleep(12)\nI'm using python -m tornado.testing discover to execute unit tests. When I connect to websocket using Javascript, I can see ping pong callbacks running perfectly, it is the unit tests when they are not executing as expected.\n2", "issue_status": "Closed", "issue_reporting_time": "2016-07-11T09:57:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "484": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1762", "issue_id": "#1762", "issue_summary": "Concurrent requests handled unreliably after 6", "issue_description": "geofurb commented on 8 Jul 2016\nLatest version, erratic behavior for multiple asynchronous requests:\nhttp://stackoverflow.com/questions/38258466/tornado-concurrency-limited-to-6-connections", "issue_status": "Closed", "issue_reporting_time": "2016-07-08T08:49:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "485": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1761", "issue_id": "#1761", "issue_summary": "How to serve webpages without defining handlers.", "issue_description": "BastinRobin commented on 6 Jul 2016\nI really love the flexibility of tornado thanks @bdarnell :) I have a situation where i cannot create handlers for each pages. So if i put a filename with .html inside project directory it should be accessible with the templating tags working fine.\n   /index.html\n    /tags/index.html\nThis code is working but templating tags not supporting :(\nimport os\nimport tornado.ioloop\nimport tornado.web\n\nroot = os.path.dirname(__file__)\nport = 9999\n\napplication = tornado.web.Application([\n    (r\"/(.*)\", tornado.web.StaticFileHandler, { \n        \"path\": root, \"default_filename\": \"index.html\"})\n])\n\nif __name__ == '__main__':\n    application.listen(port)\n    tornado.ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2016-07-06T09:09:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "486": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1760", "issue_id": "#1760", "issue_summary": "Integrate Tornado with uvloop", "issue_description": "giampaolo commented on 4 Jul 2016\nMagicStack/uvloop#35\n1", "issue_status": "Closed", "issue_reporting_time": "2016-07-03T19:22:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "487": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1759", "issue_id": "#1759", "issue_summary": "Where can i cache my dict or pandas dataframes", "issue_description": "BastinRobin commented on 1 Jul 2016\nI am having a situation. Where can i cache a pandas dataframe or python dict in a particular RequestHandler. I want to avoid the file read and conversion for every hit to the URL. First time when the URL is triggered read the csv file and store into cache. Currently for every hit i am going the file read and conversion operation.", "issue_status": "Closed", "issue_reporting_time": "2016-07-01T13:21:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "488": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1758", "issue_id": "#1758", "issue_summary": "No trigger of on_message for long messages", "issue_description": "Ottunger commented on 29 Jun 2016\nAs I said in #608 ,\nHi,\nSorry for bumping so far, but I feel like I encounter the same issue: I need to send near 400MB of data over the socket, and when doing so I have no exception on the client side that sends, but the message never triggers on_message on the server.\nAny idea where it could come from?\nThanks!\nI'll attach some client and server code so that you can drop an eye\nThe server\n   class ParameterServerWebsocketHandler(tornado.websocket.WebSocketHandler):\n       clients = []\n       server = None\n\n    def __init__(self, *args, **kwargs):\n      ParameterServerWebsocketHandler.server = self\n      self.server = kwargs.pop('server')\n      self.model = self.server.model\n      with self.model.session.graph.as_default():\n         self.saver = tf.train.Saver()\n      self.lock = threading.Lock()\n      super(ParameterServerWebsocketHandler,self).__init__(*args, **kwargs)\n\n   def open(self):\n      print(\"A new worker just connected!\")\n      ParameterServerWebsocketHandler.clients.append(self)\n      self.send_parameters()\n\n   def send_parameters(self):\n      ParameterServerWebsocketHandler.server.lock.acquire()\n      parameters = ParameterServerWebsocketHandler.server.model.get_parameters()\n      ParameterServerWebsocketHandler.server.lock.release()\n      serialized = ParameterServerWebsocketHandler.server.model.serialize(parameters)\n      self.write_message(serialized)\n\n   def on_close(self):\n      print(\"Someone left?? :(\")\n      ParameterServerWebsocketHandler.clients.remove(self)\n\n   def on_message(self, message):\n      print(\"Received a message of size %d\" % sys.getsizeof(message))\n      tornado.ioloop.IOLoop.current().spawn_callback(ParameterServerWebsocketHandler.server.process_msg, message)\n\n   @gen.coroutine\n   def process_msg(self, message):\n      time_gradient = ParameterServerWebsocketHandler.server.model.deserialize(message)\n      ParameterServerWebsocketHandler.server.server.gradient_count += 1\n      print(\"gradient_count %d\" % ParameterServerWebsocketHandler.server.server.gradient_count)\n      time_sent = time_gradient[0][0]\n      if time.time() - time_sent < time_lag:\n         ParameterServerWebsocketHandler.server.lock.acquire()\n         gradient = time_gradient[1:]\n         ParameterServerWebsocketHandler.server.model.apply(gradient)\n         ParameterServerWebsocketHandler.server.model.saveWith(ParameterServerWebsocketHandler.server.saver, ckpoint, ParameterServerWebsocketHandler.server.server.gradient_count)\n         if ParameterServerWebsocketHandler.server.server.gradient_count % 10 == 0:\n            error_rate = ParameterServerWebsocketHandler.server.model.test(ParameterServerWebsocketHandler.server.server.test_labels, ParameterServerWebsocketHandler.server.server.test_features)\n            print(\"gradients received: %d    error_rate: %f\" % (ParameterServerWebsocketHandler.server.server.gradient_count, error_rate))\n         t = time.time()\n         ParameterServerWebsocketHandler.server.lock.release()\n      else:\n         print(\"Rejected laggy message\")\n      del time_gradient\n      for cl in ParameterServerWebsocketHandler.clients:\n         cl.send_parameters()\nAnd the client:\n   @gen.coroutine\n   def init_websocket(self):                                       \n      self.websock = yield tornado.websocket.websocket_connect(\"ws://localhost:%d/\" % self.websocket_port,\n    on_message_callback=self.includemsg, connect_timeout=3600)\n\n   def request_parameters(self):\n      print(\"Request to master for new tech...\")\n      IOLoop.current().run_sync(self.request_parameters_coroutine)\n\n   @gen.coroutine\n   def request_parameters_coroutine(self):\n      print(\"Read at pipe...\")\n      parameters = yield self.websock.read_message()\n      self.includemsg(parameters)\n\n   def push_gradients(self):\n      print(\"Request to master to sync...\")\n      IOLoop.current().run_sync(self.push_gradients_coroutine)\n\n   @gen.coroutine\n   def push_gradients_coroutine(self):\n      print(\"Prepare our data...\")\n      gradients = self.model.get_gradients()\n      serialized = self.model.serialize(self.model.get_gradients())\n      del gradients\n      print(\"Sending %d bytes of data...\" % sys.getsizeof(serialized))\n      try:\n         self.websock.write_message(serialized, binary=True)\n         print(\"Written and sent...\")\n      except:\n         print(\"Too large to be sent? :'(\")\n         print(sys.exc_info()[0])\n\n   @gen.coroutine\n   def includemsg(self, parameters):\n      if parameters is None:\n         print(\"Not yet server in advance from us...\")\n         return\n      parameters = self.model.deserialize(parameters)\n      self.model.assign_parameters(parameters)", "issue_status": "Closed", "issue_reporting_time": "2016-06-29T17:40:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "489": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1757", "issue_id": "#1757", "issue_summary": "TimeoutError: [Errno 60] Operation timed out", "issue_description": "jkozlowicz commented on 28 Jun 2016\nQuite a few TimeoutErrors occur when we send requests to a given http server. I wonder if it is Tornado's fault or if the http server times out. I have increased both connect_timeout and request_timeout to one hour and still a lot of TimeoutErrors occur.\nSince I increased those to one hour isn't http_client.fetch method supposed to wait one hour until it times out? Those errors occur after running an instance of an IOLoop for a few minutes already. Also, this errno is different than 599 mentioned in this issue, thus I am not sure whose fault is this.\nI do not have access to logs of the http server, but it could be true that it runs behind a proxy like nginx, which times out if it did not receive a response from an application server that handles business logic.\nHere is the traceback:\nTraceback (most recent call last):\n  File \"/Users/X/project-discovery/src/common.py\", line 167, in worker\n    result = yield fetch_resource_list(http_client, url, headers)\n  File \"/Users/X/env-pd/lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/Users/X/env-pd/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/Users/X/env-pd/lib/python3.5/site-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/Users/X/project-discovery/src/common.py\", line 113, in fetch_resource_list\n    resp = yield http_client.fetch(http_request)\n  File \"/Users/X/env-pd/lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/Users/X/env-pd/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\nTimeoutError: [Errno 60] Operation timed out\nAnd here is the code that we run (more or less I got rid of certain parts for brevity):\n#project-discovery/src/common.py\n\n@gen.coroutine\ndef fetch_resource_list(http_client, url, headers):\n    \"\"\"\n    Fetches a list of resources from a REST endpoint specified by `url` param.\n\n    :param http_client: Tornado HTTP client that will be used to send the\n    request.\n    :param url: A string with URL to fetch the resource list from.\n    :param headers: A dict with headers to be sent with the HTTP request.\n    :return:\n    \"\"\"\n    http_request = HTTPRequest(url=url,\n                               headers=headers,\n                               request_timeout=15*60.0,\n                               connect_timeout=15*60.0)\n    if logger.isEnabledFor(logging.DEBUG):\n        logger.debug('fetching: {url}'.format(url=url))\n    resp = yield http_client.fetch(http_request)\n    if logger.isEnabledFor(logging.DEBUG):\n        logger.debug('fetched: {url}'.format(url=url))\n    body = resp.body if isinstance(resp.body, str) else resp.body.decode()\n    try:\n        resource_list = json.loads(body)\n    except ValueError as e:\n        raise e\n    else:\n        raise gen.Return(resource_list)\n\n\n@gen.coroutine\ndef worker(headers, http_client, queue, _callback,\n           _callback_args=[], _callback_kwargs={}):\n\n    \"\"\"\n    Gets a resource to be fetched from the `queue`.\n\n    If there are no resources in the queue then it waits until one arrives.\n\n    If there are resources to be fetched in the queue, each of them is\n    fetched asynchronously and then `_callback` function is invoked with the\n    fetched result, resource, `callback_args` and `_callback_kwargs` as its\n    arguments.\n\n    If the fetched resource has more pages a new instance of the same resource\n    with URL of the next page is created and put into the queue.\n\n    :param headers: A dict with headers to be sent with the HTTP request.\n    :param http_client: Tornado HTTP client that will be used to send the\n    request.\n    :param queue: A Tornado Queue to get resources to be fetched from.\n    :param _callback: A function to be invoked when the resource is fetched.\n    :param _callback_args: A list of positional arguments to invoke the\n    `_callback` function with.\n    :param _callback_kwargs: A dict with keyword arguments to invoke the\n    `_callback` function with.\n    \"\"\"\n    while True:\n        resource = yield queue.get()\n        url = resource.url\n        try:\n            result = yield fetch_resource_list(http_client, url, headers)\n        except HTTPError as e:\n            log_http_error(error=e, headers=headers, method='GET', payload=None,\n                           url=url, logger=logger)\n        except TimeoutError as e:\n            log_error(error=e, payload=None, logger=logger)\n        else:\n            if _callback is not None:\n                yield gen.Task(_callback, result, resource,\n                               *_callback_args, **_callback_kwargs)\n\n           params = extract_get_url_params(url)\n           if not is_last_page(result, params):\n                params = create_next_page_params(params)\n                new_url = build_get_url(url, params)\n                resource_dict = {\n                    field_name: getattr(resource, field_name) for field_name\n                    in resource.field_names\n                 }\n                resource_dict['url'] = new_url\n                resource_type = type(resource)\n                new_resource = resource_type(**resource_dict)\n                yield queue.put(new_resource)\n        finally:\n            queue.task_done()\n#And the code of the main coroutine (more or less)\n\nAsyncHTTPClient.configure(None, max_clients=concurrency)\nhttp_client = AsyncHTTPClient()\n\nusers_field_names = ['url']\nUsers = namedtuple('Users', field_names=users_field_names)\nUsers.field_names = users_field_names\n\nusers_endpoint_url = ''.join([config['api_url'], '/users'])\nurl = build_get_url(users_endpoint_url, params)\nusers = Users(url=url)\nusers_queue.put(users)\n\nfor _ in range(concurrency):\n    worker(\n        headers=headers,\n        stats=stats,\n        http_client=http_client,\n        queue=users_queue,\n        _callback=process_users,\n        _callback_args=[\n            config, arguments, result_container, user_repos_queue\n        ],\n    )\nyield users_queue.join()", "issue_status": "Closed", "issue_reporting_time": "2016-06-27T18:35:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "490": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1755", "issue_id": "#1755", "issue_summary": "tornado process stay in _GzipMessageDelegate.data_received() forever", "issue_description": "whynotyes commented on 23 Jun 2016\nToday, I find out that all 10 tornado process on my server were all blocked, and can not serve any HTTP request.\nFirst, I use strace -p pid to see what happened on it.\n\nNo any system call.\nSo, I use pyrasite to see its function call stack.\nIt seems that the tornado process is stay in _GzipMessageDelegate.data_received() and can not break out forever.\nWhat happen ? Is it a known problem ?\nEnvironment:\nCentOS release 6.7 (Final) x86_64\nPython 2.6.6\nTornado 4.2.1\nGzipDecompressor class rely on zlib module, which rely on zlibmodule.so", "issue_status": "Closed", "issue_reporting_time": "2016-06-23T11:22:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "491": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1754", "issue_id": "#1754", "issue_summary": "Is it possible to pass couple of modules to all template?", "issue_description": "BastinRobin commented on 18 Jun 2016\nI was to share a couple of modules which is in file called lib.py and i dont want to pass it with render or use module function in template. I want these functions to be globally accessible by all templates", "issue_status": "Closed", "issue_reporting_time": "2016-06-18T09:11:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "492": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1751", "issue_id": "#1751", "issue_summary": "tornado raise value error when setting status code 422 though it is in httplib.responses", "issue_description": "allan-simon commented on 13 Jun 2016\nI'm using python2.7 and python3.5 and in both 422 is defined\nhttps://docs.python.org/2/library/httplib.html#httplib.responses\nhttps://docs.python.org/3.5/library/http.client.html#http.client.responses\nmy code is doing\nself.set_status(422)\nself.finish({})\nand it is returning\nValueError: ('unknown status code %d', 422)\nHowever according to the doc it's supposed to be handled correctly:\nhttp://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.set_status\nstatus_code (int) \u2013 Response status code. If reason is None, it must be present in httplib.responses.", "issue_status": "Closed", "issue_reporting_time": "2016-06-13T09:48:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "493": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1749", "issue_id": "#1749", "issue_summary": "Add built-in security features, such as rate limiting, XSS protection and more", "issue_description": "ghost commented on 12 Jun 2016 \u2022\nedited by ghost\nSince Tornado is a (great!) web framework, it would be nice if it had some more built-in security features.\nFor example, being able to limit the number of HTTP request from a specific client is something that could be used to increate the security of some applications using the Tornado web framework. There are multiple features which could be added to Tornado to increase the security, to protect against XSS, DDOS attacks and other types of attacks.", "issue_status": "Closed", "issue_reporting_time": "2016-06-12T10:43:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "494": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1745", "issue_id": "#1745", "issue_summary": "should add __slots__ for HTTPHeaders", "issue_description": "ghost commented on 8 Jun 2016 \u2022\nedited by ghost\nAs I reviewing the httputil.py for HTTPHeaders, I found that there are not slots defined.\nAs I know, slots can reduce memory usage for such objects, the HTTPHeaders are used largely in RequestHandlers and HTTPClients , and their attributes are static and limited to the three internal fields: _dict, _as_list and _last_key .\nSo why not use slots ?\nFurther more, attributes defined in slots can be looked up more quickly than those without slots . In this case, the attribute _dict is referenced a lot, so i think this will make a big difference. And I made some tests as below:\nIn [11]: class C(object):\n   ....:     def __init__(self, name):\n   ....:         self.name = name\n\nIn [12]: class D(object):\n   ....:     __slots__ = ('name',)\n   ....:     def __init__(self, name):\n   ....:         self.name = name\n\nIn [13]: c = C('hello')\nIn [14]: d = D('hello')\n\nIn [17]: %timeit c.name\nThe slowest run took 28.13 times longer than the fastest. This could mean that an intermediate result is being cached \n10000000 loops, best of 3: 66.1 ns per loop\n\nIn [18]: %timeit d.name\nThe slowest run took 32.02 times longer than the fastest. This could mean that an intermediate result is being cached \n10000000 loops, best of 3: 54.5 ns per loop\nreference for name of class D(with slots) takes less time than class C . This test is ran under Python3.4 .\nBut it seems it will not work in Python2, because collections.MutableMapping in Python2 doesn't have\nslots defined.", "issue_status": "Closed", "issue_reporting_time": "2016-06-08T16:51:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "495": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1740", "issue_id": "#1740", "issue_summary": "websocket on local host works only if connected to the web", "issue_description": "uriyanko commented on 4 Jun 2016\nwebsocket on localhost works only if actually connected to the web\non_message not working in offline\nother tool like SimpleWebSocketServer.py works even without web online.", "issue_status": "Closed", "issue_reporting_time": "2016-06-04T05:24:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "496": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1738", "issue_id": "#1738", "issue_summary": "tornado responds 301 for GET requests when no handlers are configured", "issue_description": "Contributor\nafq984 commented on 3 Jun 2016\nI think it should be 404.\nThe code:\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application\n\nloop = IOLoop.instance()\napp = Application()\napp.listen(5000)\nloop.start()\nCURL request/response\n% curl -i localhost:5000/xyz\nHTTP/1.1 301 Moved Permanently\nServer: TornadoServer/4.3\nContent-Type: text/html; charset=UTF-8\nDate: Fri, 03 Jun 2016 03:49:35 GMT\nLocation: http:///\nContent-Length: 0", "issue_status": "Closed", "issue_reporting_time": "2016-06-03T03:52:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "497": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1737", "issue_id": "#1737", "issue_summary": "Using Tornado as a REST server cannot return 304", "issue_description": "fcaneva-arg commented on 3 Jun 2016 \u2022\nedited\nI'm creating a REST server using the Tornado framework and, due to the internal design, I cannot respond to the client with a HTTP 304 code. In fact, the line that causes me trouble is located at tornado/web.py, line 939. Whenever I set the HTTP code to 304, the request hangs there (with an AssertError), and exits. Are there any workarounds for this issue? The two ones I thought would be:\nFor adding to the framework: include a (bool) REST keyword at tornado.web.RequestHandler object to allow return a manually set 304 code (if True, then skip the 304 check). Maybe include at initialize? (leave decision to the developers).\nFor someone to do locally: override tornado.web.RequestHandler.finish() and modify that assertion.\nI think the first one may be cleaner and easily usable for everyone. Opinions?\nI'd like this issue to be solved a.s.a.p. because I'm working heavily over this (by the way, excellent) framework. Thanks!", "issue_status": "Closed", "issue_reporting_time": "2016-06-03T00:49:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "498": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1736", "issue_id": "#1736", "issue_summary": "Could/should a 204 response omit the Content-Length header?", "issue_description": "Contributor\nnickcoutsos commented on 3 Jun 2016\nThe 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.\nThe 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields.\nIt seems like 204 and 304 should behave in the same way in regards to the response body and use of the Content-Length/Transfer-Encoding headers.\nI'm writing a proxy and would like to be able to stream responses from other servers with as little modification as possible. ExpressJS (used in most of the upstreams I deal with) sends a 204 without a content-length header explicitly.\nI can get around the automatic addition of a Content-Length: 0 by flushing headers in my request handler instead of calling finish, but in the http1connection module it looks like it takes this to mean that I must be using a chunked response (http1connection.py#L354). Later on, however, it uses the existence of the Transfer-Encoding header to assume I'm trying to send a body and raises an error. (http1connection.py#L541)\nWould it be appropriate to treat 204 in the same way as the 304 when dealing with Content-Length/Transfer-Encoding headers? I was about to submit a pull request thinking it'd be as simple as changing\nstart_line.code != 304\nto\nstart_line.code not in (204, 304)\nbut this kind of check happens in a few different places and there are tests in place to verify some of the existing behaviour, so maybe this needs some discussion. Has this kind of thing come up before?", "issue_status": "Closed", "issue_reporting_time": "2016-06-02T20:21:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "499": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1734", "issue_id": "#1734", "issue_summary": "build failure on ubuntu/armhf buildd (test failure)", "issue_description": "Contributor\nLocutusOfBorg commented on 31 May 2016\nHi, not sure how to report that, I can't reproduce locally, and this is a new test on the latest release..\nbuild log is here\nhttps://launchpad.net/ubuntu/+source/python-tornado/4.3.0-2ubuntu1\nPYBUILD_SYSTEM=custom PYTHONPATH=. dh_auto_test\n    pybuild --test -i python{version} -p 2.7 --dir .\nI: pybuild base:184: python2.7 ./tornado/test/runtests.py\n.............ssss.....................................................sssssssssssssssssssssssssssssssssssss...........ssss..s...s........................................s...........................s.......s..s...s..................s......................................................ss.........................................................................ss........s....................ss...s.............s.....s......................s.....s......................s.....s...............................................................s.......s.................ss.E...sssssss.............................s...................................s......................................................s.....................ss.....s..................ss.....s...............................ss..s...................................................s...ss........ssssssssssssss.................................................................s.............sss......................................................................................................s.........................................................s.....................................................................................................................s....................................................................................\n======================================================================\nERROR: test_reuse_port (tornado.test.netutil_test.TestPortAllocation)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/\u00abPKGBUILDDIR\u00bb/tornado/test/netutil_test.py\", line 209, in test_reuse_port\n    sockets = bind_sockets(port, 'localhost', reuse_port=True)\n  File \"/\u00abPKGBUILDDIR\u00bb/tornado/netutil.py\", line 195, in bind_sockets\n    sock.bind(sockaddr)\n  File \"/usr/lib/python2.7/socket.py\", line 228, in meth\n    return getattr(self._sock,name)(*args)\nerror: [Errno 98] Address already in use\n\n----------------------------------------------------------------------\nRan 1315 tests in 29.752s\n\nFAILED (errors=1, skipped=114)\nSome tests were skipped because: PEP 380 (yield from) not available,\nPEP 492 (async/await) not available, asyncio module not present,\nconcurrent.futures module not present, futures module not present,\nlocalhost does not resolve to ipv6, mock package not present, needs\nfix, pycares module not present, pycurl module not present, timing\ntests unreliable on travis, tornado.speedups module not present,\ntwisted module not present ", "issue_status": "Closed", "issue_reporting_time": "2016-05-30T20:52:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "500": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1730", "issue_id": "#1730", "issue_summary": "Working with invalid cookies", "issue_description": "Contributor\nysimonson commented on 27 May 2016 \u2022\nedited\nRecently, we discovered one of our site's third-party tools was injecting invalid cookies. This broke all form submissions for affected users, because of the xsrf cookie. They shouldn't be injecting invalid cookies, of course, but I imagine this must be a not-uncommon issue, since bugs do happen.\nIs there a fix for this at the framework-level that would make sense? If so, I'm happy to attempt a PR.\nOne solution, for example, could be to reset all cookies if they fail to parse. That won't help the current request, of course, but at least future requests would have a clean slate to work with. It would've solved our problems at least, since the tool was only injecting invalid cookies sporadically.", "issue_status": "Closed", "issue_reporting_time": "2016-05-26T20:50:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "501": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1726", "issue_id": "#1726", "issue_summary": "Trivial patch to handle undefined \"sockets\" local variable", "issue_description": "SnarkBoojum commented on 24 May 2016\nThis trivial patch, which just came to Debian but has been in Ubuntu since long, makes sure a local \"sockets\" variable gets defined in all branches, and hence won't trigger an error in some cases.\nI tought it would be nice to forward it to you upstream.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2016-05-24T11:58:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "502": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1724", "issue_id": "#1724", "issue_summary": "windows SSL certificate problem: unable to get local issuer certificate", "issue_description": "eromoe commented on 24 May 2016\n[E 160524 13:21:42 web:1524] Uncaught exception POST /har/test (127.0.0.1)\n    HTTPServerRequest(protocol='http', host='y.com:8923', method='POST', uri='/har/test',     Traceback (most recent call last):\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\web.py\", line 1445, in _execute\n        result = yield result\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\gen.py\", line 1008, in run\n        value = future.result()\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\concurrent.py\", line 232, in result\n        raise_exc_info(self._exc_info)\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\gen.py\", line 1014, in run\n        yielded = self.gen.throw(*exc_info)\n      File \"E:/Project/qiandao\\web\\handlers\\har.py\", line 67, in post\n        ret = yield self.fetcher.fetch(data)\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\gen.py\", line 1008, in run\n        value = future.result()\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\concurrent.py\", line 232, in result\n        raise_exc_info(self._exc_info)\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\gen.py\", line 1014, in run\n        yielded = self.gen.throw(*exc_info)\n      File \"E:/Project/qiandao\\libs\\fetcher.py\", line 340, in fetch\n        response = yield self.client.fetch(req)\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\gen.py\", line 1008, in run\n        value = future.result()\n      File \"C:\\Python27\\lib\\site-packages\\tornado\\concurrent.py\", line 232, in result\n        raise_exc_info(self._exc_info)\n      File \"<string>\", line 3, in raise_exc_info\n    CurlError: HTTP 599: SSL certificate problem: unable to get local issuer certificate\nAfter some searching, I found:\nIn [1]: import pycurl\nIn [2]: c = pycurl.Curl()\nIn [3]: c.setopt(c.URL, 'https://quora.com')\nIn [4]: c.perform()\n---------------------------------------------------------------------------\nerror                                     Traceback (most recent call last)\n<ipython-input-4-ca1d06f79dfb> in <module>()\n----> 1 c.perform()\n\nerror: (60, 'SSL certificate problem: unable to get local issuer certificate')\nI install openssl 1.0.2, and add bin to enviroment, bu not work.", "issue_status": "Closed", "issue_reporting_time": "2016-05-24T05:48:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "503": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1723", "issue_id": "#1723", "issue_summary": "Discuss about _NormalizedHeaderCache", "issue_description": "lanzhiheng commented on 23 May 2016\nI see the source code of tornado.httputil\nPlease look this code segment:\n    def __init__(self, size):\n        super(_NormalizedHeaderCache, self).__init__()\n        self.size = size\n        self.queue = collections.deque()\nwith the self.queue tornado have there operations:\nself.queue.append(key)\n        if len(self.queue) > self.size:\n            # Limit the size of the cache.  LRU would be better, but this\n            # simpler approach should be fine.  In Python 2.7+ we could\n            # use OrderedDict (or in 3.2+, @functools.lru_cache).\n            old_key = self.queue.popleft()\n            del self[old_key]\nand then I see the deque infomation\nIn [129]: collections.deque?\nDocstring:\ndeque([iterable[, maxlen]]) --> deque object\nIf I initialize an object\nIn [139]: a = collections.deque([], 10)\n\nIn [140]: for i in range(100):\n    a.append(i)\n   .....:\n\nIn [141]: a\nOut[141]: deque([90, 91, 92, 93, 94, 95, 96, 97, 98, 99])\nIt will automatically delete the left item, when append new item, and the length of the deque greater than maxlen (10)\u3002so I want to change the code like below:\n    def __init__(self, size):\n        super(_NormalizedHeaderCache, self).__init__()\n        self.size = size\n        self.queue = collections.deque([], self.size)\n\n    def __missing__(self, key):\n        normalized = \"-\".join([w.capitalize() for w in key.split(\"-\")])\n        self[key] = normalized\n        self.queue.append(key)\n        # Limit the size of the cache.  LRU would be better, but this\n        # simpler approach should be fine.  In Python 2.7+ we could\n        # use OrderedDict (or in 3.2+, @functools.lru_cache).\n        return normalized\nIs it OK?", "issue_status": "Closed", "issue_reporting_time": "2016-05-23T09:21:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "504": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1721", "issue_id": "#1721", "issue_summary": "socket.gaierror thrown in ExecutorResolver", "issue_description": "jonathan-s commented on 17 May 2016\nIn ExecutorResolver and its children a socket.gaierror is thrown if it errors. Perhaps it would be more useful if it was an error decided by tornado instead of that of socket?", "issue_status": "Closed", "issue_reporting_time": "2016-05-17T16:41:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "505": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1719", "issue_id": "#1719", "issue_summary": "py35 error with \"bytes-like object is required, not 'str' \"", "issue_description": "rafaelcapucho commented on 12 May 2016\nWhen I try to get request.query_arguments.get('amount')[0] I get errors:\nTraceback (most recent call last):\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/web.py\", line 1445, in _execute\n    result = yield result\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/gen.py\", line 1014, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/beauty_site/handlers/categories/__init__.py\", line 78, in get\n    'h2': 'Categoria %s' % category['name'],\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/gen.py\", line 1017, in run\n    yielded = self.gen.send(value)\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/beauty_site/handlers/search/__init__.py\", line 414, in render_search_groups\n    self.render('list_groups.html', **args)\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/web.py\", line 699, in render\n    html = self.render_string(template_name, **kwargs)\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/web.py\", line 806, in render_string\n    return t.generate(**namespace)\n  File \"/home/kepler/Workspace/beauty/beauty_site_venv/lib/python3.5/site-packages/tornado/template.py\", line 345, in generate\n    return execute()\n  File \"list_groups_html.generated.py\", line 146, in _tt_execute\n    if value in request.query_arguments.get('amount')[0]:  # list_groups_filters.html:27 (via list_groups.html:28, base.html:44)\nTypeError: a bytes-like object is required, not 'str'\nWhen I execute without [0] like request.query_arguments.get('amount') it complete without warning, it was a legacy code and was running on py27 and previous version of Tornado.\nthe env:\nRequest Info:\n\n   method: GET\n   remote_ip: 127.0.0.1\n   arguments: {'amount': [b'40ml!50ml']}\n   uri: /c/cabelos.html?amount=40ml!50ml\n   body: b''\n   headers: <tornado.httputil.HTTPHeaders object at 0x7fa3ae6672b0>\n   connection: <tornado.http1connection.HTTP1Connection object at 0x7fa3ae944b00>\n   _finish_time: None\n   host: 127.0.0.1:8089\n   path: /c/cabelos.html\n   files: {}\n   body_arguments: {}\n   query_arguments: {'amount': [b'40ml!50ml']}\n   protocol: http\n   version: HTTP/1.1\n   _start_time: 1463019081.1243713\n   query: amount=40ml!50ml\nTornado 4.3 and Python 3.5.1", "issue_status": "Closed", "issue_reporting_time": "2016-05-12T05:20:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "506": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1718", "issue_id": "#1718", "issue_summary": "Incorrect response for invalid Content-Length header", "issue_description": "LaszloKatona commented on 10 May 2016 \u2022\nedited\nTornado responds with status 500 when gets non decimal characters in Content-Length header.\nEnvironment:\nUbuntu 14.04\nPython 3.4.3\nTornado 4.3\nLogged error message:\n[ERROR] tornado.general: Uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/http1connection.py\", line 706, in _server_request_loop\n    ret = yield conn.read_response(request_delegate)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/concurrent.py\", line 232, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/gen.py\", line 1017, in run\n    yielded = self.gen.send(value)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/http1connection.py\", line 219, in _read_message\n    start_line.code if self.is_client else 0, headers, delegate)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/http1connection.py\", line 534, in _read_body\n    content_length = int(headers[\"Content-Length\"])\nValueError: invalid literal for int() with base 10: '\\x8d\\x00\\x00\\x00'", "issue_status": "Closed", "issue_reporting_time": "2016-05-10T11:26:27Z", "fixed_by": "#1720", "pull_request_summary": "Fixed #1718", "pull_request_description": "Contributor\ndaftshady commented on 15 May 2016\nThis fixes #1718 .\nAs many HTTP clients allow to override Content-Length value to something which is non-integer, I think closing the connection immediately for this case is far more better than raising ValueError.", "pull_request_status": "Merged", "issue_fixed_time": "2016-05-28T16:08:27Z", "files_changed": [["8", "tornado/http1connection.py"], ["12", "tornado/test/httpserver_test.py"]]}, "507": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1717", "issue_id": "#1717", "issue_summary": "Question about handling blocking code in periodiccallback", "issue_description": "StudentForever commented on 9 May 2016\nHi\ncross-posting here as I did not get any responses on stackoverflow :\nhttp://stackoverflow.com/questions/36901463/how-to-handle-blocking-code-in-tornados-periodiccallback\nThanks", "issue_status": "Closed", "issue_reporting_time": "2016-05-09T17:10:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "508": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1715", "issue_id": "#1715", "issue_summary": "a high leve protocal parser", "issue_description": "mayflaver commented on 8 May 2016\nhttps://github.com/mayflaver/sora, a wonderful tool to provide high level parser and make protocal extends more easy, I think it is a good tool for tornado to support more third io protocal, it parse faster than yield and yield.", "issue_status": "Closed", "issue_reporting_time": "2016-05-08T14:53:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "509": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1708", "issue_id": "#1708", "issue_summary": "HTTPClient command line interface does not print headers", "issue_description": "labrys commented on 3 May 2016\nUsing the example from the docs prints an HTTPHeaders object not the actual headers.\n> python -m tornado.httpclient --print_headers --print_body=false http://www.google.com\n<tornado.httputil.HTTPHeaders object at 0x0103DFB0>", "issue_status": "Closed", "issue_reporting_time": "2016-05-03T08:26:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "510": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1707", "issue_id": "#1707", "issue_summary": "find an interesting thing", "issue_description": "892768447 commented on 2 May 2016 \u2022\nedited\nhaha! Once I was writing a library that named http.py\nhttp.py can not found HTTPRequest\nTraceback (most recent call last):\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\httputil.py\", line 39, in\nimport Cookie # py2\nImportError: No module named 'Cookie'\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"G:\\Workspace\\PythonProject\\utils\\http.py\", line 5, in\nfrom tornado.httpclient import HTTPRequest\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\httpclient.py\", line 49, in\nfrom tornado import httputil, stack_context\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\httputil.py\", line 41, in\nimport http.cookies as Cookie # py3\nFile \"G:\\Workspace\\PythonProject\\utils\\http.py\", line 5, in\nfrom tornado.httpclient import HTTPRequest\nImportError: cannot import name 'HTTPRequest'\nhttp.py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom tornado import gen\nfrom tornado.httpclient import HTTPRequest\nfrom tornado.ioloop import IOLoop\n\ntry:\n    from tornado.curl_httpclient import CurlAsyncHTTPClient as HttpClient    # @UnusedImport\nexcept:\n    from tornado.httpclient import AsyncHTTPClient as HttpClient    # @Reimport @UnusedImport\n\n@gen.coroutine\ndef get():\n    response = yield gen.Task(HttpClient().fetch,\n        HTTPRequest(\"http://127.0.0.1/menu\",\n            method = \"GET\",\n            max_redirects = 3,\n            follow_redirects = True, allow_nonstandard_methods = True\n        ), raise_error = False,\n    )\n    print(response.body)\n\n    IOLoop.instance().stop()\n\nio_loop = IOLoop.current()\nio_loop.run_sync(get)", "issue_status": "Closed", "issue_reporting_time": "2016-05-02T15:42:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "511": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1703", "issue_id": "#1703", "issue_summary": "raise ctypes.GetLastError on windows raise another Exception", "issue_description": "vit1251 commented on 29 Apr 2016\nHello, I try to create subprocess what's wrong with raise error?\n   raise ctypes.GetLastError()\nTypeError: exceptions must be old-style classes or derived from BaseException, not int\nThanx.", "issue_status": "Closed", "issue_reporting_time": "2016-04-28T20:15:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "512": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1702", "issue_id": "#1702", "issue_summary": "how to set time out without disconnecting?", "issue_description": "saintthor commented on 28 Apr 2016\nstream.socket.settimeout( 1 )\nmsg = stream.read_until( b'\\r' )\nif there is no message, timeout, the connection breaks.\nhow to remain the connection when timeout?", "issue_status": "Closed", "issue_reporting_time": "2016-04-28T09:15:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "513": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1701", "issue_id": "#1701", "issue_summary": "how to write to iostream before read_until finishs?", "issue_description": "saintthor commented on 27 Apr 2016\ni set a tcpserver. it keeps long connection with clinets. the clients may send message to the server and the server may send to the clients. the server call read_until for the client's messages, it gets nothing and keep waiting. now there is something need to be send to the client. how to stop the read_until call and send first?\nmessage = yield stream.read_until( b'\\n' ) #there is no message\nyield stream.write( 'something' ) #how to step here?", "issue_status": "Closed", "issue_reporting_time": "2016-04-27T16:23:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "514": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1697", "issue_id": "#1697", "issue_summary": "Custom StaticFileHandler", "issue_description": "rsmith31415 commented on 21 Apr 2016\nI know this has been asked before here but I think the answer was too concise. The question is mainly how to use a custom StaticFileHandler. The response was:\nThis is a bit tricky; you need to subclass StaticFileHandler and override its write_error method, then install that class with static_handler_class Application setting.\nFollowing the instructions, I have this (based on this other example):\nclass MyFileHandler(tornado.web.StaticFileHandler):\n    def write_error(self, status_code, **kwargs):\n        if status_code == 404:\n            self.redirect('http://example.com') # Fetching a default resource\nand in my Application class:\nhandlers = [\n        (r'/', IndexHandler),\n        (r'/static/(.*)', MyFileHandler, {'path': 'path/to/my/resources'}),\n]\nSurprisingly, this works. But I didn't \"install that class with static_handler_class\". There is not much information available about static_handler_class. Would you be able to provide more details?\nThank you", "issue_status": "Closed", "issue_reporting_time": "2016-04-20T21:40:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "515": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1696", "issue_id": "#1696", "issue_summary": "recommended usage of AsyncIOMainLoop throws assertion", "issue_description": "aie0 commented on 20 Apr 2016\nfrom tornado.platform.asyncio import AsyncIOMainLoop import asyncio AsyncIOMainLoop().install() asyncio.get_event_loop().run_forever()\ninstall method throws assertion:\npackages/tornado/ioloop.py\", line 176, in install\nassert not IOLoop.initialized()\nAssertionError", "issue_status": "Closed", "issue_reporting_time": "2016-04-20T12:29:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "516": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1695", "issue_id": "#1695", "issue_summary": "Logging suppress", "issue_description": "vit1251 commented on 20 Apr 2016\nPlease does not call logging.basicConfig() you suppress custom logging configuration.", "issue_status": "Closed", "issue_reporting_time": "2016-04-20T01:17:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "517": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1693", "issue_id": "#1693", "issue_summary": "get_template_namespace throws exception after request finish()", "issue_description": "Contributor\njvhellemond commented on 18 Apr 2016\nThis may be a bit of an edge case, but here goes:\nRequestHandler.get_template_namespace (web.py:828) calls namespace.update(self.ui), expecting self.ui to be a dict. But RequestHandler.finish (web.py:939) sets self.ui = None after first calling self.on_finish(). This means that any (implicit) call to get_template_namespace in an async on_finish function throws an exception.\nIn my case I have a on_finish function that waits for (yields) an async HTTP-request and then renders a template, using self.render_string, to send an email. Rendering the template fails, because (I think) get_template_namespace is called, which tries to update the template namespace dict with self.ui which has by now been set to None.\nCould setting self.ui = None be delayed until any RequestHandler.on_finish has completed and has no more async results to yield?", "issue_status": "Closed", "issue_reporting_time": "2016-04-18T15:29:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "518": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1692", "issue_id": "#1692", "issue_summary": "wrong xsrf format cause check_xsrf_cookie throw Uncaught Exception", "issue_description": "BingLau7 commented on 16 Apr 2016\nthis is error log\nTraceback (most recent call last):\n  File \"/home/huntcoder/.buildout/tornado-4.2-py2.7-linux-x86_64.egg/tornado/web.py\", line 1388, in _execute\n    self.check_xsrf_cookie()\n  File \"/home/huntcoder/.buildout/tornado-4.2-py2.7-linux-x86_64.egg/tornado/web.py\", line 1236, in check_xsrf_cookie\n    if not _time_independent_equals(utf8(token), utf8(expected_token)):\n  File \"/home/huntcoder/.buildout/tornado-4.2-py2.7-linux-x86_64.egg/tornado/web.py\", line 2969, in _time_independent_equals\n    if len(a) != len(b):\nTypeError: object of type 'NoneType' has no len()\nIn source code, if my xsrf cookie format is error, _decode_xsrf_token return None, None, None, and the check_xsrf_cookie function's _time_independent_equals(utf8(token), utf8(expected_token)) is wrong, the token is None and has no len().\nI think of the if judgment statement can modify if not token or _time_independent_equals(utf8(token), utf8(expected_token))", "issue_status": "Closed", "issue_reporting_time": "2016-04-16T07:28:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "519": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1690", "issue_id": "#1690", "issue_summary": "Hardcode CSS mimetype for StaticFileHandler?", "issue_description": "Contributor\ntakluyver commented on 14 Apr 2016\nThe implementation of StaticFileHandler uses mimetypes.guess_type() to determine the Content-Type header for the files it sends. We (Jupyter) have seen an issue several times with Windows users where CSS files are served as the wrong mimetype because of an entry in the registry. Browsers then refuse to load them as stylesheets, and display an unstyled page.\nWe are considering subclassing SFH to special-case .css files and always serve with the text/css mimetype: jupyter/notebook#1350.\nThis issue is actually more general, even if most use cases don't involve serving from arbitrary Windows machines. So we wanted to ask whether you'd consider special-casing .css within Tornado to override the default mimetype guess? Special casing it feels a bit icky, but we've seen the same thing enough times now that I reckon we need to fix it, so we'll probably do it at the application level if it's not acceptable in Tornado.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2016-04-14T14:10:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "520": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1688", "issue_id": "#1688", "issue_summary": "`await` with `ThreadPoolExecutor` is awkward", "issue_description": "Member\nbdarnell commented on 10 Apr 2016\nFutures from the concurrent.futures package are not awaitable. Until that package is updated, an adapter function is needed. convert_yielded is usually recommended as the adapter for this scenario, but as a special optimization, it passes concurrent futures through unmodified. Perhaps this optimization should be removed, and concurrent futures should be wrapped just like asyncio futures.\nAs an interim solution, tornado.platform.asyncio.to_tornado_future works in this case even though it was only intended to accept asyncio futures.\nhttps://stackoverflow.com/questions/36524431/is-this-style-of-using-thread-pool-with-tornado-ok", "issue_status": "Closed", "issue_reporting_time": "2016-04-10T16:07:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "521": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1686", "issue_id": "#1686", "issue_summary": "Loading html.entities lazily to reduce memory usage?", "issue_description": "Contributor\nbluetech commented on 8 Apr 2016\nThe html.entities module contains a huge dict and is thus somewhat costly to import, as this non-scientific program shows:\nfrom resource import getrusage, RUSAGE_SELF\n\nbefore = getrusage(RUSAGE_SELF)\nimport html.entities\nafter = getrusage(RUSAGE_SELF)\n\nprint(after.ru_maxrss - before.ru_maxrss)\nPrints 528 (kilobytes) here (linux 64 bit, python 3.5).\ntornado.escape imports html.entities, which is used to build _HTML_UNICODE_MAP, which is used in _convert_entity, which is used by xhtml_unescape, which is a public function but is not used anywhere else.\n0.5MB is not so much but can add up when running many processes (I am going through some code trying to reduce memory usage).\nPerhaps it is worth loading this module lazily, only if the xhtml_unescape function is used?", "issue_status": "Closed", "issue_reporting_time": "2016-04-08T14:52:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "522": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1685", "issue_id": "#1685", "issue_summary": "Suboptimal performance sending large messages", "issue_description": "Contributor\nmrocklin commented on 7 Apr 2016\nI notice that when I send large messages over a TCP IOStream I get considerably less bandwidth than my network provides (about 10% of total). A bit of profiling shows that a large fraction of time is spent in str.join and str.find.\nBelow follows a tiny example to replicate this on localhost.\nServer\nfrom tornado.tcpserver import TCPServer\nfrom tornado.ioloop import IOLoop\nfrom tornado import gen\n\nimport numpy as np\ndata = bytes(np.random.randint(0, 255, dtype='u1', size=100000000).data) # 100M\n\nsentinel = b'--my-sentinel--'\n\nclass MyServer(TCPServer):\n    @gen.coroutine\n    def handle_stream(self, stream, address):\n        yield stream.write(data + sentinel)\n\ns = MyServer()\ns.listen(8000)\n\nIOLoop.current().start()\nClient\nfrom tornado.tcpclient import TCPClient\nfrom tornado.ioloop import IOLoop\nfrom tornado import gen\n\nsentinel = b'--my-sentinel--'\n\n@gen.coroutine\ndef f(): \n    client = TCPClient()\n    stream = yield client.connect('localhost', 8000,\n                                  max_buffer_size=int(1e9))\n    msg = yield stream.read_until(sentinel)\n    print(len(msg))\n\nif __name__ == '__main__':\n    IOLoop().run_sync(f)\nAdd a bit of network delay\nThis adds 10ms on to localhost, just to simulate being in a real network\n# tc qdisc add dev lo root netem delay 10ms\nRemove network delay when done\n# tc qdisc del dev lo root netem\nProfiler output\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n       92    0.430    0.005    0.430    0.005 {method 'find' of 'str' objects}\n       46    0.249    0.005    0.249    0.005 {method 'join' of 'str' objects}\n       25    0.216    0.009    0.216    0.009 {method 'poll' of 'select.epoll' objects}\n     1553    0.019    0.000    0.019    0.000 {method 'recv' of '_socket.socket' objects}\n       46    0.008    0.000    0.259    0.006 iostream.py:1501(_double_prefix)\n     1553    0.002    0.000    0.022    0.000 iostream.py:721(_read_to_buffer)\n       22    0.002    0.000    0.715    0.032 iostream.py:585(_read_to_buffer_loop)\n       47    0.001    0.000    0.251    0.005 iostream.py:1510(_merge_prefix)\n     1553    0.001    0.000    0.020    0.000 iostream.py:1010(read_from_fd)\n        1    0.001    0.001    0.934    0.934 ioloop.py:746(start)\n       48    0.001    0.000    0.690    0.014 iostream.py:772(_find_read_pos)\n     6549    0.000    0.000    0.000    0.000 {len}\n\n   Ordered by: cumulative time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        1    0.000    0.000    0.957    0.957 <string>:1(<module>)\n        1    0.000    0.000    0.957    0.957 ioloop.py:400(run_sync)\n        1    0.001    0.001    0.957    0.957 ioloop.py:746(start)\n       29    0.000    0.000    0.757    0.026 stack_context.py:271(null_wrapper)\n       23    0.000    0.000    0.756    0.033 iostream.py:497(_handle_events)\n       22    0.000    0.000    0.755    0.034 iostream.py:645(_handle_read)\n       23    0.002    0.000    0.755    0.033 iostream.py:585(_read_to_buffer_loop)\n       49    0.001    0.000    0.727    0.015 iostream.py:772(_find_read_pos)\n       94    0.454    0.005    0.454    0.005 {method 'find' of 'str' objects}\n       47    0.008    0.000    0.272    0.006 iostream.py:1501(_double_prefix)\n       48    0.002    0.000    0.264    0.005 iostream.py:1510(_merge_prefix)\n       47    0.261    0.006    0.261    0.006 {method 'join' of 'str' objects}\n       26    0.198    0.008    0.198    0.008 {method 'poll' of 'select.epoll' objects}\n     1553    0.002    0.000    0.026    0.000 iostream.py:721(_read_to_buffer)\n     1553    0.001    0.000    0.023    0.000 iostream.py:1010(read_from_fd)\n     1553    0.022    0.000    0.022    0.000 {method 'recv' of '_socket.socket' objects}\n        5    0.000    0.000    0.001    0.000 ioloop.py:594(_run_callback)\n        3    0.000    0.000    0.001    0.000 client.py:7(f)\n1", "issue_status": "Closed", "issue_reporting_time": "2016-04-07T03:02:54Z", "fixed_by": "#1873", "pull_request_summary": "Use bytearray buffers in IOStream", "pull_request_description": "Contributor\npitrou commented on 2 Nov 2016 \u2022\nedited\nReplace the deques of chunks in IOStream with simple bytearrays. This simplifies and optimizes buffer management, removing many extraneous copies.\nAlso allow a memoryview as write() argument, as that's useful to avoid copies in applications.\nSeems to fix #1685. @mrocklin\n1", "pull_request_status": "Merged", "issue_fixed_time": "2017-02-21T03:28:09Z", "files_changed": [["198", "tornado/iostream.py"], ["11", "tornado/test/iostream_test.py"]]}, "523": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1684", "issue_id": "#1684", "issue_summary": "Using asyncio.gather switch back to the asyncio runner", "issue_description": "arthurdarcet commented on 6 Apr 2016\nthe asyncio runner does not handle tornado Futures, so the docs should probably warn that using asyncio.gather will fail if one of the gathered coroutine tries to await a tornado coroutine.\nAn option would be to try making the asyncio runner able to handle tornado futures: this seems to do the trick arthurdarcet/tornado@master...arthurdarcet:asyncio-runner but i haven't extensively tested it\u2026\nIf the asyncio runner handles tornado coroutines, then the to_asyncio_future on the first awaited coroutine.\nExample code:\nimport asyncio\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.platform.asyncio\n\nasync def do_tornado():\n    await tornado.gen.coroutine(lambda: None)()\n    print('tornado')\n\nasync def main():\n    await tornado.gen.multi([do_tornado()])\n    # this will fail:\n    await asyncio.gather(do_tornado())\n\ntornado.platform.asyncio.AsyncIOMainLoop().install()\n\ncoro = main()\n# not needed anymore\n#coro = tornado.platform.asyncio.to_asyncio_future(coro)\n\nloop = tornado.ioloop.IOLoop.current()\nloop.run_sync(lambda: coro)\n# or:\n#loop = asyncio.get_event_loop()\n#loop.run_until_complete(coro)", "issue_status": "Closed", "issue_reporting_time": "2016-04-06T10:57:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "524": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1681", "issue_id": "#1681", "issue_summary": "Now I have a project developed by tornado, can I run it with gunicorn without change my code or change a little\uff1fif so, how?", "issue_description": "cx3ptr commented on 3 Apr 2016\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2016-04-03T08:59:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "525": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1680", "issue_id": "#1680", "issue_summary": "Strange dependency issue", "issue_description": "CaveSpectre commented on 1 Apr 2016\nI have been battling an issue with tornado and my websocket ending up into the frozen iostream codepath, and infinitely looping. I have been attempting to upgrade to tornado to 4.3 but I keep running into problems. I successfully upgraded to 4.0.2 and my problem did not resolve.\nThe issue I am having with 4.3 is the singledispatch requirement. When I try to install singledispatch directly, it complains about not having a module named setuptools. When I try to install python-singledispatch, I end up with a strange response:\nts7800:~# apt-get install python-singledispatch\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nSome packages could not be installed. This may mean that you have\nrequested an impossible situation or if you are using the unstable\ndistribution that some required packages have not yet been created\nor been moved out of Incoming.\nThe following information may help to resolve the situation:\n\nThe following packages have unmet dependencies:\n  python-singledispatch: Depends: python:any (>= 2.7.5-5~) but it is not installable\n                         Depends: python-six but it is not going to be installed\n                         Depends: python:any (< 2.8) but it is not installable\nE: Broken packages\nBut python is 2.7.9, so within the range:\nts7800:~# python --version\nPython 2.7.9\nDoes anyone have any suggestions of how to resolve this?", "issue_status": "Closed", "issue_reporting_time": "2016-04-01T16:42:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "526": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1679", "issue_id": "#1679", "issue_summary": "tornado.process.fork_process served confused", "issue_description": "frtmelody commented on 1 Apr 2016\nI have use multiprocess in tornao httpserver, i have created 100 subprocess to serve. I think this server can server 30 request/sec, but only 3 request/sec. Why ?\nab -n100 http://127.0.0.1:8084\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport time\n\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.netutil\nimport tornado.process\n# from tornado.options import define, options\n\n\n# define(\"port\", default=8101, help=\"run on the given port\", type=int)\n\n\nclass LongHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        time.sleep(3)\n        self.write(str(os.getpid()))\n\n\nif __name__ == \"__main__\":\n    # tornado.options.parse_command_line()\n    app = tornado.web.Application(([r'/', LongHandler], ))\n    sockets = tornado.netutil.bind_sockets(18090)\n    tornado.process.fork_processes(100)\n    server = tornado.httpserver.HTTPServer(app)\n    # server.listen(options.port)\n    server.add_sockets(sockets)\n    tornado.ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2016-04-01T03:34:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "527": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1676", "issue_id": "#1676", "issue_summary": "A small problem about code comments.", "issue_description": "Contributor\nJZQT commented on 29 Mar 2016\nhttpclient.py\nclass AsyncHTTPClient(Configurable):\n    \"\"\"An non-blocking HTTP client.\n\n    Example usage::\n\n        def handle_request(response):\n            if response.error:\n                print \"Error:\", response.error\n            else:\n                print response.body\n\n        http_client = AsyncHTTPClient()\n        http_client.fetch(\"http://www.google.com/\", handle_request)\n\n    ......\nfunction name should is handle_response ???", "issue_status": "Closed", "issue_reporting_time": "2016-03-29T11:57:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "528": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1675", "issue_id": "#1675", "issue_summary": "Initialization in tornado + sqlalchemy", "issue_description": "rsmith31415 commented on 27 Mar 2016\nI want to use tornado with sqlalchemy (no async), but I'm not entirely sure about the initialization of the database connection. Basically, I have the following:\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\nclass Database(object):\n    def __init__(self):\n        # using reflection because I have an existing database\n        self.Base = automap_base()\n        self.engine = create_engine('sqlite:///my-database.db')\n        self.Base.prepare(self.engine, reflect=True) \n\nclass IndexHandler(tornado.web.RequestHandler):\n    def initialize(self):\n        self.session = self.application.session\n\n    def on_finish(self):\n        self.session.remove()\n\nclass Application(tornado.web.Application):\n\n    def __init__(self):\n        self.database = Database()\n        self.session = scoped_session(sessionmaker(bind=self.database.engine))\n\n        dirname = os.path.dirname(__file__)\n\n        handlers = [\n            (r'/', IndexHandler),\n        ]\n        settings = {\n            'debug': True,\n            'static_path': os.path.join(dirname, 'static'),\n        }\n\n        tornado.web.Application.__init__(self, handlers, **settings)\nI have read a couple of related resources. This blogpost suggests creating the engine in a separate class, passing this engine to the application and initiating a scope_session there. I don't think the author is deleting the session after finishing the request, but I added that part in my sample code.\nOn the other hand, this gist instantiates a BaseHandler class that creates the engine and provides a session. In this case, I think, every time you get a request, a new engine and session is created. In the previous example, only a new session is created. I'm not sure if that is an important difference.\nFinally, the sqlalchemy documentation provides this helpful diagram which is similar to what the blogpost is doing:\nWeb Server          Web Framework        SQLAlchemy ORM Code\n--------------      --------------       ------------------------------\nstartup        ->   Web framework        # Session registry is established\n                    initializes          Session = scoped_session(sessionmaker())\n\nincoming\nweb request    ->   web request     ->   # The registry is *optionally*\n                    starts               # called upon explicitly to create\n                                         # a Session local to the thread and/or request\n                                         Session()\n\n                                         # the Session registry can otherwise\n                                         # be used at any time, creating the\n                                         # request-local Session() if not present,\n                                         # or returning the existing one\n                                         Session.query(MyClass) # ...\n\n                                         Session.add(some_object) # ...\n\n                                         # if data was modified, commit the\n                                         # transaction\n                                         Session.commit()\n\n                    web request ends  -> # the registry is instructed to\n                                         # remove the Session\n                                         Session.remove()\n\n                    sends output      <-\noutgoing web    <-\nresponse\nSo what is the proper way to initialize things here?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2016-03-27T16:28:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "529": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1673", "issue_id": "#1673", "issue_summary": "Why can't I access URL parameters from the prepare() method?", "issue_description": "wil93 commented on 25 Mar 2016\nI am using tornado and I declared a RequestHandler with a single parameter like this:\nclass StuffHandler(RequestHandler):\n    def get(self, stuff_name):\n        ...\n\napp = Application([\n    (r'/stuff/(.*)/public', StuffHandler)\n])\nNow I added another handler for '/stuff/(.*)/private', which requires the user to be authenticated:\nclass PrivateStuffHandler(RequestHandler):\n    @tornado.web.authenticated\n    def get(self, stuff_name):\n        ...\nThis of course will cause get_current_user() to be called before get(). The problem is that, in order for get_current_user() to run, I need to know the stuff_name parameter.\nSo I thought that I may use the prepare() or the initialize() method, which is called before get_current_user(). However, I can't seem to access stuff_name from those methods. I tried putting stuff_name as a parameter but it didn't work, then I tried calling self.get_argument(\"stuff_name\") but it didn't work either.\nWhy can't I access an URL parameter from the prepare() method?\nI am now looking at the source code here: https://github.com/tornadoweb/tornado/blob/8fb0164ea63d2603e743fbd47d760b1e6df96a54/tornado/web.py#L1413L1422\nShouldn't the line 1422 be changed from\nresult = self.prepare()\nto:\nresult = self.prepare(*self.path_args, **self.path_kwargs)\n?", "issue_status": "Closed", "issue_reporting_time": "2016-03-25T12:13:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "530": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1672", "issue_id": "#1672", "issue_summary": "SSL issues on Tornado 4.3.0", "issue_description": "viyatb commented on 23 Mar 2016\nHi @bdarnell, I am having a problem in removing an error.\nOur proxy (OWTF mitm) has a function:\n    @tornado.web.asynchronous\n    def connect(self):\n        \"\"\"\n        This function gets called when a connect request is received.\n        * The host and port are obtained from the request uri\n        * A socket is created, wrapped in ssl and then added to SSLIOStream\n        * This stream is used to connect to speak to the remote host on given port\n        * If the server speaks ssl on that port, callback start_tunnel is called\n        * An OK response is written back to client\n        * The client side socket is wrapped in ssl\n        * If the wrapping is successful, a new SSLIOStream is made using that socket\n        * The stream is added back to the server for monitoring\n        \"\"\"\n        host, port = self.request.uri.split(':')\n        def start_tunnel():\n            try:\n                self.request.connection.stream.write(b\"HTTP/1.1 200 Connection established\\r\\n\\r\\n\")\n                wrap_socket(\n                            self.request.connection.stream.socket,\n                            host,\n                            self.application.ca_cert,\n                            self.application.ca_key,\n                            self.application.ca_key_pass,\n                            self.application.certs_folder,\n                            success=ssl_success\n                           )\n            except tornado.iostream.StreamClosedError:\n                pass\n\n        def ssl_success(client_socket):\n            client = tornado.iostream.SSLIOStream(client_socket)\n            server.handle_stream(client, self.application.inbound_ip)\n\n        # Tiny Hack to satisfy proxychains CONNECT request to HTTP port.\n        # HTTPS fail check has to be improvised\n        def ssl_fail():\n            try:\n                self.request.connection.stream.write(b\"HTTP/1.1 200 Connection established\\r\\n\\r\\n\")\n            except tornado.iostream.StreamClosedError:\n                pass\n            server.handle_stream(self.request.connection.stream, self.application.inbound_ip)\n\n        # Hacking to be done here, so as to check for ssl using proxy and auth\n        try:\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0))\n            upstream = tornado.iostream.SSLIOStream(s)\n            #start_tunnel()\n            upstream.set_close_callback(ssl_fail)\n            upstream.connect((host, int(port)), start_tunnel)\n        except Exception:\n            self.finish()\nIt ran fine on Tornado 4.0.2 but the upgrade causes this error\n[E 160323 01:43:59 ioloop:629] Exception in callback None\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 883, in start\n        handler_func(fd_obj, events)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 275, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 507, in _handle_events\n        self._handle_connect()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 1376, in _handle_connect\n        do_handshake_on_connect=False)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/netutil.py\", line 519, in ssl_wrap_socket\n        return context.wrap_socket(socket, **kwargs)\n      File \"/usr/lib/python2.7/ssl.py\", line 350, in wrap_socket\n        _context=self)\n      File \"/usr/lib/python2.7/ssl.py\", line 537, in __init__\n        raise ValueError(\"check_hostname requires server_hostname\")\n    ValueError: check_hostname requires server_hostname\nMultiple issues like this have been archived, for instance urllib3/urllib3#517.\nUsing s = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0), server_hostname=host) seems to silence the errors, but the request never goes beyond the initial connect request.\nIs this tornado related or just a problem in SSL handshake in the proxy?", "issue_status": "Closed", "issue_reporting_time": "2016-03-23T05:52:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "531": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1671", "issue_id": "#1671", "issue_summary": "How to achieve the server side jump", "issue_description": "szcountryboy commented on 22 Mar 2016\nself.redirect (\"/a/b\") this is the client to jump, that is, the URL bar shows the jump after the URL\nHow to carry out the server segment to jump it similar to servlet Java (redirect, forward) inside the forward, the server side after the jump, the client address bar does not need to change, show or jump before the URL", "issue_status": "Closed", "issue_reporting_time": "2016-03-22T03:15:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "532": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1670", "issue_id": "#1670", "issue_summary": "When Use AsyncHttpClien.AttributeError: 'GZipContentEncoding' object has no attribute '_gzip_file'", "issue_description": "892768447 commented on 21 Mar 2016\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\web.py\", line 781, in render\nself.finish(html)\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\web.py\", line 932, in finish\nself.flush(include_footers=True)\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\web.py\", line 891, in flush\nchunk = transform.transform_chunk(chunk, include_footers)\nFile \"D:\\Python3.4.3\\lib\\site-packages\\tornado-4.3-py3.4-win32.egg\\tornado\\web.py\", line 2763, in transform_chunk\nself._gzip_file.write(chunk)\nAttributeError: 'GZipContentEncoding' object has no attribute '_gzip_file'", "issue_status": "Closed", "issue_reporting_time": "2016-03-21T16:08:12Z", "fixed_by": "#1699", "pull_request_summary": "Begin to fix type confusion in HTTPHeaders.", "pull_request_description": "Member\nbdarnell commented on 24 Apr 2016\nValues in HTTPHeaders were typed inconsistently: the class itself\nassumed that values were of type str, while many callers assumed they\nwere bytes. Since headers are practically restricted to ascii, this\nwould work on python 2 but fail when certain combinations were\nencountered on python 3 (notably the combination of GzipContentEncoding\nwith multiple preexisting Vary headers).\nThis commit adds a test and fixes the bug, and also adds enough type\nannotations that mypy was able to report errors in the old incorrect\ncode.\nFixes #1670", "pull_request_status": "Merged", "issue_fixed_time": "2016-04-24T00:11:54Z", "files_changed": [["6", "tornado/escape.py"], ["11", "tornado/http1connection.py"], ["13", "tornado/httputil.py"], ["31", "tornado/test/web_test.py"], ["5", "tornado/util.py"], ["43", "tornado/web.py"]]}, "533": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1669", "issue_id": "#1669", "issue_summary": "os.fork() not supported on windows", "issue_description": "pstanisl commented on 21 Mar 2016\nUnable to start tornado server (on Windows) if the code contains process.fork_processes, because package os doesn't contains fork.\nAttributeError: 'module' object has no attribute 'fork'", "issue_status": "Closed", "issue_reporting_time": "2016-03-21T14:02:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "534": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1668", "issue_id": "#1668", "issue_summary": "Tornado Stream is closed, cannot see the output message", "issue_description": "ghost commented on 21 Mar 2016\nDear,\nI used a packae using Tornado for I/O.\nhttps://dato.com/learn/gallery/notebooks/intro-regression.html\nHowever, afer running function , the output Tornado seems closed...\nFile \"\\Anaconda2\\envs\\dato-env\\lib\\site-packages\\zmq\\eventloop\\zmqstream.py\", line 492, in _check_closed\nraise IOError(\"Stream is closed\")\nIOError: Stream is closed\nERROR:tornado.application:Exception in callback <functools.partial object at 0x0000000025716E58>\nTraceback (most recent call last):\nHow can I enable back the stream in the script and see the output in IPython ?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2016-03-21T11:06:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "535": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1667", "issue_id": "#1667", "issue_summary": "Error when yielding from concurrent.futures.Future", "issue_description": "Contributor\nmrocklin commented on 18 Mar 2016\nWhen yielding from a concurrent.futures.Future I get this exception:\nyield thread_pool_executor.submit(func, *args)\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 294, in wrapper\n    Runner(result, future, yielded)\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 955, in __init__\n    if self.handle_yield(first_yielded):\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 1097, in handle_yield\n    self.future, lambda f: self.run())\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/ioloop.py\", line 592, in add_future\n    lambda future: self.add_callback(callback, future))\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/concurrent.py\", line 262, in add_done_callback\n    self._callbacks.append(fn)\nAttributeError: 'NoneType' object has no attribute 'append'\ndistributed.utils - ERROR - 'NoneType' object has no attribute 'append'\nAfter some effort I've been unable to reproduce this error locally (my apologies.) My first thought was that I was operating in a thread unsafe manner but I'm not yet able to find anything like this. Any suggestions on either what I might be doing incorrectly or if this is a proper bug in Tornado?\nLooking briefly at the code it seems like there might be an issue if the future were to finish before adding the callback to return to the yield point. Is this a reasonable concern?", "issue_status": "Closed", "issue_reporting_time": "2016-03-18T15:46:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "536": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1666", "issue_id": "#1666", "issue_summary": "unable to use __file__ to get the project base_dir from the tornado.options.parse_config_file.", "issue_description": "hackrole commented on 18 Mar 2016\nI use tornado.options to define a few options and parse from both the file and cmdline.\nthe problem is that I want to get the base_dir by use os.path.realpath(file). which will raise Exception.\nhow can I got out of this. this code was like below.\n# options.py\n# -*- coding: utf-8 -*-\n\nfrom tornado.options import options\n\n\ndef define_options(option_parser):\n    \"\"\"\u5b9a\u4e49\u914d\u7f6e\"\"\"\n    def config_callback(path):\n        option_parser.parse_config_file(path, final=False)\n\n    option_parser.define('config', type=str, help=\"config file path\",\n                         callback=config_callback, group=\"config file\")\n    option_parser.define('file_path', type=str, help=\"path\",\n                         group=\"config\")\n    return option_parser\n\nif __name__ == \"__main__\":\n    opts = define_options(options)\n    opts.parse_command_line(['options.py', '--config=config.py'])\n    print opts.host, opts.port\n\n# config.py\n# -*- coding: utf-8 -*-\n\nfrom os import path\n\n\n# this will raise\nbase_path = path.dirname(path.realpath(__file__))\n\nfile_path = path.join(base_path, 'hello.ini')\nwhile I run python options.py, it will raise Error. the error msg was beow.\n$ python options.py\nTraceback (most recent call last):\n  File \"options.py\", line 19, in <module>\n    opts.parse_command_line(['options.py', '--config=config.py'])\n  File \"/home/daipeng/.virtualenvs/logagent_env/local/lib/python2.7/site-packages/tornado/options.py\", line 286, in parse_command_line\n    option.parse(value)\n  File \"/home/daipeng/.virtualenvs/logagent_env/local/lib/python2.7/site-packages/tornado/options.py\", line 448, in parse\n    self.callback(self._value)\n  File \"options.py\", line 9, in config_callback\n    option_parser.parse_config_file(path, final=False)\n  File \"/home/daipeng/.virtualenvs/logagent_env/local/lib/python2.7/site-packages/tornado/options.py\", line 306, in parse_config_file\n    exec_in(native_str(f.read()), config, config)\n  File \"<string>\", line 10, in exec_in\n  File \"<string>\", line 7, in <module>\nNameError: name '__file__' is not defined", "issue_status": "Closed", "issue_reporting_time": "2016-03-18T06:54:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "537": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1663", "issue_id": "#1663", "issue_summary": "ApacheBench | AttributeError: 'NoneType' object has no attribute 'decode'", "issue_description": "bensooraj commented on 13 Mar 2016\nI am trying to run a simple benchmark test for the async requests. Following is the code:\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.httpclient\nfrom tornado.options import define, options\nimport urllib, urllib.parse\nimport json\nimport datetime\nimport time\nimport oauth2\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\n\ndef authorize(url):\n    // Returns the OAuth GET request string\n\nclass IndexHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        query = self.get_argument('q')\n        client = tornado.httpclient.AsyncHTTPClient()\n\n        url = \"https://api.twitter.com/1.1/search/tweets.json?\" + \\\n              urllib.parse.urlencode(\n                  {\n                      \"q\": query.encode('utf8'),\n                      \"result_type\": \"recent\",\n                      \"count\": 100\n                  }\n              )\n        client.fetch(url,\n                     headers={'Authorization': authorize(url=url)},\n                     callback=self.on_response)\n\n    def on_response(self, response):\n        print(response.body.decode(\"utf-8\")[:600])\n        body = json.loads(response.body.decode(\"utf-8\"))\n        result_count = len(body['statuses'])\n        now = datetime.datetime.now()\n        raw_oldest_tweet_at = body['statuses'][-1]['created_at']\n        oldest_tweet_at = datetime.datetime.strptime(raw_oldest_tweet_at,\n                                                     \"%a %b %d %H:%M:%S +0000 %Y\")\n        seconds_diff = time.mktime(now.timetuple()) - time.mktime(oldest_tweet_at.timetuple())\n        tweets_per_second = float(result_count) / seconds_diff\n\n        self.write(\"\"\"\n        <div style=\"text-align: center\">\n        <div style=\"font-size: 72px\">%s</div>\n        <div style=\"font-size: 144px\">%.03f</div>\n        <div style=\"font-size: 24px\">tweets per second</div>\n        </div>\"\"\" % (self.get_argument('q'), tweets_per_second))\n\n        self.finish()\n\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n\n    app = tornado.web.Application(handlers=[\n        (r\"/\", IndexHandler)\n    ], debug=True)\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\nI run the following command at the CLI:\nab -c5 -t20s http://localhost:8888/?q=pants\nwhere,\n-c => concurrency (Number of multiple requests to make at a time)\n-t => timelimit (Seconds to max. to spend on benchmarking)\nThe stack trace:\n[E 160313 21:12:13 web:1496] Uncaught exception GET /?q=pants (::1)\n    HTTPServerRequest(protocol='http', host='localhost:8888', method='GET', uri='/?q=pants', version='HTTP/1.0', remote_ip='::1', headers={'Host': 'localhost:8888', 'User-Agent': 'ApacheBench/2.3', 'Accept': '*/*'})\n    Traceback (most recent call last):\n      File \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/tornado/web.py\", line 1369, in _stack_context_handle_exception\n        raise_exc_info((type, value, traceback))\n      File \"<string>\", line 3, in raise_exc_info\n      File \"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/tornado/stack_context.py\", line 314, in wrapped\n        ret = fn(*args, **kwargs)\n      File \"/Users/Bensooraj/Desktop/tornado_sandbox/playground/tornado_TweetPerSecondSync/tweet_rate_async.py\", line 60, in on_response\n        print(response.body.decode(\"utf-8\")[:600])\n    AttributeError: 'NoneType' object has no attribute 'decode'\n[E 160313 21:12:13 web:1908] 500 GET /?q=pants (::1) 22288.87ms\n\n\n// First 600 characters of the second response\n[I 160313 21:12:14 web:1908] 200 GET /?q=pants (::1) 14016.38ms\n// First 600 characters of the third response\n[I 160313 21:12:14 web:1908] 200 GET /?q=pants (::1) 8999.25ms\n// First 600 characters of the fourth response\n[I 160313 21:12:14 web:1908] 200 GET /?q=pants (::1) 19054.25ms\n// First 600 characters of the fifth response\n[I 160313 21:12:15 web:1908] 200 GET /?q=pants (::1) 4325.70ms\nThis works perfect for single requests. As you can see, 1 out of the 5 requests has resulted in the AttributeError. But as I increase the concurrency levels, the problem aggravates (that is, more number of requests fail even though some succeed). Could this be a timeout issue?\nAny help will be highly appreciated.", "issue_status": "Closed", "issue_reporting_time": "2016-03-13T16:33:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "538": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1660", "issue_id": "#1660", "issue_summary": "Python 64-bit crashes when using `tornado` `CurlAsyncHTTPClient` on Windows", "issue_description": "yannmh commented on 10 Mar 2016\nHello,\nI recently found an issue that causes Python 64-bit to crash when using tornado CurlAsyncHTTPClient on Windows .\nFor example, the following snippet\nimport tornado.ioloop\nimport tornado.httpclient\n\ntornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\nhttp_client = tornado.httpclient.AsyncHTTPClient()\n\ndef done(r):\n    print \"done!\", r\n\nresponse = http_client.fetch(\"https://google.com\", done)\n\ntornado.ioloop.IOLoop.instance().start()\nwould immediately stops, and raises a \"python.exe has stopped working\" Windows pop-up.\nAt the opposite, it does not happen with Python 32-bit.\nInvestigating a little more, the crash occurs at this line and the Event Log shows it's happening within pycurl.pyd module.\nI opened a ticket with the PycURL team to report the issue and get their thoughts about it:\npycurl/pycurl#395. The early feedback shows it could be related to libcurl.\nNevertheless, I thought it'd be interesting to share the issue and maybe get your thoughts about a potential workaround.\nVersions\nPython version\nPython 2.7.11 (v2.7.11:6d1b6a68f775, Dec  5 2015, 20:40:30) [MSC v.1500 64 bit (AMD64)] on win32\nTornado version\n4.3\nPycURL version\nPycURL/7.43.0 libcurl/7.47.0 OpenSSL/1.0.2e zlib/1.2.8 c-ares/1.10.0 libssh2/1.6.0\nBest,\nYann", "issue_status": "Closed", "issue_reporting_time": "2016-03-10T18:24:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "539": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1659", "issue_id": "#1659", "issue_summary": "Calling `Future._set_done` twice causes `TypeError`", "issue_description": "dave-shawley commented on 7 Mar 2016\nI'm not completely sure how this is happening but I noticed that we are getting a TypeError raised from within Future._set_done. I believe that this is caused by calling one of the set functions more than once. Yes, I know that this is \"undefined\" behavior and I am not completely sure this is how it is happening. What I am sure of is that the implementation of Future._set_done is pretty fragile:\ndef _set_done(self):\n    self._done = True\n    for cb in self._callbacks:\n        try:\n            cb(self)\n        exception Exception:\n            app_log.exception('Exception in callback %r for %r',\n                              cb, self)\n    self._callbacks = None\nThe last line is the problematic one. Is there any reason for not simply doing del self._callbacks[:] or self._callbacks = []? This would avoid the possibility of raising a TypeError here.", "issue_status": "Closed", "issue_reporting_time": "2016-03-06T20:00:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "540": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1656", "issue_id": "#1656", "issue_summary": "current_user's docstring example has unexpected indent", "issue_description": "Contributor\ntao12345666333 commented on 3 Mar 2016\nIn web.py L1075 the example code has unexpected indent.", "issue_status": "Closed", "issue_reporting_time": "2016-03-03T14:58:43Z", "fixed_by": "#1657", "pull_request_summary": "fix tornado/web.py #L1075 current_user docstring example", "pull_request_description": "Contributor\ntao12345666333 commented on 3 Mar 2016\nThe example has unexpected indent. fix #1656", "pull_request_status": "Merged", "issue_fixed_time": "2016-03-04T02:14:51Z", "files_changed": [["4", "tornado/web.py"]]}, "541": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1655", "issue_id": "#1655", "issue_summary": "Bokeh + Tornado not working on Raspberry pi", "issue_description": "multimedial commented on 29 Feb 2016\nHello,\nI am using the bokeh graph server and it uses Tornado for websockets to server streaming data to be displayed in the browser.\nI filed a bug against Bokeh today as I don't get any data served (see bokeh/bokeh#3961).\nI was redirected to your project as it seems as if the error stems from the tornado module.\nIn short, none of the server examples of Bokeh do run on the Raspberry pi (I am using a Raspberry pi 2). The reason seems to be that Tornado takes too long and/or times out the websocket (see below, and the bug report at Bokeh provided at the URL above).\nI would be very grateful if this could be adressed, as I would very much like to use bokeh for a commercial visualization project...\nThank you for your time and consideration.\n`pi@raspberrypi:~ bokeh serve bokeh_single_plot.py --host 192.168.178.16:80\n2016-02-29 16:00:25,431 Starting Bokeh server version 0.12.0dev1\n2016-02-29 16:00:25,434 Allowed Host headers: ['192.168.178.16:80']\n2016-02-29 16:00:25,435 These host origins can connect to the websocket: ['localhost:5006', '192.168.178.16:80']\n2016-02-29 16:00:25,436 Patterns are: [('/bokeh_single_plot/?', , {'application_context': , 'bokeh_websocket_path': '/bokeh_single_plot/ws'}), ('/bokeh_single_plot/ws', , {'application_context': , 'bokeh_websocket_path': '/bokeh_single_plot/ws'}), ('/bokeh_single_plot/autoload.js', , {'application_context': , 'bokeh_websocket_path': '/bokeh_single_plot/ws'}), ('/static/(.*)', )]\n2016-02-29 16:00:25,457 Starting Bokeh server on port 5006 with applications at paths ['/bokeh_single_plot']\n2016-02-29 16:00:40,473 [pid 5076] 0 clients connected\n2016-02-29 16:00:40,475 [pid 5076] /bokeh_single_plot has 0 sessions with 0 unused\n2016-02-29 16:00:55,471 [pid 5076] 0 clients connected\n2016-02-29 16:00:55,473 [pid 5076] /bokeh_single_plot has 0 sessions with 0 unused\n2016-02-29 16:01:10,280 404 GET /Kemper (127.0.0.1) 6.83ms\n2016-02-29 16:01:10,458 [pid 5076] 0 clients connected\n2016-02-29 16:01:10,459 [pid 5076] /bokeh_single_plot has 0 sessions with 0 unused\n2016-02-29 16:01:19,159 Running state NOT_YET_CONNECTED\n2016-02-29 16:01:39,185 Failed to connect to server: HTTPError(599, 'Timeout', None)\n2016-02-29 16:01:39,188 transitioning to state DISCONNECTED\n2016-02-29 16:01:39,190 Stopping client loop in state DISCONNECTED due to True from connected_or_closed\n2016-02-29 16:01:39,196 Error running application handler : Cannot push session document because we failed to connect to the server (to start the server, try the 'bokeh serve' command)\nFile \"session.py\", line 269, in push:\nraise IOError(\"Cannot push session document because we failed to connect to the server (to start the server, try the 'bokeh serve' command)\") Traceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/bokeh/application/handlers/code_runner.py\", line 71, in run\nexec(self.code, module._dict)\nFile \"/home/pi/bokeh_single_plot.py\", line 41, in\nsession = push_session(curdoc())\nFile \"/usr/local/lib/python2.7/dist-packages/bokeh/client/session.py\", line 63, in push_session\nsession.push(document)\nFile \"/usr/local/lib/python2.7/dist-packages/bokeh/client/session.py\", line 269, in push\nraise IOError(\"Cannot push session document because we failed to connect to the server (to start the server, try the 'bokeh serve' command)\")\nIOError: Cannot push session document because we failed to connect to the server (to start the server, try the 'bokeh serve' command)\n2016-02-29 16:01:39,321 200 GET /bokeh_single_plot (127.0.0.1) 20503.33ms\n2016-02-29 16:01:39,328 [pid 5076] 0 clients connected\n2016-02-29 16:01:39,330 [pid 5076] /bokeh_single_plot has 1 sessions with 1 unused\n2016-02-29 16:01:39,337 404 GET /ws?bokeh-protocol-version=1.0&bokeh-session-id=f6yb1MzJQCiqbsfDhJ5TpR1UnSR3bh58hZKWckTQMXJS (::1) 2.88ms\n2016-02-29 16:01:39,570 WebSocket connection opened\n2016-02-29 16:01:39,572 Receiver created for Protocol(u'1.0')\n2016-02-29 16:01:39,574 ServerHandler created for Protocol(u'1.0')\n2016-02-29 16:01:39,576 ServerConnection created\n2016-02-29 16:01:39,599 Sending pull-doc-reply from session 'vOVYbRtBaqd5mv3oHLUAtNy0DzTZOCyAFVlBU518BHRN'\n2016-02-29 16:01:40,458 [pid 5076] 1 clients connected\n2016-02-29 16:01:40,460 [pid 5076] /bokeh_single_plot has 1 sessions with 0 unused\n2016-02-29 16:01:55,463 [pid 5076] 1 clients connected`", "issue_status": "Closed", "issue_reporting_time": "2016-02-29T18:28:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "542": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1654", "issue_id": "#1654", "issue_summary": "Split code into folders and files", "issue_description": "jonathansp commented on 27 Feb 2016\nHow about splitting tornado's code into folders? For instance, we could rename web.py to __init__.py and put it inside a /web folder. After that, we are able to move handler classes to a file web/handlers.py and import it on init file.\nSome files in tornado seems like a \"god modules\". I think they know too much. If we move code this way, we won't have troubles with legacy code, once we'll be able to set __all__ variable.\nAlso, tests must pass without any changes.", "issue_status": "Closed", "issue_reporting_time": "2016-02-27T00:55:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "543": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1652", "issue_id": "#1652", "issue_summary": "Should the final rendering of JS and CSS assets be done through UI modules?", "issue_description": "Contributor\nemehrkay commented on 25 Feb 2016\nWould it be useful for tornado.web.RequestHandler.render to use UI modules to create the inline and linked JS/CSS? It could be as simple as defining simple modules for each with a render method that does what this code does (https://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L736).\nThe web.Application would define these modules by default allowing developers to override them.\nclass JSFileModule(UIModule):\n\n    def render(self, js_files=None):\n        js_files = js_files or []\n        # copy/paste, not tested\n        paths = []\n        unique_paths = set()\n        for path in js_files:\n            if not is_absolute(path):\n                path = self.static_url(path)\n            if path not in unique_paths:\n                paths.append(path)\n                unique_paths.add(path)\n        return ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                           '\" type=\"text/javascript\"></script>'\n                           for p in paths)\n\n...and so on\n\n# update to web.RequestHandlerRender\n....\nif js_files:\n    js = self.ui['modules'].JSFileModule(js_files)\n    sloc = html.rindex(b'</body>')\n    html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\nThis would be useful in situations where the developer would like more control over how the assets are added to the final markup. A simple example would be writing a custom JSFileModule to combine all of the files into one or uglyify/minimize the assets.\nIf this is something that Tornado should/could do, I'll create the pull request.\nThanks", "issue_status": "Closed", "issue_reporting_time": "2016-02-25T15:16:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "544": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1651", "issue_id": "#1651", "issue_summary": "PeriodicCallback docs or behavior incorrect", "issue_description": "Contributor\nabhinav commented on 25 Feb 2016\nAs per the docs for PeriodicCallback,\nIf the callback runs for longer than callback_time milliseconds, subsequent invocations will be skipped to get back on schedule.\nThis doesn't appear to be the behavior. Here's an example where things are running on time:\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\nfrom tornado.ioloop import PeriodicCallback\n\ncalls = []\nfinished = 0\nstart_time = None\nsleep_time = 0.250\n\n\n@gen.coroutine\ndef cb():\n    global finished\n    calls.append(IOLoop.current().time())\n    yield gen.sleep(sleep_time)\n    finished += 1\n\n\n@gen.coroutine\ndef main():\n    global start_time\n    start_time = IOLoop.current().time()\n    PeriodicCallback(cb, 300).start()\n    yield gen.sleep(1)\n\n\nIOLoop.current().run_sync(main)\nprint \"calls:\", \", \".join(\"%.2f\" % (t - start_time) for t in calls)\nprint \"finished:\", finished\nOutput, as expected:\ncalls: 0.30, 0.60, 0.90\nfinished: 2\n3 invocations at 300 millisecond intervals. The last one doesn't finish because the IOLoop stops too early.\nIf you change the sleep_time to 0.5, you get,\ncalls: 0.30, 0.60, 0.90\nfinished: 1\n3 invocations at 300 millisecond intervals, only one of them finishing. As per the docs, this should really be, \"calls: 0.30, 0.90\" because the one at 0.6 overlaps with the ongoing invocation from 0.3.", "issue_status": "Closed", "issue_reporting_time": "2016-02-24T19:38:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "545": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1650", "issue_id": "#1650", "issue_summary": "WebSocketHandler.on_message should allow coroutines", "issue_description": "jaapz commented on 23 Feb 2016\nI'd like to be able to use python 3.5's async/await syntax as much as possible. However, when I implement a WebSocketHandler and use async/await in the on_message handler, tornado gives me the following error:\n/home/jaapz/Programming/mijnbaopt-websocket/.env/lib/python3.5/site-packages/tornado/websocket.py:417: RuntimeWarning: coroutine 'on_message' was never awaited\nBut when I use tornado.gen.coroutine as a decorator on the on_message method and use the yield from syntax inside it, everything works as expected.\nThe async/await syntax does work on the prepare method of the WebSocketHandler, so it would be nice if it'd also work on on_message.\n3", "issue_status": "Closed", "issue_reporting_time": "2016-02-23T12:43:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "546": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1646", "issue_id": "#1646", "issue_summary": "Are you the author of this project? http://ip-json.rhcloud.com/", "issue_description": "dotku commented on 19 Feb 2016\nI found this project on rhcould and I can't find the author's information but only tornado support... I think I might be able to find the author over here?!", "issue_status": "Closed", "issue_reporting_time": "2016-02-19T07:17:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "547": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1645", "issue_id": "#1645", "issue_summary": "HEAD requests don't write the body but still add Content-Length", "issue_description": "friedcell commented on 18 Feb 2016\nIt seems that when you make a HEAD request, the content (if any) is correctly not written to the response (https://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L892) while the Content-Length header is written (https://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L921) as if all content was present in the body.\nSolution could be as easy as adding and self.request.method != \"HEAD\" to https://github.com/tornadoweb/tornado/blob/master/tornado/web.py#L921", "issue_status": "Closed", "issue_reporting_time": "2016-02-18T16:42:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "548": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1644", "issue_id": "#1644", "issue_summary": "SSLError: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:1750)", "issue_description": "viyatb commented on 17 Feb 2016\nI have observe several SSL errors in our tornado MiTM proxy (at https://github.com/owtf/owtf.git). Here is the stack trace.\n[ERROR] [2016-02-17 11:08:47,950] [File 'web.py', line 1407, in log_exception] - Uncaught exception CONNECT google-gruyere.appspot.com:443 (127.0.0.1)\nHTTPServerRequest(protocol='http', host='127.0.0.1', method='CONNECT', uri='google-gruyere.appspot.com:443', version='HTTP/1.0', remote_ip='127.0.0.1', headers={})\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1288, in _stack_context_handle_exception\n    raise_exc_info((type, value, traceback))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/media/sf_owtf/framework/http/proxy/proxy.py\", line 293, in start_tunnel\n    success=ssl_success\n  File \"/media/sf_owtf/framework/http/proxy/socket_wrapper.py\", line 81, in wrap_socket\n    handshake(wrapped.fileno(), 0)\n  File \"/media/sf_owtf/framework/http/proxy/socket_wrapper.py\", line 56, in handshake\n    wrapped.do_handshake()\n  File \"/usr/lib/python2.7/ssl.py\", line 788, in do_handshake\n    self._sslobj.do_handshake()\nSSLError: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:581)\nAlso with this 2 more exceptions are raised:\n[ERROR] [2016-02-17 11:12:05,523] [File 'http1connection.py', line 683, in _server_request_loop] - Uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/http1connection.py\", line 674, in _server_request_loop\n    ret = yield conn.read_response(request_delegate)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 628, in run\n    value = future.result()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 109, in result\n    raise_exc_info(self._exc_info)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 631, in run\n    yielded = self.gen.throw(*sys.exc_info())\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/http1connection.py\", line 165, in _read_message\n    io_loop=self.stream.io_loop)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 628, in run\n    value = future.result()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 111, in result\n    raise self._exception\nSSLError: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:1750)\n[ERROR] [2016-02-17 11:12:48,004] [File 'web.py', line 1407, in log_exception] - Uncaught exception CONNECT google-gruyere.appspot.com:443 (127.0.0.1)\nHTTPServerRequest(protocol='http', host='127.0.0.1', method='CONNECT', uri='google-gruyere.appspot.com:443', version='HTTP/1.0', remote_ip='127.0.0.1', headers={})\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1288, in _stack_context_handle_exception\n    raise_exc_info((type, value, traceback))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/media/sf_owtf/framework/http/proxy/proxy.py\", line 305, in ssl_fail\n    self.request.connection.stream.write(b\"HTTP/1.1 200 Connection established\\r\\n\\r\\n\")\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 328, in write\n    self._check_closed()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 835, in _check_closed\n    raise StreamClosedError(\"Stream is closed\")\nStreamClosedError: Stream is closed", "issue_status": "Closed", "issue_reporting_time": "2016-02-17T16:28:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "549": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1643", "issue_id": "#1643", "issue_summary": "How to realize async?", "issue_description": "yyf1986 commented on 17 Feb 2016\nI want to realize a async methods,and the methods is not http request.", "issue_status": "Closed", "issue_reporting_time": "2016-02-17T02:41:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "550": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1640", "issue_id": "#1640", "issue_summary": "Option to periodicaly ping idle websockets to keep proxies happy", "issue_description": "Contributor\ntakluyver commented on 12 Feb 2016\nWe have a mixin class in Jupyter which primarily adds periodic pinging to a websocket handler. This is useful when websockets are used behind proxies, as some proxy servers will kill the connection if it's unused for a set amount of time - 60 seconds in nginx (see #1070).\nThis seems like a generally applicable bit of functionality for websockets. Are you interested in including it in tornado? I imagine that this would be disabled by default, but could be enabled by a setting websocket_ping_interval. I am happy to work on this if you think it's in scope for tornado.", "issue_status": "Closed", "issue_reporting_time": "2016-02-12T18:15:38Z", "fixed_by": "#1957", "pull_request_summary": "websocket: Periodic pinging for failure detection", "pull_request_description": "Member\nbdarnell commented on 21 Feb 2017\nOptionally ping the other end of a websocket connection periodically, and close the connection if no response is received (to supplement kernel-level failure detection for the TCP connections, and to keep some proxies from dropping the connection).\nFixes #1640\nCloses #1642\nCloses #1938\n@takluyver and @astawiarski, your changes are included here. @awong1900, you asked for a client-side ping() method in #1640. Do you really need manual control of pings (and responses) or is this ping_interval and ping_timeout enough for you?\n1", "pull_request_status": "Merged", "issue_fixed_time": "2017-02-25T22:35:23Z", "files_changed": [["8", "docs/web.rst"], ["46", "tornado/test/websocket_test.py"], ["91", "tornado/websocket.py"]]}, "551": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1638", "issue_id": "#1638", "issue_summary": "`reverse_url` doesn't escape metacharacters at url endings", "issue_description": "bhch commented on 10 Feb 2016\nThe url for /example/? or /example/{0,1} should be /example/ in both cases but the urls returned by reverse_url are /example/? and /example/%7B0,1%7D respectively.\nBelow is a simple test to reproduce the bug. I've written the test for URLSpec.reverse because that is what actually generates the urls for reverse_url.\nimport unittest\nfrom tornado.web import URLSpec\n\nclass URLSpecReverseTest(unittest.TestCase):\n    def setUp(self):\n        self.test_urls = [\n            '/example/?', \n            '/example/+', \n            '/example/*', \n            '/example/{0,1}',\n        ]\n\n    def test_urls_ending_with_metachar(self):\n        \"\"\" url returned by  `URLSpec.reverse` for urls in `self.test_urls` \n        should be '/example/'\n        \"\"\"\n        for url in self.test_urls:\n            url_spec = URLSpec(url, handler=None)\n            self.assertEqual(url_spec.reverse(), '/example/')\n\nif __name__ == '__main__':\n    unittest.main()", "issue_status": "Closed", "issue_reporting_time": "2016-02-10T11:24:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "552": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1635", "issue_id": "#1635", "issue_summary": "WebSocketHandler.get is not passed *args and **kwargs", "issue_description": "Cypher1 commented on 3 Feb 2016\nSeems that websockets' arguments are lost somewhere.\nThe place that they are lost at is still being tracked down\nThis means that websockets cannot access their arguments without reprocessing the request.uri", "issue_status": "Closed", "issue_reporting_time": "2016-02-03T07:47:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "553": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1633", "issue_id": "#1633", "issue_summary": "Is this project active?", "issue_description": "doudouOUC commented on 30 Jan 2016\nExcuse me, I have a problem about this project, Is this project active?I will use tornado in my webserver, but it is a problem that chosing a third-part async db tool. First , I found this project https://github.com/PyMySQL/Tornado-MySQL\uff0cbut this project maybe not be maintained.", "issue_status": "Closed", "issue_reporting_time": "2016-01-30T07:19:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "554": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1632", "issue_id": "#1632", "issue_summary": "There might be performance improvement if we avoid unnecessary join operation in tornado.web.RequestHandler.flush method", "issue_description": "Winiex commented on 27 Jan 2016\nIn tornado.web.RequestHandler.flush method, there exists an operation that joins the members of self._write_buffer into a string. But when self._headers_written is True and self.request.method == \"HEAD\", the result of it is discarded. I think if we avoided this operation under such condition, there might be an opportunity for performance improvement, for joining array of strings in CPython is heavy, especially when self._write_buffer contains a lot of members.\ndiff --git a/tornado/web.py b/tornado/web.py\nindex c51d5f6..5d86a8f 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -861,8 +861,6 @@ class RequestHandler(object):\n         .. versionchanged:: 4.0\n            Now returns a `.Future` if no callback is given.\n         \"\"\"\n-        chunk = b\"\".join(self._write_buffer)\n-        self._write_buffer = []\n         if not self._headers_written:\n             self._headers_written = True\n             for transform in self._transforms:\n@@ -873,6 +871,10 @@ class RequestHandler(object):\n             # Ignore the chunk and only write the headers for HEAD requests\n             if self.request.method == \"HEAD\":\n                 chunk = None\n+            else:\n+                chunk = b\"\".join(self._write_buffer)\n+\n+            self._write_buffer = []\n\n             # Finalize the cookie headers (which have been stored in a side\n             # object so an outgoing cookie could be overwritten before it\n@@ -887,6 +889,9 @@ class RequestHandler(object):\n             return self.request.connection.write_headers(\n                 start_line, self._headers, chunk, callback=callback)\n         else:\n+            chunk = b\"\".join(self._write_buffer)\n+            self._write_buffer = []\n+\n             for transform in self._transforms:\n                 chunk = transform.transform_chunk(chunk, include_footers)\n             # Ignore the chunk and only write the headers for HEAD requests\nFinal code:\ndef flush(self, include_footers=False, callback=None):\n    if not self._headers_written:\n        self._headers_written = True\n        for transform in self._transforms:\n            self._status_code, self._headers, chunk = \\\n                transform.transform_first_chunk(\n                    self._status_code, self._headers,\n                    chunk, include_footers)\n        # Ignore the chunk and only write the headers for HEAD requests\n        if self.request.method == \"HEAD\":\n            chunk = None\n        else:\n            chunk = b\"\".join(self._write_buffer)\n\n        self._write_buffer = []\n\n        # Finalize the cookie headers (which have been stored in a side\n        # object so an outgoing cookie could be overwritten before it\n        # is sent).\n        if hasattr(self, \"_new_cookie\"):\n            for cookie in self._new_cookie.values():\n                self.add_header(\"Set-Cookie\", cookie.OutputString(None))\n\n        start_line = httputil.ResponseStartLine('',\n                                                self._status_code,\n                                                self._reason)\n        return self.request.connection.write_headers(\n            start_line, self._headers, chunk, callback=callback)\n    else:\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n\n        for transform in self._transforms:\n            chunk = transform.transform_chunk(chunk, include_footers)\n        # Ignore the chunk and only write the headers for HEAD requests\n        if self.request.method != \"HEAD\":\n            return self.request.connection.write(chunk, callback=callback)\n        else:\n            future = Future()\n            future.set_result(None)\n                return future\nThis is a thought not being comprehensively tested. Any ideas?", "issue_status": "Closed", "issue_reporting_time": "2016-01-27T13:51:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "555": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1631", "issue_id": "#1631", "issue_summary": "Changes to tornado.template in 4.3 breaks external libraries that depend on it", "issue_description": "Contributor\ngmr commented on 26 Jan 2016\nThe addition of additional arguments to tornado.template.ParseError adds two additional required variables that breaks external libraries that extend tornado.template.Template that they can not exist and support < 4.3 and 4.3 without try/catch logic around raising the exception. In addition, this breaks tornado.template.Template on line 368.\nTo address this we're using a pattern like:\nif end == -1:\n    try:\n      raise template.ParseError(\"Missing end block %%} on line %d\" %\n                                line)\n    except TypeError:\n      raise template.ParseError(\"Missing end block %%} on\", \"str\", line)\nThe addition of required kwargs without default values has made internal libraries built on tornado.template.Template unusable in 4.3 and patching in support is ugly at best. While I know it's not good practice, we are referencing template._Text in our extension of tornado.template.Template which also now requires a pattern like:\ntry:\n    body.chunks.append(template._Text(reader.consume(),\n                                      reader.line))\nexcept TypeError:\n    body.chunks.append(template._Text(reader.consume(),\n                                      reader.line, 'all'))\nWhile I don't expect a change in behavior going forward, making such things have defaults would have been trivial and not made 4.3 backwards incompatible with < 4.3 in this module.", "issue_status": "Closed", "issue_reporting_time": "2016-01-26T15:00:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "556": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1630", "issue_id": "#1630", "issue_summary": "tornado.process.Subprocess.stdout.read_until does not work in python 3 (excepted bytes instead of str)", "issue_description": "Contributor\nafq984 commented on 21 Jan 2016\nI think it is about the str/bytes problem, maybe other iostream types may be affected\nConsider the following code:\nfrom tornado.ioloop import IOLoop\nfrom tornado.process import Subprocess\nfrom tornado.log import enable_pretty_logging\n\n\nasync def ping():\n    proc = Subprocess(['ping', 'www.tornadoweb.org'], stdout=Subprocess.STREAM)\n    await proc.stdout.read_until('data.')\n    while True:\n        line = await proc.stdout.read_until('ms')\n        _, _, time = line.rpartition('time=')\n        print(time)\n\n\n\nif __name__ == '__main__':\n    enable_pretty_logging()\n    loop = IOLoop.current()\n    loop.add_callback(ping)\n    loop.start()\nIt gives:\n[W 160121 16:04:03 iostream:651] error on read: a bytes-like object is required, not 'str'\nand then:\n[E 160121 16:05:29 ioloop:629]\ntornado.iostream.StreamClosedError: Stream is closed\nwas testing using python 3.5.1", "issue_status": "Closed", "issue_reporting_time": "2016-01-21T08:10:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "557": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1627", "issue_id": "#1627", "issue_summary": "spec.regex.match could not match URL", "issue_description": "pasuder commented on 15 Jan 2016\nHello Team,\nI am not sure what is going on, but it looks that spec.regex.match does not match correctly self.request.path in web.py.\nExample and screen shot from debugging session:\napplication = tornado.web.Application(\n        handlers=[\n            (r\"/items\", ItemsHandler),\n            (r\"/items/(.*)\", ItemHandler),\n        ])\nCould you advise what is wrong here?\nCheers,\nPawel", "issue_status": "Closed", "issue_reporting_time": "2016-01-14T19:31:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "558": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1625", "issue_id": "#1625", "issue_summary": "separate locale directory [Question]", "issue_description": "paytonpy commented on 9 Jan 2016\nI have a set of templates that are being used for multiple purposes. For example:\n<!-- template.html -->\n<div id=\"title\"> {{ handler.locale.translate(\"title\") }}</div>\n# en_US.csv\ntitle, \"Apple\"\n\n# de_DE.csv\ntitle, \"Apfel\"\nThis is all good until I want to use the very same template for another page and use these instead:\n# en_US.csv\ntitle, \"Cherry\"\n\n# de_DE.csv\ntitle, \"Kirsche\"\nIn this situation I either:\nhave to use a separate key (e.g. apple_title, Apple) for the title which will make CSV bigger and I also have to duplicate the template and change handler.locale.translate(\"apple_title\") accordingly.\nor I can have a separate set of locale directories and based on some criteria, update the locale dictionary entirely. Something like:\nlocale\n    apple\n        en_US.csv\n        de_DE.csv\n    cherry\n        en_US.csv\n        de_DE.csv\nBut I don't know how to go with this approach. How can I tell locale to load from another directory? Or maybe even better, load from default directory and then override some specific values from nested directory. Do you have any suggestion? Is there a better way of doing this?", "issue_status": "Closed", "issue_reporting_time": "2016-01-09T17:04:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "559": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1624", "issue_id": "#1624", "issue_summary": "httpclient.HTTPResponse creates cyclical reference", "issue_description": "dave-shawley commented on 8 Jan 2016\nI stumbled into this when running tests on pypy3. The code in question is in the HTTPResponse initializer:\nclass HTTPResponse(object):\n    def __init__(self, request, code, ... error=None ...):\n        self.code = code\n        self.reason = reason or httputil.responses.get(code, \"Unknown\")\n        #....\n        if error is None:\n            if self.code < 200 or self.code >= 300:\n                self.error = HTTPError(self.code, message=self.reason,\n                                       response=self)\n            else:\n                self.error = None\nThis might not be a huge problem in terms of memory but these could accrete over time. The specific problem that I ran into was with pypy3 where logging repr(error) causes an infinite recursion failure. The following simple program exhibits the problem when run under pypy3. Request a failure status with http://localhost:8000/319 and it will raise a RuntimeError: maximum recursion depth exceeded in the call to logging.exception.\nimport logging\n\nfrom tornado import gen, httpclient, ioloop, web\n\n\nclass Handler(web.RequestHandler):\n\n    @gen.coroutine\n    def get(self, status):\n        request = httpclient.HTTPRequest(\n            'http://httpbin.org/status/{}'.format(status))\n        client = httpclient.AsyncHTTPClient()\n        try:\n            yield client.fetch(request)\n            self.set_status(200)\n            self.finish()\n        except httpclient.HTTPError as error:\n            logging.exception('%s %s failed: %r', request.method,\n                              request.url, error)\n            self.send_error(error.code, reason='fubard')\n\n\ndef make_application():\n    return web.Application([web.url('/(?P<status>\\d+)', Handler)])\n\n\nif __name__ == '__main__':\n    app = make_application()\n    app.listen(8000)\n    try:\n        ioloop.IOLoop.current().start()\n    except KeyboardInterrupt:\n        pass", "issue_status": "Closed", "issue_reporting_time": "2016-01-08T01:54:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "560": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1623", "issue_id": "#1623", "issue_summary": "Recommendation: Let the time events to be processed ASAP", "issue_description": "jackyfkc commented on 7 Jan 2016\nIn start() method within class PollIOLoop, line 826, file ioloop.py\n for callback in callbacks:\n     self._run_callback(callback)\n for timeout in due_timeouts:\n     if timeout.callback is not None:\n         self._run_callback(timeout.callback)\nIn the above code snippet, we could find the time events are handled after callbacks. If so, the time events would be delayed in a random way. Processing time events earlier is less dangerous than delaying them in practice.", "issue_status": "Closed", "issue_reporting_time": "2016-01-07T10:22:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "561": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1616", "issue_id": "#1616", "issue_summary": "how to upload files with AsyncHTTPClient", "issue_description": "saintthor commented on 21 Dec 2015\nif using requests, codes like:\ndata = {...}\naddr = '...'\nwith file( ... ) as f:\nresponse = requests.post( addr, data = data, files = { 'file': f } )\nplease show me the async code using AsyncHTTPClient.", "issue_status": "Closed", "issue_reporting_time": "2015-12-21T08:53:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "562": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1610", "issue_id": "#1610", "issue_summary": "Template support for async for", "issue_description": "iceb0y commented on 19 Dec 2015\nAs an asynchronous web framework, template support for \"async for\" in PEP 0492 might be a good idea.", "issue_status": "Closed", "issue_reporting_time": "2015-12-19T04:04:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "563": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1609", "issue_id": "#1609", "issue_summary": "reverse_url should unescape regex string", "issue_description": "iceb0y commented on 19 Dec 2015\nFor example we have the route\n(FaviconHandler, r'/favicon\\.ico', {}, 'favicon')\nAnd reverse_url('favicon') gives us '/favicon.ico'.", "issue_status": "Closed", "issue_reporting_time": "2015-12-19T04:04:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "564": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1608", "issue_id": "#1608", "issue_summary": "Non-ASCII headers are handled incorrectly by CurlAsyncHTTPClient", "issue_description": "Sjord commented on 17 Dec 2015\nIf a server returns a non-ASCII character in a header, the curl client should still handle the response, but it raises an UnicodeDecodeError instead.\nCode:\nyield CurlAsyncHTTPClient().fetch('https://httpbin.org/response-headers?X-Foo=bl%C3%A9')\nGot:\nTraceback (most recent call last):\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/curl_httpclient.py\", line 453, in _curl_header_callback\n    header_line = native_str(header_line)\n  File \"/home/sjoerd/.virtualenvs/protomon/lib/python3.4/site-packages/tornado/escape.py\", line 222, in to_unicode\n    return value.decode(\"utf-8\")\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xe9 in position 9: invalid continuation byte\nRFC 7230 says:\nHistorically, HTTP has allowed field content with text in the ISO-8859-1 charset, supporting other charsets only through use of RFC2047 encoding. In practice, most HTTP header field values use only a subset of the US-ASCII charset. Newly defined header fields SHOULD limit their field values to US-ASCII octets. A recipient SHOULD treat other octets in field content (obs-text) as opaque data.", "issue_status": "Closed", "issue_reporting_time": "2015-12-17T09:16:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "565": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1607", "issue_id": "#1607", "issue_summary": "Differentiate HTTPError(599, \"Timeout\")", "issue_description": "Contributor\nColorFuzzy commented on 17 Dec 2015\nThere are there different kind of \"Timeout\" in AsyncHTTPClient.fetch\nRequest is waiting in the queue, it triggers a timeout before connecting(internal/external server problem).\nRequest is timeout because of long connecting(DNS/network problem).\nRequest is timeout because of long interacting after connecting(network/server problem).\nSample code of AsyncHTTPClient.fetch:\nURL: https://github.com/tornadoweb/tornado/blob/master/tornado/httpclient.py#L252\n    def handle_response(response):\n        if raise_error and response.error:\n            future.set_exception(response.error)\n        else:\n            future.set_result(response)\n    self.fetch_impl(request, handle_response)\nIf we raise response.error, we even loose the request_time information, the only message in response.error is just \"Timeout\".\nSo, it would be convenient to use different error message, like:\nTimeout: in request queue\nTimeout: when connecting\nTimeout: when interacting\nI had add this feature to my company's project, it works well, and it gets pretty easy to distinguish httpclient internal problems with dns/network/external server problems.\nI'd like to send a pull request to tornado project, it would better to start a proposal before coding.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-12-17T03:14:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "566": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1606", "issue_id": "#1606", "issue_summary": "Escape syntax for comments", "issue_description": "elliottslaughter commented on 17 Dec 2015\nAccording to https://github.com/tornadoweb/tornado/blob/master/tornado/template.py#L94-L101 there is an escape syntax for {{ ({{!) and {% ({%!), but not for {#.\nCan you please add a syntax to escape {#? (Perhaps {#!.)", "issue_status": "Closed", "issue_reporting_time": "2015-12-17T01:44:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "567": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1605", "issue_id": "#1605", "issue_summary": "how to run the AsyncTestCase?", "issue_description": "saintthor commented on 15 Dec 2015\nafter the class defination from http://www.tornadoweb.org/en/stable/testing.html :\nclass MyTestCase(AsyncTestCase):\n@tornado.testing.gen_test\ndef test_http_fetch(self):\nclient = AsyncHTTPClient(self.io_loop)\nresponse = yield client.fetch(\"http://www.tornadoweb.org\")\n# Test contents of response\nself.assertIn(\"FriendFeed\", response.body)\nhow to run it to start testing work? please show me the whole example code.", "issue_status": "Closed", "issue_reporting_time": "2015-12-15T03:08:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "568": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1602", "issue_id": "#1602", "issue_summary": "pip install tornado not working properly", "issue_description": "jvanlangen commented on 9 Dec 2015\nJust started with this an ran into issues:\nWith these lines while executing pip install tornado\n\"Failed building wheel for tornado\"\n\"Failed building wheel for backports.ssl-match-hostname\"\nWhat does this mean???\n** complete logging **\nNAS> pip install tornado\nCollecting tornado\nDownloading tornado-4.3.tar.gz (450kB)\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 454kB 175kB/s\nCollecting backports.ssl-match-hostname (from tornado)\nDownloading backports.ssl_match_hostname-3.4.0.2.tar.gz\nCollecting singledispatch (from tornado)\nDownloading singledispatch-3.4.0.3-py2.py3-none-any.whl\nCollecting certifi (from tornado)\nDownloading certifi-2015.11.20.1-py2.py3-none-any.whl (368kB)\n100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 372kB 207kB/s\nCollecting backports-abc>=0.4 (from tornado)\nDownloading backports_abc-0.4-py2.py3-none-any.whl\nRequirement already satisfied (use --upgrade to upgrade): six in /usr/local/lib/python2.7/site-packages (from singledispatch->tornado)\nBuilding wheels for collected packages: tornado, backports.ssl-match-hostname\nRunning setup.py bdist_wheel for tornado\nComplete output from command /usr/bin/python -c \"import setuptools;file='/tmp/pip-build-jK5tDf/tornado/setup.py';exec(compile(open(file).read().replace('\\r\\n', '\\n'), file, 'exec'))\" bdist_wheel -d /tmp/tmpSCFKl3pip-wheel-:\nusage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\nor: -c --help [cmd1 cmd2 ...]\nor: -c --help-commands\nor: -c cmd --help\nerror: invalid command 'bdist_wheel'\nFailed building wheel for tornado\nRunning setup.py bdist_wheel for backports.ssl-match-hostname\nComplete output from command /usr/bin/python -c \"import setuptools;file='/tmp/pip-build-jK5tDf/backports.ssl-match-hostname/setup.py';exec(compile(open(file).read().replace('\\r\\n', '\\n'), file, 'exec'))\" bdist_wheel -d /tmp/tmp7MZvUzpip-wheel-:\nusage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\nor: -c --help [cmd1 cmd2 ...]\nor: -c --help-commands\nor: -c cmd --help\nerror: invalid command 'bdist_wheel'\nFailed building wheel for backports.ssl-match-hostname\nFailed to build tornado backports.ssl-match-hostname\nInstalling collected packages: backports.ssl-match-hostname, singledispatch, certifi, backports-abc, tornado\nRunning setup.py install for backports.ssl-match-hostname\nRunning setup.py install for tornado\nSuccessfully installed backports-abc-0.4 backports.ssl-match-hostname-3.4.0.2 certifi-2015.11.20.1 singledispatch-3.4.0.3 tornado-4.3\nNAS>", "issue_status": "Closed", "issue_reporting_time": "2015-12-09T16:11:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "569": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1601", "issue_id": "#1601", "issue_summary": "Tornado should not collapse `Set-Cookie` headers", "issue_description": "viyatb commented on 9 Dec 2015\nCurrently tornado collapses multiple Set-Cookie headers from the response into a single header with comma-separated cookies. This makes parsing on the client-side very hard as the expires parameter in the Set-Cookie header also has ',' in it.\nFor example, if the origin server issues the following response headers,\nHTTP/1.1 302 Found\nDate: Mon, 23 Mar 2015 18:24:11 GMT\nServer: Apache\nPragma: no-cache\nSet-Cookie: Navajo=3wJATUguEoQWBd0-; Domain=.server.com; Path=/; Secure; Version=1; HttpOnly\nSet-Cookie: NID=74=pPAmuMR-fBtT9mbGOeC2maregcA4JoK43YfBDlXrfqgH5PMmd2Wy-QF_i_Ygc3AgzxSkhvLVBiHEri3k8gl2SiuwgHO68aHb-uousPE9jI346KprSS9enikTZx9ImHrWso8GglTYyeINnlwe9Kc4kb50ufiqxH4s1pbyDnD2; expires=Wed, 08-Jun-2016 14:57:52 GMT; path=/; domain=.google.nl; HttpOnly,CONSENT=WP.24dd69; expires=Fri, 01-Jan-2038 00:00:00 GMT; path=/; domain=.google.nl\nLocation: https://server.com/something\nCache-Control: no-cache\nExpires: Thu, 1 Jan 1970 00:00:00 GMT\nContent-Length: 285\nContent-Type: text/html; charset=utf-8\nSet-Cookie: BITD-Persistence=1638274978.47873.0000; path=/\nThe self.response.headers.get(\"Set-Cookie\", None) call returns collapsed cookies (separated by ','). In order to avoid this, I need the _raw_ Set-Cookie header so that multiple cookies can be parsed by \\r\\n control characters.\nMore details in a similar issue, jnunemaker/httparty#384", "issue_status": "Closed", "issue_reporting_time": "2015-12-09T06:08:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "570": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1598", "issue_id": "#1598", "issue_summary": "HTTP1Connection cannot handle http/1.0 304 response", "issue_description": "BeanYoung commented on 3 Dec 2015\nWhen HTTP1Connection receive a http/1.0 304 response, start_line at\nthis line is ResponseStartLine(version='HTTP/1.0', code=304, reason='Not Modified'), and _can_keep_alive crash.", "issue_status": "Closed", "issue_reporting_time": "2015-12-03T10:19:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "571": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1597", "issue_id": "#1597", "issue_summary": "POST to Django behind Tornado executed twice", "issue_description": "Dmitri-Sintsov commented on 3 Dec 2015\nHi!\nMy customer uses Windows 2012 R2 for their hosting and I have no another choice but to run Django behind Tornado because Django fastcgi handlers fails both in IIS and nginx and I was unable to compile mod_wsgi for apache (and the precompiled one from whl crashes). Tornado seems to work fine, it's nice to know it has binary speedups even for Windows. However I stuck to one major problem, when checking test deploy.\nDjango is 1.8.7. Tornado is 4.3. Also I use Python 3.4.3, not Python 2.7, if that matters.\nWhen I run Django through it's development server (not recommended in production):\npython manage.py runserver\nAJAX post handlers fired in client-side Javascript are executed at server-side (Django views) just once.\nWhen I run via recommended script\nhttps://github.com/bdarnell/django-tornado-demo/blob/master/testsite/tornado_main.py\nas\npython tornado_main.py\neverything seems fine except Django views are executed twice (not once) during client-side POST (XMLHttpRequest).\nClient-side scripts are not altered so it must not be at client side especially because manage.py runserver works fine in that case (both at Windows 2012 R2 and in Ubuntu 14.04). But I haven't tried to install and use Tornado at development computer (Ubuntu) yet.\nI am not much into low-level WSGI stuff I do not know how to fix this problem myself. Is that a Tornado bug or Django bug?\nMaybe later I'll try to install Tornado in Ubuntu to check whether the problem persists cross platform.\nAlso tornado_main.py failed with configuration error until I added the following line:\nos.environ['DJANGO_SETTINGS_MODULE'] = 'ispdev.settings'", "issue_status": "Closed", "issue_reporting_time": "2015-12-03T09:29:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "572": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1594", "issue_id": "#1594", "issue_summary": "how to learn tornado", "issue_description": "szl-926929 commented on 24 Nov 2015\nhow can i use test code in tornado to learn tornado? i have use tornado write a simple demo. in the demo, i use asyhttpclient to send sms, use motor to complete Database operation, use ProcessPoolExecutor to Complete the calculation operation. but i still think know little about tornado. now , i want to read the test code to learn how use tornado . but ,how can i to read the code? Have a tutorial?\nthanks", "issue_status": "Closed", "issue_reporting_time": "2015-11-24T08:37:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "573": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1592", "issue_id": "#1592", "issue_summary": "yield future", "issue_description": "oxpy commented on 23 Nov 2015\nhi:\nIf yielding a concurrent.future ,does it block the thread ?\nAnd if :\nyield futureA\nyield futureB\nin this circumstance , if futureA does not get its async result ,futureB will never be taken care of , is this right?\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-11-23T08:27:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "574": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1590", "issue_id": "#1590", "issue_summary": "Add debounce decorator", "issue_description": "Contributor\nAaronOpfer commented on 22 Nov 2015\nI propose adding a decorator called debounce. It would be similar in function to the method of the same name in lodash, a JavaScript library.\ndebounce would be a sort of relative of PeriodicCallback so I suppose it could live in tornado.gen.\nOften times when writing asynchronous code on the server, clients may all ask for the same event to occur within a very short time. Or, an asynchronous server may have a continuous data-feed from a TCP socket which has tendencies to be bursty but also have periods of inactivity. This information could also be ephemeral where only the latest piece of information is relevant to users (examples of data that fits this description might be event counters, change notifications for a file or remote resource, etc.).\nIf servers acted on every event in this theoretical data stream, it would perform the work on every invocation. Then, the result of this work would be thrown away immediately afterward when the new updated data arrived. In fact, a server could begin to have severe latency and performance problems if the length of time the work the server wants to perform on an event is longer than the period between the duplicate events.\ndebounce would be a silver bullet for this problem. It would be able to collapse several calls to the same method in some time frame into a single invocation of that method. The return value of debounce would be a Future, which will eventually hold the result of the method call when it occurs. debounce would have options for whether to trigger on the leading edge, the trailing edge, or both the leading and trailing edge of the timeout value.\nIn addition, debounce would also have an optional feature its version in lodash does not: the ability to prevent further calls to the method if there is already an incomplete future from a previous call. This incomplete future would be returned by debounce instead. This would make debounce act like a simple job queue that prevents duplicate entries.\nThe only part of this feature that's a bit iffy is handling methods of classes, since they would most likely want a different timer per class instance. It would be possible to approximate this behavior automatically with a kwarg self=None on the wrapped function, and then using self as a key to differentiate sets of timers, but that only would work if the wrapped function was following the unenforced convention of using 'self' as the class instance argument. This is probably a reasonable assumption to make.", "issue_status": "Closed", "issue_reporting_time": "2015-11-21T22:06:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "575": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1589", "issue_id": "#1589", "issue_summary": "Improve Libraries and Ecosystem", "issue_description": "rskumar commented on 22 Nov 2015\nNot an issue, but Request to Improve\nWhile I love Python and Tornado, specifically for its coroutine decorator based coding style, which lets me write clean and readable code, I mostly have to fallback to other framework in later phases.\nWhy - because my projects just does not depend on Tornado, but other programs like Database, Caching etc.\nFor example, NodeJS, has mature and many vendor supported libraries, Tornado lacks in this. Take Redis, Cassandra etc. Redis library works fine, as expected on Nodejs, tornado-redis just has a lots of problems, gave me a headache with a basic issue and is not actively maintained. Cassandra has few examples of async query, none native to Tornado.\nWhat can we do, to improve the developers ecosystem around Tornado, so they can actively contribute and introduce new libraries.\nOther way I can see, is to support AsyncIO loops (which now is in Tornado), and then their libraries can be used without any issues in Tornado.", "issue_status": "Closed", "issue_reporting_time": "2015-11-21T21:03:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "576": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1585", "issue_id": "#1585", "issue_summary": "Subprocess wait_for_exit Error on Windows", "issue_description": "elveatles commented on 17 Nov 2015\nIf I create a tornado Subprocess and wait for it to exit, I get this error:\nERROR:tornado.application:Future exception was never retrieved: Traceback (most recent call last):\nFile \"C:\\Python27\\Lib\\site-packages\\tornado\\gen.py\", line 230, in wrapper\nyielded = next(result)\nFile \"C:\\test.py\",\nyield proc.wait_for_exit()\nFile \"C:\\Python27\\Lib\\site-packages\\tornado\\process.py\", line 290, in wait_for_exit\nself.set_exit_callback(callback)\nFile \"C:\\Python27\\Lib\\site-packages\\tornado\\process.py\", line 262, in set_exit_callback\nSubprocess.initialize(self.io_loop)\nFile \"C:\\Python27\\Lib\\site-packages\\tornado\\process.py\", line 310, in initialize\nsignal.SIGCHLD,\nAttributeError: 'module' object has no attribute 'SIGCHLD'\nSo I guess Windows does not have SIGCHLD. Does this mean wait_for_exit is not supported on Windows?", "issue_status": "Closed", "issue_reporting_time": "2015-11-17T04:09:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "577": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1583", "issue_id": "#1583", "issue_summary": "tornado httpclient fails on graph.facebook.com", "issue_description": "thestick613 commented on 12 Nov 2015\ni'm using a slight modification of the facebook example code. I've started getting a lot of these:\n[W 151111 19:52:46 auth:113] Error response HTTP 503: No server is available for the request fetching\n[W 151111 19:52:46 auth:113] Error response HTTP 503: No server is available for the request fetching https://graph.facebook.com/XXXXXX\nFunny thing is, the first try always fails (when using tornado's async http client), but the second one goes around.\nI've replaced that bit of code with urllib.urlopen(\"http://graph.facebook.com/XXXX\").read() and it works perfectly.\nNow, i'm sure there's likely something wrong on the facebook side, as i've open a ticket over there as well, but maybe we could make all of these requests on an external api in auth.py at least 2-3 times retryable?", "issue_status": "Closed", "issue_reporting_time": "2015-11-11T20:24:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "578": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1577", "issue_id": "#1577", "issue_summary": "parse_response_start_line without reason like 'HTTP/1.1 200'", "issue_description": "mikechiu1012 commented on 4 Nov 2015\nHi there,\nI suffer a situation that some server will return header_data without reason like:\nHTTP/1.1 200\nServer .....\n....\nand that will cause function parse_response_start_line in httputil.py raise HTTPInputError\nIs it possible to change the regular expression from\nmatch = re.match(\"(HTTP/1.[01]) ([0-9]+) ([^\\r]*)\", line)\nto\nmatch = re.match(\"(HTTP/1.[01]) ([0-9]+)\\s*([^\\r]*)\", line) \nthat could make such case passed successfully.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-11-04T15:29:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "579": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1573", "issue_id": "#1573", "issue_summary": "Tornado test setup fails when localhost has more than one address", "issue_description": "Contributor\nmacro commented on 30 Oct 2015\nWe have an admittedly odd configuration where localhost resolves to two addresses:\n>>> import socket\n>>> socket.getaddrinfo('localhost', 0, socket.AF_INET, socket.SOCK_STREAM)\n[(2, 1, 6, '', ('127.0.0.1', 0)), (2, 1, 6, '', ('127.0.1.1', 0))]\nThe problem is Tornado's test setup fails when more than one localhost address is returned:\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/var/lib/venv/local/lib/python2.7/site-packages/tornado/testing.py\", line 351, in setUp\n    sock, port = bind_unused_port()\n  File \"/var/lib/venv/local/lib/python2.7/site-packages/tornado/testing.py\", line 89, in bind_unused_port\n    [sock] = netutil.bind_sockets(None, 'localhost', family=socket.AF_INET)\nValueError: too many values to unpack\nWe're using Tornado 4.2.1.", "issue_status": "Closed", "issue_reporting_time": "2015-10-29T21:59:05Z", "fixed_by": "#1574", "pull_request_summary": "Fixes #1573: Grab first localhost socket when more than one localhost interface registered", "pull_request_description": "Contributor\nmacro commented on 30 Oct 2015\nThis fixes #1573.", "pull_request_status": "Merged", "issue_fixed_time": "2015-11-07T00:54:48Z", "files_changed": [["4", "tornado/testing.py"]]}, "580": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1572", "issue_id": "#1572", "issue_summary": "Options should support setitem", "issue_description": "Member\nbdarnell commented on 30 Oct 2015\nFrom http://stackoverflow.com/questions/33411269/attributeerror-in-python-tornado-to-configure-log-into-a-file/33417289\nOptions currently override getattr, setattr, and getitem. Item and attribute syntax should be symmetric so we need a setitem override to match setattr.", "issue_status": "Closed", "issue_reporting_time": "2015-10-29T19:19:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "581": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1571", "issue_id": "#1571", "issue_summary": "Error handling in StackContext", "issue_description": "sergiimk commented on 29 Oct 2015\nHi! Recently I was a bit puzzled by the error handling logic in Tornado's StackContext.\nI've been implementing a simple logic that should prevent request handlers from making async calls to other services while they still holding the DB connection checked out from the connection pool. StackContext seemed like the natural choice for this.\nCode below illustrates the solution:\nimport contextlib\nfrom tornado.ioloop import IOLoop\nfrom tornado.gen import coroutine, sleep\nfrom tornado.stack_context import StackContext, run_with_stack_context\n\n\nholds_db_connection = False\n\n\ndef ensure_does_not_hold_db_connection_when_yielding():\n    @contextlib.contextmanager\n    def ctx():\n        global holds_db_connection\n\n        print '> ctx'\n        yield\n        print '< ctx'\n\n        if holds_db_connection:\n            holds_db_connection = False\n            raise Exception('DB connection is checked out!')\n\n    return StackContext(ctx)\n\n@coroutine\ndef logic():\n    global holds_db_connection\n    print '> logic'\n\n    try:\n        holds_db_connection = True\n        print '  < logic yields'\n        yield sleep(1)  # Simulates external call\n        print '  > logic activated'\n    except Exception as e:\n        print '< exc logic', e\n        raise\n    else:\n        print '< ret logic'\n\n@coroutine\ndef request_handler():\n    print '> request'\n\n    try:\n        yield run_with_stack_context(\n            ensure_does_not_hold_db_connection_when_yielding(),\n            logic\n        )\n    except Exception as e:\n        print '< exc request', e\n    else:\n        print '< ret request'\n\n\nio_loop = IOLoop.current()\nio_loop.add_callback(request_handler)\nio_loop.start()\nWhen running this however the output was not what I expected:\n> request            # request starts\n> ctx                # entering stack context\n> logic\n  < logic yields     # we got to the yield point in logic()\n< ctx                # check raises exception in stack context\n< exc request DB connection is checked out!  # exception propagates to request()\n> ctx\n< ctx\n> ctx\n  > logic activated  # logic() coroutine is activated again\n< ret logic          # and continues to execute to completion??\n< ctx\nSo essentially when exception is raised in StackContext it propagates to the request(), but makes logic() coroutine an orphan. And since its Runner is still registered - it is scheduled for execution even though request() already returned.\nThe way I think about StackContext is as of a hook that executes before coroutine is suspended and activated again, so I expected all exceptions to be re-raised into the coroutine itself using generator.throw(). So exceptions that can happen when you yield would be a union of exceptions that the thing you are yielding to can raise, plus all the exceptions that can be raised from active StackContexts.\nAnd the output I expected to see would look like this:\n> request     # request starts\n> ctx         # entering stack context\n> logic\n  < logic yields  # we got to the yield point in logic()\n< ctx             # check raises exception in stack context\n< exc logic ...   # exception is re-raised in logic() coroutine\n< exc request ... # exception propagates to request()\nWould you agree with this, or am I missing something?", "issue_status": "Closed", "issue_reporting_time": "2015-10-29T17:49:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "582": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1570", "issue_id": "#1570", "issue_summary": "gunicorn integration issue: add do_handshake_on_connect, suppress_ragged_eofs to acceptable ssl options", "issue_description": "shrkw commented on 28 Oct 2015\nPython 2.7.5\ntornado 4.2.1\ngunicorn 19.3.0\nI'm implementing simple tornado app that works on gunicorn, also I want to let it listen HTTPS.\nBut tornado refuses ssl options passed from gunicorn.\nI created a smalll patch to let tornado accept a few additional ssl options, and it works well on my environment.\nI'm not sure this patch is reasonable enough, but may I create PR?\npatch:\ndiff --git a/tornado/netutil.py b/tornado/netutil.py\nindex 4fc8d04..aeb4a85 100644\n--- a/tornado/netutil.py\n+++ b/tornado/netutil.py\n@@ -462,7 +462,8 @@ class OverrideResolver(Resolver):\n # to their SSLContext equivalents (the other arguments are still passed\n # to SSLContext.wrap_socket).\n _SSL_CONTEXT_KEYWORDS = frozenset(['ssl_version', 'certfile', 'keyfile',\n-                                   'cert_reqs', 'ca_certs', 'ciphers'])\n+                                   'cert_reqs', 'ca_certs', 'ciphers',\n+                                   'do_handshake_on_connect', 'suppress_ragged_eofs'])\n\n\n def ssl_options_to_context(ssl_options):\n@@ -508,6 +509,13 @@ def ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs):\n     appropriate).\n     \"\"\"\n     context = ssl_options_to_context(ssl_options)\n+    if isinstance(ssl_options, dict):\n+        if 'do_handshake_on_connect' not in kwargs:\n+            kwargs['do_handshake_on_connect'] = ssl_options.get('do_handshake_on_connect', True)\n+        if 'suppress_ragged_eofs' not in kwargs:\n+            kwargs['suppress_ragged_eofs'] = ssl_options.get('suppress_ragged_eofs', True)\n+\n+\n     if hasattr(ssl, 'SSLContext') and isinstance(context, ssl.SSLContext):\n         if server_hostname is not None and getattr(ssl, 'HAS_SNI'):\n             # Python doesn't have server-side SNI support so we can't\nstacktrace when happen AssertionError:\n[2015-10-27 20:29:04 +0000] [4360] [INFO] Booting worker with pid: 4360\nERROR:tornado.application:Exception in callback (<gunicorn.sock.TCPSocket object at 0x2a6bc50>, <function null_wrapper at 0x2c91488>)\nTraceback (most recent call last):\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/ioloop.py\", line 866, in start\n    handler_func(fd_obj, events)\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/netutil.py\", line 265, in accept_handler\n    callback(connection, address)\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/tcpserver.py\", line 239, in _handle_connection\n    do_handshake_on_connect=False)\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/netutil.py\", line 501, in ssl_wrap_socket\n    context = ssl_options_to_context(ssl_options)\n  File \"/home/hiro/.virtualenvs/CP275_asyncproxy/lib/python2.7/site-packages/tornado/netutil.py\", line 471, in ssl_options_to_context\n    assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options\nAssertionError: {'do_handshake_on_connect': False, 'certfile': '/home/hiro/201510/server.crt', 'suppress_ragged_eofs': True, 'ciphers': 'TLSv1', 'ssl_version': 3, 'cert_reqs': 0, 'ca_certs': None, 'keyfile': '/home/hiro/201510/server.key'}\nand here is a starting command line for gunicorn:\n$ gunicorn --certfile=/home/hiro/201510/server.crt --keyfile=/home/hiro/201510/server.key -b 0.0.0.0:16189 -w 1 -k \"tornado\" 'httpproxy:get_service(\"tcp://0.0.0.0:5555\")'", "issue_status": "Closed", "issue_reporting_time": "2015-10-28T07:16:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "583": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1565", "issue_id": "#1565", "issue_summary": "Unit tests fail under python2.7", "issue_description": "Contributor\nfernandoflorez commented on 24 Oct 2015\nUnit tests are failing under python2.7:\nFAIL: test_root_static_path (tornado.test.web_test.StaticFileTest)\nTraceback (most recent call last):\nFile \"tornado/testing.py\", line 132, in call\nresult = self.orig_method(_args, *_kwargs)\nFile \"tornado/test/web_test.py\", line 1223, in test_root_static_path\nself.assertEqual(response.code, 200)\nAssertionError: 404 != 200\nFAIL: test_root_static_path (tornado.test.wsgi_test.WSGIAdapterWrappedTest)\nTraceback (most recent call last):\nFile \"tornado/testing.py\", line 132, in call\nresult = self.orig_method(_args, *_kwargs)\nFile \"tornado/test/web_test.py\", line 1223, in test_root_static_path\nself.assertEqual(response.code, 200)\nAssertionError: 404 != 200\nFAIL: test_root_static_path (tornado.test.wsgi_test.WSGIApplicationWrappedTest)\nTraceback (most recent call last):\nFile \"tornado/testing.py\", line 132, in call\nresult = self.orig_method(_args, *_kwargs)\nFile \"tornado/test/web_test.py\", line 1223, in test_root_static_path\nself.assertEqual(response.code, 200)\nAssertionError: 404 != 200", "issue_status": "Closed", "issue_reporting_time": "2015-10-24T04:23:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "584": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1562", "issue_id": "#1562", "issue_summary": "multiple process option raises RuntimeException", "issue_description": "selam commented on 22 Oct 2015\ntornado can not work with multiple process mode on 4.2.1, raises RuntimeError with\n\"Cannot run in multiple processes: IOLoop instance has already been initialized. You cannot call IOLoop.instance() before calling start_processes()\" message, or if it's change then documentation it's not updated\nfrom tornado.web import Application\nfrom tornado.web import RequestHandler\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpserver import HTTPServer\n\n\nclass TestHandler(RequestHandler):\n    def get(self):\n          self.write(\"Ok\")\n\nclass TestApplication(Application):\n\n    def __init__(self):\n        _handlers = [\n            (r'/', TestHandler),\n        ]\n\n        settings = {\n            \"debug\": True,\n        }\n        Application.__init__(self, _handlers, **settings)\n\n\nif __name__ == '__main__':\n    server = HTTPServer(TestApplication())\n    server.bind(8002)\n    server.start(0)\n    IOLoop.current().start()", "issue_status": "Closed", "issue_reporting_time": "2015-10-21T20:18:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "585": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1561", "issue_id": "#1561", "issue_summary": "Method on AsyncHTTPTestCase to check there are no messages to read", "issue_description": "chemary commented on 21 Oct 2015\nMore than an issue is a question, I created it in Stackoverflow also, if I'm doing bad ussing issues for this delete it.\nI have a Tornado chat and I'm doing some tests, most client messages generate a reply from the server, but others must not generate any reply.\nI managed to do it with this code, waiting for the read timeout to occur, there is a better way to do it?\nimport json\nimport tornado\nfrom tornado.httpclient import HTTPRequest\nfrom tornado.web import Application\nfrom tornado.websocket import websocket_connect\nfrom tornado.testing import AsyncHTTPTestCase, gen_test\n\nclass RealtimeHandler(tornado.websocket.WebSocketHandler):\n    def on_message(self, message):\n        if message != 'Hi':\n            self.write_message('Hi there')\n        return \n\nclass ChatTestCase(AsyncHTTPTestCase):\n    def get_app(self):\n        return Application([\n            ('/rt', RealtimeHandler),\n        ])\n\n    @gen_test\n    def test_no_reply(self):\n        request = HTTPRequest('ws://127.0.0.1:%d/rt' % self.get_http_port())\n        ws = yield websocket_connect(request)\n\n        ws.write_message('Hi')\n\n        with self.assertRaises(tornado.ioloop.TimeoutError):\n            response = yield ws.read_message()\nAlso there is a problem when test ends\n======================================================================\nERROR: test_no_reply (myproj.tests.ChatTestCase)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/home/ubuntu/my_env/local/lib/python2.7/site-packages/tornado/testing.py\", line 120, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/home/ubuntu/my_env/local/lib/python2.7/site-packages/tornado/testing.py\", line 506, in post_coroutine\n    self._test_generator.throw(e)\nStopIteration", "issue_status": "Closed", "issue_reporting_time": "2015-10-21T16:28:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "586": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1559", "issue_id": "#1559", "issue_summary": "Exception in util.py decompress()", "issue_description": "Contributor\nszweep commented on 19 Oct 2015\nI received this error while running some specific unit tests against a lighttpd server:\nFile \"/etc/wg/dxcp_test/tornado/http1connection.py\", line 601, in data_received\ncompressed_data, self._chunk_size)\nFile \"/etc/wg/dxcp_test/tornado/util.py\", line 68, in decompress\nreturn self.decompressobj.decompress(value, max_length)\nerror: Error -3 while decompressing: incorrect header check\nThe error was caused by a non-RFC compliant response from the server in that it contained both a Content-Length header and a Transfer-Encoding: chunked header. While this is not optimal, the tornado client should be able to handle this. According to RFC 2616, 4.4 #3 \"If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored\".\nIn this case the Content-Length was not ignored. Though the data was chunked it was interpreted as non-chunked and the decompress failed. I found a simple solution in util.py _read_body() to change the ordering so that the Transfer-Encoding is checked before the content length.\nI can generate a pull request with this fix if you'd like.", "issue_status": "Closed", "issue_reporting_time": "2015-10-19T17:41:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "587": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1556", "issue_id": "#1556", "issue_summary": "AsyncHTTPClient#fetch does not work correctly from another thread", "issue_description": "speranskydanil commented on 17 Oct 2015\nCode below does not log anything in v4.2.1 (however it works in v3.2.1) :\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpclient import AsyncHTTPClient\nfrom threading import Thread\nfrom time import sleep\n\nimport logging\nfrom tornado.options import parse_command_line\n\nparse_command_line()\nlog = logging.getLogger().info\n\nloop = IOLoop.current()\nhttp = AsyncHTTPClient()\n\ndef f():\n    while True:\n        sleep(1)\n        http.fetch(\"http://google.com\", lambda r: log(r))\n\nThread(target=f).start()\nloop.start()\nInteresting moment -- it works if we change the code for f as follows:\ndef f():\n    while True:\n        sleep(1)\n        http.fetch(\"http://google.com\", lambda r: log(r))\n        loop.add_callback(lambda: None) # hack\n// Windows, Python 3.4.3\n1", "issue_status": "Closed", "issue_reporting_time": "2015-10-17T17:00:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "588": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1552", "issue_id": "#1552", "issue_summary": "Can't enable CurlAsyncHTTPClient to use cookies while following redirections", "issue_description": "kardaj commented on 16 Oct 2015\nThe default behavior of the CurlAsyncHTTPClient is similar to curl -L 'https://apps.dresden.de/ords/f?p=1110' when I set follow_redirects to True and max_redirects to 50. which leads to the following error HTTP 599: Maximum (50) redirects followed\nWhat I would like to do is enable the Client to behave the same way as curl -c cookiejar -L 'https://apps.dresden.de/ords/f?p=1110' but I can't seem to find a work around this using the HTTPRequest API.", "issue_status": "Closed", "issue_reporting_time": "2015-10-15T20:07:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "589": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1551", "issue_id": "#1551", "issue_summary": "How to serve large HTML Files", "issue_description": "ImmanuelSamuel commented on 14 Oct 2015\nEOL error when serving large HTML files", "issue_status": "Closed", "issue_reporting_time": "2015-10-14T04:11:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "590": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1549", "issue_id": "#1549", "issue_summary": "AttributeError: 'NoneType' object has no attribute 'do_handshake'", "issue_description": "david-pureal commented on 12 Oct 2015\nHi, I'm using tornado 4.2 to build a secure websocket server.\nAll things work as expected, but a 'ERROR: Uncaught exception' is produced continuously in the log.\nFull stack:\n2015-10-12 17:50:25,852 - ERROR: Uncaught exception\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/site-packages/tornado/http1connection.py\", line 693, in _server_request_loop\nret = yield conn.read_response(request_delegate)\nFile \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 870, in run\nvalue = future.result()\nFile \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 215, in result\nraise_exc_info(self._exc_info)\nFile \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 876, in run\nyielded = self.gen.throw(*exc_info)\nFile \"/usr/local/lib/python2.7/site-packages/tornado/http1connection.py\", line 168, in _read_message\nquiet_exceptions=iostream.StreamClosedError)\nFile \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 870, in run\nvalue = future.result()\nFile \"/usr/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 215, in result\nraise_exc_info(self._exc_info)\nFile \"\", line 3, in raise_exc_info\nAttributeError: 'NoneType' object has no attribute 'do_handshake'\nmy dirty solution:", "issue_status": "Closed", "issue_reporting_time": "2015-10-12T09:54:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "591": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1548", "issue_id": "#1548", "issue_summary": "AttributeError: 'NoneType' object has no attribute 'do_handshake'", "issue_description": "david-pureal commented on 12 Oct 2015\nHi, I'm using tornado 4.2 to build a secure websocket server.\nAll things work as expected, but a 'ERROR: Uncaught exception' is produced continuously in the log.", "issue_status": "Closed", "issue_reporting_time": "2015-10-12T09:50:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "592": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1547", "issue_id": "#1547", "issue_summary": "request handler to return an orderedDict?", "issue_description": "suipinglu commented on 12 Oct 2015\nHi,\nIs it possible to get an ordered dict for a post request?\nclass MainHandler(tornado.web.RequestHandler):\n    def post(self):\n        request_dict = self.request.arguments\nthe request_dict here is a dict type, but it is possible for me to get as an ordered dict?\nthe end point I am sending this form data requires some elements appear on the top. Is there a way to just get the whole dict back with the same order when i submit?\nCheers,", "issue_status": "Closed", "issue_reporting_time": "2015-10-12T05:26:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "593": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1546", "issue_id": "#1546", "issue_summary": "Exceptions in list of futures don't propagate immediately", "issue_description": "Contributor\nmrocklin commented on 10 Oct 2015\nWhen we wait on several futures/coroutines\nyield [a(), b(), c()]\nIf one coroutine raises an exception I would hope that the yield would raise the exception almost immediately. However, in the small example below we seem to wait until all futures/coroutines complete. Am I doing something silly here? Is there a way to achieve immediate percolation of exceptions?\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\n\n@gen.coroutine\ndef throws():\n    raise Exception()\n\n@gen.coroutine\ndef slow():\n    yield gen.sleep(1)\n    raise gen.Return(1)\n\n@gen.coroutine\ndef f():\n    yield [throws(), slow()]\n\nIOLoop.current().run_sync(f)\nmrocklin@workstation:~/workspace/distributed$ time python foo.py \nTraceback (most recent call last):\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 879, in run\n    yielded = self.gen.send(value)\n  File \"foo.py\", line 11, in slow\n    raise gen.Return(1)\ntornado.gen.Return\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"foo.py\", line 17, in <module>\n    IOLoop.current().run_sync(f)\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/ioloop.py\", line 445, in run_sync\n    return future_cell[0].result()\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/concurrent.py\", line 215, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 876, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"foo.py\", line 15, in f\n    yield [throws(), slow()]\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 870, in run\n    value = future.result()\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/concurrent.py\", line 215, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 656, in callback\n    result_list.append(f.result())\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/concurrent.py\", line 215, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/mrocklin/Software/anaconda/lib/python3.4/site-packages/tornado/gen.py\", line 215, in wrapper\n    result = func(*args, **kwargs)\n  File \"foo.py\", line 6, in throws\n    raise Exception()\nException\n\nreal    0m1.113s\nuser    0m0.091s\nsys 0m0.021s", "issue_status": "Closed", "issue_reporting_time": "2015-10-09T22:04:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "594": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1545", "issue_id": "#1545", "issue_summary": "Application url prefix", "issue_description": "suipinglu commented on 8 Oct 2015\nHi everyone,\nIs the there a way to set a prefix for each url? Just like automatically add \"/api/v1\" for each request.\nCheers", "issue_status": "Closed", "issue_reporting_time": "2015-10-08T02:38:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "595": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1543", "issue_id": "#1543", "issue_summary": "Autoreload with asyncio event loop doesn't work", "issue_description": "rudyryk commented on 6 Oct 2015\nWhen running Tornado server in debug mode with autoreload and asyncio event loop the following exception raises: RuntimeError: Cannot close a running event loop.\nSeems like autoreload hook tries to close event loop, but asyncio loop can't be closed without calling stop(). Code to reproduce and traceback are below.\nSteps to reproduce:\nrun the app server\nmodify script with app server code to trigger auto reload\n# save this to server.py and run as \"python server.py\"\nimport os\nimport asyncio\nimport tornado.ioloop\nimport tornado.httpserver\nimport tornado.web\n\nfrom tornado.ioloop import IOLoop\nIOLoop.configure('tornado.platform.asyncio.AsyncIOLoop')\n\n\nclass HomePage(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello!\")\n\nif __name__ == '__main__':\n    port = 8000\n    host = '127.0.0.1'\n    app = tornado.web.Application(\n        [\n            (r'/', HomePage),\n        ],\n        debug=True)\n\n    print(\"Running server at http://%s:%s\" % (host, port))\n\n    server = tornado.httpserver.HTTPServer(app)\n    server.bind(port, host)\n    server.start()\n    tornado.ioloop.IOLoop.current().start()\nThe full traceback:\nTraceback (most recent call last):\n  File \"/Users/user/.virtualenvs/project/src/tornado/tornado/ioloop.py\", line 1039, in _run\n    return self.callback()\n  File \"/Users/user/.virtualenvs/project/src/tornado/tornado/autoreload.py\", line 190, in _reload_on_update\n    _check_file(modify_times, path)\n  File \"/Users/user/.virtualenvs/project/src/tornado/tornado/autoreload.py\", line 205, in _check_file\n    _reload()\n  File \"/Users/user/.virtualenvs/project/src/tornado/tornado/autoreload.py\", line 212, in _reload\n    fn()\n  File \"/Users/user/.virtualenvs/project/src/tornado/tornado/platform/asyncio.py\", line 63, in close\n    self.asyncio_loop.close()\n  File \"/usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/unix_events.py\", line 55, in close\n    super().close()\n  File \"/usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/selector_events.py\", line 94, in close\n    raise RuntimeError(\"Cannot close a running event loop\")\nRuntimeError: Cannot close a running event loop \n1", "issue_status": "Closed", "issue_reporting_time": "2015-10-06T13:04:50Z", "fixed_by": "#1984", "pull_request_summary": "autoreload: Don't close the IOLoop on reload", "pull_request_description": "Member\nbdarnell commented on 25 Mar 2017\nThis was a last-ditch effort to close file descriptors that were not\nmarked as CLOEXEC. However, it was never complete (it didn't touch\nfile descriptors that were not registered on the IOLoop), and it can't\nwork with asyncio (which does not allow closing the IOLoop without\nstopping it and unwinding the stack first). Since Tornado (and\nhopefully all major libraries using the IOLoop) is careful about\nsetting CLOEXEC when needed, just get rid of the close.\nFixes #1543", "pull_request_status": "Merged", "issue_fixed_time": "2017-03-26T15:14:40Z", "files_changed": [["6", "tornado/autoreload.py"]]}, "596": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1539", "issue_id": "#1539", "issue_summary": "Closing websocket serverside, no reason or code given on client-side.", "issue_description": "jonathan-s commented on 2 Oct 2015\nI'm writing tests for websockets and using websocket.websocket_connect to create a client-side connection to the server. But when closing the connection serverside the only thing the client-side connection is getting is None. It would be great if the implementation got the code and the reason too. Unless I'm missing something.", "issue_status": "Closed", "issue_reporting_time": "2015-10-02T11:31:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "597": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1535", "issue_id": "#1535", "issue_summary": "Broken link", "issue_description": "Contributor\nremyleone commented on 1 Oct 2015\nThis link that is featured on the readme page seems to be broken :( https://developers.facebook.com/opensource/", "issue_status": "Closed", "issue_reporting_time": "2015-10-01T07:47:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "598": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1534", "issue_id": "#1534", "issue_summary": "tornado rejects valid SSL certificates", "issue_description": "centromere commented on 30 Sep 2015\nI'm using version 4.2.1, installed with pip:\n$ python\nPython 2.7.6 (default, Jun 22 2015, 17:58:13)\n[GCC 4.8.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from tornado.httpclient import HTTPClient\n>>> http_client = HTTPClient()\n>>> response = http_client.fetch('https://dl.bintray.com/mitchellh/consul/0.5.2_linux_amd64.zip')\nWARNING:tornado.general:SSL Error on 7 ('54.192.87.100', 443): [Errno 1] _ssl.c:510: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/httpclient.py\", line 102, in fetch\n    self._async_client.fetch, request, **kwargs))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 445, in run_sync\n    return future_cell[0].result()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 215, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\nssl.SSLError: [Errno 1] _ssl.c:510: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed\nThis error also occurs with the following URL:\nhttp://github.com/hashicorp/consul-template/releases/download/v0.10.0/consul-template_0.10.0_linux_amd64.tar.gz", "issue_status": "Closed", "issue_reporting_time": "2015-09-30T17:36:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "599": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1532", "issue_id": "#1532", "issue_summary": "FacebookGraphMixin failing", "issue_description": "wannabeCitizen commented on 29 Sep 2015\nI had to modify _on_access_token so that it did not attempt to make a facebook_request to /me. With the code as it stands, I get this error:\nTypeError: 'Future' object is not callable\nHowever, removing that extra request fixes this, and I can use the access_token in the next part of my auth pipeline.", "issue_status": "Closed", "issue_reporting_time": "2015-09-29T00:38:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "600": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1522", "issue_id": "#1522", "issue_summary": "Typo in websocket client documentation", "issue_description": "gpiffault commented on 22 Sep 2015\nThe example in tornado.websocket.websocket_connect doc section reads:\nconn = yield websocket_connection(loop)\nI think it should be something like:\nconn = yield websocket_connect(url)", "issue_status": "Closed", "issue_reporting_time": "2015-09-22T13:34:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "601": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1521", "issue_id": "#1521", "issue_summary": "Including a page which extends another template raises NotImplementedError", "issue_description": "holymonson commented on 22 Sep 2015\nexample, rendering mypage.html will fail:\n<!-- mypage.html -->\n{% include \"another.html\" %}\n\n<!-- another.html -->\n{% extends \"base.html\" %}\n{% block title %}My page title{% end %}\n\n<!-- base.html -->\n<title>{% block title %}Default title{% end %}</title>\ncalltrace:\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python3.4/site-packages/tornado/web.py\", line 1369, in _stack_context_handle_exception\n        raise_exc_info((type, value, traceback))\n      File \"<string>\", line 3, in raise_exc_info\n      File \"/usr/local/lib/python3.4/site-packages/tornado/web.py\", line 1572, in wrapper\n        result = method(self, *args, **kwargs)\n      File \"./main.py\", line 206, in get\n        self.render(\"entrance.html\", title=\"My title\", series=series, layouts=layouts)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/web.py\", line 704, in render\n        html = self.render_string(template_name, **kwargs)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/web.py\", line 808, in render_string\n        t = loader.load(template_name)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 343, in load\n        self.templates[name] = self._create_template(name)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 371, in _create_template\n        template = Template(f.read(), name=name, loader=self)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 237, in __init__\n        self.code = self._generate_python(loader, compress_whitespace)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 291, in _generate_python\n        ancestors[0].generate(writer)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 416, in generate\n        self.body.generate(writer)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 429, in generate\n        chunk.generate(writer)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 473, in generate\n        included.file.body.generate(writer)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 429, in generate\n        chunk.generate(writer)\n      File \"/usr/local/lib/python3.4/site-packages/tornado/template.py\", line 398, in generate\n        raise NotImplementedError()\n    NotImplementedError", "issue_status": "Closed", "issue_reporting_time": "2015-09-22T07:00:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "602": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1520", "issue_id": "#1520", "issue_summary": "Tornado logging: \"No handlers could be found for logger \"tornado.application\"", "issue_description": "vgoklani commented on 18 Sep 2015\nI'm getting the following error with Tornado:\nNo handlers could be found for logger \"tornado.application\"\nI've read through the docs, and it appears that I need to define this:\naccess_log = logging.getLogger(\"tornado.access\")\napp_log = logging.getLogger(\"tornado.application\")\ngen_log = logging.getLogger(\"tornado.general\")\nbut then what? What do I do with these things? The error isn't going away.\nalso note that this is the first line of my main() function:\ntornado.options.parse_command_line()\nI've also explicitly added this:\nlogging.basicConfig()\nAlso, I've noticed that all my 200 level requests are being routed to stderr, instead of stdout, how do I redirect that to stdout. I only want the 500-level errors to go to stderr.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-09-18T15:50:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "603": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1519", "issue_id": "#1519", "issue_summary": "https protocol causes connection timeout when not using ssl_options", "issue_description": "janbalaz commented on 17 Sep 2015\nEven in the minimal Tornado example connecting via https to non-https Tornado server causes probably connection closing on timeout (expected is certificate warning).\nIssue is maybe with regex in _read_message() method in http2connection.py. When header is encrypted, regex won't find anything and header_future is None.\nThis will be passed to start() function in ioloop.py and empty callbacks will be called until timeout. That's maybe good in other cases, but in my opinion with https is expected certificate warning.\nI hope I tracked the issue correctly :)", "issue_status": "Closed", "issue_reporting_time": "2015-09-16T19:17:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "604": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1518", "issue_id": "#1518", "issue_summary": "tornado.httpclient.HTTPClient.fetch() executes callback on contents of redirect response", "issue_description": "terminalmage commented on 14 Sep 2015\nAssume the following example of using the HTTPClient to retrieve a file:\n>>> tornado.version\n'4.2.1'\n>>> try:\n...     fh = open('/tmp/foo.msi', 'wb')\n...     def handle_chunk(chunk):\n...         fh.write(chunk)\n...     tornado.httpclient.HTTPClient(max_body_size=107374182400).fetch('http://download.macromedia.com/get/flashplayer/current/licensing/win/install_flash_player_18_plugin.msi', method='GET', streaming_callback=handle_chunk)\n... finally:\n...     fh.close()\n...\nHTTPResponse(_body=None,buffer=<_io.BytesIO object at 0x7f933e4a7470>,code=200,effective_url='http://fpdownload.macromedia.com/get/flashplayer/current/licensing/win/install_flash_player_18_plugin.msi',error=None,headers={'Content-Length': '19924480', 'Accept-Ranges': 'bytes', 'Server': 'Apache', 'Last-Modified': 'Fri, 07 Aug 2015 12:22:31 GMT', 'Connection': 'close', 'Etag': '\"1300600-51cb7b0998fc0\"', 'Date': 'Mon, 14 Sep 2015 17:24:22 GMT', 'Content-Type': 'application/x-msi'},reason='OK',request=<tornado.httpclient.HTTPRequest object at 0x7f933e196250>,request_time=4.273449897766113,time_info={})\n>>> with open('/tmp/foo.msi', 'rb') as fh:\n...     first_288_bytes = fh.read(288)\n...\n>>> first_288_bytes\n'<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\\n<html><head>\\n<title>302 Found</title>\\n</head><body>\\n<h1>Found</h1>\\n<p>The document has moved <a href=\"http://fpdownload.macromedia.com/get/flashplayer/current/licensing/win/install_flash_player_18_plugin.msi\">here</a>.</p>\\n</body></html>'\nThis results in a corrupted file, as the HTTP response from the 302 redirect is written to the destination file via the callback.\nIt's entirely possible that I am doing something wrong, but this looks like a bug. I can conceive of no way to reliably determine that the callback is being executed on a 302 redirect response, since the raw data from the chunk of the file is what is passed to the callback function, leaving nothing from the HTTPResponse object to be examined in order to determine whether or not to write the chunk to the destination file.", "issue_status": "Closed", "issue_reporting_time": "2015-09-14T17:39:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "605": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1515", "issue_id": "#1515", "issue_summary": "demos\\websocket When i posted, 404: Not Found", "issue_description": "sevenguin commented on 11 Sep 2015\nLike the title, When i open demos\\websocket, and post some message, 404 is showed to me.The url is http://127.0.0.1:8888/a/message/new", "issue_status": "Closed", "issue_reporting_time": "2015-09-11T06:24:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "606": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1513", "issue_id": "#1513", "issue_summary": "netutil.bind_sockets: add an ability to set SO_REUSEPORT", "issue_description": "Contributor\nnoxiouz commented on 8 Sep 2015\nI'd like to set SO_REUSEPORT on a binded socket to have more fair load balancing in case of a multiple process setup. Right now I have to copy bind_sockets implementation and add couple of strigns. What if we add an optional parametr (tuple of socket options) to bind_socket to set the options after socket.socket(...)?", "issue_status": "Closed", "issue_reporting_time": "2015-09-08T13:37:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "607": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1512", "issue_id": "#1512", "issue_summary": "How to deal with global variables in multi processes mode?", "issue_description": "zguangyu commented on 3 Sep 2015\nI'm trying to use a global dict to store user information, including permission. When a user logs in, the auth view query user information and save it into the global dict with user name as its key, and set a username cookie.\nThe problem is that when I start my app in multi processes mode, some logged in user request can not find its information in the global dict. It seems that only the process receiving the request will query and store the user information.\nA way to solve my problem is to use a cache service such as redis or memcached to store cache data.\nThe websocket chat demo also use a class static variable to store connections. Does it have the same problem?", "issue_status": "Closed", "issue_reporting_time": "2015-09-03T12:28:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "608": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1509", "issue_id": "#1509", "issue_summary": "gen.multi_future() does not support list/dicts of Deferreds (or asyncio.Future?)", "issue_description": "Chippiewill commented on 2 Sep 2015\ngen.convert_yielded() can support yielding individual Deferreds and asyncio.Futures thanks to singledispatch.\nUnfortunately when yielding a list of deferreds this fails as they do not get converted to Futures. Currently I work around this with a helper function to convert a list of deferreds into futures manually but this is not ideal.", "issue_status": "Closed", "issue_reporting_time": "2015-09-02T09:41:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "609": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1507", "issue_id": "#1507", "issue_summary": "Easy get POST/GET data", "issue_description": "Andyworker commented on 1 Sep 2015\nThe tornado web have a bug, get post data, The value is null when was the html form post in time\n#   coding:utf-8\n#   created time:9/1/2015 8:59 AM\n#   created by andy\n#   desc:\n\n\"\"\"\n    #docstring:\n\n\"\"\"\n__author__ = 'Andy guan'\n__version__ = '1.0'\n\nimport json\n\nfrom tornado.web import RequestHandler\n\n\nclass Method(RequestHandler):\n\n    \"\"\"\n        Method function, for get/POST method got to data\n        :param: method -- POST method data\n                          GET method data\n        :arg: get param name\n    \"\"\"\n\n    def maigc_method(self, method, *args):\n\n        while True:\n            try:\n                query = {}\n\n                if method == 'post':    # POST Method\n                    for param in args:\n                        query[param] = json.dumps({k: self.get_argument(k) for k in self.request.arguments})[param]\n\n                elif method == 'get':   # GET Method\n                    for param in args:\n                        query[param] = self.request.arguments[param]\n\n                    return query\n\n                else:\n                    raise TypeError('Not support requested type')\n\n            except KeyError or json.JSONEncoder as e:\n                raise RuntimeError('Not found param:%s' % e)", "issue_status": "Closed", "issue_reporting_time": "2015-09-01T01:50:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "610": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1505", "issue_id": "#1505", "issue_summary": "self.fetch throws `Async operation timed out` but self.http_client works okay", "issue_description": "rsmith31415 commented on 30 Aug 2015\nIs there some reason why this should fail (with\nAssertionError: Async operation timed out after 5 seconds) when the request takes several seconds\nclass TestKernelHandlerWithKernelsJulia(AsyncHTTPTestCase):\n\n    def get_app(self):\n        self.application = Application()\n        return self.application\n\n    def setUp(self):\n        super(MyTest, self).setUp()\n\n    def tearDown(self):\n        super(MyTest, self).setUp()\n\n    def test_post_method_2(self):\n        data = json.dumps({'param1': '1', 'param2': '2'})\n        response = self.fetch('/myurl', method='POST', body=data)\n        response = json.loads(response.body)\n        self.assertTrue(response['value'] == '2')\nbut this succeeds:\n    def test_post_method(self):\n        data = json.dumps({'param1': '1', 'param2': '2'})\n        response = self.http_client.fetch('/myurl', self.handle_request, method='POST', body=data)\n\n    def handle_request(self, response):\n        response = json.loads(response.body)\n        self.assertTrue(response['value']== '1')\nAn additional question. How can I increase the wait time in this case (the equivalent decorator to @gen_test(timeout=10))?", "issue_status": "Closed", "issue_reporting_time": "2015-08-29T19:54:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "611": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1503", "issue_id": "#1503", "issue_summary": "is iostream write block server ?", "issue_description": "altanozlu commented on 29 Aug 2015\nhi i'm new to tornado and async\ni have code like that\ndef sendData(self,data):\nself.stream.write(struct.pack(\"!i\",len(data))+data)\nis it can block server until write done\nif i'm gonna send big data it'll be huge problem for me", "issue_status": "Closed", "issue_reporting_time": "2015-08-29T04:19:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "612": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1501", "issue_id": "#1501", "issue_summary": "Don't initialize the IOLoop in tornado.platform.twisted.install().", "issue_description": "zguangyu commented on 25 Aug 2015\nI'm trying to call both http_server.start(0) and tornado.platform.twisted.install(). The http_server.start(0) requires that IOLoop instance must not be initialized before it, while tornado.platform.twisted.install() will make the IOLoop instance be initialized. But the install function need to be called before any twisted code. That places me in a dilemma.", "issue_status": "Closed", "issue_reporting_time": "2015-08-25T10:47:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "613": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1500", "issue_id": "#1500", "issue_summary": "HTTPHeaders impl doesnt support setdefault", "issue_description": "patapra commented on 25 Aug 2015\nhi,\ntornado v4.2\nim seeing an issue where the HTTPHeaders obj doesn't support the setdefault method on builtin dicts. The issue is that setdefault bypasses your custom setitem, so any key-value set using it will not exist in self._as_list (which is used in get_all()).\nJust a suggestion: since you guys are attempting to alter the key names and values when setting an item, subclassing the collections MutableMapping abc (instead of dict) may provide better compatibility with a builtin dict.", "issue_status": "Closed", "issue_reporting_time": "2015-08-24T19:37:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "614": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1499", "issue_id": "#1499", "issue_summary": "PEP-0492: Infinite loop in convert_yielded", "issue_description": "arthurdarcet commented on 24 Aug 2015\nTrying to await more than two coroutines nested starts an infinite loop. Am I using everything correctly ?\nimport asyncio\nimport tornado.gen\nimport tornado.ioloop\n\nasync def do():\n    await asyncio.sleep(.5)\n\nasync def main():\n    await do()\n\nio_loop = tornado.ioloop.IOLoop.current()\nio_loop.run_sync(lambda: tornado.gen.convert_yielded(main()))\nTraceback (most recent call last):\n  File \"a.py\", line 13, in <module>\n    io_loop.run_sync(lambda: tornado.gen.convert_yielded(main()))\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/ioloop.py\", line 446, in run_sync\n    return future_cell[0].result()\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/concurrent.py\", line 222, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/ioloop.py\", line 426, in run\n    result = func()\n  File \"a.py\", line 13, in <lambda>\n    io_loop.run_sync(lambda: tornado.gen.convert_yielded(main()))\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/functools.py\", line 743, in wrapper\n    return dispatch(args[0].__class__)(*args, **kw)\n\n#--------\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/gen.py\", line 1086, in convert_yielded\n    return _wrap_awaitable(yielded)\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/gen.py\", line 262, in wrapper\n    Runner(result, future, yielded)\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/gen.py\", line 867, in __init__\n    if self.handle_yield(first_yielded):\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/gen.py\", line 1006, in handle_yield\n    self.future = convert_yielded(yielded)\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/functools.py\", line 743, in wrapper\n    return dispatch(args[0].__class__)(*args, **kw)\n#-------- (repeated)\n\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/lib/python3.5/site-packages/tornado/gen.py\", line 1085, in convert_yielded\n    elif isawaitable(yielded):\n  File \"/usr/local/Cellar/python3/3.5.0rc1_2/Frameworks/Python.framework/Versions/3.5/lib/python3.5/inspect.py\", line 215, in isawaitable\n    isinstance(object, collections.abc.Awaitable))\n  File \"/Users/arthur/Documents/reaaad/castamere/.venv/bin/../lib/python3.5/abc.py\", line 182, in __instancecheck__\n    if subclass in cls._abc_cache:\nRecursionError: maximum recursion depth exceeded while calling a Python object\nsys:1: RuntimeWarning: coroutine 'fetch' was never awaited", "issue_status": "Closed", "issue_reporting_time": "2015-08-24T15:49:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "615": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1498", "issue_id": "#1498", "issue_summary": "AsyncHttpClient 599 Network unreachable errors", "issue_description": "ghandee commented on 24 Aug 2015\nHi,\nI'm using tornado's 4.2.1 AsyncHttpClient to send HEAD requests to couple of urls (client is configured to use CurlAsyncHTTPClient and max_clients is set to 1000) and I have libcurl compiled with c-ares enabled.\nSimplified version of code looks pretty much like that\nconcurrency = 10\nsem = tornado.locks.Semaphore(concurrency)\n\ndef fun(self, url):\n        with (yield sem.acquire()):\n            try:\n                response = yield self.client.fetch(\n                    url, method='HEAD',\n                    validate_cert=False,\n                    request_timeout=REQUEST_TIMEOUT,\n                    connect_timeout=CONNECT_TIMEOUT\n                )\nInitially, I wasnt using semaphores but without this concurrency primitive code in my case starts throwing lots of errors (same if I increase semaphore lock counter to say 50).\nAfter a while I start getting 599 Network unreachable errors which I cant debug in any reasonable way :/\nThe code runs in infinite loop, sends head request, and schedules next call using add_timeout. I wanted to be able to ping as many resources as possible and at first I run at \"too many open files problem, which was OS configuration limititaiton that I solved\". Right now I think I have reasonable setup but I am not able to use tornado's event loop's full potential.\nHas someone used AsyncHttpClient in similar case (sending multiple requests) and ran into something similar ?\nAny clues / help / ideas will be appreciated", "issue_status": "Closed", "issue_reporting_time": "2015-08-24T10:20:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "616": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1493", "issue_id": "#1493", "issue_summary": "PEP-0492 async/await with AsyncHTTPClient", "issue_description": "arthurdarcet commented on 19 Aug 2015\nI'm trying to get the example from the docs working: http://tornado.readthedocs.org/en/latest/guide/coroutines.html#python-3-5-async-and-await\nwith the following code\nimport asyncio\nfrom tornado.httpclient import AsyncHTTPClient\n\nasync def main():\n    http_client = AsyncHTTPClient()\n    response = await http_client.fetch('http://httpbin.org')\n    return response.body\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nbut all I get is a RuntimeError: Task got bad yield: <tornado.concurrent.Future \u2026>\nAm I doing something wrong or is the tornado support for PEP-0492 not complete yet?\nThanks for your help\n(I am on master for tornado and Python 3.5.0rc1)", "issue_status": "Closed", "issue_reporting_time": "2015-08-19T16:42:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "617": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1492", "issue_id": "#1492", "issue_summary": "done coroutines keep running", "issue_description": "wjackson commented on 19 Aug 2015\nI'm able to successfully use a tornado.locks.Event to signal a long running coroutine to finish on demand. However, the done coroutines continue to execute. Am I doing something wrong? Is this a bug?\nExample code:\nfrom __future__ import print_function\nfrom tornado.ioloop import IOLoop\nimport tornado.locks as locks\nfrom functools import partial\nimport tornado.gen as gen\nfrom tornado.concurrent import chain_future\n\ndef stoppable(func):\n\n    @gen.coroutine\n    def new_func(*args, **kwargs):\n        stop_event = kwargs.pop('stop_event')\n\n        wrapped_f = func(*args, **kwargs)\n        event_f = stop_event.wait()\n\n        chain_future(event_f , wrapped_f)\n\n        yield [wrapped_f, event_f]\n\n    return new_func\n\n@stoppable\n@gen.coroutine\ndef ping_emu(coro_index):\n\n    count = 0\n    while True:\n        print('ping [coro_index=%d] [count=%d]' % (coro_index, count) )\n        yield gen.sleep(1)\n        count += 1\n\n@gen.coroutine\ndef main_coro():\n\n    coro_index = 0\n    while True:\n        stop_ev = locks.Event()\n        IOLoop.current().call_later(2, stop_ev.set)\n\n        ping_emu_f = ping_emu(coro_index, stop_event=stop_ev)\n\n        # so we can see when the ping emulator future is done\n        ping_emu_f.add_done_callback(\n            lambda _: print('coro done [coro_index=%d]' % coro_index)\n        )\n\n        # run the ping future\n        yield ping_emu_f\n\n        coro_index += 1\n\nIOLoop.instance().run_sync(main_coro)\nExample output:\nping [coro_index=0] [count=0]\nping [coro_index=0] [count=1]\ncoro done [coro_index=0]\nping [coro_index=1] [count=0]\nping [coro_index=0] [count=2]\nping [coro_index=1] [count=1]\nping [coro_index=0] [count=3]\ncoro done [coro_index=1]\nping [coro_index=2] [count=0]\nping [coro_index=1] [count=2]\nping [coro_index=0] [count=4]\nping [coro_index=2] [count=1]\nping [coro_index=1] [count=3]\nping [coro_index=0] [count=5]\ncoro done [coro_index=2]\nping [coro_index=3] [count=0]\nping [coro_index=2] [count=2]\nping [coro_index=1] [count=4]\nping [coro_index=0] [count=6]\nping [coro_index=3] [count=1]\nping [coro_index=2] [count=3]\nping [coro_index=1] [count=5]\nping [coro_index=0] [count=7]\ncoro done [coro_index=3]\nI'd like for the coroutines who's futures are done to stop running but as you can see they don't. Any information or help would be appreciated.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-08-19T16:21:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "618": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1491", "issue_id": "#1491", "issue_summary": "ThreadedResolver executor and io_loop.close()", "issue_description": "iivvaall commented on 18 Aug 2015\nThe following code dumps an exception.\n#!/usr/bin/env python \n\nimport tornado\nfrom tornado.ioloop import IOLoop\nimport tornado.netutil\n\nio_loop = IOLoop.current()\n\nresolver = tornado.netutil.ThreadedResolver()\nres = resolver.resolve('invalid', 9999)\nio_loop.add_future(res, lambda(res): None)\nresolver.close()\n\nio_loop.call_later(0, lambda: io_loop.stop())\n\nio_loop.start()\nio_loop.close()\nERROR:concurrent.futures:exception calling callback for <Future at 0x7f1eec1896d0 state=finished raised gaierror>\nTraceback (most recent call last):\n  File \"/home/ival/files/cwd/torch/run/torch/local/lib/python2.7/site-packages/concurrent/futures/_base.py\", line 298, in _invoke_callbacks\n    callback(self)\n  File \"/home/ival/files/cwd/torch/run/torch/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 584, in <lambda>\n    lambda future: self.add_callback(callback, future))\n  File \"/home/ival/files/cwd/torch/run/torch/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 914, in add_callback\n    raise RuntimeError(\"IOLoop is closing\")\nRuntimeError: IOLoop is closing\nThe exception pollutes unittests output.\nIf there is no more then one resolver instance in a script, the bug is eliminated by manually shutting the executor down after resolver.close().\ntornado.netutil.ThreadedResolver._threadpool.shutdown()\ntornado.netutil.ThreadedResolver._threadpool = None\npython2.7.6\nargparse==1.2.1\nbackports.ssl-match-hostname==3.4.0.2\ncertifi==2015.04.28\nenum34==1.0.4\nfutures==3.0.3\ntornado==4.2.1\nwsgiref==0.1.2", "issue_status": "Closed", "issue_reporting_time": "2015-08-18T18:02:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "619": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1489", "issue_id": "#1489", "issue_summary": "Broken link in latest documentation.", "issue_description": "andrzejkrecicki commented on 17 Aug 2015\nOn http://www.tornadoweb.org/en/stable/ page in section \"Discussion and support\" link http://developers.facebook.com/opensource/ leads to 404 page.\nI tried to find Tornado at https://code.facebook.com/projects/backend but it's not present there.", "issue_status": "Closed", "issue_reporting_time": "2015-08-16T23:12:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "620": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1485", "issue_id": "#1485", "issue_summary": "HTTPError not copyable", "issue_description": "Contributor\nalunduil commented on 13 Aug 2015\nWhen attempting to make a copy (through a deepcopy of a container), the following exception is raised:\nTypeError: __init__() missing 1 required positional argument: 'status_code'\nPerhaps a simple copy and deepcopy implementation would be appropriate? If so, let me know and I can give a pull request a stab. If it's not appropriate, I can try to find a workaround.", "issue_status": "Closed", "issue_reporting_time": "2015-08-13T16:44:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "621": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1484", "issue_id": "#1484", "issue_summary": "On OS X, pre-fork requests with python-requests cause HTTPS connections in workers to kill the worker", "issue_description": "jsocol commented on 13 Aug 2015\nThis is a very specific set of circumstances, so I've included as minimal a reproduction as I can below. I recognize that it's probably too esoteric to bother fixing, but I figured it was worth writing down.\nOn OS X (at least on 10.10.4) if you\nConfigure AsyncHTTPClient with the CurlAsyncHTTPClient\nMake a request using requests in the main process (HTTP or HTTPS)\nThen call .bind(PORT) .start(n) (for any n) and start the IOLoop\nThen use AsyncHTTPClient (with @gen.coroutine or @web.asynchronous) or HTTPClient to make an HTTPS request in a handler\nThe worker process dies\nI tried this on Tornado 4.0.2, 4.2.1, and master, using the most recent released requests (2.7.0) and pycurl ('PycURL/7.19.5.1 libcurl/7.37.1 SecureTransport zlib/1.2.5'), the curl version is:\n$ curl --version\ncurl 7.37.1 (x86_64-apple-darwin14.0) libcurl/7.37.1 SecureTransport zlib/1.2.5\nProtocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smtp smtps telnet tftp \nFeatures: AsynchDNS GSS-Negotiate IPv6 Largefile NTLM NTLM_WB SSL libz \nSome things which prevent the issue from occurring:\nI can't reproduce this on Ubuntu 14.04 with the libcurl4-openssl-dev or libcurl4-gnutls-dev libraries, so I think it might be related to SecureTransport somehow.\nUsing the default AsyncHTTPClient.\nMoving the requests.get() call until after .start(0).\nUsing .listen() instead of bind/start.\nMaking an HTTP request in the handler instead of HTTPS.\nHere's the output of the log:\n2015-08-13 12:01:24,882 [INFO] 80378 [requests.packages.urllib3.connectionpool]: Starting new HTTP connection (1): jamessocol.com\n2015-08-13 12:01:25,355 [DEBUG] 80378 [requests.packages.urllib3.connectionpool]: \"GET / HTTP/1.1\" 200 None\n2015-08-13 12:01:25,363 [INFO] 80378 [tornado.general]: Starting 4 processes\n2015-08-13 12:01:32,542 [DEBUG] 80385 [tornado.curl_httpclient]: GET https://github.com/\n2015-08-13 12:01:32,544 [DEBUG] 80385 [tornado.curl_httpclient]: Hostname was NOT found in DNS cache\n2015-08-13 12:01:32,578 [DEBUG] 80385 [tornado.curl_httpclient]: Trying 192.30.252.130...\n2015-08-13 12:01:32,595 [DEBUG] 80385 [tornado.curl_httpclient]: Connected to github.com (192.30.252.130) port 443 (#0)\n2015-08-13 12:01:33,063 [WARNING] 80378 [tornado.general]: child 3 (pid 80385) killed by signal 11, restarting\nAnd here's the full reproduction (the logging config is to get the PID and turn on the requests logging, otherwise you can ignore it)\nimport logging.config\n\nfrom tornado import web, httpclient, httpserver, ioloop\n\nimport requests\n\n\ndef configure_logging():\n    LOGGING = {\n        'version': 1,\n        'disable_existing_loggers': True,\n        'formatters': {\n            'standard': {\n                'format': ('%(asctime)s [%(levelname)s] %(process)d '\n                           '[%(name)s]: %(message)s'),\n            },\n        },\n        'handlers': {\n            'default': {\n                'class': 'logging.StreamHandler',\n                'formatter': 'standard',\n            },\n        },\n        'loggers': {\n            'tornado': {\n                'propagate': True,\n            },\n            'requests': {\n                'propagate': True,\n            },\n        },\n        'root': {\n            'handlers': ['default'],\n            'level': 'DEBUG',\n        },\n    }\n    logging.config.dictConfig(LOGGING)\n\n\nclass DemoHandler(web.RequestHandler):\n    def get(self):\n        client = httpclient.HTTPClient()\n        client.fetch('https://github.com/')\n        self.write('hi\\n')\n        self.finish()\n\n\nif __name__ == '__main__':\n    configure_logging()\n    httpclient.AsyncHTTPClient.configure(\n        'tornado.curl_httpclient.CurlAsyncHTTPClient')\n    app = web.Application([web.url(r'^/$', DemoHandler)])\n    http_server = httpserver.HTTPServer(app)\n    requests.get('http://jamessocol.com/')\n    http_server.bind(5001)\n    http_server.start(0)\n    ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2015-08-13T16:10:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "622": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1483", "issue_id": "#1483", "issue_summary": "yield coroutine func does not response when runing it for a period of time", "issue_description": "zhkzyth commented on 8 Aug 2015\nHello, i am using tornado for the service of user logi.But today,it just did not work as usual.\nI wrote some code like below:\nsign_token, session_key = yield self.login_user(raw_user)\nlog.info('Success to login user(%s) with sign_token(%s) and session_key(%s).' % (raw_user['id'], sign_token, session_key))\nAs usual, it should work when it call the self.login_user function.\nBelow is the code:\n    @tornado.gen.coroutine\n    def login_user(self, raw_user):\n\n        req = self.requestObj\n        user_info = self.prepare_user_info(raw_user)\n        redis_conn = req.application.redis_conn\n\n        # set session data\n        session_key = SESSION_PREFIX + str(raw_user['id'])\n        # now = time.mktime(time.gmtime())\n        now = get_utc_time_stamp()\n        session_id = yield self.__gen_session_id()\n        sign_token_id = yield self.__gen_sign_token()\n        session_data = {\n            'session': session_id,\n            'session_expired_at': now + SESSION_LIFE_TIME,\n            'token': sign_token_id,\n            'token_expired_at': now + SIGN_TOKEN_LIFE_TIME\n        }\n        yield tornado.gen.Task(redis_conn.hmset, session_key, session_data)\n        log.info('Successfully to set a record for session_key:' + session_key)\n\n        # set user_info\n        # avoid to write None to redis\n        for key in user_info:\n            if user_info[key] is None:\n                user_info[key] = ''\n\n        log.info('dump user data to cache: %s ' % user_info)\n\n        user_info_key = USER_INFO_PREFIX + str(raw_user['id'])\n        yield tornado.gen.Task(redis_conn.hmset, user_info_key, user_info)\n\n        log.info('Successfully to set a record for user_key:' + user_info_key)\n\n        raise tornado.gen.Return([sign_token_id, session_id])\nBut now the func just stop responsing, the log Success to login user(... did not come out.And no exception at all.\nSome infos may help:\nMySQL-python==1.2.5\nPyYAML==3.11\nbackports.ssl-match-hostname==3.4.0.2\ncertifi==14.05.14\ncffi==0.8.6\ncryptography==0.6.1\nprotobuf==2.4.1\npyOpenSSL==0.14\npycparser==2.10\nsix==1.8.0\ntornado==4.0.2\ntornado-redis==2.4.18\ntorndb==0.3\nwsgiref==0.1.2\npytz", "issue_status": "Closed", "issue_reporting_time": "2015-08-08T12:21:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "623": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1480", "issue_id": "#1480", "issue_summary": "curl_httpclient blocks ioloop under certain conditions", "issue_description": "misuzu commented on 5 Aug 2015\n# libcurl3:amd64 7.43.0-1\n# pycurl==7.19.5.1\n# tornado==4.2.1\n# connect with ssh -D 8080 to host with 192.168.1.0/24 network\n# make sure 192.168.1.161 (pick yours) is unavailable\n# run this script\n# in 5 seconds terminate ssh session\n\nimport pycurl\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.log\nfrom tornado.httpclient import AsyncHTTPClient\n\n\ntornado.log.enable_pretty_logging()\n\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\",\n                          max_clients=10)\n\n\nhttp_client = AsyncHTTPClient()\n\n\n@tornado.gen.coroutine\ndef curl_fetch(url):\n    prepare_curl_callback = lambda x: x.setopt(pycurl.PROXYTYPE,\n                                               pycurl.PROXYTYPE_SOCKS5)\n    try:\n        response = yield http_client.fetch(url,\n                                           prepare_curl_callback=prepare_curl_callback,\n                                           proxy_host='127.0.0.1',\n                                           proxy_port=8080,\n                                           connect_timeout=30,\n                                           request_timeout=30)\n        return response.body\n    except:\n        # just ignore\n        pass\n\n\nioloop = tornado.ioloop.IOLoop.instance()\n# unavailable host on proxy side\nurl = \"http://192.168.1.161\"\nfor _ in range(500):\n    ioloop.add_callback(curl_fetch, url)\n\n\nioloop.set_blocking_log_threshold(0.5)\nioloop.start()\nHere is script output\n$ python test.py \n[W 150805 14:39:33 ioloop:350] IOLoop blocked for 0.500000 seconds in\n      File \"test.py\", line 47, in <module>\n        ioloop.start()\n      File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/ioloop.py\", line 813, in start\n        self._run_callback(timeout.callback)\n      File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/ioloop.py\", line 592, in _run_callback\n        ret = callback()\n      File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/curl_httpclient.py\", line 144, in _handle_timeout\n        pycurl.SOCKET_TIMEOUT, 0)\n      File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/curl_httpclient.py\", line 112, in _set_timeout\n        def _set_timeout(self, msecs):\n\n^CTraceback (most recent call last):\n  File \"test.py\", line 47, in <module>\n    ioloop.start()\n  File \"/tmp/pyenv/lib/python3.4/site-packages/tornado/ioloop.py\", line 841, in start\n    event_pairs = self._impl.poll(poll_timeout)\nKeyboardInterrupt", "issue_status": "Closed", "issue_reporting_time": "2015-08-05T11:43:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "624": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1474", "issue_id": "#1474", "issue_summary": "Add argument to web.Finish()", "issue_description": "socketpair commented on 29 Jul 2015\nI mean instead of\nself.finish({'error': 42})\nraise web.Finish()\nwe can write\nraise web.Finish({'error': 42})\nSo, it should pass argument to finish() inside. and if argument is given, but self._finished is True - it should raise appropriate exception.", "issue_status": "Closed", "issue_reporting_time": "2015-07-29T09:25:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "625": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1472", "issue_id": "#1472", "issue_summary": "DELETE requests never end.", "issue_description": "mendrugory commented on 27 Jul 2015\nI am building my rest api using Tornado 4.2.1 with Python 3.4.\nIf I try to send a delete request (the same with put) the request arrives to the server and it performs its duty, but the rest client (I am using the Firefox rest client) never receives the response.\nI have tried the following codes:\n    def delete(self, company_id):\n        company_model = CompanyModel()\n        company_model.delete(company_id)\n        self.set_status(NO_CONTENT)\n    def delete(self, company_id):\n        company_model = CompanyModel()\n        company_model.delete(company_id)\n        self.set_status(NO_CONTENT)\n        return\n    def delete(self, company_id):\n        company_model = CompanyModel()\n        company_model.delete(company_id)\n        self.set_status(NO_CONTENT)\n        self.finish()\nIn order to make it works I have implemented the following:\n    def delete(self, company_id):\n        company_model = CompanyModel()\n        company_model.delete(company_id)\n        self.set_status(ACCEPTED)\n        self.write(json.dumps(dict()))", "issue_status": "Closed", "issue_reporting_time": "2015-07-27T16:15:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "626": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1470", "issue_id": "#1470", "issue_summary": "`parse_config_file` not support non-string type or indent", "issue_description": "wilbeibi commented on 27 Jul 2015\nFor now I have to use pyyaml because the built-in parse_config_file:\nOnly support string type\nDoes not support embedded config (So we cannot put development config file and production config together)", "issue_status": "Closed", "issue_reporting_time": "2015-07-26T21:58:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "627": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1469", "issue_id": "#1469", "issue_summary": "ioloop.py(line 252) is None or not None", "issue_description": "yjwei commented on 24 Jul 2015\nline 252\uff0c IOLoop.current(instance=False) is None\u3002why then raise \"already exists\"?", "issue_status": "Closed", "issue_reporting_time": "2015-07-24T07:15:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "628": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1467", "issue_id": "#1467", "issue_summary": "Future leaks?", "issue_description": "jetz commented on 23 Jul 2015\nRecently we develop a comet server using tornado 4.1, but it eats more and more memory. After analyzing by guppy, we find the Future objects are increasing all the time. Only a few hundreds at the beginning, but a few days later, there are tens of thousand, and never decrease even with lower http requests. Like:\nEspecially when clients close with long poll unfinished (it will lead on_connection_close), the new Futures will stay there and can't release with gc. I figure it out using ab, so I think it is main reason for the leak.\nFllowing is core part of the code:\nclass StatusCometHandler(tornado.web.RequestHandler):\n\n    def initialize(self):\n        self.broker = Broker()\n\n    def prepare(self):\n        self.broker.connect()\n\n    def on_finish(self):\n        self.broker.disconnect()\n\n    def on_connection_close(self):\n        # WARNNING: disconnect here will lead memory leak, no idea\n        pass\n\n    @tornado.gen.coroutine\n    def get(self):\n        try:\n            sid = self.get_query_argument('sid')\n            appid = self.get_query_argument('appid')\n        except tornado.web.MissingArgumentError as e:\n            self.write(...)\n            return\n        except AssertionError:\n            self.write(...)\n            return\n        step = yield self.broker.get_step(sid, timeout=5)\n        if not step:\n            self.write(...)\n        else:\n            r = yield self.broker.get_auth(sid)\n            self.write(...)\nHere broker is redis and get_step will return a gen.Task wrapped blpop (tornadoredis). get_auth is just a wrapped get command .\nSo, is it possible Future leaks in some situation, eg. can't be resoved and always stay there? Or I do something wrong?", "issue_status": "Closed", "issue_reporting_time": "2015-07-23T09:46:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "629": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1466", "issue_id": "#1466", "issue_summary": "AttributeError when overriding get_new_ioloop with more than one test", "issue_description": "rsmith31415 commented on 23 Jul 2015\nI believe this is an old issue in which overriding get_new_ioloop in AsyncHTTPTestCase throws AttributeError: 'NoneType' object has no attribute done when there are more than one test in the class (that is, the first test actually passes correctly but other tests output the previous error). This is a sample code:\nimport tornado.web\nimport tornado.gen\nimport tornado.websocket\nimport tornado.httpserver\nimport tornado.ioloop \n\nimport json\nimport time\n\nfrom tornado.testing import gen_test\nfrom tornado.testing import AsyncHTTPTestCase\nfrom tornado import websocket\n\nclass EchoWebSocket(tornado.websocket.WebSocketHandler):\n    def open(self):\n        print(\"WebSocket opened\")\n\n    def on_message(self, message):\n        message = json.loads(message)\n\n        tornado.ioloop.IOLoop.current().add_callback(lambda: self.write_message(message))\n\n    def on_close(self):\n        print(\"WebSocket closed\")\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n\n        handlers = [\n            (r'/websocket', EchoWebSocket),\n        ]\n        settings = {\n            'debug': True,\n        }\n\n        tornado.web.Application.__init__(self, handlers, **settings)\n\n\nif __name__ == '__main__':\n    tornado.options.parse_command_line()\n    app = Application()\n    app.listen(8000)\n\n    try:\n        tornado.ioloop.IOLoop.current().start()\n    except:\n        pass\n    finally:\n        tornado.ioloop.IOLoop.current().stop()\n\nclass TestEchoWebSocket(AsyncHTTPTestCase):\n    def get_app(self):\n        self.application = Application()\n        return self.application\n\n    def get_new_ioloop(self):\n        return tornado.ioloop.IOLoop.current()\n\n    def setUp(self):\n        super(TestEchoWebSocket, self).setUp()\n\n    def tearDown(self):\n        tornado.ioloop.IOLoop.current().stop()\n\n    @gen_test()\n    def test_websocket_1(self):\n        url = \"ws://localhost:%d/websocket\" % self.get_http_port()\n        ws = yield websocket.websocket_connect(url, io_loop=self.io_loop)\n        data = {'value': '1'}\n        data = json.dumps(data)\n        ws.write_message(data)\n        response = yield ws.read_message()\n        response = json.loads(response)\n        self.assertEqual(response['value'], \"1\")\n\n    @gen_test\n    def test_websocket_2(self):\n        url = \"ws://localhost:%d/websocket\" % self.get_http_port()\n        ws = yield websocket.websocket_connect(url, io_loop=self.io_loop)\n        data = {'value': '1'}\n        data = json.dumps(data)\n        ws.write_message(data)\n        response = yield ws.read_message()\n        response = json.loads(response)\n        self.assertEqual(response['value'], \"1\")\n.E\n======================================================================\nERROR: test_websocket_2 (tornado_addcallback_test2.TestEchoWebSocket)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/home/user/anaconda/envs/tornado-environment/lib/python2.7/site-packages/tornado/testing.py\", line 120, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/home/user/anaconda/envs/tornado-environment/lib/python2.7/site-packages/tornado/testing.py\", line 503, in post_coroutine\n    timeout=timeout)\n  File \"/home/user/anaconda/envs/tornado-environment/lib/python2.7/site-packages/tornado/ioloop.py\", line 419, in run_sync\n    if not future_cell[0].done():\nAttributeError: 'NoneType' object has no attribute 'done'\n\n----------------------------------------------------------------------\nRan 2 tests in 0.013s\n\nFAILED (errors=1)\nI don't think this is related to websockets, but that is what I have to reproduce this issue. I tried to use tornado.ioloop.IOLoop.current() instead of tornado.ioloop.IOLoop.instance() but the problem remains. I also tried to see if tornado.ioloop.IOLoop.current().add_callback(lambda: self.write_message(message)) was somehow related but using self.write_message(message) throws the same error. How can I fix this issue?", "issue_status": "Closed", "issue_reporting_time": "2015-07-23T01:09:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "630": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1464", "issue_id": "#1464", "issue_summary": "locks.py and @run_on_executor can work together?", "issue_description": "mqingyn commented on 11 Jul 2015\nI found Queue,Event and Lock in Tornado4.2,but these are not thread safe. So ThreadedResolver and @run_on_executor can worked with them?", "issue_status": "Closed", "issue_reporting_time": "2015-07-11T01:22:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "631": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1463", "issue_id": "#1463", "issue_summary": "Creating a coroutine which runs forever", "issue_description": "KimiNewt commented on 8 Jul 2015\nI have a pattern which I've used often, wherein I add a future which needs to run for the entirety of the program. For instance, constantly querying another service and acting on the results when they arrive (possibly gen.sleeping if the other service says it's not ready, though that's not important)\nIt usually looks something like this:\n@gen.coroutine\ndef query_forever(self):\n    while not self.should_stop:\n          res = yield my_other_coroutine()\n          if not do_something(res):\n                yield gen.sleep(SLEEP_TIME)\n\n# Later\nIOLoop.current().add_future(query_forever(), terminated_callback)\nIt can also be done by a callback reregistering itself when finished. It would be similar to creating a PeriodicCallback with an interval of zero.\nIs this something that has room in the main package? I can create a PR if so.", "issue_status": "Closed", "issue_reporting_time": "2015-07-08T07:40:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "632": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1462", "issue_id": "#1462", "issue_summary": "Prevent @gen.coroutine from eating 'callback' kwarg.", "issue_description": "KenjiTakahashi commented on 6 Jul 2015\nI have a code where I have to pass a callback (kw)argument which is used by the wrapped function for some other purpose. It would be nice to have a way to tell the coroutine wrapper not to \"eat\" it.\nLooking through the code, I see there is a replace_callback boolean in the coroutine function, but there is no way to set it when using it as decorator. And even if there was, it is not propagated to the wrapper anyway.\nFor now I have worked around it by calling _make_coroutine_wrapper directly with replace_callback=False, but it feels a bit clumsy.", "issue_status": "Closed", "issue_reporting_time": "2015-07-06T15:46:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "633": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1459", "issue_id": "#1459", "issue_summary": "Testing websockets and POST request occurring concurrently", "issue_description": "rsmith31415 commented on 1 Jul 2015\nI need to test a POST request occurring immediately after a message sent using websockets, but I get tornado.access: ERROR: 500 POST. This is what I have so far:\n    @gen_test\n    def test_interaction(self):\n        url = \"ws://localhost:%d/websocket\" % self.get_http_port()\n        ws = yield websocket.websocket_connect(url, io_loop=self.io_loop)\n        data = json.dumps(data) # data includes something that sends an initial message\n        ws.write_message(data)\n        data_post = urlencode(other_data)\n        response_post = yield self.http_client.fetch(self.get_url('/my_url'), method='POST', body=data_post)\n        response = yield ws.read_message()\n        response = json.loads(response.body)\n        self.assertEqual(some_condition)\nIs it possible to test this kind of interaction? The idea is to test that the POST request modifies the result of the websocket response.", "issue_status": "Closed", "issue_reporting_time": "2015-07-01T14:43:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "634": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1458", "issue_id": "#1458", "issue_summary": "Add option for setting server_hostname in tornado.httpclient.HTTPRequest?", "issue_description": "kawing-chiu commented on 26 Jun 2015\nI'm trying to make a https request like this using AsyncHTTPClient:\nrequest = HTTPRequest('https://some_ip_address/2',\n        headers={'Host': 'xxx.appspot.com'},\n        ssl_options=ssl_context)\nIt failed with an ssl.CertificateError saying that the hostnames don't match. This is because the ssl connection assumes that the hostname to match is some_ip_address. If the server_hostname parameter of IOStream.start_tls() is also set to xxx.appspot.com then it works fine. However, this parameter is not exposed and I can find no way to work around it. So, should this parameter be added to the interface or am I missing something?", "issue_status": "Closed", "issue_reporting_time": "2015-06-26T12:48:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "635": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1452", "issue_id": "#1452", "issue_summary": "Redirect handling in http client does not retain cookies.", "issue_description": "dave-shawley commented on 12 Jun 2015\nI was testing some OAuth related code that sets a login cookie and redirects to the root of the application. I believe that _HTTPConnection.finish should be copying the Set-Cookie header from the redirect response (e.g., self.headers) into new_request. I will put together a pull request for this some time tonight. If I am missing something, let me know.\nOh... and keep up the good work ;)", "issue_status": "Closed", "issue_reporting_time": "2015-06-12T11:38:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "636": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1451", "issue_id": "#1451", "issue_summary": "ValueError from curl_httpclient causing response callback to not get called", "issue_description": "bobpoekert commented on 9 Jun 2015\nInvalid HTTP responses are causing the following exception to get thrown and not caught:\nValueError: need more than 1 value to unpack\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/curl_httpclient.py\", line 467, in _curl_header_callback\n    headers.parse_line(header_line)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 189, in parse_line\n    name, value = line.split(\":\", 1)\nAs far as I can tell when this happens the response callback never gets called.", "issue_status": "Closed", "issue_reporting_time": "2015-06-09T05:14:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "637": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1450", "issue_id": "#1450", "issue_summary": "Tornado Templating With {% code %}", "issue_description": "BastinRobin commented on 6 Jun 2015\nHow to use {% code %} {% end %} inside html template. Its one of main feature i am expecting. If any one can give me an answer at stackoverflow it could be helpful.\nhttp://stackoverflow.com/q/30678690/2158057", "issue_status": "Closed", "issue_reporting_time": "2015-06-06T03:47:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "638": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1449", "issue_id": "#1449", "issue_summary": "tornado.locale has issues on files with UTF-8 BOM encoding", "issue_description": "Contributor\njnsflint commented on 5 Jun 2015\nWe had a .csv file that was saved in UTF-8 BOM. Tornado then does not load the first line for translation. We could fix this issue by saving the file as UTF-8 without BOM.\nAccording to this thread on stackoverflow the issue might be here:\nf = open(full_path, \"r\", encoding=\"utf-8\")\nwhich should check if there is a BOM or not. Unfortunately python does not to do this by its own :/", "issue_status": "Closed", "issue_reporting_time": "2015-06-04T19:20:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "639": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1447", "issue_id": "#1447", "issue_summary": "XSRF CVE in tornado 2.2.1", "issue_description": "opoplawski commented on 28 May 2015\nWe believe that tornado 2.2.1 in EPEL6 is vulnerable to the XSRF CVE - bug is filed here:\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1222820\nI made a quick attempt to backport the 3.2.2 fix (attached to bug report), but it does not look good. I'm hoping for a little help/advice from upstream. Perhaps updating to a somewhat newer tornado in EPEL6 first would be good, but we can't break API. Any suggestions?", "issue_status": "Closed", "issue_reporting_time": "2015-05-27T20:02:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "640": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1445", "issue_id": "#1445", "issue_summary": "HTTPHeaders do not unpickled", "issue_description": "tonal commented on 21 May 2015\ntest case:\nPython 3.4.0 (default, Apr 11 2014, 13:05:11) \n[GCC 4.8.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import tornado.httputil as thu\n>>> h = thu.HTTPHeaders({\"content-type\": \"text/html\"})\n>>> import pickle\n>>> s = pickle.dumps(h, -1)\n>>> pickle.loads(s)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/media/tonal/my_book/lang/sources/git/tornado/tornado/httputil.py\", line 211, in __setitem__\n    self._as_list[norm_name] = [value]\nAttributeError: 'HTTPHeaders' object has no attribute '_as_list'", "issue_status": "Closed", "issue_reporting_time": "2015-05-21T11:19:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "641": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1443", "issue_id": "#1443", "issue_summary": "Test failures ipv6 disabled", "issue_description": "opoplawski commented on 19 May 2015\nI have ipv64.disable=1 on my kernel boot line. Trying to build 4.1.0 through current git master I get:\nERROR: test_ipv6 (tornado.test.simple_httpclient_test.SimpleHTTPClientTestCase)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 119, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/simple_httpclient_test.py\", line 256, in test_ipv6\n    [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)\nValueError: need more than 0 values to unpack\n\n======================================================================\nERROR: test_ipv6 (tornado.test.simple_httpclient_test.SimpleHTTPSClientTestCase)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 119, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/simple_httpclient_test.py\", line 256, in test_ipv6\n    [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)\nValueError: need more than 0 values to unpack\n\n======================================================================\nERROR: test_connect_ipv6_dual (tornado.test.tcpclient_test.TCPClientTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 119, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 107, in test_connect_ipv6_dual\n    self.do_test_connect(socket.AF_INET6, 'localhost')\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 500, in post_coroutine\n    timeout=timeout)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/ioloop.py\", line 444, in run_sync\n    return future_cell[0].result()\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/concurrent.py\", line 214, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/gen.py\", line 230, in wrapper\n    yielded = next(result)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 84, in do_test_connect\n    port = self.start_server(family)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 60, in start_server\n    self.server = TestTCPServer(family)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 40, in __init__\n    self.port = sockets[0].getsockname()[1]\nIndexError: list index out of range\n\n======================================================================\nERROR: test_connect_ipv6_ipv6 (tornado.test.tcpclient_test.TCPClientTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 119, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 100, in test_connect_ipv6_ipv6\n    self.do_test_connect(socket.AF_INET6, '::1')\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 500, in post_coroutine\n    timeout=timeout)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/ioloop.py\", line 444, in run_sync\n    return future_cell[0].result()\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/concurrent.py\", line 214, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/gen.py\", line 230, in wrapper\n    yielded = next(result)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 84, in do_test_connect\n    port = self.start_server(family)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 60, in start_server\n    self.server = TestTCPServer(family)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 40, in __init__\n    self.port = sockets[0].getsockname()[1]\nIndexError: list index out of range\n\n======================================================================\nERROR: test_connect_unspec_ipv6 (tornado.test.tcpclient_test.TCPClientTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 119, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 115, in test_connect_unspec_ipv6\n    self.do_test_connect(socket.AF_UNSPEC, '::1')\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/testing.py\", line 500, in post_coroutine\n    timeout=timeout)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/ioloop.py\", line 444, in run_sync\n    return future_cell[0].result()\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/concurrent.py\", line 214, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/gen.py\", line 876, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/test/tcpclient_test.py\", line 85, in do_test_connect\n    stream = yield self.client.connect(host, port)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/gen.py\", line 870, in run\n    value = future.result()\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/concurrent.py\", line 214, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/gen.py\", line 879, in run\n    yielded = self.gen.send(value)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/tcpclient.py\", line 167, in connect\n    af, addr, stream = yield connector.start()\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/tcpclient.py\", line 80, in start\n    self.try_connect(iter(self.primary_addrs))\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/tcpclient.py\", line 95, in try_connect\n    future = self.connect(af, addr)\n  File \"/export/home/orion/fedora/python-tornado/python-tornado-4.2.0git/python3/tornado/tcpclient.py\", line 179, in _create_stream\n    stream = IOStream(socket.socket(af),\n  File \"/usr/lib64/python3.4/socket.py\", line 123, in __init__\n    _socket.socket.__init__(self, family, type, proto, fileno)\nOSError: [Errno 97] Address family not supported by protocol\nI'm not sure if this is worth handling better or not.", "issue_status": "Closed", "issue_reporting_time": "2015-05-18T22:30:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "642": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1442", "issue_id": "#1442", "issue_summary": "Add timeout to Task", "issue_description": "stephane-martin commented on 18 May 2015\ntornado.gen.Task could take a timeout parameter, and then raise an exception if the task has not returned after the timeout", "issue_status": "Closed", "issue_reporting_time": "2015-05-17T19:50:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "643": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1441", "issue_id": "#1441", "issue_summary": "class tornado.auth.GoogleOAuth2Mixin No more!!!", "issue_description": "omata-metamax commented on 15 May 2015\nHello,\nGoogle authentication with oauth2 is no more, instead google upgrade this to something called Google Connect, please update to this very last mechanism.\nThanks in advance,", "issue_status": "Closed", "issue_reporting_time": "2015-05-14T21:51:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "644": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1440", "issue_id": "#1440", "issue_summary": "sth wrong with running demo/chat", "issue_description": "xiazhibin commented on 9 May 2015\ni run the demo 'chat'.\ninput 'localhost:8888' in my chrome\nbut from the terminal,it returns 302 .\nso i delete all handlers except MainHandler and change the MainHandler like this:\nclass MainHandler(BaseHandler):\ndef get(self):\nself.wirte('hello')\nand then it works.\ni guess my path is sth wrong,but i am not sure.\ni can not solve this problem.\nmy workspace is mac ,python3.4.2.the demo 'chat' run on virtualenv", "issue_status": "Closed", "issue_reporting_time": "2015-05-09T09:36:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "645": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1439", "issue_id": "#1439", "issue_summary": "IOLoop become current loop issue", "issue_description": "yuxizhou commented on 6 May 2015\nIn version 4.1, when a new IOLoop is created, it automatically becomes \u201ccurrent\u201d for the thread if there is not already a current instance.\nso, if I instance an IOLoop before application.listen(8888), HttpServer will add this socket into the IOLoop I instance before. finally I run \"tornado.ioloop.IOLoop.instance().start()\", socket is NOT added into this \"main loop\".\nimport tornado.ioloop\nimport tornado.web\n\n_ioloop = tornado.ioloop.IOLoop()\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2015-05-06T08:16:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "646": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1435", "issue_id": "#1435", "issue_summary": "Future.result() and Future.exception() have timeout=None that is not used in code", "issue_description": "socketpair commented on 30 Apr 2015\nsee subj. Etither document that these arguments are ignored, or remove them", "issue_status": "Closed", "issue_reporting_time": "2015-04-30T05:23:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "647": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1429", "issue_id": "#1429", "issue_summary": "WaitIterator sometimes hangs", "issue_description": "Contributor\nWGH- commented on 24 Apr 2015\nFor some reason, this example hangs if you pass n>1. It works if n==1.\nimport tornado.gen\nimport tornado.ioloop\n\n@tornado.gen.coroutine\ndef f(n=1):\n    for _ in range(n):\n        yield tornado.gen.sleep(0.5)\n    return 5\n\n@tornado.gen.coroutine\ndef g():\n    raise RuntimeError\n\n@tornado.gen.coroutine\ndef main():\n    waiter = tornado.gen.WaitIterator(g(), f(2))\n    while not waiter.done():\n        try:\n            val = yield waiter.next()\n        except Exception as e:\n            print(\"Caught %r\" % e)\n        else:\n            print(\"Returned val=%r\" % val)\n\n    print(\"waiter loop finished\")\n\nif __name__ == \"__main__\":\n    tornado.ioloop.IOLoop.instance().run_sync(main)", "issue_status": "Closed", "issue_reporting_time": "2015-04-24T09:56:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "648": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1428", "issue_id": "#1428", "issue_summary": "xhtml_unescape doesn't handle hex numeric references", "issue_description": "Contributor\nszweep commented on 24 Apr 2015\nHi,\nWhile attempting to use the tornado.escape.xhtml_unescape function to decode data encoded externally I noticed that the function would fail to decode if the encoded string contained a numeric character specified in hex. I.e. unescaping '&#32;' works OK, but '&#x20;' doesn't.\nI have a fix for this in escape.py and could generate a pull request if you would like to take a look.\nThanks,\nSteve Zweep", "issue_status": "Closed", "issue_reporting_time": "2015-04-23T20:52:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "649": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1427", "issue_id": "#1427", "issue_summary": "tornado.options.Error: Option already defined in", "issue_description": "harryprince commented on 22 Apr 2015\nHow I can address this problem\uff1f", "issue_status": "Closed", "issue_reporting_time": "2015-04-22T06:15:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "650": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1424", "issue_id": "#1424", "issue_summary": "application/json only instance dict", "issue_description": "yskomur commented on 20 Apr 2015\nalso add list [] for json_encode in web.py write.\nlike\nif isinstance(chunk, dict) or isinstance(chunk, list):\nchunk = escape.json_encode(chunk)\nin web.py line around 656", "issue_status": "Closed", "issue_reporting_time": "2015-04-19T20:09:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "651": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1420", "issue_id": "#1420", "issue_summary": "ValueError: I/O operation on closed epoll fd", "issue_description": "VMitov commented on 14 Apr 2015\nJust updated tornado from 3.1.1.0 to 4.1 and I'm getting the following error:\n\"ValueError: I/O operation on closed epoll fd\"\nThe error is raised on Application().listen() and is caused by call to HTTPClient().fetch() preceding it. Commenting self._io_loop.close() in HTTPClient().close() gives the impression of fixing the problem, but I can't find proper solution for now.\nAny suggestions?", "issue_status": "Closed", "issue_reporting_time": "2015-04-14T15:43:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "652": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1415", "issue_id": "#1415", "issue_summary": "Save file cause tornado losing socket binding", "issue_description": "MengJueM commented on 10 Apr 2015\nBackground:\nTornado installed latest from PyPi\nWin7\nPycharm\nI open the debug=True flag, once I save the py file, I will get below error:\nTraceback (most recent call last):\n  File \"C:/Users/xxx/PycharmProjects/scip/tornado/definition_readonly.py\", line 60, in <module>\n    main()\n  File \"C:/Users/xxx/PycharmProjects/scip/tornado/definition_readonly.py\", line 54, in main\n    http_server.listen(options.port)\n  File \"C:\\Users\\xxx\\Miniconda\\envs\\vispy\\lib\\site-packages\\tornado\\tcpserver.py\", line 125, in listen\n    sockets = bind_sockets(port, address=address)\n  File \"C:\\Users\\xxx\\Miniconda\\envs\\vispy\\lib\\site-packages\\tornado\\netutil.py\", line 145, in bind_sockets\n    sock.bind(sockaddr)\n  File \"C:\\Users\\xxx\\Miniconda\\envs\\vispy\\lib\\socket.py\", line 224, in meth\n    return getattr(self._sock,name)(*args)\nsocket.error: [Errno 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted\n\nProcess finished with exit code 1\nBelow is toy code I used:\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport pymongo\n\nfrom bson import json_util\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\n\nclass WordHandler(tornado.web.RequestHandler):\n    def data_received(self, chunk):\n        pass\n\n    def get(self, word):\n        coll = self.application.db.words\n        word_doc = coll.find({\"word\": word})\n\n        if word_doc:\n            word_doc = json_util.dumps(word_doc)\n            self.write(word_doc)\n        else:\n            self.set_status(404)\n            self.write({\"error\": \"word not found\"})\n\n    def post(self, word):\n        definition = self.get_argument(\"definition\")\n        coll = self.application.db.words\n        word_doc = coll.find_one({\"word\": word})\n        if word_doc:\n            word_doc['definition'] = definition\n            coll.save(word_doc)\n        else:\n            word_doc = {'word': word, 'definition': definition}\n            coll.insert(word_doc)\n        self.write(word_doc)\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r\"/(\\w+)\", WordHandler),\n        ]\n        conn = pymongo.MongoClient(host=\"go.imf.cc\")\n        self.db = conn[\"test\"]\n        tornado.web.Application.__init__(self, handlers, debug=True)\n\n\ndef main():\n    tornado.options.parse_command_line()\n    http_server = tornado.httpserver.HTTPServer(Application())\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == '__main__':\n    # tornado.ioloop.IOLoop.instance().stop()\n    main()\nI have to run tornado.ioloop.IOLoop.instance().stop() to clean the socket binding and then restart tornado server.", "issue_status": "Closed", "issue_reporting_time": "2015-04-10T10:11:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "653": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1413", "issue_id": "#1413", "issue_summary": "Exception in CurlAsyncHTTPClient doesn't set exception in request future", "issue_description": "ojomio commented on 8 Apr 2015\nI have a situation in which one faulty request stops all my application. The traceback is as follows\nERROR:[tornado.application][ioloop.py:585]:Exception in callback (14, <function wrap.<locals>.null_wrapper at 0x7f4b2008dbf8>)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/ioloop.py\", line 837, in start\n    handler_func(fd_obj, events)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/curl_httpclient.py\", line 138, in _handle_events\n    self._finish_pending_requests()\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/curl_httpclient.py\", line 197, in _finish_pending_requests\n    self._process_queue()\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/curl_httpclient.py\", line 215, in _process_queue\n    curl.info[\"headers\"])\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/curl_httpclient.py\", line 278, in _curl_setup_request\n    curl.setopt(pycurl.URL, native_str(request.url))\nUnicodeEncodeError: 'ascii' codec can't encode character '\\u2116' in position 73: ordinal not in range(128)\nAs I understand, in CurlAsyncHTTPClient._handle_socket() there is a line\n self.io_loop.add_handler(fd, self._handle_events,\n                                     ioloop_event)\nwhich adds a handler on some FD events to IOLoop. So when an event is processed it is basically in no context other than bare IOLoop.\nIf an exception occurs in such a handler Tornado does not handle it and neither does it call handle_response() defined in AsyncHTTPClient.fetch() thus leaving the associated Future unfinished(future leaks!)\nWhen my application waits all coroutines in a yield list_ construct it lacks one which called faulty request and hangs :(", "issue_status": "Closed", "issue_reporting_time": "2015-04-08T08:24:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "654": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1410", "issue_id": "#1410", "issue_summary": "PeriodicCallback", "issue_description": "alanderex commented on 5 Apr 2015\nIf multiple cores are used, PeriodicCallback seems to get excecuted on each and every core.\nSo on my 8 core server _ mycronfunc_ was called eight times, though it's supposed to run only once (on any core).\nserver = HTTPServer(app)\nserver.bind(9999)\nserver.start(0)  # Forks multiple sub-processes 0 = use all cores\ninterval_ms = 30 * 1000\nPeriodicCallback(mycronfunc, interval_ms).start()\nIOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2015-04-05T10:00:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "655": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1404", "issue_id": "#1404", "issue_summary": "HTTPS connection error", "issue_description": "beef9999 commented on 2 Apr 2015\nUbuntu 14.04 and 12.04 (all tested), 64bit\npip install tornado (ver 4.1)\ncurl -X POST -v -k https://remote_ip:8080\nError as below:\nERROR:tornado.application:Exception in callback (<socket._socketobject object at 0x7fb670a4ad00>, <function null_wrapper at 0x7fb670a05aa0>)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 840, in start\n    handler_func(fd_obj, events)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/netutil.py\", line 223, in accept_handler\n    callback(connection, address)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/tcpserver.py\", line 225, in _handle_connection\n    do_handshake_on_connect=False)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/netutil.py\", line 470, in ssl_wrap_socket\n    return ssl.wrap_socket(socket, **dict(context, **kwargs))\n  File \"/usr/lib/python2.7/ssl.py\", line 489, in wrap_socket\n    ciphers=ciphers)\n  File \"/usr/lib/python2.7/ssl.py\", line 243, in __init__\n    ciphers)\nSSLError: _ssl.c:295: Both the key & certificate files must be specified\nMy server code looks like this:\nimport tornado\nimport tornado.web\nimport tornado.httpserver\nimport tornado.ioloop\n\nclass Docker(tornado.web.RequestHandler):\n    def post(self, *args, **kwargs):\n        self.write('1\\n')\n\napplication = tornado.web.Application(\n    handlers=[\n        (r'/', Docker),\n    ],\n    debug=True,\n)\n\nif __name__ == '__main__':\n    ssl_options={'certfile': 'certificate.crt',\n                 'keyfile': 'privateKey.key'},\n    srv = tornado.httpserver.HTTPServer(application, xheaders=True, ssl_options=ssl_options)\n    srv.bind(8080)\n    srv.start()\n    tornado.ioloop.IOLoop.instance().start()\nNote that I use openssl to generate the certificate and key file:\nopenssl genrsa -out privkey.pem 2048\nopenssl req -new -x509 -key privkey.pem -out cacert.pem -days 1095\nEspecially, when I added one key into the ssl_options dict, cert_reqs=ssl.CERT_NONE, enven more strange error appeared:\nFile /usr/local/lib/python2.7/dist-packages/tornado/netutil.py:\nreturn ssl.wrap_socket(socket, **dict(context, **kwargs))\ndictionary update sequence element #0 has length 1 2 is required\nI'm really desperate to make my tornado app work properly under HTTPS, could you help?", "issue_status": "Closed", "issue_reporting_time": "2015-04-02T08:25:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "656": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1403", "issue_id": "#1403", "issue_summary": "(sorry wrong repo) TypeError: 'TornadoCursor' object is not iterable", "issue_description": "v3ss0n commented on 2 Apr 2015\nI am now testing rethinkdb in tornado, all test pass in rethinktb tornado connection test but when i tried to use it inside tornado , I am having problem iterating TornadoCursor.\nimport logging\nimport tornado.escape\nimport tornado.ioloop\nimport tornado.web\nimport os.path\nimport uuid\nimport rethinkdb as r\nfrom tornado.concurrent import Future\nfrom tornado import gen\nfrom tornado.options import define, options, parse_command_line\nr.set_loop_type(\"tornado\")\ndefine(\"port\", default=8080, help=\"run on the given port\", type=int)\ndefine(\"debug\", default=False, help=\"run in debug mode\")\nconn = r.connect(\"localhost\")\nevt = r.db(\"rechat\").table(\"events\")\nclass MainHandler(tornado.web.RequestHandler):\n\n    @gen.coroutine\n    def get(self):\n        con = yield conn\n        curs = yield evt.run(con)\n        messages = list(curs)\n        self.render(\"index.html\", messages=messages)\nTried looping , list comprehension , none of that helped.", "issue_status": "Closed", "issue_reporting_time": "2015-04-02T01:16:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "657": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1402", "issue_id": "#1402", "issue_summary": "I want to add my site to the Projects Built on Tornado. how to do this?", "issue_description": "no13bus commented on 1 Apr 2015\nMy project is builded by tornado, mongo, redis and highchart. It uses github webhook to analysis that who star your repository, where are they and show the top 5 followers. And you can fellow some users.\nHere is the demo:\nhttp://ohmyrepo.ml/show?u=no13bus&r=ohmyrepo\nSouce code:\nhttps://github.com/no13bus/ohmyrepo", "issue_status": "Closed", "issue_reporting_time": "2015-04-01T08:29:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "658": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1400", "issue_id": "#1400", "issue_summary": "getting many HTTP 599 errors for valid urls", "issue_description": "YS- commented on 30 Mar 2015\nI'm using tornado AsyncHTTPClient with the following code, I basically call the scrape function with a url generator list that contains 10K urls.\nI expect to have maximum 50 concurrent requests at any time, which doesn't seem to work as the entire process ends in about 2 minutes.\nI got ~200 valid responses and ~9000 HTTP 599 error. I checked many urls that threw this error and they do load in less than 10 sec', I'm able to reach most urls using urllib2/requests with a smaller timeout (5 seconds).\nAll requests sent to different servers, running from ubuntu with python 2.7.3 & tornado version = \"4.1\".\nI suspect that something is wrong as I can fetch most urls using other (blocking) libraries.\nimport tornado.ioloop\nimport tornado.httpclient\n\nclass Fetcher(object):\n    def __init__(self, ioloop):\n        self.ioloop = ioloop\n        self.client = tornado.httpclient.AsyncHTTPClient(io_loop=ioloop, max_clients=50)\n        self.client.configure(None, defaults=dict(user_agent=\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36\",\n                                                  connect_timeout=20,request_timeout=20, validate_cert=False))\n\n    def fetch(self, url):\n        self.client.fetch(url, self.handle_response)\n\n    @property\n    def active(self):\n        \"\"\"True if there are active fetching happening\"\"\"\n        return len(self.client.active) != 0\n\n    def handle_response(self, response):\n        if response.error:\n            print \"Error: %s, time: %s, url: %s\" % (response.error, response.time_info, response.effective_url)\n        else:\n           # print \"clients %s\" % self.client.active\n            print \"Got %d bytes\" % (len(response.body))\n\n        if not self.active:\n            self.ioloop.stop()\n\ndef scrape(urls):\n    ioloop = tornado.ioloop.IOLoop.instance()\n    ioloop.add_callback(scrapeEverything, *urls)\n    ioloop.start()\n\ndef scrapeEverything(*urls):\n    fetcher = Fetcher(tornado.ioloop.IOLoop.instance())\n\n    for url in urls:\n        fetcher.fetch(url)\n\nif __name__ == '__main__':\nscrape()", "issue_status": "Closed", "issue_reporting_time": "2015-03-30T16:24:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "659": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1395", "issue_id": "#1395", "issue_summary": "Returning Future from BaseIOStream.read_until_close", "issue_description": "Contributor\nlegnaleurc commented on 25 Mar 2015\nIt says:\nChanged in version 4.0: The callback argument is now optional and a Future will be returned if it is omitted.\nThis is true if both callback=None and streaming_callback=None, but not when streaming_callback is not None. For example:\np = Subprocess([...], stdout=Subprocess.STREAM)\n# raise exception\nyield p.stdout.read_until_close(streaming_callback=print)\n# need to wrap in Task\nyield Task(p.stdout.read_until_close, streaming_callback=print)\nIs this an intended behavior?", "issue_status": "Closed", "issue_reporting_time": "2015-03-25T05:37:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "660": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1391", "issue_id": "#1391", "issue_summary": "Add a coroutine version process.Subprocess.wait", "issue_description": "Contributor\nlegnaleurc commented on 19 Mar 2015\nLike https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.wait\nPossible implementation:\n@gen.coroutine\ndef wait(self):\n    returncode = self.proc.poll()\n    while returncode is None:\n        yield gen.moment\n        returncode = self.proc.poll()", "issue_status": "Closed", "issue_reporting_time": "2015-03-19T10:20:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "661": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1390", "issue_id": "#1390", "issue_summary": "Document about web.Application.listen", "issue_description": "Contributor\nlegnaleurc commented on 19 Mar 2015\nIt states:\nNote that after calling this method you still need to call\n``IOLoop.instance().start()`` to start the server.\nActually HTTPServer is using IOLoop.current(), so the paragraph is not true if other IOLoop has been created before IOLoop.instance().\nFor example:\nclass Worker(threading.Thread):\n\n    def __init__(self, *args, **kwargs):\n        super(Worker, self).__init__(*args, **kwargs)\n        self.ioloop = IOLoop()\n\n\nworker = Worker()\napplication = Application([...])\napplication.listen(8000)\nworker.start()\nIOLoop.instance().start()\nThen the handlers will run on the thread, instead of the main ioloop.", "issue_status": "Closed", "issue_reporting_time": "2015-03-19T09:55:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "662": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1389", "issue_id": "#1389", "issue_summary": "Incomplete doc string in IOLoop.current", "issue_description": "Contributor\nlegnaleurc commented on 19 Mar 2015\ntornado/tornado/ioloop.py\nLine 192 in 458cc4f\n            Added ``instance`` argument to control the \nAdded ``instance`` argument to control the", "issue_status": "Closed", "issue_reporting_time": "2015-03-19T09:36:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "663": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1387", "issue_id": "#1387", "issue_summary": "fetch method do not have raise_error argument, why?", "issue_description": "no13bus commented on 18 Mar 2015\nhere is my code:\n@gen.coroutine\n def post(self):\n        url = 'https://api.github.com/users/AUS3RIS'\n        res = yield AsyncHTTPClient().fetch(url, raise_error=False)\nand the error is TypeError: __init__() got an unexpected keyword argument 'raise_error'. But this told me that raise_error exist. My tornado version is 3.2 or 4.0.", "issue_status": "Closed", "issue_reporting_time": "2015-03-18T09:14:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "664": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1386", "issue_id": "#1386", "issue_summary": "Tornado and CurlHTTPClient does not work in pypy", "issue_description": "mqingyn commented on 18 Mar 2015\nTornado and CurlHTTPClient does not work in pypy ,a SystemError: StackOverflow object at 0x1d47148 exception is thrown \u3002", "issue_status": "Closed", "issue_reporting_time": "2015-03-18T08:38:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "665": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1385", "issue_id": "#1385", "issue_summary": "@gen.coroutine do not support redirect?", "issue_description": "no13bus commented on 18 Mar 2015\nI use self.redirect('/') in post method. here is the code:\nclass IndexHandler(BaseHandler):\n    def get(self):\n        pass\n\n    @gen.coroutine\n    def post(self):\n        a = True\n        if a:\n           self.redirect('/')\n        else:\n           self.render('index.html')\nBut I got this error:\nRuntimeError: Cannot write() after finish(). May be caused by using async operations without the @asynchronous decorator.\nIf I want use redirect, how can I do?Thanks.", "issue_status": "Closed", "issue_reporting_time": "2015-03-18T05:38:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "666": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1384", "issue_id": "#1384", "issue_summary": "tornado4.1 qps is lower than 3.2", "issue_description": "mqingyn commented on 18 Mar 2015\nthe same helloworld program \uff0csame environment\uff0cstart 5 processes\uff0cuse tornado 3.2/4.1\uff0cab test\u3002\n3.2: 2300+ qps/s\n4.1: 1200+ qps/s\nThat is still a significant gap\u3002\nI don't known why ,I think the new version should be faster\uff5e\uff5e", "issue_status": "Closed", "issue_reporting_time": "2015-03-18T01:07:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "667": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1383", "issue_id": "#1383", "issue_summary": "Install via Python Wheel", "issue_description": "rcorzogutierrez commented on 18 Mar 2015\ncreate a universal wheel distribution", "issue_status": "Closed", "issue_reporting_time": "2015-03-17T21:00:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "668": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1378", "issue_id": "#1378", "issue_summary": "Document how to handle yielding many tasks, and catching exceptions.", "issue_description": "diranged commented on 13 Mar 2015\nIn a recent change by @bdarnell (241956a#diff-f9417e85a5edaa0ca2318cad516e1d6aL122), if yield [taska, taskb, taskc] is called, and more than one of those tasks raises an exception, Tornado jumps in and decides to log the exception for you when the Future object is being cleaned up. I get why this is done. However, I don't understand how we're supposed to handle it.\nWe use this yield [... many things ...] pattern a ton in Kingpin. Since Tornado 4.1, we are unable to control the logging output when multiple asynchronous tasks fail, even though we are absolutely logging each of those exceptions.\nHere is a super simple example yield_all.py code:\nimport random\nimport time\n\nfrom tornado import gen\nfrom tornado import ioloop\n\n\n@gen.coroutine\ndef tornado_sleep(seconds=1.0):\n    yield gen.Task(ioloop.IOLoop.current().add_timeout,\n                   time.time() + seconds)\n\n\n@gen.coroutine\ndef raise_exception(name):\n    print (\"%s is sleeping\" % name)\n    yield tornado_sleep(random.random())\n    print (\"%s is raising exception!\" % name)\n    try:\n        raise Exception('Bad things from %s' % name)\n    except Exception as e:\n        print (\"%s raised exception: %s\" % (name, e))\n        raise e\n\n\n@gen.coroutine\ndef raise_many():\n\n    tasks = [raise_exception('one'),\n             raise_exception('two'),\n             raise_exception('three'),\n             raise_exception('four')]\n\n    print (\"Beginning yield\")\n    yield tasks\n\n\ndef print_tidy_exception(e):\n    # Skip traceback that involves site-packages.\n    import traceback\n    trace_lines = traceback.format_exc(e).splitlines()\n    skip_next = False\n    for l in trace_lines:\n        if 'tornado' in l:\n            skip_next = True\n            continue\n        if not skip_next:\n            print(l)\n        skip_next = False\n\nif __name__ == '__main__':\n    try:\n        ioloop.IOLoop.instance().run_sync(raise_many)\n    except Exception as e:\n        print_tidy_exception(e)\nHere is the example output in Tornado 4:\npython yield_all.py \none is sleeping\ntwo is sleeping\nthree is sleeping\nfour is sleeping\nBeginning yield\none is raising exception!\none raised exception: Bad things from one\ntwo is raising exception!\ntwo raised exception: Bad things from two\nfour is raising exception!\nfour raised exception: Bad things from four\nthree is raising exception!\nthree raised exception: Bad things from three\nTraceback (most recent call last):\n  File \"yield_all.py\", line 53, in <module>\n    ioloop.IOLoop.instance().run_sync(raise_many)\n  File \"yield_all.py\", line 35, in raise_many\n    yield tasks\n  File \"yield_all.py\", line 23, in raise_exception\n    raise e\nException: Bad things from one\nHere is the example output in Tornado 4.1:\npython yield_all.py \none is sleeping\ntwo is sleeping\nthree is sleeping\nfour is sleeping\nBeginning yield\nfour is raising exception!\nfour raised exception: Bad things from four\none is raising exception!\none raised exception: Bad things from one\ntwo is raising exception!\ntwo raised exception: Bad things from two\nthree is raising exception!\nthree raised exception: Bad things from three\nTraceback (most recent call last):\n  File \"yield_all.py\", line 53, in <module>\n    ioloop.IOLoop.instance().run_sync(raise_many)\n  File \"yield_all.py\", line 35, in raise_many\n    yield tasks\n  File \"yield_all.py\", line 23, in raise_exception\n    raise e\nException: Bad things from one\nERROR:tornado.application:Future exception was never retrieved: Traceback (most recent call last):\n  File \"/Users/diranged/git/Nextdoor/kingpin/.venv/lib/python2.7/site-packages/tornado/gen.py\", line 812, in run\n    yielded = self.gen.send(value)\n  File \"yield_all.py\", line 23, in raise_exception\n    raise e\nException: Bad things from two\nERROR:tornado.application:Future exception was never retrieved: Traceback (most recent call last):\n  File \"/Users/diranged/git/Nextdoor/kingpin/.venv/lib/python2.7/site-packages/tornado/gen.py\", line 812, in run\n    yielded = self.gen.send(value)\n  File \"yield_all.py\", line 23, in raise_exception\n    raise e\nException: Bad things from three\nERROR:tornado.application:Future exception was never retrieved: Traceback (most recent call last):\n  File \"/Users/diranged/git/Nextdoor/kingpin/.venv/lib/python2.7/site-packages/tornado/gen.py\", line 812, in run\n    yielded = self.gen.send(value)\n  File \"yield_all.py\", line 23, in raise_exception\n    raise e\nException: Bad things from four\nThe question here is, how do we properly handle multiple Future objects raising Exceptions? We're already handling and logging the Exception, but we want to continue to raise it up the stack anyways.", "issue_status": "Closed", "issue_reporting_time": "2015-03-12T19:33:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "669": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1377", "issue_id": "#1377", "issue_summary": "close_code and close_reason are not set for WebSocketHandler", "issue_description": "Contributor\nvovanec commented on 12 Mar 2015\nHey,\nI've just noticed that close_code and close_reason are never set for WebSocketHandler, so they're always None. In my custom websocket handler implementation I'm overriding that by overriding close method in a way:\n    def __init__(self, handler, mask_outgoing=False):\n        self.closed = False\n\n    def close(self, code=None, reason=None):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n\n        if not self.closed:\n            super().close(code, reason)\n            self.handler.close_code = code\n            self.handler.close_reason = reason\n            self.closed = True\nI'm happy to submit pull request but not really sure whether the way I'm working it around is completely correct.\nPlease advise.\n--Vovan", "issue_status": "Closed", "issue_reporting_time": "2015-03-12T18:25:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "670": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1374", "issue_id": "#1374", "issue_summary": "There is a template issue", "issue_description": "tudousi commented on 11 Mar 2015\nI like this format a string in a template file\n<span class=\"post-time\">{{ time.strftime('%Y-%m-%d',time.localtime(float(comm['time']))) }}</span>\nbut An error has occurred\nFile \"modules/comment-list_html.generated.py\", line 24, in _tt_execute\n_tt_tmp = time.strftime('%Y-%m-%d',time.localtime(float(comm['time']))) # modules/comment-list.html:17\nNameError: global name 'time' is not defined", "issue_status": "Closed", "issue_reporting_time": "2015-03-11T13:53:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "671": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1372", "issue_id": "#1372", "issue_summary": "Close socket connection", "issue_description": "carlware commented on 8 Mar 2015\nHi, I have the following code. This is a tcp server that handles data from a tcp/ip connection. Just works fine. But when the client close its connection, the socket in the server never closes. So after reach the limit of open files (in linux). I get the error ``Too many open files`\nclass Connection(object):\n\n    stream_set = set([])\n\n    def __init__(self, stream, address):\n        logging.info('receive a new connection from %s', address)\n        self.stream = stream\n        self.address = address\n        self.stream_set.add(self.stream)\n        self.stream.set_close_callback(self._on_close)\n        self.stream.read_until('$', self._on_read_complete)\n\n    def _on_read_complete(self, data):\n        logging.info('read a new line from %s', self.address)\n        self.stream.write(process_data(data), self._on_write_complete)\n\n    def _on_write_complete(self):\n        logging.info('write a line to %s', self.address)\n        if not self.stream.reading():\n            self.stream.read_until('$', self._on_read_complete)\n\n    def _on_close(self):\n        logging.info('client quit %s', self.address)\n        self.stream_set.remove(self.stream)\n\n\nclass Server(TCPServer):\n    \"\"\"\n        Server for incoming devices.\n    \"\"\"\n    def __init__(self, io_loop=None, ssl_options=None, **kwargs):\n        logging.info('TCP server is started')\n        TCPServer.__init__(self, io_loop=io_loop, ssl_options=ssl_options, **kwargs)\n\n    def handle_stream(self, stream, address):\n        Connection(stream, address)\nI was wondering how to solve it. And I tried the following\ndef _on_close(self):\n    logging.info('client quit %s', self.address)\n    self.stream.close_fd()\n    self.stream_set.remove(self.stream)\nBut this gives the error AttributeError: 'NoneType' object has no attribute 'close'. I thought that the stream object has a socket, because the iostream object looks like this.\nclass IOStream(BaseIOStream):\n    def __init__(self, socket, *args, **kwargs):\n        self.socket = socket\n        self.socket.setblocking(False)\n        super(IOStream, self).__init__(*args, **kwargs)\nWhat could be the proper way to close the sockets one the client disconnects ?", "issue_status": "Closed", "issue_reporting_time": "2015-03-08T05:20:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "672": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1370", "issue_id": "#1370", "issue_summary": "Inconsistency between get_argument and get_arguments", "issue_description": "Contributor\nysimonson commented on 7 Mar 2015\nThis threw me off until going through the tornado source code. Given the query parameter foo=bar%20:\nself.get_argument(\"foo\", None) will evaluate to \"bar\" (i.e. no trailing whitespace.)\nself.get_arguments(\"foo\", None) will evaluate to \"bar \" (i.e. with a trailing whitespace.)\nThis is because the second argument in get_argument is the default value, whereas in get_arguments it's whether to strip whitespace.\nWhat if we gave get_argument and get_arguments the same interface, to prevent others from making the same mistake? i.e. get_arguments would have a default value argument.\nI'd be happy to make a PR if yes, but I realize this would be very backwards-incompatible.", "issue_status": "Closed", "issue_reporting_time": "2015-03-06T20:22:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "673": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1369", "issue_id": "#1369", "issue_summary": "Minor inconsistency in get_argument vs get_arguments", "issue_description": "Contributor\nysimonson commented on 7 Mar 2015\nGiven the query parameter foo=bar%20:\nself.get_argument(\"foo\", None) will evaluate to bar (i.e. no trailing whitespace.)\nself.get_arguments(\"foo\", None) will evaluate to bar (i.e. with a trailing whitespace.)\nObserved in v4.1.", "issue_status": "Closed", "issue_reporting_time": "2015-03-06T20:15:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "674": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1368", "issue_id": "#1368", "issue_summary": "Blog demo uses deprecated GoogleMixin", "issue_description": "jackcaicn commented on 5 Mar 2015\nI try run demo/blog, it display\n400. That\u2019s an error.\n\nOpenID auth request contains an unregistered domain: http://192.168.1.120:8851/\nneed change anything?", "issue_status": "Closed", "issue_reporting_time": "2015-03-05T07:46:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "675": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1367", "issue_id": "#1367", "issue_summary": "How to get Tornado version", "issue_description": "jackcaicn commented on 5 Mar 2015\nHow to get Tornado version", "issue_status": "Closed", "issue_reporting_time": "2015-03-05T07:05:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "676": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1365", "issue_id": "#1365", "issue_summary": "do_handshake EOF error", "issue_description": "fonnesbeck commented on 3 Mar 2015\nWhen using Tornado with IPython notebooks on a Ubuntu server, I am getting the following error:\n[E 12:13:47.821 NotebookApp] Uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/http1connection.py\", line 693, in _server_request_loop\n    ret = yield conn.read_response(request_delegate)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/gen.py\", line 830, in run\n    value = future.result()\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/concurrent.py\", line 211, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/gen.py\", line 836, in run\n    yielded = self.gen.throw(*exc_info)\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/http1connection.py\", line 168, in _read_message\n    quiet_exceptions=iostream.StreamClosedError)      File \"/usr/local/lib/python3.4/dist-packages/tornado/gen.py\", line 830, in run\n    value = future.result()\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/concurrent.py\", line 211, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/usr/local/lib/python3.4/dist-packages/tornado/iostream.py\", line 1228, in _do_ssl_handshake        self.socket.do_handshake()\n  File \"/usr/lib/python3.4/ssl.py\", line 805, in do_handshake\n    self._sslobj.do_handshake()\nssl.SSLEOFError: EOF occurred in violation of protocol (_ssl.c:598)\nThe result of which is that I am not able to connect with my session. Running Python 3.4 on Ubuntu 14.04.1 on a Digital Ocean instance.", "issue_status": "Closed", "issue_reporting_time": "2015-03-03T17:23:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "677": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1362", "issue_id": "#1362", "issue_summary": "Flaky test: SSL EOF error on Pypy", "issue_description": "Member\nbdarnell commented on 2 Mar 2015\nSample build:\nhttps://travis-ci.org/tornadoweb/tornado/jobs/52559843\nObserved configurations: pypy 2.5.0, default IOLoop with or without deps.\nThe tests pass but sometimes log this error:\n[E 150228 18:52:59 http1connection:702] Uncaught exception\n    Traceback (most recent call last):\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/http1connection.py\", line 693, in _server_request_loop\n        ret = yield conn.read_response(request_delegate)\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/gen.py\", line 830, in run\n        value = future.result()\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/concurrent.py\", line 211, in result\n        raise_exc_info(self._exc_info)\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/gen.py\", line 836, in run\n        yielded = self.gen.throw(*exc_info)\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/http1connection.py\", line 168, in _read_message\n        quiet_exceptions=iostream.StreamClosedError)\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/gen.py\", line 830, in run\n        value = future.result()\n      File \"/home/travis/virtualenv/pypy-2.5.0/site-packages/tornado-4.2.dev1-py2.7.egg/tornado/concurrent.py\", line 211, in result\n        raise_exc_info(self._exc_info)\n      File \"<string>\", line 3, in raise_exc_info\n    SSLError: [Errno 8] EOF occurred in violation of protocol\nI have been unable to reproduce this locally after many test runs. We should probably treat this error as equivalent to ECONNRESET once we can identify where to catch it.", "issue_status": "Closed", "issue_reporting_time": "2015-03-01T18:53:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "678": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1361", "issue_id": "#1361", "issue_summary": "Flaky test: double-close of PipeIOStream", "issue_description": "Member\nbdarnell commented on 2 Mar 2015\nSample build:\nhttps://travis-ci.org/tornadoweb/tornado/jobs/52565157\nObserved error configurations: py3.4 with TwistedIOLoop\nThe tests pass, but on rare occasions they log this error:\n[E 150228 20:23:37 ioloop:595] Exception in callback functools.partial(<function wrap.<locals>.null_wrapper at 0x7f778816e9d8>)\n    Traceback (most recent call last):\n      File \"/home/travis/virtualenv/python3.4.2/lib/python3.4/site-packages/tornado-4.2.dev1-py3.4-linux-x86_64.egg/tornado/ioloop.py\", line 575, in _run_callback\n        ret = callback()\n      File \"/home/travis/virtualenv/python3.4.2/lib/python3.4/site-packages/tornado-4.2.dev1-py3.4-linux-x86_64.egg/tornado/stack_context.py\", line 275, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"/home/travis/virtualenv/python3.4.2/lib/python3.4/site-packages/tornado-4.2.dev1-py3.4-linux-x86_64.egg/tornado/iostream.py\", line 422, in close\n        self.close_fd()\n      File \"/home/travis/virtualenv/python3.4.2/lib/python3.4/site-packages/tornado-4.2.dev1-py3.4-linux-x86_64.egg/tornado/iostream.py\", line 1406, in close_fd\n        os.close(self.fd)\n    OSError: [Errno 9] Bad file descriptor\nIt's unclear which test is failing, but since the stack trace is in PipeIOStream.close_fd it's either a test for PipeIOStream or Subprocess.", "issue_status": "Closed", "issue_reporting_time": "2015-03-01T18:50:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "679": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1360", "issue_id": "#1360", "issue_summary": "Tornado as WSGI socket error on Windows with autoreload", "issue_description": "celestian02 commented on 1 Mar 2015\nHi,\nI have been trying the simplest integration between Flask and Tornado, on UNIX systems, I don't have any issues with autoreload but on windows I get the following:\n[I 150301 12:17:54 autoreload:195] C:\\<PATH>\\tes.py modified; restarting server\n[E 150301 12:17:54 ioloop:588] Exception in callback <functools.partial object at 0x031A2390>\n    Traceback (most recent call last):\n      File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 568, in _run_callback\n        ret = callback()\n      File \"C:\\<PATH>\\libs\\tornado\\stack_context.py\", line 275, in null_wrapper\n        return fn(*args, **kwargs)\n      File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 993, in _run\n        self._schedule_next()\n      File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 1000, in _schedule_next\n        self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\n      File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 465, in add_timeout\n        return self.call_at(deadline, callback, *args, **kwargs)\n      File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 873, in call_at\n        heapq.heappush(self._timeouts, timeout)\n    TypeError: heap argument must be a list\nTraceback (most recent call last):\n  File \"C:\\<PATH>\\tes.py\", line 42, in <module>\n    run_server()\n  File \"C:\\<PATH>\\tes.py\", line 37, in run_server\n    io_loop.start()\n  File \"C:\\<PATH>\\libs\\tornado\\ioloop.py\", line 815, in start\n    event_pairs = self._impl.poll(poll_timeout)\n  File \"C:\\<PATH>\\libs\\tornado\\platform\\select.py\", line 63, in poll\n    self.read_fds, self.write_fds, self.error_fds, timeout)\nselect.error: (10038, 'An operation was attempted on something that is not a socket')\nWould you have any idea why this occurs on Windows and not on UNIX systems ? Thanks!\nBelow is the very basic flask/tornado implementation:\nfrom flask import Flask\nimport tornado.wsgi\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.autoreload\n\napp = Flask(__name__)\napp.debug = True\n\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello World!\"\n\n\ndef run_server():\n    # Create the HTTP server\n    http_server = tornado.httpserver.HTTPServer(\n        tornado.wsgi.WSGIContainer(app)\n    )\n    http_server.listen(5000)\n\n    # Reads args given at command line (this also enables logging to stderr)\n    tornado.options.parse_command_line()\n\n    # Start the I/O loop with autoreload\n    io_loop = tornado.ioloop.IOLoop.instance()\n    tornado.autoreload.start()\n    try:\n        io_loop.start()\n    except KeyboardInterrupt:\n        pass\n\nif __name__ == \"__main__\":\n    run_server()", "issue_status": "Closed", "issue_reporting_time": "2015-03-01T15:55:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "680": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1359", "issue_id": "#1359", "issue_summary": "Tornado as WSGI socket error on Windows with autoreload", "issue_description": "celestian02 commented on 1 Mar 2015\nHi,\nI have been trying the simplest integration between Flask and Tornado, on UNIX systems, I don't have any issues with autoreload but on windows I get the following:\n'''\n[I 150301 12:17:54 autoreload:195] C:\\tes.py modified; restarting server\n[E 150301 12:17:54 ioloop:588] Exception in callback <functools.partial object at 0x031A2390>\nTraceback (most recent call last):\nFile \"C:\\libs\\tornado\\ioloop.py\", line 568, in _run_callback\nret = callback()\nFile \"C:\\libs\\tornado\\stack_context.py\", line 275, in null_wrapper\nreturn fn(_args, *_kwargs)\nFile \"C:\\libs\\tornado\\ioloop.py\", line 993, in _run\nself._schedule_next()\nFile \"C:\\libs\\tornado\\ioloop.py\", line 1000, in _schedule_next\nself._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)\nFile \"C:\\libs\\tornado\\ioloop.py\", line 465, in add_timeout\nreturn self.call_at(deadline, callback, _args, *_kwargs)\nFile \"C:\\libs\\tornado\\ioloop.py\", line 873, in call_at\nheapq.heappush(self._timeouts, timeout)\nTypeError: heap argument must be a list\nTraceback (most recent call last):\nFile \"C:\\tes.py\", line 42, in\nrun_server()\nFile \"C:\\tes.py\", line 37, in run_server\nio_loop.start()\nFile \"C:\\libs\\tornado\\ioloop.py\", line 815, in start\nevent_pairs = self._impl.poll(poll_timeout)\nFile \"C:\\libs\\tornado\\platform\\select.py\", line 63, in poll\nself.read_fds, self.write_fds, self.error_fds, timeout)\nselect.error: (10038, 'An operation was attempted on something that is not a socket')\n'''", "issue_status": "Closed", "issue_reporting_time": "2015-03-01T15:54:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "681": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1357", "issue_id": "#1357", "issue_summary": "Can a Tornado RequestHandler attend requests, while waiting for a Future to finish?", "issue_description": "cganterh commented on 1 Mar 2015\nCan a single Tornado RequestHandler class attend new requests, while waiting for a Future to finish in one of its instances?\nThis is only the question. I wrote a more detailed explanation in stackoverflow.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2015-02-28T23:22:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "682": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1351", "issue_id": "#1351", "issue_summary": "raise_error=False does not work with synchronous HTTPClient", "issue_description": "mccutchen commented on 26 Feb 2015\nThe new raise_error kwarg added in #1258 does not seem to work as documented with the synchronous tornado.httpclient.HTTPClient. Given this test script:\nimport tornado\nimport tornado.httpclient\nprint tornado.version\nclient = tornado.httpclient.HTTPClient()\nresp = client.fetch('http://httpbin.org/status/400', raise_error=False)\nprint resp.code, resp.reason\nI get the following output, which seems to show that the raise_error=False argument isn't actually working for this case:\n$ python tornado_test.py \n4.1\nTraceback (most recent call last):\n  File \"tornado_test.py\", line 5, in <module>\n    resp = client.fetch('http://httpbin.org/status/400', raise_error=False)\n  File \"/opt/buzzfeed/cassandra-playground/venv/lib/python2.7/site-packages/tornado/httpclient.py\", line 103, in fetch\n    response.rethrow()\n  File \"/opt/buzzfeed/cassandra-playground/venv/lib/python2.7/site-packages/tornado/httpclient.py\", line 576, in rethrow\n    raise self.error\ntornado.httpclient.HTTPError: HTTP 400: BAD REQUEST\nI would expect instead to get output like so:\n$ python tornado_test.py \n4.1\n400 BAD REQUEST\nIf this is indeed an bug and not some mistake in my setup or understanding of the expected behavior, I'll try to find the time to submit a fix.", "issue_status": "Closed", "issue_reporting_time": "2015-02-25T19:55:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "683": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1350", "issue_id": "#1350", "issue_summary": "iostream 'NoneType' has no len()", "issue_description": "mikhail-ekzi commented on 25 Feb 2015\nHello, I've got an issue with tornado/iostream.py.\nThis issue is completly discussed and solved (UPD: not solved) here https://github.com/SiCKRAGETV/sickrage-issues/issues/231\nAs for tornado, u've got this strings in tornado/iostream.py:\n1416 if len(deque) == 1 and len(deque[0]) <= size:\n1417 return\nAnd after this u've got:\n1432 if not deque:\n1433 deque.appendleft(b\"\")\nUPD: seems that the problem is more deeper:\nIn:\n806 def _handle_write(self):\nWe get the number of bytes in this way:\nnum_bytes = self.write_to_fd(self._write_buffer[0])\nWhich executing function:\n987 def write_to_fd(self, data):\n988 return self.socket.send(data)\nThis two strings returns the length of data and after that self._write_buffer is NULL.", "issue_status": "Closed", "issue_reporting_time": "2015-02-25T10:59:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "684": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1345", "issue_id": "#1345", "issue_summary": "Documentation for tornado.ioloop.PeriodicCallback is not exactly true", "issue_description": "sjbrown commented on 21 Feb 2015\nDocumentation states:\n'''\nThe callback is called every callback_time milliseconds.\n'''\nTo that should be added something like this:\n'''\nUnless a particular execution of the callback takes more than callback_time milliseconds, in which case, the sucessive executions will follow immediately until it is back on schedule.\n'''", "issue_status": "Closed", "issue_reporting_time": "2015-02-21T06:50:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "685": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1342", "issue_id": "#1342", "issue_summary": "options - parse callbacks don't get OptionParser", "issue_description": "sehoffmann commented on 17 Feb 2015\ntornado.log.define_logging_options doesn't work as intented because enable_pretty_logging doesn't get the actual OptionParser which triggered the callback and will thus use the default options object even if that didn't invoked the callback.\ndef run_parse_callbacks(self):\n    for callback in self._parse_callbacks:\n        callback()\nshould be changed to either:\ncallback(self)\nor:\ncallback(options = self)\nand it should be documented, that callbacks receive the OptionParser object.\nIf this isn't viable due to whatever reasons, define_logging_options should atleast bind the options object when adding the callback so that aboves bug is fixed.", "issue_status": "Closed", "issue_reporting_time": "2015-02-17T14:08:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "686": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1339", "issue_id": "#1339", "issue_summary": "streaming applications unfriendliness (producer-consumer speed mismatch)", "issue_description": "fcicq commented on 15 Feb 2015\nContent production can not be paused/resumed based on tcpstream(iostream) congestion,\nand no method can be used to pause/resume the receiving side of the iostream,\ncongestion feedback is impossible at the moment with tornado.\nso it may take a lot of memory to serve contents to misbehaving clients like \"curl --limit-rate 1\" until StreamBufferFullError is raised or something.\nI experienced this issue with a proxy server written in tornado,\nthe receiver side of the proxy have a large Recv-Q seen with netstat,\nas it doesn't process and send to the next hop as fast as receiving, causing a big tcp buffer usage.\nThe real issue is the producer-consumer speed mismatch,\nTwisted has solved this problem for a long time with the Twisted producer and consumer system,\nso feel free to consider this issue as feature request.\nhttps://twistedmatrix.com/documents/current/core/howto/producers.html", "issue_status": "Closed", "issue_reporting_time": "2015-02-14T20:39:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "687": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1337", "issue_id": "#1337", "issue_summary": "Upload will fail if filename is not presented", "issue_description": "mattchen commented on 13 Feb 2015\nHello, although I'm not so sure if this is a bug, but I have ran into this problem recently.\nSometimes I build multi-part request with Content-Disposition header using modern http code library, the \"filename\" param may be missing, in this case, tornado will ignore it entirely.\nI checked HTTP 1.1 RFC, but I'm not so sure if we could ignore this \"filename\" param.\nHope you can understand what I'm talking about. Thank you.", "issue_status": "Closed", "issue_reporting_time": "2015-02-13T17:46:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "688": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1332", "issue_id": "#1332", "issue_summary": "why the RequestHandler.write support dict but not list?", "issue_description": "hackrole commented on 11 Feb 2015\nthe RequestHandler can auto json-encode dict but not list.\n        if not isinstance(chunk, (bytes_type, unicode_type, dict)):\n            raise TypeError(\"write() only accepts bytes, unicode, and dict objects\")\n        if isinstance(chunk, dict):\n            chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\nso when I write the user-list like [{'uid': 111}, {'uid': 222}], it raise Error.\ndoes there any design-consider here?", "issue_status": "Closed", "issue_reporting_time": "2015-02-11T04:35:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "689": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1330", "issue_id": "#1330", "issue_summary": "will tornado imply somethings like django-rest-framework.", "issue_description": "hackrole commented on 10 Feb 2015\nI recent try the django-rest-framework, some of its features is really awsome for making restful-api-application.\nas example, the seriliazers as a form-validate, a serials of renderers to change the output during to the requests header or request path suffix.\nand what I like most is the viewset. use list/retrieve/update/create/delete for resource method, but not get/post/put/delete. I even not need to define two requestHandler for one resource.\ndoes there any plan about this? I really recommend.", "issue_status": "Closed", "issue_reporting_time": "2015-02-10T02:05:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "690": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1329", "issue_id": "#1329", "issue_summary": "Not all WebSocket servers recognize WebSocket headers sent with WebSocketClientConnection.", "issue_description": "misuzu commented on 9 Feb 2015\ntornado.httputil._NormalizedHeaderCache class convert Sec-WebSocket-Key and Sec-WebSocket-Version headers to Sec-Websocket-Key and Sec-Websocket-Version (s in Websocket is lowercase).\nSo some servers can misinterpret WebSocket version (telnet):\nGET /WebSocketConnection HTTP/1.1\nHost: <host>\nConnection: Upgrade\nOrigin: null\nSec-Websocket-Key: LS34zB0raD7SH1iW6KppXQ==\nSec-Websocket-Version: 13\nUpgrade: websocket\n\n\nHTTP/1.1 101 Web Socket Protocol Handshake\nUpgrade: WebSocket\nConnection: Upgrade\nWebSocket-Origin: null\nWebSocket-Location: ws://<host>/WebSocketConnection\nBut with capital s all is fine:\nGET /WebSocketConnection HTTP/1.1\nHost: <host>\nConnection: Upgrade\nOrigin: null\nSec-WebSocket-Key: LS34zB0raD7SH1iW6KppXQ==\nSec-WebSocket-Version: 13\nUpgrade: websocket\n\n\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: GXPYujuKxDumAkK84+pWXLTJ1RY=\nNow i can connect to server only when i monkeypatch tornado.httputil._NormalizedHeaderCache:\nimport tornado.httputil\n\n\nclass NormalizedHeaderCache(tornado.httputil._NormalizedHeaderCache):\n    def __missing__(self, key):\n        normalized = \"-\".join([w.capitalize() for w in key.split(\"-\")])\n        # Fix WebSocket issue\n        normalized = normalized.replace('Websocket', 'WebSocket')\n        self[key] = normalized\n        self.queue.append(key)\n        if len(self.queue) > self.size:\n            old_key = self.queue.popleft()\n            del self[old_key]\n        return normalized\n\n\ntornado.httputil._normalized_headers = NormalizedHeaderCache(1000)", "issue_status": "Closed", "issue_reporting_time": "2015-02-09T13:46:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "691": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1328", "issue_id": "#1328", "issue_summary": "HTTPError ignores a `message` argument.", "issue_description": "eglyph commented on 6 Feb 2015\nHTTPError is a subclass on Exception, however, a message argument is ignored. Therefore a top-level exception handling block should always include a special clause for HTTPError.\nHere is an example:\n   try:\n      ...\n  except Exception, e:\n     # will throw AttributeError when the actual exception type is HTTPError\n     logging.debug(\"Exception message: %s\", e.message) ", "issue_status": "Closed", "issue_reporting_time": "2015-02-06T16:37:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "692": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1326", "issue_id": "#1326", "issue_summary": "Possibly replace urlparse.parse_qs import in tornado.escape with one that can handle named indices (gist included)", "issue_description": "Contributor\nemehrkay commented on 4 Feb 2015\nIn PHP it is possible to have form elements be named in a way that allows for associative arrays (basically dicts) when processed on the server.\nI did a little digging and noticed that the parse_qs function is tiny which makes it easy to hack against and I came up with this: https://gist.github.com/emehrkay/484cf1dc814f8c8a2e1e\nIt basically allows you to pass in something like:\n   \"name[first]=mark&name[lastx][hi]=male&key=val&list[]=1&list[]=2\"\n\n    #and get\n    print parse_qs(s2) #{'list[]': ['1', '2'], 'name': {'lastx': {'hi': 'male'}, 'first': 'mark'}, 'key': ['val']}\nWhat do you think? Useful?", "issue_status": "Closed", "issue_reporting_time": "2015-02-04T06:28:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "693": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1324", "issue_id": "#1324", "issue_summary": "Cookies set with secure=False end up getting set as secure cookies", "issue_description": "Contributor\nccampbell commented on 4 Feb 2015\nThis one had me scratching my head for a little bit.\nIt's not actually a tornado bug, so I understand if you don't feel like fixing it, but I think it would make sense for Tornado to handle this so that the behavior is not completely unexpected.\nself.set_cookie('test', '1', secure=False)\nEnds up writing back the cookie with secure flag.\nI did the following\n>>> morsel = Cookie.SimpleCookie()\n>>> morsel['test'] = '1'\n>>> morsel['test']['secure'] = False\n>>> morsel.output()\n'Set-Cookie: test=1; secure'\nSeems like SimpleCookie only checks for the presence of the key and not the value. Could perhaps add a simple check to make sure v != False in this loop\ntornado/tornado/web.py\nLines 524 to 526 in 96f81df\n for k, v in kwargs.items(): \n     if k == 'max_age': \n         k = 'max-age' ", "issue_status": "Closed", "issue_reporting_time": "2015-02-03T20:35:07Z", "fixed_by": "#1325", "pull_request_summary": "Skip falsy values for some SimpleCookie flags", "pull_request_description": "Contributor\nccampbell commented on 4 Feb 2015\nThis makes sure if you pass httponly=False or secure=False it does not add those flags to the Set-Cookie header.\nFixes #1324", "pull_request_status": "Merged", "issue_fixed_time": "2015-02-07T18:18:08Z", "files_changed": [["18", "tornado/test/web_test.py"], ["6", "tornado/web.py"]]}, "694": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1322", "issue_id": "#1322", "issue_summary": "Allow ssl options a password param?", "issue_description": "splucas commented on 4 Feb 2015\nIt appears that the call to context.load_cert_chain in (netutils) ssl_options_to_context does not provide a way to pass in a password to load_cert_chain. Any chance that could be added?\nThanks!\n-Sean", "issue_status": "Closed", "issue_reporting_time": "2015-02-03T18:32:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "695": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1318", "issue_id": "#1318", "issue_summary": "Consider providing a websocket client for unit testing", "issue_description": "payne92 commented on 28 Jan 2015\nConsider providing a websocket client, analogous to httpclient, for unit testing websocket apps.\nThere is a websocket client for Tornado, but it introduces an external dependency on that library. See: https://github.com/jbalogh/tornado-websocket-client", "issue_status": "Closed", "issue_reporting_time": "2015-01-28T14:50:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "696": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1316", "issue_id": "#1316", "issue_summary": "tornado.util.import_object raise TypeError when name is unicode type", "issue_description": "zhyq0826 commented on 27 Jan 2015\npython 2.7, when module name is unicode type, raise error like this\n>>> tornado.util.import_object(u'tornado.util')\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/util.py\", line 103, in import_object\n    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)\nTypeError: Item in ``from list'' not a string\npython issue21720", "issue_status": "Closed", "issue_reporting_time": "2015-01-27T09:19:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "697": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1315", "issue_id": "#1315", "issue_summary": "Something error in namespace.update(self.ui)", "issue_description": "blackshirt commented on 27 Jan 2015\ni have some try with tornado, and render login.html page...even its works, but it printing some traceback on console ..\nhere the traceback:\nTraceback (most recent call last):\nFile \"C:\\Python34\\lib\\site-packages\\tornado\\web.py\", line 1332, in _execute\nresult = method(_self.path_args, *_self.path_kwargs)\nFile \"C:\\Users\\black\\dompetku\\dompetku\\handler\\login.py\", line 37, in post\nself.render('login.html', form=form)\nFile \"C:\\Python34\\lib\\site-packages\\tornado\\web.py\", line 665, in render\nhtml = self.render_string(template_name, **kwargs)\nFile \"C:\\Python34\\lib\\site-packages\\tornado\\web.py\", line 770, in render_string\nnamespace = self.get_template_namespace()\nFile \"C:\\Python34\\lib\\site-packages\\tornado\\web.py\", line 793, in get_template_namespace\nnamespace.update(self.ui)\nTypeError: 'NoneType' object is not iterable\nHere the login handler. Form was intances form from with wtforms-tornado\nclass LoginHandler(basehandler.BaseHandler):\n\"\"\" Class untuk menghandle login process \"\"\"\ndef get(self):\n    form = LoginForm()\n    self.render('login.html', form=form)\n\ndef post(self):\n    \"\"\" Check login process \"\"\"\n    # username = self.get_argument(\"name\", \"\")\n    # password = self.get_argument(\"password\", \"\")\n    form = LoginForm(self.request.arguments)\n\n    if form.validate():\n        username = form.data['name']\n        password = form.data['password']\n        auth = self._authenticate(username, password)\n        if auth:\n            self.set_secure_cookie(\"user\", username)\n            self.redirect('/trans')\n        else:\n            self.clear_cookie('user')\n\n    self.render('login.html', form=form)\nwhats going wrong with traceback ?? i can't see any hint for this", "issue_status": "Closed", "issue_reporting_time": "2015-01-27T07:25:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "698": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1309", "issue_id": "#1309", "issue_summary": "how to write unit-test for file-upload handlers in tornado", "issue_description": "hackrole commented on 23 Jan 2015\nI write my unittest like this due to some experices on django unit-teset. but it not works. I saw the header and the body seems not handled, and I can't find any example or tutorial about this.\nfrom os import path\nfrom tornado.testing import AsyncHTTPTestCase\n\nclass ImageTestCase(AsyncHTTPTestCase):\n\n    def test_post_return_ok(self):\n        fpath = path.join(path.dirname(__file__), 'test.jpg')\n        f = open(fpath)\n\n        url = \"/img\"\n        data = {\n            \"image\": f,\n        }\n\n        response = self.fetch(url, method=\"POST\",  body=data)\n        print response.request.header\n        print response.request.body\nthis result is somethind like this:\nipdb> response.request.body\n'image=%3Copen+file+%27%2Fhome%2Fdaipeng%2Fprojects%2Fnext_chat%2Fnchat%2Ftests%2Ftest.jpg%27%2C+mode+%27r%27+at+0x360e150%3E'\n\nipdb> response.request.headers\n{'Content-Type': 'application/x-www-form-urlencoded', 'Connection': 'close', 'Content-Length': '191', 'Host': u'localhost:42321', 'Accept-Encoding': 'gzip'}", "issue_status": "Closed", "issue_reporting_time": "2015-01-23T03:16:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "699": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1308", "issue_id": "#1308", "issue_summary": "Can I redirect using POST method?", "issue_description": "guochunyang commented on 22 Jan 2015\nThe function is to sending a form to UnionPay Server, it needs users to click the button.\nBut I want to omit it\uff0cusing redirect with POST instead.\nCat I implement it?", "issue_status": "Closed", "issue_reporting_time": "2015-01-22T03:17:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "700": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1307", "issue_id": "#1307", "issue_summary": "AsyncTestCase + process.Subprocess = BUG", "issue_description": "socketpair commented on 21 Jan 2015\nSuppose test:\n@gen.coroutine\ndef async_exec(args, **kwargs):\n    kwargs['stdout'] = Subprocess.STREAM\n    kwargs['stderr'] = Subprocess.STREAM\n    p = Subprocess(args, **kwargs)\n    (code, stdout, stderr) = yield [\n        Task(p.set_exit_callback),\n        p.stdout.read_until_close(),\n        p.stderr.read_until_close(),\n    ]\n    raise gen.Return((code, stdout, stderr))\n\nclass TestAsyncExec(AsyncTestCase):\n    @gen_test\n    def test_async_exec(self):\n        (code, stdout, stderr) = yield async_exec(['echo', 'teststring'])\n        self.assertEqual(code, 0)\n        self.assertEqual(stdout, 'teststring\\n')\n        self.assertEqual(stderr, '')\nThis will SOMETIMES NOT WORKING (!) (race condition). To fix, I should do that:\nclass TestAsyncExec(AsyncTestCase):\n    def setUp(self):\n        super(TestAsyncExec, self).setUp()\n        Subprocess.uninitialize() # someone may do initialize() during imports...\n        Subprocess.initialize(self.io_loop)\n\n    def tearDown(self):\n        super(TestAsyncExec, self).tearDown()\n        Subprocess.uninitialize()\nThis is not so obvious. Seems, some changes required to make life of testers easy.\nMaybe integrate that code into AsyncTestCase.setUp()/tearDown()?", "issue_status": "Closed", "issue_reporting_time": "2015-01-21T10:34:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "701": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1305", "issue_id": "#1305", "issue_summary": "Undecorated coroutines", "issue_description": "Member\nbdarnell commented on 20 Jan 2015\nUndecorated coroutines (called with yield from as in asyncio) can be much faster than decorated ones. It's already possible to use them, but it requires a strict separation between coroutines that may be entry points (must be decorated, called with yield) and those that are only used internally (may be undecorated, and if so, only called with yield from). We may want to embrace this pattern by:\nAdding a __iter__ method to Future that returns itself, so that decorated coroutines can be called with either yield or yield from\nAdding generator functions to convert_yielded\n(Maybe) Making most of the places that auto-detect a returned Future (e.g. for RequestHandler methods) also recognize undecorated generator functions and wrap them automatically.\nSince the main benefits of undecorated coroutines come with the yield from syntax, we cannot actually use them in Tornado itself as long as we support python 2.", "issue_status": "Closed", "issue_reporting_time": "2015-01-19T19:57:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "702": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1304", "issue_id": "#1304", "issue_summary": "Better logging of SSL errors", "issue_description": "Member\nbdarnell commented on 19 Jan 2015\nSSL errors generally get logged as uncaught exceptions with a full stack trace (twice, in some cases: see https://groups.google.com/forum/?fromgroups#!searchin/python-tornado/catching$20sslerrors/python-tornado/MnNbTemU6ps/Z5ze8GEYXC8J). This is unnecessarily noisy; it would be better to treat at least some ssl errors (those which are clearly caused by the client) as less urgent and log a single-line warning (in some cases like an unclean connection shutdown we may not want to log anything at all).", "issue_status": "Closed", "issue_reporting_time": "2015-01-18T18:55:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "703": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1302", "issue_id": "#1302", "issue_summary": "AttributeError: 'module' object has no attribute 'gen'", "issue_description": "guochunyang commented on 17 Jan 2015\nI installed tornado using sudo pip install tornado in Ubuntu 14.04.\ncode:\n# coding: utf-8\nimport socket\nimport sys\nimport errno\nfrom time import ctime\nimport tornado \n\ndef handle_connection(client_socket, client_address):\n    while True:\n        data = client_socket.recv(1024)\n        if not data:\n            print 'disconnect', client_address\n            client_socket.close()\n            break;\n        else:\n            client_socket.send('[%s] %s' % (ctime(), data)) #echo\n\n@tornado.gen.engine\ndef main(server_socket):\n    while True:\n        (client_socket, client_address) = yield server_socket.accept()\n        print 'Got connection from ', client_address\n        handle_connection(client_socket, client_address)\n\nif __name__ == '__main__':\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    listen_address = ('localhost', 9981)\n    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    server_socket.bind(listen_address)\n    server_socket.listen(10)\n\n    main(server_socket)\nError:\ngen|\u21d2 python 1.py   \nTraceback (most recent call last):\n  File \"1.py\", line 18, in <module>\n    @tornado.gen.engine\nAttributeError: 'module' object has no attribute 'gen'", "issue_status": "Closed", "issue_reporting_time": "2015-01-17T16:41:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "704": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1298", "issue_id": "#1298", "issue_summary": "Cannot run ./runtests.sh", "issue_description": "Contributor\nysimonson commented on 7 Jan 2015\nOn the master branch, I can't run ./runtests.sh:\n$ ./runtests.sh \nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py\", line 162, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py\", line 72, in _run_code\n    exec code in run_globals\n  File \"/Users/ysimonson/Desktop/dailymuse/tornado/tornado/test/runtests.py\", line 141, in <module>\n    main()\n  File \"/Users/ysimonson/Desktop/dailymuse/tornado/tornado/test/runtests.py\", line 138, in main\n    tornado.testing.main(**kwargs)\n  File \"tornado/testing.py\", line 691, in main\n    unittest.main(defaultTest=\"all\", argv=argv, **kwargs)\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py\", line 94, in __init__\n    self.parseArgs(argv)\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py\", line 149, in parseArgs\n    self.createTests()\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/main.py\", line 158, in createTests\n    self.module)\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\", line 130, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\", line 115, in loadTestsFromName\n    test = obj()\n  File \"/Users/ysimonson/Desktop/dailymuse/tornado/tornado/test/runtests.py\", line 55, in all\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\", line 130, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/local/Cellar/python/2.7.8_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/unittest/loader.py\", line 100, in loadTestsFromName\n    parent, obj = obj, getattr(obj, part)\nAttributeError: 'module' object has no attribute 'iostream_test'\ntox still works.", "issue_status": "Closed", "issue_reporting_time": "2015-01-07T15:45:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "705": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1297", "issue_id": "#1297", "issue_summary": "Newline in header: 'HTTP/1.0\\n 404 Not Found'", "issue_description": "dsindex commented on 6 Jan 2015\ntornado version : 4.0.2\napplication.log\n2015-01-06 16:51:33,017 - ERROR - web - Uncaught exception in write_error\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/tornado/web.py\", line 929, in send_error\n    self.write_error(status_code, **kwargs)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/web.py\", line 957, in write_error\n    \"message\": self._reason,\n  File \"/usr/local/lib/python2.7/site-packages/tornado/web.py\", line 895, in finish\n    self.flush(include_footers=True)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/web.py\", line 849, in flush\n    start_line, self._headers, chunk, callback=callback)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/http1connection.py\", line 370, in write_headers\n    raise ValueError('Newline in header: ' + repr(line))\nValueError: Newline in header: 'HTTP/1.0\\n 404 Not Found'\nthere is no exception in version 3.2\nmy code for set_header()\nself.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n...\nself.set_header('Content-Type', 'application/javascript; charset=utf-8')\n...\nself.set_header('Content-Type', 'application/json; charset=utf-8')", "issue_status": "Closed", "issue_reporting_time": "2015-01-06T08:12:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "706": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1295", "issue_id": "#1295", "issue_summary": "tcpclient make httpclient fetch slow---- i m wrong, so please ignore", "issue_description": "chjuheng commented on 5 Jan 2015\ni write a spider use tornado.\nthe main code is:\n@gen.coroutine\ndef crawl(self, url):\nresponse = yield gen.Task(self.http_client.fetch, request)\ntornado now version as much as slow get response then tornado 3.1.1version\nhttp_client is a simple_httpclient.", "issue_status": "Closed", "issue_reporting_time": "2015-01-05T08:15:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "707": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1292", "issue_id": "#1292", "issue_summary": "SyntaxError in documentation example", "issue_description": "peterbe commented on 30 Dec 2014\nThe last example Asynchronous and non-Blocking I/O on using yield would cause a SyntaxError because you can't have a yield and a non-empty return in python 2.7\nfrom tornado import gen\n\n@gen.coroutine\ndef fetch_coroutine(url):\n    http_client = AsyncHTTPClient()\n    response = yield http_client.fetch(url)\n    return response.body  # <-- SyntaxError", "issue_status": "Closed", "issue_reporting_time": "2014-12-30T18:02:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "708": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1291", "issue_id": "#1291", "issue_summary": "Malformed HTTP headers", "issue_description": "krkd commented on 30 Dec 2014\nI experienced problem with \"Malformed HTTP headers\" when cookie was encoded with utf8.\nLet assume that data passed to HTTPConnection._on_headers have \"COOKIE\" header which contains cookie with value\n\"\\xd0\\x9a\\xd1\\x83\\xd1\\x85\\xd0\\xbd\\xd0\\xb8\"  \nafter decoding with latin1 cookie was like\n'\u00d0\\x9a\u00d1\\x83\u00d1\\x85\u00d0\u00bd\u00d0\u00b8' \nwhich contains \\x85 unicode newline character.\nhttputil.HTTPHeaders.parse use builtin method splitlines which recognize \\x85 character as newline and splits string by this character. In summary ValueError will be raised because\nstrig after \\x85 does not start with whitespace\nline after \\x85 does not contain \":\" character.\nIn my project i use spit(\"\\r\\n\") instead of splitlines in httputil.HTTPHeaders.parse.", "issue_status": "Closed", "issue_reporting_time": "2014-12-30T14:03:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "709": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1288", "issue_id": "#1288", "issue_summary": "Why is the commit of insert so unstable using psycopg2?", "issue_description": "kamelzcs commented on 25 Dec 2014\nPython: 2.7.6\nTornado: 4.0.2\nPsycopg2: 2.5.4\nA single insert and commit query could lead to very huge unstable time cost.\nThe code:\nimport os\n\nimport tornado.web\nimport tornado.ioloop\nimport tornado.options\nfrom tornado import gen\nimport tornado.httpserver\nimport psycopg2\nimport logging\n\ndb_database = `test`\ndb_user = 'postgres'\ndb_password = ''\ndb_host = ''\ndb_port = 5431\ndsn = 'dbname=%s user=%s password=%s host=%s port=%s' % (\n    db_database, db_user, db_password, db_host, db_port)\n\nclass BaseHandler(tornado.web.RequestHandler):\n    @property\n    def db(self):\n        return self.application.db\n\n\nclass OverviewHandler(BaseHandler):\n    @gen.coroutine\n    def get(self):\n        try:\n            cursor = self.db.cursor()\n            cursor.execute('INSERT INTO \"member\" (\"membername\", \"birthday\") VALUES (%s, %s) RETURNING ID', ('123', '2014/12/17'))\n            logging.debug('before commit')\n            self.db.commit()\n            logging.debug('after commit')\n            self.write('Query results: %s<br>\\n' % cursor.fetchall())\n        except Exception as error:\n            self.write(str(error))\n\n        self.finish()\n\n\ndef main():\n    try:\n        tornado.options.parse_command_line()\n        application = tornado.web.Application([\n            (r'/', OverviewHandler),\n        ], debug=True)\n\n        application.db = psycopg2.connect(dsn)\n\n        http_server = tornado.httpserver.HTTPServer(application)\n        http_server.listen(8888, 'localhost')\n        tornado.ioloop.IOLoop.instance().start()\n    except KeyboardInterrupt:\n        print('Exit')\n\n\nif __name__ == '__main__':\n    main()\nThe result is as follows:\n[I 141225 17:18:52 web:1811] 200 GET /query (127.0.0.1) 19.35ms\n[I 141225 17:18:53 web:1811] 200 GET /query (127.0.0.1) 16.96ms\n[I 141225 17:18:55 web:1811] 200 GET /query (127.0.0.1) 402.65ms\n[I 141225 17:18:58 web:1811] 200 GET /query (127.0.0.1) 2317.28ms\n[I 141225 17:19:02 web:1811] 200 GET /query (127.0.0.1) 1396.84ms\n[I 141225 17:19:03 web:1811] 200 GET /query (127.0.0.1) 33.61ms\n[I 141225 17:19:04 web:1811] 200 GET /query (127.0.0.1) 444.74ms\n[I 141225 17:19:05 web:1811] 200 GET /query (127.0.0.1) 15.53ms\n[I 141225 17:19:06 web:1811] 200 GET /query (127.0.0.1) 18.40ms\n[I 141225 17:19:07 web:1811] 200 GET /query (127.0.0.1) 12.16ms\n[I 141225 17:19:11 web:1811] 200 GET /query (127.0.0.1) 3081.28ms\nAs I am not sure whether it has something to do with Psycopg, post the same link on Psycopg", "issue_status": "Closed", "issue_reporting_time": "2014-12-25T09:06:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "710": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1284", "issue_id": "#1284", "issue_summary": "AsyncHTTPTestCase raise an error: Async operation timed out after 5 seconds", "issue_description": "mumuniao commented on 22 Dec 2014\nI used AsyncHTTPTestCase , just line the doc wirte, here is my testcase:\nclass MyTestCase(AsyncHTTPTestCase):\ndef get_app(self):\nreturn Application(URL_HANDLERS, settings)\ndef get_new_ioloop(self):\n    return ioloop.IOLoop.instance()\n\ndef test_get(self):\n    path = \"/hello/?diu=864264028377957&cp=1\"\n    response = self.fetch(path=path)\n    self.assertEqual(response.code, 200)\nraise error: AssertionError: Async operation timed out after 5 seconds\nI use urllib2 to test the server is worked: urllib2.urlopen( self.fetch(path=path)), i failed\ntornado version is 4.0.2\nThanks", "issue_status": "Closed", "issue_reporting_time": "2014-12-22T08:37:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "711": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1283", "issue_id": "#1283", "issue_summary": "AssertionError: Already reading", "issue_description": "984958198 commented on 21 Dec 2014\nhi\nWhen receiving the length of 3000 bytes The following error will occur\n2014-12-20 21:36:21,748 - tornado.application - ERROR - Uncaught exception, closing connection.\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 508, in wrapper\n    return callback(*args)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/tmp/2g_online_service/service.py\", line 77, in broadcast_messages\n    self.read_message()\n  File \"/tmp/2g_online_service/service.py\", line 37, in read_message\n    self._stream.read_bytes(self.num_bytes,self.broadcast_messages)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 279, in read_bytes\n    future = self._set_read_callback(callback)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 615, in _set_read_callback\n    assert self._read_callback is None, \"Already reading\"\nAssertionError: Already reading\n2014-12-20 21:36:21,749 - tornado.application - ERROR - Exception in callback <functools.partial object at 0x18716d8>\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/ioloop.py\", line 565, in _run_callback\n    ret = callback()\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 508, in wrapper\n    return callback(*args)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"/tmp/2g_online_service/service.py\", line 77, in broadcast_messages\n    self.read_message()\n  File \"/tmp/2g_online_service/service.py\", line 37, in read_message\n    self._stream.read_bytes(self.num_bytes,self.broadcast_messages)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 279, in read_bytes\n    future = self._set_read_callback(callback)\n  File \"/usr/lib/python2.6/site-packages/tornado-4.0.2-py2.6-linux-x86_64.egg/tornado/iostream.py\", line 615, in _set_read_callback\n    assert self._read_callback is None, \"Already reading\"\nAssertionError: Already reading", "issue_status": "Closed", "issue_reporting_time": "2014-12-21T05:22:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "712": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1282", "issue_id": "#1282", "issue_summary": "Is there any way to build a context manager which does some async things inside?", "issue_description": "kamelzcs commented on 19 Dec 2014\nIf not, how to get around?\nThe following code will not get the yahoo content.\nIn the example, get_and_log want to get some content async in the __enter__ function, then return that content out, at last log some the exception in the __exit__.\nIt seems the __enter__ will return at the first yield but not from the raise gen.Return(response).\nI guess the reason is __enter__ is called by the caller as a normal function which returns some value, but the current __enter__ is a future, could only return with yield.\nfrom functools import wraps\n\nimport logging\n\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpserver import HTTPServer\nfrom tornado.web import asynchronous, RequestHandler, Application\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.log import enable_pretty_logging\nimport tornado.options\ntornado.options.parse_command_line()\n\ndef get_and_log(func):\n    @wraps(func)\n    def inner(*args, **kwargs):\n        with (Appender(AsyncHTTPClient)) as content:\n            logging.debug(content)\n            return ((func(*args, **kwargs)))\n    return(inner)\n\nclass Appender(object):\n    def __init__(self, client):\n        self.client = client\n\n    @gen.coroutine\n    def __enter__(self):\n        logging.debug('__enter__ entered')\n        response = yield self.client.fetch(\"http://yahoo.com\")\n        raise gen.Return(response)\n\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            logging.debug('exeption happened')\n        else:\n            logging.debug('no exeption')\n\n\n@gen.coroutine\n@get_and_log\ndef test():\n    http_client = AsyncHTTPClient()\n    response = yield http_client.fetch(\"http://google.com\")\n    raise gen.Return(response)\n\nclass AsyncHandler(RequestHandler):\n    @gen.coroutine\n    def get(self):\n        result = yield test()\n        logging.debug(result)\n        self.finish()\n\nif __name__ == '__main__':\n\n    application = Application([\n        (r'/', AsyncHandler),\n    ], debug=True)\n\n    http_server = HTTPServer(application)\n    http_server.listen(8181, 'localhost')\n    IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2014-12-19T09:00:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "713": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1280", "issue_id": "#1280", "issue_summary": "Tornado sends only first two 128KB chunks", "issue_description": "imro2 commented on 18 Dec 2014\nIf Web application is not set to autoreload modified modules, tornado only sends two chunks of 128KB and then gets stuck in poll on select until another request comes in.\nScenario;\nRunning tornado on Windows 7\ndata to be written to socket must be larger then 256KB\nwhen request comes, a thread is created and in BaseIOStream._handle_write writes data to socket, in its third iteration thru the while loop it receives an exception from socket: \"[Errno 10035] A non-blocking socket operation could not be completed immediately\", it breaks and the thread ads fd to pending fds and quits.\nProblem is that if there are no other request coming in the main thread is stuck in _Select.poll waiting for select.select to return. Since the default _POLL_TIMEOUT is 3600s, and there were no other poll_timeouts, only way to release this lock is make another request.\nIf autoreload is set to true, this does not happen as the autoreloader keeps scheduling itself in regular intervals and therefore the timeout is always only few seconds.", "issue_status": "Closed", "issue_reporting_time": "2014-12-18T09:07:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "714": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1278", "issue_id": "#1278", "issue_summary": "ioloop.py:491 Exception in callback <functools.partial object at 0x7fa9b6e2c208>", "issue_description": "nickponline commented on 17 Dec 2014\nI'm seeing this error occasionally on a webserver. It doesn't seem to cause problems, would do you know what cases it?", "issue_status": "Closed", "issue_reporting_time": "2014-12-16T23:06:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "715": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1275", "issue_id": "#1275", "issue_summary": "Don't depend on backports.ssl_match_hostname with python >=2.7.9, <3.0", "issue_description": "Contributor\nfelixonmars commented on 12 Dec 2014\nSince Python 2.7.9, the ssl module got backported from 3.4 and contains the needed functions:\nPython 2.7.9 (default, Dec 11 2014, 04:42:00)\n[GCC 4.9.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import ssl\n>>> hasattr(ssl, 'match_hostname') and hasattr(ssl, 'CertificateError')\nTrue\nSo backports.ssl_match_hostname could be omitted from dependencies if python >=2.7.9, <3.0 were detected.", "issue_status": "Closed", "issue_reporting_time": "2014-12-12T14:59:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "716": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1269", "issue_id": "#1269", "issue_summary": "Websocket message size limits", "issue_description": "Member\nbdarnell commented on 10 Dec 2014\nWebsocket servers need a way to limit the size of messages they will accept. The max_body_size limit applies to individual message fragments, but there is no limit on the number or size of fragments that make up a message. The websocket compression support (that is new in 4.1) will also need to be made aware of size limits, like the gzip support for http bodies in 4.0.\nFlow control is also an issue; we should allow on_message to return a Future similarly to data_received.", "issue_status": "Closed", "issue_reporting_time": "2014-12-10T15:54:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "717": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1267", "issue_id": "#1267", "issue_summary": "Malformed Filenames Throw Exception on Upload", "issue_description": "moloch-- commented on 10 Dec 2014\nMalformed file names on upload cause a stacktrack (newlines):\nRequest\nPOST /user/share/files HTTP/1.1\nHost: 192.168.6.132:8888\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; rv:34.0) Gecko/20100101 Firefox/34.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: http://192.168.6.132:8888/user/share/files\nCookie: _xsrf=2|bc84a83c|854187cbb6f98741a3bd8dcb9d308438|1418192086; session_id=\"2|1:0|10:1418196229|10:session_id|44:MjhiNThmNjBhZjg2Mzk5MjI3YjNjNWZiZWQzMTg1M2M=|ccec410256872ff6ecd0bf108e8f0820369a7f6c5391e74fb178fedab152e7cf\"\nConnection: keep-alive\nContent-Type: multipart/form-data; boundary=---------------------------202882737716448\nContent-Length: 56563\n\n-----------------------------202882737716448\nContent-Disposition: form-data; name=\"_xsrf\"\n\n2|f67ca701|cfb988f6fc01887ce94582f6d7c88b05|1418192086\n-----------------------------202882737716448\nContent-Disposition: form-data; name=\"files\"; filename=\"\n\"\nContent-Type: madeup/madeup\n\nGIF89a/*\ufffd\ufffd\u00f7\nResponse\n[E 141209 23:36:27 http1connection:53] Uncaught exception\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/http1connection.py\", line 234, in _read_message\n        delegate.finish()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httpserver.py\", line 282, in finish\n        self.delegate.finish()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1883, in finish\n        self.request._parse_body()\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 436, in _parse_body\n        self.headers)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 689, in parse_body_arguments\n        parse_multipart_form_data(utf8(v), body, arguments, files)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 721, in parse_multipart_form_data\n        headers = HTTPHeaders.parse(part[:eoh].decode(\"utf-8\"))\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 198, in parse\n        h.parse_line(line)\n      File \"/usr/local/lib/python2.7/dist-packages/tornado/httputil.py\", line 184, in parse_line\n        name, value = line.split(\":\", 1)\n    ValueError: need more than 1 value to unpack", "issue_status": "Closed", "issue_reporting_time": "2014-12-10T07:54:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "718": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1265", "issue_id": "#1265", "issue_summary": "Potential SSL slowdowns?", "issue_description": "Contributor\nchrisseto commented on 6 Dec 2014\nWe attempting to build a File storage and file serving service using tornado.\nOur solution thus far has been passing around streams to more or less \"smartly\" proxy the file to and from our cloud storage backend to and from the end user.\nWe began seeing performance issues and did some profiling with plop.\nIt seems that a lot of time is spent in SSL related function. However when we mixed in AIOHTTP we saw a performance increase.\nThe relevant code is here\nAnd the issue boils down to could Tornado's performance be limited by the SSL implementation or is there some other caveat that's being overlooked here?", "issue_status": "Closed", "issue_reporting_time": "2014-12-05T20:58:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "719": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1263", "issue_id": "#1263", "issue_summary": "replace call to platform.system() with sys.platform", "issue_description": "Contributor\nnbargnesi commented on 5 Dec 2014\nThere's a call to platform.system() in netutil introduced in the hack around mac firewall problems maybe a bit anomalous among similar checks in the codebase that use sys.platform instead.\nOn Linux and Mac, platform.system() is a bit like a bull in a china shop as os.popen tries to the output of uname. Using sys.platform avoids a class of complicated behavior around popen, subprocess, and fork, especially with processes that may be attempting to bind ports in child processes (the fork will wreak havoc with parent processes that care about SIGCHLD).", "issue_status": "Closed", "issue_reporting_time": "2014-12-05T06:33:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "720": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1259", "issue_id": "#1259", "issue_summary": "Customize how to get real IPs", "issue_description": "Contributor\nlilydjwg commented on 25 Nov 2014\nHi, Tornado has a xheaders setting that is great for requests passed over by nginx. But there are others that do such reverse proxying too, e.g. CloudFlare uses both X-Forwarded-For (which will be the last but one behind nginx) and Cf-Connecting-IP (which Tornado does not handle, and it's necessary to check the request is from CloudFlare). I think it'll be great if Tornado provides a way to customize this.", "issue_status": "Closed", "issue_reporting_time": "2014-11-25T12:29:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "721": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1257", "issue_id": "#1257", "issue_summary": "pip install tornado yields error", "issue_description": "mkstarr commented on 21 Nov 2014\nE:\\computer code\\pip-1.0.2>pip install tornado\nTraceback (most recent call last):\nFile \"C:\\Anaconda\\Scripts\\pip-script.py\", line 3, in\nfrom pip import main\nFile \"C:\\csvn\\Python27\\lib\\site-packages\\pip__init__.py\", line 9, in\nfrom pip.log import logger\nFile \"C:\\csvn\\Python27\\lib\\site-packages\\pip\\log.py\", line 8, in\nfrom pip import backwardcompat\nFile \"C:\\csvn\\Python27\\lib\\site-packages\\pip\\backwardcompat__init__.py\", line\n66, in\nfrom urllib2 import URLError, HTTPError\nFile \"C:\\csvn\\Python27\\lib\\urllib2.py\", line 94, in\nimport httplib\nFile \"C:\\csvn\\Python27\\lib\\httplib.py\", line 71, in\nimport socket\nFile \"C:\\csvn\\Python27\\lib\\socket.py\", line 47, in\nimport _socket\nImportError: DLL load failed: %1 is not a valid Win32 application.\nE:\\computer code\\pip-1.0.2>", "issue_status": "Closed", "issue_reporting_time": "2014-11-21T18:20:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "722": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1254", "issue_id": "#1254", "issue_summary": "call AsyncHTTPClient in the requestHandler get method make all the unittestcase raise timeout Exception", "issue_description": "hackrole commented on 19 Nov 2014\nI have a utils function like this:\n@gen.coroutine\ndef nd_sms_verify(code, mobile):\n    u\"\"\"\n    \u53d1\u9001\u77ed\u4fe1\u63a5\u53e3\n    \"\"\"\n    url = \"http://baidu.com\"\n\n    http_client = AsyncHTTPClient()\n    response = yield http_client.fetch(url)\n    print response\n\n    if response.body == '100':\n        raise gen.Return([True, u\"\u53d1\u9001\u6210\u529f\"])\n    else response.body == '108':\n        raise gen.Return([False, u\"\u77ed\u4fe1\u8bf7\u6c42\u592a\u9891\u7e41\"])\nI write a unittest for this, and it works fine.\nfrom unittest2 import TestCase\nfrom view_utils import nd_sms_verify\nfrom tornado.ioloop import IOLoop\n\n\nclass SendSmsTestCase(TestCase):\n\n    def test_send_sms_return_ok(self):\n        code = \"8899\"\n        mobile = \"18321445606\"\n        io_loop = IOLoop.instance()\n        data = io_loop.run_sync(\n            lambda: nd_sms_verify(code, mobile), timeout=20)\n        self.assertIsNotNone(data)\n        self.assertIn(data[0], [True, False])\nbut when I called it on my view function, it works ok, but all the unittest cases raise timeout.\nclass RegisterFinishHandler(BaseHandler):\n\n    @gen.coroutine\n    def get(self):\n        code = '2209'\n        mobile = '13113113131'\n\n        # send sms\n        result = yield view_utils.nd_sms_verify(code['code'], mobile)\n        print result\nI checked the source. It seems that AsyncHTTPClient may create a new IOLoop, which cause error with the AsyncHTTPTestCase io_loop.\nI have meet a lot questions like this, I want to know why the AsyncTestCase have its own ioloop, which may cause other function fails.", "issue_status": "Closed", "issue_reporting_time": "2014-11-19T06:33:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "723": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1253", "issue_id": "#1253", "issue_summary": "unittest with @gen_test and ioloop.run_sync raise timeout exception.", "issue_description": "hackrole commented on 17 Nov 2014\nI was write a application with tornado and mongodb(using motor).\nI setup and teardown the unittest case like below::\nclass BaseTestCase(AsyncHTTPTestCase):\ndef setUp(self):\nsuper(BaseTestCase, self).setUp()\nself.ioloop.run_sysnc(self.drop_db)\nself.ioloop.run_sync(self.fixture_setup)\n@gen.coroutine\ndef fixture_setup(self):\n       yield motorclient.db.collection.insert({})\n       ......\n\ndef tearDown(self)\n      self.ioloop.run_sync(self.drop_db)\n@gen.coroutine\ndef drop_db(self):\nyield motorclient.drop_database(dbname)\nthe subclass will run ok, it I not use gen_test like this;\nclass SubTestCase(BaseTestCase):\n  def test_ok(self):\n         response = self.fetch('/')\n        self.assertEquals(response.code, 200)\nbut not work like this.\n    @gen_test\n   def test_ok(self):\n          user = yield motorclient,db.collections.find_one({'mobile': mobile})\nthen all the testcase(I mean all, not only this one) wil fail and raise Timeout Exception.\nthe exception may seems like that:\nERROR: test_get_without_uid_return_html (tests.test_view_register.RegisterMsgTest)\nTraceback (most recent call last):\nFile \"/home/daipeng/projects/next_chat/nchat/tests/base.py\", line 23, in setUp\nself.io_loop.run_sync(self.drop_database)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 417, in run_sync\nraise TimeoutError('Operation timed out after %s seconds' % timeout)\nTimeoutError: Operation timed out after None seconds\nso how can I use motor for insert/update/delete/find in the test method??", "issue_status": "Closed", "issue_reporting_time": "2014-11-17T03:49:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "724": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1252", "issue_id": "#1252", "issue_summary": "AsyncHTTPClient fails if fetch is initiated before IOLoop.start", "issue_description": "kssreeram commented on 16 Nov 2014\nI'm running OS X Yosemite, Python 2.7.8, and Tornado 4.0.2.\nAsyncHTTPClient fails if initiated just before the IOLoop is started (but of course after it's created). The following script fails with a timeout error:\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpclient import AsyncHTTPClient\n\ndef handle_response(response) :\n    print \"response =\", response\n\nio_loop = IOLoop()\nclient = AsyncHTTPClient(io_loop)\nclient.fetch(\"http://google.com\", handle_response)\n\nio_loop.start()\nI can get it to work by delaying the fetch call until after IOLoop.start. The following script delays the fetch with add_callback and works fine:\nfrom tornado.ioloop import IOLoop\nfrom tornado.httpclient import AsyncHTTPClient\n\ndef handle_response(response) :\n    print \"response =\", response\n\nio_loop = IOLoop()\nclient = AsyncHTTPClient(io_loop)\n\ndef fetch() :\n    client.fetch(\"http://google.com\", handle_response)\n\nio_loop.add_callback(fetch)\n\nio_loop.start()", "issue_status": "Closed", "issue_reporting_time": "2014-11-15T22:09:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "725": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1251", "issue_id": "#1251", "issue_summary": "kqueue on BSD fails with Mock transport", "issue_description": "yurivict commented on 14 Nov 2014\nThis testcase fails with kqueue, and passes with select:\n# testcase.py\nimport zmq\nfrom zmq.eventloop import ioloop, zmqstream\nimport mock\n\ndef x(transport):\n  socket = transport.ctx.socket(zmq.REQ)\n  stream = zmqstream.ZMQStream(socket, io_loop=ioloop.IOLoop.current())\n\nx(mock.Mock())\nFailure with kqueue:\n  File \"/usr/local/lib/python2.7/site-packages/tornado/platform/kqueue.py\", line 41, in register\n    self._control(fd, events, select.KQ_EV_ADD)\n  File \"/usr/local/lib/python2.7/site-packages/tornado/platform/kqueue.py\", line 61, in _control\n    fd, filter=select.KQ_FILTER_READ, flags=flags))\n  TypeError: fileno() returned a non-integer\nVersion 4.0.2", "issue_status": "Closed", "issue_reporting_time": "2014-11-14T13:20:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "726": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1250", "issue_id": "#1250", "issue_summary": "proposal: deprecate json_encode", "issue_description": "vmarkovtsev commented on 13 Nov 2014\nPlease see my comment on #706", "issue_status": "Closed", "issue_reporting_time": "2014-11-13T09:36:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "727": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1249", "issue_id": "#1249", "issue_summary": "about tornad design", "issue_description": "liyang1009 commented on 12 Nov 2014\ni'm a like the tornado framework but i have some questions why tornado is single thread\uff1fwhy tornado not session manage\uff1f\nthank you !", "issue_status": "Closed", "issue_reporting_time": "2014-11-12T13:51:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "728": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1248", "issue_id": "#1248", "issue_summary": "Multiple cookie with the same name", "issue_description": "ls0f commented on 10 Nov 2014\nI read the source code of the set_cookie function,tornado don't support multiple cookie with the same name. What is the purpose of it?", "issue_status": "Closed", "issue_reporting_time": "2014-11-10T15:53:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "729": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1247", "issue_id": "#1247", "issue_summary": "Typo in docs about max_age_days for secure cookies", "issue_description": "altf4 commented on 10 Nov 2014\nThis really confused me for like 10 minutes! The doc at docs/guide/security.rst currently says:\nBy default, Tornado's secure cookies expire after 30 days. To change this, use the expires_days keyword argument to set_secure_cookie and the max_age_days argument to set_secure_cookie\nWhen I think it should say:\nBy default, Tornado's secure cookies expire after 30 days. To change this, use the expires_days keyword argument to set_secure_cookie and the max_age_days argument to get_secure_cookie\nNote the bolded word for the difference.\nmax_age_days is a parameter of get_secure_cookie() and not set_secure_cookie().", "issue_status": "Closed", "issue_reporting_time": "2014-11-10T04:34:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "730": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1243", "issue_id": "#1243", "issue_summary": "Anyway to modify sec_websocket_protocol using websocket_connect()?", "issue_description": "xihan88 commented on 7 Nov 2014\nI use original websocket in javascript, which is OK to add a subprotocol; And I use tornado httpserver to handle websocket subprotocols, which is also perfect; Now I'm trying to crate a python websocket client, but I figure out that it seems impossible to change the subprotocol using websocket_connect(). So do you plan to add sudprotocol as an argument in the future? Or I should use another way to create a websocket client which supports subprotocol in python?", "issue_status": "Closed", "issue_reporting_time": "2014-11-06T20:48:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "731": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1242", "issue_id": "#1242", "issue_summary": "WebSocketHandler open method has to receive arguments?", "issue_description": "icoxfog417 commented on 6 Nov 2014\nI used websocket its address is like localhost/xxxxx/socket (xxxxx is chat group's id).\nThen I received Uncaught exception from here .\nBecause callback passed the url parameter (xxxxx) to open method , but it can't receive the parameter.\nI can avoid it by enabling oepn to receive the parameter in my inherited class.\nBut comment on open describes that The arguments to open are extracted from the tornado.web.URLSpec,\nSo I think open has to be defined by open(self, *args, **kwargs) like get(self, *args, **kwargs).\nIf so, above Uncaught exception won't occur.", "issue_status": "Closed", "issue_reporting_time": "2014-11-06T01:57:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "732": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1240", "issue_id": "#1240", "issue_summary": "StaticFileHandler throws exception \"missing 1 required positional argument: 'path'\"", "issue_description": "Rawieo commented on 2 Nov 2014\nPython 3.4.0, Tornado 3.1.1\nExample application: http://goo.gl/gjPqI4\nSome logs: http://pastebin.com/me40BeV8", "issue_status": "Closed", "issue_reporting_time": "2014-11-02T10:55:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "733": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1236", "issue_id": "#1236", "issue_summary": "`tornado.escape.url_escape` does not work when used inside urlspec", "issue_description": "abdelouahabb commented on 30 Oct 2014\nThis works\nhttps://gist.github.com/abdelouahabb/1557c0bb9db59a8d5b17\nbut if i use:\napplication = tornado.web.Application([(tornado.escape.url_escape(r\"/\u0627\u0644\u0633\u0644\u0627\u0645\"), MainHandler),...\nit is not escaped.", "issue_status": "Closed", "issue_reporting_time": "2014-10-30T02:31:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "734": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1235", "issue_id": "#1235", "issue_summary": "tornado web send_error treats exceptions as lists", "issue_description": "kpachnis commented on 30 Oct 2014\nHello,\nThe tornado.web.RequestHandler send_error method treats the exc_info keyword argument as a sequence, generating another TypeError exception; 'Exception' object does not support indexing\nRemoving [1]\nexception = kwargs['exc_info']\nseems to work.\nTested with Tornado 4.0.2 on Python 3.4.2", "issue_status": "Closed", "issue_reporting_time": "2014-10-29T21:10:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "735": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1234", "issue_id": "#1234", "issue_summary": "Enable Sourcegraph", "issue_description": "thomas-huang commented on 28 Oct 2014\nI want to use Sourcegraph code search and code review with tornado. A project maintainer needs to enable it to set up a webhook so the code is up-to-date there.\nCould you please enable tornado on @sourcegraph by going to https://sourcegraph.com/github.com/tornadoweb/tornado and clicking on Settings? (It should only take 15 seconds.)\nThank you!", "issue_status": "Closed", "issue_reporting_time": "2014-10-28T14:25:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "736": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1232", "issue_id": "#1232", "issue_summary": "Enable Sourcegraph", "issue_description": "sunisdown commented on 27 Oct 2014\nI want to use Sourcegraph code search and code review with tornado. A project maintainer needs to enable it to set up a webhook so the code is up-to-date there.\nCould you please enable tornado on @sourcegraph by going to https://sourcegraph.com/github.com/tornadoweb/tornado and clicking on Settings? (It should only take 15 seconds.)\nThank you!", "issue_status": "Closed", "issue_reporting_time": "2014-10-27T09:47:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "737": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1230", "issue_id": "#1230", "issue_summary": "In some cases, on OS X on_close is not being called for terminated websocket connections", "issue_description": "mikelikespie commented on 25 Oct 2014\nTo repro:\nConnect to tornado websocket server (running on OS X)\nTurn off network interface on client\non_close will not get called, nor will the connection be removed from the IO loop.", "issue_status": "Closed", "issue_reporting_time": "2014-10-24T21:08:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "738": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1229", "issue_id": "#1229", "issue_summary": "Typo on line tornado/iostream.py:334", "issue_description": "beyondwdq commented on 24 Oct 2014\nTypo on line tornado/iostream.py:334\n    if data:\n        if (self.max_write_buffer_size is not None and\n                self._write_buffer_size + len(data) > self.max_write_buffer_size):\n            raise StreamBufferFullError(\"Reached maximum read buffer size\")\nThe Error message of StreamBufferFullError should be \"Reached maximum write buffer size\".", "issue_status": "Closed", "issue_reporting_time": "2014-10-24T06:27:41Z", "fixed_by": "#1231", "pull_request_summary": "fixed error message in iostream", "pull_request_description": "Contributor\ndaftshady commented on 26 Oct 2014\nfixed #1229", "pull_request_status": "Merged", "issue_fixed_time": "2014-10-27T00:52:16Z", "files_changed": [["2", "tornado/iostream.py"]]}, "739": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1228", "issue_id": "#1228", "issue_summary": "test_gaierror failures on OSX", "issue_description": "Contributor\nmatthew-brett commented on 23 Oct 2014\n$ python -m tornado.test.runtests\n..................................................................ssssssssssssssssssssssssssssss..........s..s........................................................................s...s....................................................................................sss....sss....sss............................................................ss.............F.........................F..................ssssssssssssssssssssssssss.............................ss....sssssss........................s...................................................................................................................................................................................sssssssssss..............................................s.................................................................................................................................................s...................................................................................................s.............................................................................\n======================================================================\nFAIL: test_gaierror (tornado.test.iostream_test.TestIOStream)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/Users/mb312/.virtualenvs/test/lib/python2.7/site-packages/tornado-4.1.dev1-py2.7-macosx-10.6-intel.egg/tornado/testing.py\", line 118, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/Users/mb312/.virtualenvs/test/lib/python2.7/site-packages/tornado-4.1.dev1-py2.7-macosx-10.6-intel.egg/tornado/test/iostream_test.py\", line 253, in test_gaierror\n    self.assertTrue(isinstance(stream.error, socket.gaierror), stream.error)\nAssertionError: False is not true\n\n======================================================================\nFAIL: test_gaierror (tornado.test.iostream_test.TestIOStreamSSL)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/Users/mb312/.virtualenvs/test/lib/python2.7/site-packages/tornado-4.1.dev1-py2.7-macosx-10.6-intel.egg/tornado/testing.py\", line 118, in __call__\n    result = self.orig_method(*args, **kwargs)\n  File \"/Users/mb312/.virtualenvs/test/lib/python2.7/site-packages/tornado-4.1.dev1-py2.7-macosx-10.6-intel.egg/tornado/test/iostream_test.py\", line 253, in test_gaierror\n    self.assertTrue(isinstance(stream.error, socket.gaierror), stream.error)\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 1061 tests in 14.282s\n\nFAILED (failures=2, skipped=95)\nIn both cases, stream.error appears to be None. What is the next best step to debug?", "issue_status": "Closed", "issue_reporting_time": "2014-10-23T01:03:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "740": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1226", "issue_id": "#1226", "issue_summary": "deleted", "issue_description": "JackTandy commented on 18 Oct 2014\ndeleted", "issue_status": "Closed", "issue_reporting_time": "2014-10-18T17:28:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "741": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1224", "issue_id": "#1224", "issue_summary": "concurrency errors running multiple processes together with a process pool executor", "issue_description": "cliffxuan commented on 15 Oct 2014\nI'm trying to run multiple processes and at the same time use the concurrent.futures.ProcessPoolExecutor to run CPU intensive jobs. The first few requests are happily served, but then a KeyError is raised from concurrent.futures.process, and the server hangs.\nIs this a bug in Tornado?\nThis is the simplest form I stripped the code to.\nserver:\n\"\"\"\nserver runs 2 processes and does job on a ProcessPoolExecutor\n\"\"\"\nimport tornado.web\nimport tornado.ioloop\nimport tornado.gen\nimport tornado.options\nimport tornado.httpserver\n\nfrom concurrent.futures import ProcessPoolExecutor\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    executor = ProcessPoolExecutor(1)\n\n    @tornado.gen.coroutine\n    def post(self):\n        num = int(self.request.body)\n        result = yield self.executor.submit(pow, num, 2)\n        self.finish(str(result))\n\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\n\ndef main():\n    tornado.options.parse_command_line()\n    server = tornado.httpserver.HTTPServer(application)\n    server.bind(8888)\n    server.start(2)\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == '__main__':\n    main()\nclient\n\"\"\"\nclient\n\"\"\"\nfrom tornado.httpclient import AsyncHTTPClient\nfrom tornado.gen import coroutine\nfrom tornado.ioloop import IOLoop\n\n\n@coroutine\ndef remote_compute(num):\n    rsp = yield AsyncHTTPClient().fetch(\n        'http://127.0.0.1:8888', method='POST', body=str(num))\n    print 'result:', rsp.body\n\nIOLoop.instance().run_sync(lambda: remote_compute(10))\nerror traceback\nException in thread Thread-1:\nTraceback (most recent call last):\n  File \"/usr/local/Cellar/python/2.7.7_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 810, in __bootstrap_inner\n    self.run()\n  File \"/usr/local/Cellar/python/2.7.7_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 763, in run\n    self.__target(*self.__args, **self.__kwargs)\n  File \"/Users/cliffxuan/.virtualenvs/executor/lib/python2.7/site-packages/concurrent/futures/process.py\", line 216, in _queue_management_worker\n    work_item = pending_work_items[result_item.work_id]\nKeyError: 0", "issue_status": "Closed", "issue_reporting_time": "2014-10-14T21:08:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "742": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1221", "issue_id": "#1221", "issue_summary": "Testing in python 3.4 fails when Deps = True", "issue_description": "grimley517 commented on 12 Oct 2014\nI'm hoping this output file is readable https://travis-ci.org/grimley517/tornado/jobs/37721090", "issue_status": "Closed", "issue_reporting_time": "2014-10-12T04:55:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "743": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1219", "issue_id": "#1219", "issue_summary": "Add timeouts to TCPClient", "issue_description": "Member\nbdarnell commented on 11 Oct 2014\nTCPClient needs built-in timeout support (as opposed to wrapping with gen.with_timeout) so it can close its sockets instead of just waiting for the default socket connect timeout.", "issue_status": "Closed", "issue_reporting_time": "2014-10-11T15:29:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "744": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1218", "issue_id": "#1218", "issue_summary": "Correctly parse If-None-Match header", "issue_description": "Member\nbdarnell commented on 11 Oct 2014\nWe currently just look for the current Etag as a substring of If-None-Match, which mostly works for our hash-generated Etags (although it did mask a bug involving str() on a bytes object in python 3), but is not guaranteed to be correct for applications that override compute_etag.", "issue_status": "Closed", "issue_reporting_time": "2014-10-11T15:28:03Z", "fixed_by": "#1274", "pull_request_summary": "Fixed #1218.", "pull_request_description": "Contributor\ndaftshady commented on 12 Dec 2014\nFixed #1218, please review this.\nSplit If-None-Match with , to handle multiple etag in a single header.\nIf \"*\" is given and any current entity exists for that resource, this method should return True.\nFind etag match in tags (maybe including weak validator).", "pull_request_status": "Merged", "issue_fixed_time": "2015-03-06T03:56:48Z", "files_changed": [["82", "maint/test/redbot/red_test.py"], ["66", "tornado/test/web_test.py"], ["24", "tornado/web.py"]]}, "745": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1216", "issue_id": "#1216", "issue_summary": "url_concat: Enable doseq for urlencode", "issue_description": "collinsethans commented on 4 Oct 2014\nWe communicate with Solr and it can take multiple 'fq' args. Since url_concat takes a dict, we pass fq key values in a list.\nSetting 'urlencode(args, True)' will take all the values for the key.", "issue_status": "Closed", "issue_reporting_time": "2014-10-04T07:50:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "746": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1213", "issue_id": "#1213", "issue_summary": "Body should be allowed to be empty for PUT", "issue_description": "ke4roh commented on 1 Oct 2014\nThis stack trace line is from Tornado 3.2.1 (but continuing into the latest code in lines 317-328):\n  File \"/opt/rh/python33/root/usr/lib64/python3.3/site-packages/tornado/simple_httpclient.py\", line 308, in _on_connect\n    % self.request.method)\nAssertionError: Body must not be empty for \"PUT\" request\nThe HTTP specification doesn't require content for these requests (although it discusses the content). The fact of calling a PUT or POST may be all that is required to change the system's state.\nThere's discussion here:\nhttp://lists.w3.org/Archives/Public/ietf-http-wg/2010JulSep/0273.html\nSome example use cases:\nPUT: I want to tag an artifact named on the URL with the tag also provided on the URL\nPOST: I want to check the session named on the URL to see if it's still valid (and by doing so extend its validity if it is still valid).", "issue_status": "Closed", "issue_reporting_time": "2014-10-01T14:27:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "747": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1210", "issue_id": "#1210", "issue_summary": "on_close handler doesn't seem to be called upon interruption to websocket connection", "issue_description": "aaronjwood commented on 27 Sep 2014\nI have an application that keeps track of connected clients and \"locks\" editable fields for other clients until there are no other clients trying to access it. The page is \"locked\" when someone loads the page and establishes a connection with the tornado socket server. Once that user moves to another page or closes the browser/tab the socket server removes them from the dictionary of connected clients so that another client that's waiting can start their workflow.\nTesting this functionality over the VPN from home one day led me to find that if I disconnect from the VPN and then close the page or navigate away from the page that establishes a socket connection tornado doesn't seem to call the on_close method. This causes the client to be stored in the dictionary until the socket server is restarted.\nShouldn't tornado be calling on_close upon a disconnect OR an interruption to the connection?\nI'm using tornado 4.0.1 with python 3.4.", "issue_status": "Closed", "issue_reporting_time": "2014-09-26T20:44:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "748": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1209", "issue_id": "#1209", "issue_summary": "Raising HTTPError in streaming handler drops connection", "issue_description": "jmcarp commented on 26 Sep 2014\nIn a handler decorated with stream_request_body, raising an HTTPError interrupts the connection to the client rather than returning the expected error response. For example:\n@web.stream_request_body\nclass MyHandler(web.RequestHandler):\n    def put(self):\n        raise web.HTTPError(400)\nI would like the client to receive an error response with a code of 400, but instead it gets a broken pipe error. Is this expected? Is there a way to return a normal HTTP error in this case?", "issue_status": "Closed", "issue_reporting_time": "2014-09-25T21:52:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "749": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1208", "issue_id": "#1208", "issue_summary": "StreamClosedError", "issue_description": "nospamcalfee commented on 24 Sep 2014\nI am using tornado, in Ubuntu 13.10 (64 bit). I am not sure of the Tornado version.\nHere is a console dump of the failure. It happens when the mp4 playback is started. Interestingly, the playback works ok.\nERROR:tornado.application:Uncaught exception GET /Ollie_Hopnoodles_Haven_of_Bliss.mp4 (127.0.0.1)\nHTTPServerRequest(protocol='http', host='localhost:8888', method='GET', uri='/Ollie_Hopnoodles_Haven_of_Bliss.mp4', version='HTTP/1.1', remote_ip='127.0.0.1', headers={'Host': 'localhost:8888', 'Accept-Language': 'en-US,en;q=0.5', 'Range': 'bytes=1572864-', 'Accept': 'video/webm,video/ogg,video/;q=0.9,application/ogg;q=0.7,audio/;q=0.6,/;q=0.5', 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:30.0) Gecko/20100101 Firefox/30.0', 'Connection': 'keep-alive', 'Referer': 'http://localhost:8888/', 'Cookie': 'chatdemo_user=\"2|1:0|10:1409957404|13:chatdemo_user|224:eyJjbGFpbWVkX2lkIjogImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vYWNjb3VudHMvbzgvaWQ/aWQ9QUl0T2F3bm96ajloT3FnVTF6UUdVeGJFb1RPdmZQSjBIc0JacVg0IiwgImZpcnN0X25hbWUiOiAiU3RldmUiLCAibGFzdF9uYW1lIjogIkNhbGZlZSIsICJuYW1lIjogIlN0ZXZlIENhbGZlZSJ9|5ca21c20862a501375700bf3c1d9c975cac9cff1d1fdf5893f63f37500b3df0a\"; _xsrf=2|f5e1d17e|86893f3413646199c64dfe78faf87916|1409957404'})\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1334, in _execute\nresult = yield result\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 617, in run\nvalue = future.result()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 109, in result\nraise_exc_info(self._exc_info)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 620, in run\nyielded = self.gen.throw(*sys.exc_info())\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 2172, in get\nyield self.flush()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/gen.py\", line 617, in run\nvalue = future.result()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/concurrent.py\", line 111, in result\nraise self._exception\nStreamClosedError\nERROR:tornado.general:Cannot send error response after headers written\nHere is the python source:\n!/usr/bin/python2\nimport tornado.web\nimport tornado.websocket\nimport tornado.ioloop\nclass MainHandler(tornado.web.RequestHandler):\ndef get(self):\nself.render(\"mini.html\")\napplication = tornado.web.Application([\n(r\"/\", MainHandler),\n(r\"/(.*)\", tornado.web.StaticFileHandler, {'path': '.'}),\n])\nif name == \"main\":\napplication.listen(8888)\ntornado.ioloop.IOLoop.instance().start()\nAnd here is the html source with all \"<\" s removed to not confuse this website:\n!DOCTYPE html>\nhtml>\nhead>\ntitle>mp4 server /title>\n/head>\nbody>\nvideo controls\nsource src=\"./Ollie_Hopnoodles_Haven_of_Bliss.mp4\" type=\"video/mp4\">\n/video>\n/body>\n/html>", "issue_status": "Closed", "issue_reporting_time": "2014-09-23T22:48:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "750": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1205", "issue_id": "#1205", "issue_summary": "Implement function returning Future aroud Subprocess.set_exit_callback", "issue_description": "socketpair commented on 23 Sep 2014\nI mean, after implementing, instead of:\nyield gen.Task(proc.set_exit_callback)\nwe may write\nyield proc.wait_for_exit()", "issue_status": "Closed", "issue_reporting_time": "2014-09-23T06:40:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "751": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1203", "issue_id": "#1203", "issue_summary": "tornado.test.tcpclient_test fails in nosetest3", "issue_description": "kimscheibel commented on 22 Sep 2014\ntornado.test.tcpclient_test.do_test_connect() is a utility function for other tests and should not be run as a test directly. Yet, nosetest3 does exactly that.\nMight want to apply fix for similar issue in tornado.testing where func.__test__ is set to false.", "issue_status": "Closed", "issue_reporting_time": "2014-09-21T22:18:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "752": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1202", "issue_id": "#1202", "issue_summary": "tornado escape json_encode problem", "issue_description": "zairoo commented on 21 Sep 2014\nHello\neg:\njson_encode(dict(status=dict(code=1, add_time=\"2014-09-21 14:33:54\", message=\"test\")))\noutput result:\n{\"status\": {\"message\": \"test\", \"code\": 1, \"add_time\": \"2014-09-21 14:33:54\"}}\nhow to display initial order? I can sort?\n{\"status\": { \"code\": 1,\"add_time\": \"2014-09-21 14:33:54\", \"message\": \"test\"}}", "issue_status": "Closed", "issue_reporting_time": "2014-09-21T07:14:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "753": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1201", "issue_id": "#1201", "issue_summary": "asyncio's ProactorEventLoop does not work with the AsyncIOMainLoop adapter", "issue_description": "KimiNewt commented on 20 Sep 2014\nWhen trying to setup a tornado ioloop inside an asyncio eventloop, when the eventloop is a ProactorEventLoop you get a NotImplementedException when you try to hook up some socket-related component since ProactorEventLoop does not implement add_reader.\nThe following code raises that exception (on Windows):\nimport asyncio\nimport socket, os\nfrom tornado.platform.asyncio import AsyncIOMainLoop\nfrom tornado.iostream import IOStream\n\nif os.name == 'nt':\n    loop = asyncio.ProactorEventLoop() # for subprocess' pipes on Windows\n    asyncio.set_event_loop(loop)\nelse:\n    loop = asyncio.get_event_loop()\nAsyncIOMainLoop().install()\n\ni = IOStream(socket.socket())\ni.connect(('www.google.com', 80), lambda: None)", "issue_status": "Closed", "issue_reporting_time": "2014-09-20T07:58:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "754": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1200", "issue_id": "#1200", "issue_summary": "Tornado not closing keep-alive sockets", "issue_description": "williame commented on 20 Sep 2014\nMy webserver keeled over recently due to \"to many files open\". I poked around, and my limit was 1024. I restarted the server and upped the ulimit, but I still wondered how the webserver had used up 1K of descriptors; its not a busy site.\nI am running it as non-root and using an iptable rule to give it traffic from port 80. Standard stuff.\nThe server has been running a few days now, under very light load; a few browser visits per hour.\nI have just run lsof on it and it has loads of TCP connections open! They are in sets of 6, which is how many concurrent sockets a browser normally opens against a site.\nI will try and anonymize a bit of lsof output:\npython  12448  wil   80u  IPv4 3570570303      0t0        TCP box:3456->ip-123.123.221.221:55550 (ESTABLISHED)\npython  12448  wil   81u  IPv4 3570570701      0t0        TCP box:3456->ip-123.123.221.221:55552 (ESTABLISHED)\npython  12448  wil   82u  IPv4 3570570713      0t0        TCP box:3456->ip-123.123.221.221:55554 (ESTABLISHED)\npython  12448  wil   83u  IPv4 3570570739      0t0        TCP box:3456->ip-123.123.221.221:55556 (ESTABLISHED)\npython  12448  wil   84u  IPv4 3570570740      0t0        TCP box:3456->ip-123.123.221.221:55558 (ESTABLISHED)\npython  12448  wil   85u  IPv4 3570570741      0t0        TCP box:3456->ip-123.123.221.221:55560 (ESTABLISHED)\nI can match up these ip-addresses with my normal webserver logs and see how long ago these were created.\nAnd many of these sockets that are open go back days!\nWhat gives? Why aren't they getting closed? How do you get tornado to close stale sockets?", "issue_status": "Closed", "issue_reporting_time": "2014-09-19T21:04:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "755": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1199", "issue_id": "#1199", "issue_summary": "Normalizing of HTTP headers problem", "issue_description": "JoakimSoderberg commented on 18 Sep 2014\na7dc5bc#diff-9b84c7e5ffcc39dd22d142abd484d8bfR129 which normalizes all outgoing headers, for instance \"set-cookies\" to \"Set-Cookies\" breaks support for some older clients we have. As @jagguli mentions, why not just do lowercase here? At least have it as an option.\nWhen upgrading from an older Tornado version to this latest one, some older clients broke for us (not easily upgradeable), these clients are using an older version of libwebsockets with this bug (it only parses lower case headers in the Websocket upgrade response properly):\nwarmcat/libwebsockets#137\nSo now to be able to run the latest Tornado with these older clients we are stuck with monkey patching. It would be nice to have an option to turn this \"prettyfying outgoing headers\" off.", "issue_status": "Closed", "issue_reporting_time": "2014-09-18T10:15:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "756": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1196", "issue_id": "#1196", "issue_summary": "Websocket error when writing faster", "issue_description": "inspired1 commented on 17 Sep 2014\nIn my application i have do send via websocket a huge amount of data. Something like 10000 dictionaries per second. Each dictionary i JSONed as a string of ~ 180 chars.\nI tried:\nWebSocketHandler.write_message() for each dictionary\none WebSocketHandler.write_message() call with a serialized list of 10,100, 1000 dictionaries.\nIt's always the same result.\nClient dies because a low level protocol error (1002) without other explanation.\nI noticed sometimes Client can't decode frame because it find a character (x) on byte x. I mean: char (181) in position 181 or char(42) in position 42 and so on.\nI can figure out something on tornado.websocket code confuses on frame position with frame length.\nTank You", "issue_status": "Closed", "issue_reporting_time": "2014-09-17T13:29:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "757": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1195", "issue_id": "#1195", "issue_summary": "tornado template problem\uff1f", "issue_description": "zairoo commented on 17 Sep 2014\nuse bootstrap modal.js in tornado template.\nHow to directly output the {{***}}\neg:\nscript type='text/template' id=\"domain-remark-template\"\n<div style=\"width:400px;\".....{{name}}</div.....", "issue_status": "Closed", "issue_reporting_time": "2014-09-17T08:57:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "758": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1192", "issue_id": "#1192", "issue_summary": "Monotime is a C extension which is unsuitable for PyPy", "issue_description": "Contributor\nthedrow commented on 15 Sep 2014\nIt will slow down tornado when using it with PyPy.\nIs there an alternative?", "issue_status": "Closed", "issue_reporting_time": "2014-09-15T13:08:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "759": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1191", "issue_id": "#1191", "issue_summary": "Add a speedups version that uses CFFI", "issue_description": "Contributor\nthedrow commented on 15 Sep 2014\nThere's only one method in the speedups module that performs some masking arithmetics.\nIt shouldn't be that hard to provide a CFFI module that does exactly the same (with cleaner code).\nDo you guys think we should convert the C extension into CFFI or just add a pypyspeedups module with the same functionality?\nWill PyPy benfit from calculating the masking arithmetics in C?", "issue_status": "Closed", "issue_reporting_time": "2014-09-15T10:05:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "760": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1188", "issue_id": "#1188", "issue_summary": "curl_httpclient: executing request in streaming callback raises error", "issue_description": "tdryer commented on 15 Sep 2014\nUsing curl_httpclient, executing a request in the streaming callback of another request raises an error from pycurl. Using simple_httpclient (remove AsyncHTTPClient.configure line) works as expected. Tested on Ubuntu 14.04 with Python 2.7.6 / Tornado 4.0.2 / pycurl 7.19.5.\nfrom tornado import ioloop, gen, httpclient\n\n@gen.coroutine\ndef main():\n    httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n    http_client = httpclient.AsyncHTTPClient()\n\n    @gen.coroutine\n    def sync():\n        yield http_client.fetch('https://httpbin.org/get')\n\n    def streaming_callback(stuff):\n        ioloop.IOLoop.instance().add_future(sync(), lambda f: f.result())\n\n    yield http_client.fetch('https://httpbin.org/get', streaming_callback=streaming_callback)\n\n\nif __name__ == '__main__':\n    ioloop.IOLoop.instance().run_sync(main)\nERROR:tornado.application:Exception in callback <functools.partial object at 0x7f389c10b4c8>\nTraceback (most recent call last):\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 565, in _run_callback\n    ret = callback()\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\n  File \"curl_test.py\", line 13, in <lambda>\n    ioloop.IOLoop.instance().add_future(sync(), lambda f: f.result())\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 109, in result\n    raise_exc_info(self._exc_info)\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/gen.py\", line 175, in wrapper\n    yielded = next(result)\n  File \"curl_test.py\", line 10, in sync\n    yield http_client.fetch(httpclient.HTTPRequest('https://httpbin.org/get'))\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/httpclient.py\", line 245, in fetch\n    self.fetch_impl(request, handle_response)\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/curl_httpclient.py\", line 82, in fetch_impl\n    self._process_queue()\n  File \"/home/tom/.virtualenvs/newest-tornado/local/lib/python2.7/site-packages/tornado/curl_httpclient.py\", line 216, in _process_queue\n    self._multi.add_handle(curl)\nerror: cannot add/remove handle - multi_perform() already running", "issue_status": "Closed", "issue_reporting_time": "2014-09-15T04:52:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "761": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1184", "issue_id": "#1184", "issue_summary": "Speed up stack_context.py", "issue_description": "scoder commented on 14 Sep 2014\nI profiled the tornado benchmark in CPython's test suite\nhttps://hg.python.org/benchmarks/file/9a1136898539/performance/bm_tornado_http.py\nand it gave me this (CPython 3.4 on Ubuntu 14.04):\n         1297716 function calls (1277262 primitive calls) in 1.355 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n36663/20463    0.082    0.000    1.288    0.000 stack_context.py:269(wrapped)\n    48605    0.061    0.000    0.096    0.000 stack_context.py:253(wrap)\n    36663    0.048    0.000    0.054    0.000 stack_context.py:227(_remove_deactivated)\n    15602    0.041    0.000    0.082    0.000 ioloop.py:713(add_callback)\n    16200    0.039    0.000    0.053    0.000 iostream.py:980(_merge_prefix)\n    13200    0.039    0.000    0.132    0.000 iostream.py:337(_run_callback)\n     4200    0.039    0.000    0.039    0.000 {method 'send' of '_socket.socket' objects}\n    43856    0.037    0.000    0.037    0.000 {built-in method hasattr}\n        1    0.035    0.035    1.349    1.349 ioloop.py:549(start)\n...\nI found it a bit surprising that so much time was spent in a helper module like stack_context.py, so I compiled the module with Cython (0.21) and the picture changed to this (some C calls add into their caller's timings now):\n         1061674 function calls (1057420 primitive calls) in 1.191 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    13200    0.057    0.000    0.107    0.000 iostream.py:337(_run_callback)\n    15602    0.054    0.000    0.057    0.000 ioloop.py:713(add_callback)\n        1    0.044    0.044    1.188    1.188 ioloop.py:549(start)\n     4200    0.038    0.000    0.038    0.000 {method 'send' of '_socket.socket' objects}\n    13200    0.037    0.000    0.749    0.000 iostream.py:338(wrapper)\n    15602    0.036    0.000    0.958    0.000 ioloop.py:452(_run_callback)\n    16200    0.035    0.000    0.048    0.000 iostream.py:980(_merge_prefix)\n    15600    0.031    0.000    0.031    0.000 {method 'recv' of '_socket.socket' objects}\n...\nThis resulted in a speedup of about 7% for the overall benchmark.\nI recommend doing that officially, i.e. run cythonize(\"tornado/stack_context.py\") before a release and ship the resulting .c file as additional extension module.\nhttp://docs.cython.org/src/reference/compilation.html#compiling-with-distutils", "issue_status": "Closed", "issue_reporting_time": "2014-09-13T22:05:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "762": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1177", "issue_id": "#1177", "issue_summary": "AsyncTestCase swallows multiple callback exceptions", "issue_description": "Contributor\nbrickZA commented on 10 Sep 2014\nWhen multiple callbacks that raise exceptions are run on the ioloop AsyncTestCase seems to swallow all exceptions apart from the last, as demonstrated by this snippet below. With python 2.7 and tornado 4.0.1 only Exception(2) is printed, although both callbacks ran and raised exceptions. This is particularly problematic when the failure in cb2() was caused by cb1() not performing some expected action.\nimport unittest\nimport tornado.testing\n\nclass TestTest(tornado.testing.AsyncTestCase):\n\n    @tornado.testing.gen_test()\n    def test_testy(self):\n\n        def start():\n            self.io_loop.add_callback(cb1)\n            self.io_loop.add_callback(cb2)\n\n        def cb1():\n            print('hi 1!')\n            raise Exception(1)\n\n        def cb2():\n            print 'hi 2!'\n            raise Exception(2)\n\n        start()\n\nif __name__ == '__main__'\n    unittest.main()", "issue_status": "Closed", "issue_reporting_time": "2014-09-10T09:28:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "763": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1174", "issue_id": "#1174", "issue_summary": "Tornado 3.2, uncaught StreamClosedError exception", "issue_description": "snoshy commented on 5 Sep 2014\nsorry for the sparse bug report, and i hope this is the right place to report this. i can provide more details about the issue if necessary, but it seems somewhat straightforward. a closed stream on accept shouldn't throw.\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1693, in __call__\n    handler._execute(transforms, *args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 152, in _execute\n    self.ws_connection.accept_connection()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 529, in accept_connection\n    self._accept_connection()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 575, in _accept_connection\n    \"\\r\\n\" % (self._challenge_response(), subprotocol_header)))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 214, in write\n    self._check_closed()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 593, in _check_closed\n    raise StreamClosedError(\"Stream is closed\")\nStreamClosedError: Stream is closed", "issue_status": "Closed", "issue_reporting_time": "2014-09-05T04:45:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "764": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1173", "issue_id": "#1173", "issue_summary": "WebSocketHandler close() method should call on_close()", "issue_description": "yixuanhu commented on 5 Sep 2014\nWebSocketHandler.on_close() method should be invoked when WebSocketHandler.close() was called explicitly by user", "issue_status": "Closed", "issue_reporting_time": "2014-09-05T02:49:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "765": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1172", "issue_id": "#1172", "issue_summary": "_parse_headers and latin1", "issue_description": "Contributor\nSuminAndrew commented on 3 Sep 2014\nHTTP1Connection._parse_headers assumes that headers are in latin1 encoding\ntornado/tornado/http1connection.py\nLine 493 in 93ae079\n data = native_str(data.decode('latin1')).lstrip(\"\\r\\n\") \n\nThis is compliant with both RFC 2616 and PEP 3333, but there still exists an issue with cookies, which are saved in system encoding by some browsers (IE8, for example) and are not escaped. In our project we experienced this issue and introduced a fallback mechanism.\nWerkzeug has also introduced a workaround: https://github.com/mitsuhiko/werkzeug/blob/c16acc75429bf33734b27ad2efdc6ff0774077c8/werkzeug/http.py#L846, which seems harmless enough\n@bdarnell, what is your opinion?", "issue_status": "Closed", "issue_reporting_time": "2014-09-03T14:16:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "766": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1170", "issue_id": "#1170", "issue_summary": "reverse_url can not Create correct Url", "issue_description": "ghanbari commented on 1 Sep 2014\nHi, I Have This Route:\n(r'^/FoodListAdminCP/Recipes/Keywords/Index/?$', handlers.admin.recipe.keyword.Index, None, 'superpanel_recipe_keyword_index'),\nBut That dont Know What is My Mean From '/?',\nThat Create This Url:\n/FoodListAdminCP/Recipes/Keywords/Index/?\nThat Can Not Reverse Regex, Correctly\nThanks For Your Time(Sorry, I Can Not Speak English Very Good)", "issue_status": "Closed", "issue_reporting_time": "2014-09-01T05:45:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "767": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1169", "issue_id": "#1169", "issue_summary": "I want to use the stream_request_body class decorator for uploading large file. How to use the stream_request_body class decorator?", "issue_description": "cloveses commented on 27 Aug 2014\nif you need to handlefiles that are too large to comfortable keep in memory ,How to use the stream_request_body class decorator?How to save the uploaded file?\nDo you give me an exampe?\nThe key method is prepare,data_received.\nThanks for your reply.\n@stream_request_body\nclass MyFileUpHandler(RequestHandler):\n....def prepare(self):\n........pass\n....def get(self):\n........htmlstr = '''upload file form html string'''\n........self.write(htmlstr)\n....def post(self):\n........pass\n....def data_received(self, data):\n........pass", "issue_status": "Closed", "issue_reporting_time": "2014-08-27T13:53:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "768": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1168", "issue_id": "#1168", "issue_summary": "HTTP client does not handle socket connection errors", "issue_description": "Contributor\nghost commented on 27 Aug 2014\nThe tornado.httpclient implementations of async and blocking HTTP clients do not handle socket errors arising on connection failures, such as \"[Errno 65] No route to host\" and \"[Errno 61] Connection refused\".\nIt's my understanding that a tornado.httpclient.HTTPError (code 599 or similar) should be raised on socket errors, in Tornado 4.0.1 (and earlier versions) an AttributeError is raised on socket connection errors.\nThe problem can be reproduced with the following code:\nimport tornado.httpclient\nhttp = tornado.httpclient.HTTPClient()\nhttp.fetch('http://example.com:90')\nWhich causes a socket connection error that results in an AttributeError raised in tcpclient.py:\nWARNING:tornado.general:Connect error on fd 10: [Errno 65] No route to host\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.4/site-packages/tornado/httpclient.py\", line 96, in fetch\n    self._async_client.fetch, request, **kwargs))\n  File \"/usr/local/lib/python3.4/site-packages/tornado/ioloop.py\", line 418, in run_sync\n    return future_cell[0].result()\n  File \"/usr/local/lib/python3.4/site-packages/tornado/concurrent.py\", line 111, in result\n    raise self._exception\n  File \"/usr/local/lib/python3.4/site-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python3.4/site-packages/tornado/tcpclient.py\", line 129, in on_timeout\n    self.try_connect(iter(self.secondary_addrs))\n  File \"/usr/local/lib/python3.4/site-packages/tornado/tcpclient.py\", line 97, in try_connect\n    future.add_done_callback(functools.partial(self.on_connect_done,\nAttributeError: 'NoneType' object has no attribute 'add_done_callback'", "issue_status": "Closed", "issue_reporting_time": "2014-08-27T13:12:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "769": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1167", "issue_id": "#1167", "issue_summary": "Fail silently in template expressions", "issue_description": "jaimegildesagredo commented on 27 Aug 2014\nI would like to know your thoughts on adding a new feature to allow expressions in templates fail silently.\nMany times we get a 500 error in production because an expression ({{ some expression }}) in a template raises an exception caused by data that change dynamically. In most cases we could render the template with an empty string where the expression raised but don't want to mess up the template with many if/try statements.\nThe idea is to be able to render a page in production to the client even if some data is not like expected, instead of giving a 500 error.\nIt also would be interesting to enable/disable this functionality based on the environment: production/development/debug.", "issue_status": "Closed", "issue_reporting_time": "2014-08-27T11:29:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "770": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1165", "issue_id": "#1165", "issue_summary": "Memory leak", "issue_description": "misuzu commented on 26 Aug 2014\nTornado 3.2.2:\nmisuzu@mio:~$ ps aux | grep main\nmisuzu   29712  1.5  0.0  57988 12408 pts/6    S+   11:22   0:00 python main.py\nmisuzu   29714  0.0  0.0  13924   936 pts/5    S+   11:22   0:00 grep main\nmisuzu@mio:~$ ab -n 10000 -c 10 http://localhost:8080/\nThis is ApacheBench, Version 2.3 <$Revision: 1604373 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking localhost (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests\n\n\nServer Software:        TornadoServer/3.2.2\nServer Hostname:        localhost\nServer Port:            8080\n\nDocument Path:          /\nDocument Length:        0 bytes\n\nConcurrency Level:      10\nTime taken for tests:   1.671 seconds\nComplete requests:      10000\nFailed requests:        0\nTotal transferred:      1940000 bytes\nHTML transferred:       0 bytes\nRequests per second:    5985.38 [#/sec] (mean)\nTime per request:       1.671 [ms] (mean)\nTime per request:       0.167 [ms] (mean, across all concurrent requests)\nTransfer rate:          1133.95 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.0      0       0\nProcessing:     1    2   0.1      2       2\nWaiting:        1    2   0.1      2       2\nTotal:          1    2   0.1      2       2\n\nPercentage of the requests served within a certain time (ms)\n  50%      2\n  66%      2\n  75%      2\n  80%      2\n  90%      2\n  95%      2\n  98%      2\n  99%      2\n 100%      2 (longest request)\nmisuzu@mio:~$ ab -n 10000ps aux | grep main\nmisuzu   29712 14.1  0.0  58244 12496 pts/6    S+   11:22   0:01 python main.py\nmisuzu   29723  0.0  0.0  13924   936 pts/5    S+   11:22   0:00 grep main\nmisuzu@mio:~$ \nTornado 4.0.1:\nmisuzu@mio:~$ ps aux | grep main                                                                                                                                                                                                    \nmisuzu   29824  0.8  0.0  58300 12896 pts/6    S+   11:27   0:00 python main.py\nmisuzu   29828  0.0  0.0  13924   936 pts/5    S+   11:27   0:00 grep main                                                                                                                                                                    \nmisuzu@mio:~$ ab -n 10000 -c 10 http://localhost:8080/                                                                                                                                                                               \nThis is ApacheBench, Version 2.3 <$Revision: 1604373 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking localhost (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests\n\n\nServer Software:        TornadoServer/4.0.1\nServer Hostname:        localhost\nServer Port:            8080\n\nDocument Path:          /\nDocument Length:        0 bytes\n\nConcurrency Level:      10\nTime taken for tests:   3.384 seconds\nComplete requests:      10000\nFailed requests:        0\nTotal transferred:      1940000 bytes\nHTML transferred:       0 bytes\nRequests per second:    2954.86 [#/sec] (mean)\nTime per request:       3.384 [ms] (mean)\nTime per request:       0.338 [ms] (mean, across all concurrent requests)\nTransfer rate:          559.81 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.0      0       0\nProcessing:     1    3   8.6      3     173\nWaiting:        1    3   8.6      3     173\nTotal:          1    3   8.6      3     173\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      3\n  75%      3\n  80%      3\n  90%      3\n  95%      3\n  98%      3\n  99%      4\n 100%    173 (longest request)\nmisuzu@mio:~$ ps aux | grep main                                                                                                                                                                                                    \nmisuzu   29824 15.9  0.7 287372 242020 pts/6   S+   11:27   0:03 python main.py\nmisuzu   29840  0.0  0.0  13924   936 pts/5    S+   11:27   0:00 grep main\nAs you can see tornado 4.0.1 is eating up 240MB and 2x slower than 3.2.2:\nRequests per second: 5985.38 #/sec (3.2.2)\nRequests per second: 2954.86 #/sec (4.0.1)\nCode is same:\nimport tornado.ioloop\nimport tornado.web\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.finish('')\n\n\napplication = tornado.web.Application([\n    (r'/', MainHandler),\n])\n\n\nif __name__ == '__main__':\n    application.listen(8080)\n    tornado.ioloop.IOLoop.instance().start()\nPython 2.7.8", "issue_status": "Closed", "issue_reporting_time": "2014-08-26T08:34:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "771": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1164", "issue_id": "#1164", "issue_summary": "Proxying streamed uploads", "issue_description": "Contributor\nchrisseto commented on 26 Aug 2014\nSo a bit of an edge case here but I'm attempting to proxy a streamed upload to Rackspace.\nThis code does exactly what I need but for amazon's S3 service.\nSadly Rackspace does not seem to support multipart uploads so the only option, without reading the entire file into memory, is to make some form of generator.\nSo is there any way to turn data_recieved from RequestsHandler decorated with tornado.web.stream_request_body into a generator that could be referenced in prepare and passed to other functions?\nBest case scenario the code would look something like this:\n@tornado.web.stream_request_body\nclass UploadHandler(RequestHandler):\n    def prepare(self):\n        requests.post('RackspaceUrl', data=self.data_received, stream=True)\n\n    def data_received(self, data):\n        #Process data if needed\n        yield data", "issue_status": "Closed", "issue_reporting_time": "2014-08-25T19:25:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "772": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1163", "issue_id": "#1163", "issue_summary": "Starting and stopping tornado server in thread", "issue_description": "ninduni commented on 26 Aug 2014\nI've got a main process that is generating a lot of data, and I'm using a tornado server (started in a background thread) to feed it to clients. I would rather not run it in a thread, but I don't know how to stop ioloop.start() from blocking otherwise.\nProblem is, I've got to start and stop this server for various reasons. Stopping it works fine, but when I try to start it again, I get\n[Errno 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted\nI then tried adding all_fds=True to the ioloop.close() call, but that gives a TypeError: 'NoneType' object is not iterable on line 779 of ioloop.py. Same thing occurs if I try stopping the HTTPServer before closing the ioloop.\nI've seen #737 but I'm not seeing a solution that fixes my problem.\nWhat is the appropriate way to close and restart an ioloop?", "issue_status": "Closed", "issue_reporting_time": "2014-08-25T18:50:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "773": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1161", "issue_id": "#1161", "issue_summary": "Blocking calls using @gen.coroutine", "issue_description": "bbirand commented on 25 Aug 2014\nI am trying to write a simple, blocking function my_recv_future that sends a ZMQ packet, and then returns when the response is received. The ZMQ library supports the Tornado ioloop, and its knowledge is not necessary for this example\nI wrote this function:\n@gen.coroutine\ndef my_recv_future(socket, amsg):\n    zmqstream = ZMQStream(socket)  # Required for ZMQ\n    future = Future()\n    def _finish(reply):\n        future.set_result(reply)\n        zmqstream.close()\n    zmqstream.on_recv(_finish)\n    zmqstream.send(amsg)\n    resp = yield future   #Block here waiting for the reply\n    raise gen.Return(resp)\nI then want to call this function as:\nval = my_recv_future(socket, amsg) #Blocking call, wait till reply\n# Do things with val\nThe problem is that since my_recv_future is a @gen.coroutine, it returns a Future, while I want it to return the actual value. When I try to block on val.result(), I get an error saying that DummyFuture doesn't support blocking. I tried installing concurrent.futures, but I still get the same error (I thought it was supposed to overwrite the supplied version).\nHow does one block on a Future? What is the right way to create a blocking function as in above?", "issue_status": "Closed", "issue_reporting_time": "2014-08-25T05:54:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "774": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1160", "issue_id": "#1160", "issue_summary": "No child processes IOError with Python 2.7.8 and Tornado 4.0.1", "issue_description": "pbui commented on 24 Aug 2014\nWith Python 2.7.8 and Tornado 4.0.1 on Linux, I get the following:\nTraceback (most recent call last):\n  File \"notifyd.py\", line 224, in <module>\n    notifyd.run()\n  File \"notifyd.py\", line 203, in run\n    self.listen(self.port, self.address)\n  File \"/usr/lib/python2.7/site-packages/tornado/web.py\", line 1691, in listen\n    server.listen(port, address)\n  File \"/usr/lib/python2.7/site-packages/tornado/tcpserver.py\", line 125, in listen\n    sockets = bind_sockets(port, address=address)\n  File \"/usr/lib/python2.7/site-packages/tornado/netutil.py\", line 100, in bind_sockets\n    if (platform.system() == 'Darwin' and address == 'localhost' and\n  File \"/usr/lib/python2.7/platform.py\", line 1310, in system\n    return uname()[0]\n  File \"/usr/lib/python2.7/platform.py\", line 1277, in uname\n    processor = _syscmd_uname('-p','')\n  File \"/usr/lib/python2.7/platform.py\", line 1012, in _syscmd_uname\n    rc = f.close()\nIOError: [Errno 10] No child processes\nLooking at the commit logs, I can trace the cause of this regression to this commit:\na6e83a6\nReverting this commit fixes the problem... but that doesn't solve the original problem the commit tried to fix.\nNote, Python 3.4 does not have this problem.", "issue_status": "Closed", "issue_reporting_time": "2014-08-24T05:55:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "775": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1159", "issue_id": "#1159", "issue_summary": "problems via Handler's Pattern & reverse_url", "issue_description": "ghanbari commented on 24 Aug 2014\nMy Handler is:\n....\n(r'(?i)/Company/UserManagement', ComUser.UserIndexHandler, None, 'company_user_index'),\n......\nAnd In Template I will Reverse This Route via \"{{ reverse_url('company_user_index') }}\".\nBut That Raise:\n.....\nFile \"base/company/dashboard_html.generated.py\", line 115, in _tt_execute\n_tt_tmp = reverse_url('company_user_index') # base/parent_companies.html:143 (via base/parent_companies.html:134)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1235, in reverse_url\nreturn self.application.reverse_url(name, _args)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1789, in reverse_url\nreturn self.named_handlers[name].reverse(_args)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 2818, in reverse\n\"Cannot reverse url regex \" + self.regex.pattern\nAssertionError: Cannot reverse url regex (?i)/Company/UserManagement$\nI test too: {{ reverse_url('company_user_index', 'test') }}\nBecause I think That first match group(?i) Is Necessary, but That no must be in reality\nI'm very Thank for Your Time(sorry, i can not speak english)", "issue_status": "Closed", "issue_reporting_time": "2014-08-24T04:18:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "776": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1156", "issue_id": "#1156", "issue_summary": "gzip encoding does not work in 4.0", "issue_description": "geerk commented on 23 Aug 2014\nFirst of all: thanks for great work.\nI found, that gzip encoding does not work in 4.0 or 4.0.1. But it works in older versions (e.g. 3.2.2), though.\nPython version: 3.4\nOS: Mac OS X 10.9.4, Ubuntu 14.04\nUPD: seems like it is related only for StaticFileHandler", "issue_status": "Closed", "issue_reporting_time": "2014-08-23T08:13:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "777": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1154", "issue_id": "#1154", "issue_summary": "Tornado 4.0.1, AsyncHTTPTestCase, IOLoop is already running", "issue_description": "hgenru commented on 22 Aug 2014\nAfter the upgrade, there was a problem with the use of tornado.testing tools.\nI'm run this simple code: https://gist.github.com/hgenru/47ad817a199de2e33333\n(env)\u279c pip install tornado==3.2\n\n(env)\u279c env/bin/nosetests\n.\n----------------------------------------------------------------------\nRan 1 test in 0.082s\n\nOK\n\n\n(env)\u279c pip uninstall tornado && pip install tornado\n(env)\u279c env/bin/nosetests\nE\n======================================================================\nERROR: test_response (test.HelloHandlerTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/testing.py\", line 118, in __call__\n    result = self.orig_method()\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/testing.py\", line 494, in post_coroutine\n    timeout=timeout)\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/ioloop.py\", line 418, in run_sync\n    return future_cell[0].result()\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/concurrent.py\", line 109, in result\n    raise_exc_info(self._exc_info)\n  File \"<string>\", line 3, in raise_exc_info\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/gen.py\", line 160, in wrapper\n    result = func(*args, **kwargs)\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/testing.py\", line 480, in pre_coroutine\n    result = f(self, *args, **kwargs)\n  File \"/home/hgen/test/47ad817a199de2e33333/test.py\", line 15, in test_response\n    res = self.fetch('/')\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/testing.py\", line 373, in fetch\n    return self.wait()\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/testing.py\", line 303, in wait\n    self.io_loop.start()\n  File \"/home/hgen/test/47ad817a199de2e33333/env/lib/python3.4/site-packages/tornado/ioloop.py\", line 704, in start\n    raise RuntimeError(\"IOLoop is already running\")\nRuntimeError: IOLoop is already running\n\n----------------------------------------------------------------------\nRan 1 test in 0.075s\n\nFAILED (errors=1)\n1", "issue_status": "Closed", "issue_reporting_time": "2014-08-22T15:02:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "778": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1151", "issue_id": "#1151", "issue_summary": "Write handle list like dict and output a Json,", "issue_description": "Contributor\nwsantos commented on 21 Aug 2014\nIs okay to put that logic on 'write', if 'write' function receive dict o list dumps to JSON ?, I am using tornado as backed for angular, and i have to handle the list in a lot of places so i need to set the header import JSON dumps and send to 'write', or maybe, a good approach will be to write a new function to handle all JSON responses like a 'write_json'", "issue_status": "Closed", "issue_reporting_time": "2014-08-21T00:56:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "779": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1147", "issue_id": "#1147", "issue_summary": "Missing return statements in ioloop.call_later and ioloop.call_at", "issue_description": "battlecrystudios commented on 13 Aug 2014\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2014-08-12T22:31:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "780": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1146", "issue_id": "#1146", "issue_summary": "async_sleep function for coroutines", "issue_description": "Contributor\nvirtuald commented on 12 Aug 2014\nIt seems like it would be useful to have something like this in tornado, for the times when you want to asynchronously sleep.\ndef async_sleep(seconds):\n    future = concurrent.Future()\n    ioloop.IOLoop.current().call_later(seconds, lambda: future.set_result(None))\n    return future\nThis would then let you do something like so:\nyield async_sleep(0.5)\nIf there's already a one-liner that does that, I haven't found it yet.", "issue_status": "Closed", "issue_reporting_time": "2014-08-12T15:20:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "781": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1145", "issue_id": "#1145", "issue_summary": "torndb Error 2006: MySQL Server has gone away", "issue_description": "zairoo commented on 11 Aug 2014\nError 2006: MySQL Server has gone away. This error occurs frequently, how to solve?", "issue_status": "Closed", "issue_reporting_time": "2014-08-11T04:51:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "782": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1144", "issue_id": "#1144", "issue_summary": "websocket same-origin policy causing issues on localhost", "issue_description": "ahyatt commented on 10 Aug 2014\nThe Tornado's same-origin policy seems to cause issues with localhost, namely due to the numerous ways of specifying the localhost name. This is specifically an issue with the emacs websockets library.\nFor context, see pull request ahyatt/emacs-websocket#35.\nHow can a developer using the emacs websockets library know what hostname to use to connect to the Tornado server, \"localhost\" versus \"127.0.0.1\", versus a different system hostname? The origin is the same.\nI'd suggest relaxing the checks for localhost. If you are using some standard localhost naming convention that I may not be aware of, I'm happy to change my code to suit.", "issue_status": "Closed", "issue_reporting_time": "2014-08-09T22:59:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "783": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1143", "issue_id": "#1143", "issue_summary": "json_decode return a tornado.util.ObjectDict object", "issue_description": "cloverstd commented on 9 Aug 2014\nHi,\nCould json_decode return a tornado.util.ObjectDict object?\nIf it is a tornado.util.ObjectDict, It can be handled convenience.\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2014-08-09T09:44:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "784": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1140", "issue_id": "#1140", "issue_summary": "Tornado 4.0 raises AttributeError in WebSocketClientConnection._on_close", "issue_description": "truebiker commented on 6 Aug 2014\nwebsocket.py:676 has following implementation of WebSocketClientConnection._on_close:\ndef _on_close(self):\n    self.on_message(None)\n    self.resolver.close()\n    super(WebSocketClientConnection, self)._on_close()\nwhich fails when trying to call resolver.close() as it has no such attribute. The traceback:\ntornado.application: <ERROR> Exception in callback <functools.partial object at 0x7fde2ffbac00>\nTraceback (most recent call last):\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/ioloop.py\", line 565, in _run_callback\n    ret = callback()\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/stack_context.py\", line 275, in null_wrapper\n    return fn(*args, **kwargs)\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/iostream.py\", line 508, in wrapper\n    callback(*args)\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/stack_context.py\", line 343, in wrapped\n    raise_exc_info(exc)\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/stack_context.py\", line 314, in wrapped\n    ret = fn(*args, **kwargs)\nFile \"/<path_to_env>/lib/python2.7/site-packages/tornado/websocket.py\", line 678, in _on_close\n    self.resolver.close()\nAttributeError: 'WebSocketClientConnection' object has no attribute 'resolver'", "issue_status": "Closed", "issue_reporting_time": "2014-08-06T14:16:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "785": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1136", "issue_id": "#1136", "issue_summary": "socket.gaierrors for ipv6 tests on OSX 10.6", "issue_description": "Contributor\nmatthew-brett commented on 5 Aug 2014\nI'm getting three of these errors running on Pythons 2.7 through 3.4 on OSX 10.6:\nhttp://nipy.bic.berkeley.edu/builders/scipy-stack-3.3.5-wheel-requires/builds/97/steps/shell_5/logs/stdio\nThe errors are of form:\n======================================================================\nERROR: test_connect_ipv6_dual (tornado.test.tcpclient_test.TCPClientTest)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n    ...\n  File \"/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/socket.py\", line 530, in getaddrinfo\n    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nsocket.gaierror: [Errno 8] nodename nor servname provided, or not known\nI get the same errors using compiled tornado 4.0 release (via wheels) and not-compiled on current trunk (installing with no compiler). I don't get this error on a 10.7 machine (current trunk, with compiler). Could this be something specific to do with 10.6 and ipv6? Any suggestions for further tests I could try?", "issue_status": "Closed", "issue_reporting_time": "2014-08-05T07:58:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "786": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1134", "issue_id": "#1134", "issue_summary": "Exceptions getting swallowed in coroutines", "issue_description": "Contributor\nvirtuald commented on 30 Jul 2014\nI'm sure that I'm missing something here, but I don't understand why the exceptions in a coroutine are getting swallowed, and I keep getting bit by this.\nGist of sample program that demonstrates an exception being swallowed (see exception_gets_lost() ) : https://gist.github.com/virtuald/96882b5d3724c70fe3a1\nI feel like this is a bug -- but I also feel like I may be missing something. At the very least, it's very unexpected behavior, and I feel like the 'unhandled exception handler' in ioloop should be logging it, but it doesn't. What am I missing here?", "issue_status": "Closed", "issue_reporting_time": "2014-07-29T23:09:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "787": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1133", "issue_id": "#1133", "issue_summary": "stall tearDown in AsyncTestCase with prepare\u2019d WebSocketHandler", "issue_description": "zakkie commented on 29 Jul 2014\nAsyncTestCase.tearDown will never return when it has called coroutine in WebSocketHandler.prepare.\nfor example:\n# script: ws-test.py\nfrom tornado import web, testing, httpclient, gen, websocket\nfrom tornado.options import options\n\noptions.define(\"target_url\")\n\nclass DummyContentsHandler(web.RequestHandler):\n    def get(self, *args, **kwargs):\n        self.write(\"done\")\n\nclass PreparedWebSocketHandler(websocket.WebSocketHandler):\n    @gen.coroutine\n    def prepare(self):\n        client = httpclient.AsyncHTTPClient()\n        response = yield client.fetch(options.target_url)\n\n    @gen.coroutine\n    def on_message(self, message):\n        \"\"\"received any message, return response of target_url\n        \"\"\"\n        client = httpclient.AsyncHTTPClient()\n        response = yield client.fetch(options.target_url)\n        self.write_message(response.body)\n\nclass SampleTestCase(testing.AsyncHTTPTestCase):\n    def get_app(self):\n        options.target_url = \"http://localhost:%s/contents\" % self.get_http_port()\n        return web.Application([\n            (r\"/ws_proxy\", PreparedWebSocketHandler),\n            (r\"/contents\", DummyContentsHandler),\n        ])\n\n    @testing.gen_test\n    def test_ws(self):\n        url = \"ws://localhost:%d/ws_proxy\" % self.get_http_port()\n        ws = yield websocket.websocket_connect(url, io_loop=self.io_loop)\n        ws.write_message(\"hello\")\n        res = yield ws.read_message()\n        self.assertEqual(res, \"done\")\n        print(\"ok\")\n$ nosetests -xs ws-test.py\nok\n^C    <========== **Cancel manually**\n----------------------------------------------------------------------\nRan 1 test in 7.786s\n\nOK\n$ nosetests -V\nnosetests version 1.3.3\npython -V\nPython 3.4.1\n$ pip freeze | grep tornado\ntornado==4.0\nIt also reproduced with Python 2.7.8.\nNote: What actually I wanted to do is user authentication in WebSocketHandler with a database which has REST API. Proposed script is a simplified example.", "issue_status": "Closed", "issue_reporting_time": "2014-07-29T02:44:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "788": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1132", "issue_id": "#1132", "issue_summary": "Facebook demo has Invalid App ID", "issue_description": "thomasdohse commented on 29 Jul 2014\nRunning the Facebook Demo gives \"Invalid App ID: 9e2ada1b462142c4dfcc8e894ea1e37c\". Attempted from Chrome and Firefox by accessing http://localhost:8888/ as directed by the README.\nUpdate: It is just the facebook_api_key and facebook_secret values which are invalid. I created a new facebook app and put my keys in the demo code and it works correctly.", "issue_status": "Closed", "issue_reporting_time": "2014-07-28T23:36:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "789": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1131", "issue_id": "#1131", "issue_summary": "when coroutine in coroutine, why performance is so bad?", "issue_description": "mayflaver commented on 28 Jul 2014\n@gen.coroutine\ndef fetch_json(url):\n    response = yield AsyncHTTPClient().fetch(url)\n    result = do_with_response(response)\n    raise gen.Return(result)\n\n@gen.coroutine\ndef perform(url):\n    response = yield fetch_json(url)\n    result = do_with_response(response)\n    raise gen.Return(result)\nwhen call perform, like this\"yield perform(url)\u201c\uff0c why performance is so bad compare with \"yield AsyncHTTPClient().fetch(url)\u201d\uff1f\n1", "issue_status": "Closed", "issue_reporting_time": "2014-07-28T06:55:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "790": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1130", "issue_id": "#1130", "issue_summary": "Update blog example to use GoogleOAuth2Mixin instead of GoogleMixin", "issue_description": "Knio commented on 27 Jul 2014\nGoogleMixin docs read:\nDeprecated since version 4.0: New applications should use GoogleOAuth2Mixin below\ninstead of this class. As of May 19, 2014, Google has stopped supporting\nregistration-free authentication.\nIt would be nice if the blog example was updated to reflect the new usage.", "issue_status": "Closed", "issue_reporting_time": "2014-07-27T05:05:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "791": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1127", "issue_id": "#1127", "issue_summary": "WebSocket connection fail on V4.0", "issue_description": "fanchong commented on 24 Jul 2014\nwhen i tried to use websocket on V4.0, i got a warnning said 'tornado.access:403' and the connection failed.But when i changed to the v3.2.2, the issue was gone.", "issue_status": "Closed", "issue_reporting_time": "2014-07-24T08:16:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "792": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1126", "issue_id": "#1126", "issue_summary": "WebSocket disconnects and errors", "issue_description": "ghost commented on 23 Jul 2014\nFreeciv-web is a HTML5 strategy game, which implements WebSockets using Tornado 4.0. I have been logging Javascript errors in Freeciv-web using Track:js, and have discovered that many users are having WebSocket related error-messages. In particular, during the past 12 hours:\nThe 'onerror' WebSocket Javascript event listener is called 5 times, of which 3 are called on the inital connect, and 2 are called after about one hour.\nThe 'onclose' WebSocket Javascript event listener is called 38 times, where the error code in the error object is 1005. Most of these events are not errors, but are close events triggered by the user closing the browser window.\nThe 'onclose' WebSocket Javascript event listener is called 14 times, where the error code in the error object is 1006. These events seems to be errors.\nThe WebSocket server implementation is here: Freeciv-proxy running Tornado 4.0 on Python 3.4.0 on Ubuntu 14.04 Linux. Freeciv-proxy runs on multiple Python instances on various ports, while nginx proxies HTTP packets on port 80. nginx config\nThe client Javascript implementation is here: Freeciv-web.\nHow can I better understand these Javascript errors? Any help much appreciated!", "issue_status": "Closed", "issue_reporting_time": "2014-07-23T18:07:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "793": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1123", "issue_id": "#1123", "issue_summary": "redirect requests starting with '//' to '/' leading to wrong place", "issue_description": "Contributor\nlilydjwg commented on 21 Jul 2014\nTornado uses urljoin to join self.request.uri and the destination but when self.request.uri starts with '//' it generates locations still start with '//' because this behaviour of urljoin:\n>>> from urllib.parse import urljoin                                                                                                                   \n>>> urljoin('//abc', '/abc')\n'//abc/abc'\nI suggest using self.request.full_url() instead. Also, the HTTP specification says that the Location header should include the host part.\nPS: self.request.full_url() doesn't work for proxy requests that have full urls in their request line.", "issue_status": "Closed", "issue_reporting_time": "2014-07-21T06:11:08Z", "fixed_by": "#1373", "pull_request_summary": "Fixed double slash redirect issue", "pull_request_description": "Contributor\ndaftshady commented on 9 Mar 2015\nFixed #1123 by removing urljoin because joining request uri with redirect url is doing nothing for now.\nAlthough I agree with using urljoin with full_uri() as its base is more better way to go, this patch temporarily fixes the issue.", "pull_request_status": "Merged", "issue_fixed_time": "2015-03-10T02:25:50Z", "files_changed": [["6", "tornado/test/web_test.py"], ["3", "tornado/web.py"]]}, "794": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1121", "issue_id": "#1121", "issue_summary": "Provide a mechanism to determine if there is an IOLoop on the current thread", "issue_description": "Contributor\nvirtuald commented on 19 Jul 2014\nWhat I would like to be able to do is implement some function that is able to do some operation regardless of what thread it's on.\nif IOLoop.has_ioloop():\n    # do some async thing here\nelse:\n   IOLoop.instance().add_callback( async_thing_here )\nThe semantics of IOLoop.current() don't meet this, because it will always return something if an IOLoop has been initialized somewhere.", "issue_status": "Closed", "issue_reporting_time": "2014-07-19T16:07:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "795": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1119", "issue_id": "#1119", "issue_summary": "IOLoop.call_{at,later} don't return handles", "issue_description": "ericpeden commented on 18 Jul 2014\nThe lack of return values make it impossible to cancel timeouts created by these methods.", "issue_status": "Closed", "issue_reporting_time": "2014-07-17T21:47:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "796": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1118", "issue_id": "#1118", "issue_summary": "getattr in httputil.py", "issue_description": "johnbazan commented on 18 Jul 2014\nHi guys, i have just moved to Tornado 4.0 from 3.8 and i am experiencing an issue with the HTTPServerRequest class from httputil.py module.\nThe init method takes these arguments:\nself, method=None,\nuri=None,\nversion=\"HTTP/1.0\",\nheaders=None,\nbody=None,\nhost=None,\nfiles=None,\nconnection=None,\nstart_line=None\nSo, it should be able to create an HTTPServerRequest without taking any arguments\ni.e.: HTTPServerRequest()\nBut there's a getattr that has no default value, so if connection is None, then context is None too, and we can't get a remote_ip from it.\n    context = getattr(connection, 'context', None)\n    self.remote_ip = getattr(context, 'remote_ip')\n    self.protocol = getattr(context, 'protocol', \"http\")\nThe traceback is something like this:\nbase_handler = base.BaseHandler(app, HTTPServerRequest())\nFile \"PATH/tornado/httputil.py\", line 338, in init\nself.remote_ip = getattr(context, 'remote_ip')\nAttributeError: 'NoneType' object has no attribute 'remote_ip'\nThis breaks the retro-compatibility with 3.8\nIf i am wrong, please let me know, hope this report can be useful.\nKind Regards,\nJonathan", "issue_status": "Closed", "issue_reporting_time": "2014-07-17T20:55:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "797": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1117", "issue_id": "#1117", "issue_summary": "Coroutines hangs on exceptions when using ThreadPoolExecutor.", "issue_description": "misuzu commented on 17 Jul 2014\nfrom concurrent.futures import ThreadPoolExecutor\nfrom tornado.gen import Return, coroutine\nfrom tornado.ioloop import IOLoop\n\npool = ThreadPoolExecutor(max_workers=1)\n\n\n@coroutine\ndef compute1():\n    def make_exception():\n        return 1 / 2\n    print('compute 1 start')\n    result = yield pool.submit(make_exception)\n    print('compute 1 end')\n    raise Return(result)\n\n\n@coroutine\ndef compute2():\n    def make_exception():\n        return 1 / 0\n    print('compute 2 start')\n    result = yield pool.submit(make_exception)\n    print('compute 2 end')\n    raise Return(result)\n\n\n@coroutine\ndef run():\n    result = yield compute1()\n    print(result)\n    result = yield compute2()\n    print(result)\n    raise Return(result)\n\n\nrun()\nIOLoop.instance().start()\n$ python ~/test_tornado.py \ncompute 1 start\ncompute 1 end\n0\ncompute 2 start\n^CTraceback (most recent call last):\n  File \"/home/misuzu/test_tornado.py\", line 38, in <module>\n    IOLoop.instance().start()\n  File \"/home/misuzu/Documents/Virtualenvs/generic/local/lib/python2.7/site-packages/tornado/ioloop.py\", line 808, in start\n    event_pairs = self._impl.poll(poll_timeout)\nKeyboardInterrupt\n$ pip freeze | grep tornado\ntornado==4.0", "issue_status": "Closed", "issue_reporting_time": "2014-07-17T14:25:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "798": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1115", "issue_id": "#1115", "issue_summary": "v4 cannot be easily installed on Windows", "issue_description": "Kwpolska commented on 16 Jul 2014\nHello,\nNikola is using livereload, which depends on Tornado without a version specifier, so pip is now trying to install version 4.0.0.\nBut, for some reason, version 4.0.0 cannot be installed on Windows without VC++ and its compiler. Why is that? Could you please:\n(a) fix this and allow usage without speedups; or\n(b) build a wheel package and publish it on PyPI?", "issue_status": "Closed", "issue_reporting_time": "2014-07-16T08:12:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "799": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1114", "issue_id": "#1114", "issue_summary": "tornado.httpserver.HTTPConnection is gone", "issue_description": "g-p-g commented on 16 Jul 2014\nThe new release removed tornado.httpserver.HTTPConnection, which breaks gunicorn when using the tornado worker. Was there a good reason for doing that?", "issue_status": "Closed", "issue_reporting_time": "2014-07-15T23:04:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "800": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1112", "issue_id": "#1112", "issue_summary": "doc error", "issue_description": "mayflaver commented on 15 Jul 2014\nhttp://www.tornadoweb.org/en/stable/guide/structure.html\nclass MainHandler(tornado.web.RequestHandler):\n    @tornado.gen.coroutine\n    def get(self):\n        http = tornado.httpclient.AsyncHTTPClient()\n        yield http.fetch(\"http://friendfeed-api.com/v2/feed/bret\")\n        json = tornado.escape.json_decode(response.body)\n        self.write(\"Fetched \" + str(len(json[\"entries\"])) + \" entries \"\n                   \"from the FriendFeed API\")", "issue_status": "Closed", "issue_reporting_time": "2014-07-15T17:06:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "801": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1111", "issue_id": "#1111", "issue_summary": "Pycurl violates RFC 2616/10.3.2 and switch from POST to GET", "issue_description": "remh commented on 15 Jul 2014\nHi there,\nOne of our user is using a proxy that sends a 301 for a redirection.\nUnfortunately by default curl will change a POST method to a GET when following such a redirection.\nIt is possible to change that behavior by setting CURLOPT_POSTREDIR to 3.\nhttp://stackoverflow.com/questions/8156073/curl-violate-rfc-2616-10-3-2-and-switch-from-post-to-get\nWould it be possible to let the possibility to override that parameter ?\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2014-07-15T15:58:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "802": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1110", "issue_id": "#1110", "issue_summary": "Don't use BytesIO to make interface of read-only data file-like", "issue_description": "Contributor\nkmike commented on 15 Jul 2014\nHi,\nWhen doing #1109 and checking scrapy/scrapy#803 I've run a couple of benchmarks:\nhttp://nbviewer.ipython.org/gist/kmike/b23a3b12fac6654b1c90 (Python 3.4)\nhttp://nbviewer.ipython.org/gist/kmike/4e79964c1d589faef174 (Python 2.7)\nThe problem is that BytesIO copies the data, so using it just to make interface file-like for readonly data could be quite wasteful.\nI believe this is a problem in curl_httpclient, simple_httpclient and wsgi tornado modules, and by using another wrapper (or at least by falling back to cStringIO in Python 2.x) they can be made faster and more memory efficient.", "issue_status": "Closed", "issue_reporting_time": "2014-07-15T12:39:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "803": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1104", "issue_id": "#1104", "issue_summary": "NPE in iostream.py", "issue_description": "jooadam commented on 11 Jul 2014\nI got this under Tornado 3.2.2:\nException in thread Thread-1:\nTraceback (most recent call last):\n  ...\n  File \".../server.py\", line 28, in respond\n    request.finish()\n  File \".../tornado/web.py\", line 888, in finish\n    self.flush(include_footers=True)\n  File \".../tornado/web.py\", line 851, in flush\n    self.request.write(headers + chunk, callback=callback)\n  File \".../tornado/httpserver.py\", line 501, in write\n    self.connection.write(chunk, callback=callback)\n  File \".../tornado/httpserver.py\", line 234, in write\n    self.stream.write(chunk, self._on_write_complete)\n  File \".../tornado/iostream.py\", line 229, in write\n    self._handle_write()\n  File \".../tornado/iostream.py\", line 564, in _handle_write\n    _merge_prefix(self._write_buffer, num_bytes)\n  File \".../tornado/iostream.py\", line 1023, in _merge_prefix\n    if len(deque) == 1 and len(deque[0]) <= size:\nTypeError: object of type 'NoneType' has no len()\nTornado is running behind Nginx, handlers are marked as asynchronous and queued for later response.", "issue_status": "Closed", "issue_reporting_time": "2014-07-11T12:39:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "804": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1103", "issue_id": "#1103", "issue_summary": "KeyError in ioloop.py", "issue_description": "jooadam commented on 11 Jul 2014\nTornado 3.2.2 raises quite a lot of these:\nERROR:tornado.application:Exception in callback None\nTraceback (most recent call last):\n  File \".../tornado/ioloop.py\", line 688, in start\n    self._handlers[fd](fd, events)\nKeyError: 8\nTornado is running behind Nginx, handlers are marked as asynchronous and queued for later response.", "issue_status": "Closed", "issue_reporting_time": "2014-07-11T12:31:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "805": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1100", "issue_id": "#1100", "issue_summary": "How to add iframe code?", "issue_description": "aligoren commented on 10 Jul 2014\nHi\nI trying to add my pages google maps. But not working\nOutput:\n\nHow to run iframe code on Tornado?\nview.html page content\n{{ googlemaps }}\nThis code run but iframe can't work.\nGooglemaps data in my database. Not static pages.\nExample:\nlocalhost/la => Los Angeles Map\nlocalhost/ca => California Map etc..\nThank you and sorry for my bad english", "issue_status": "Closed", "issue_reporting_time": "2014-07-10T05:26:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "806": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1096", "issue_id": "#1096", "issue_summary": "Invalid XSRF cookie value throws TypeError", "issue_description": "Contributor\ntiwilliam commented on 7 Jul 2014\nWhen running Tornado 3.2.2 and getting bogus data sent in XSRF cookies, we end up with following exception. _xsrf is set to foo in following trace.\nStacktrace (most recent call last):\n  File \"tornado/web.py\", line 1338, in _execute\n    self.check_xsrf_cookie()\n  File \"tornado/web.py\", line 1184, in check_xsrf_cookie\n    if not _time_independent_equals(utf8(token), utf8(expected_token)):\n  File \"tornado/web.py\", line 2759, in _time_independent_equals\n    if len(a) != len(b):\nTypeError: object of type 'NoneType' has no len()", "issue_status": "Closed", "issue_reporting_time": "2014-07-07T11:09:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "807": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1087", "issue_id": "#1087", "issue_summary": "RequestHandler.send_error strips custom HTTP headers", "issue_description": "Contributor\nCaligatio commented on 26 Jun 2014\nIt appears that RequestHandler.send_error calls self.clear() explicitly which removes all previously added HTTP headers. This causes issues when someone wants to issue a 503 with the optional \"Retry-After\" header as it simply strips out the header.\nI'm not aware of any particular need for clear() to be called so would it be possible to just remove this call?", "issue_status": "Closed", "issue_reporting_time": "2014-06-25T20:35:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "808": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1083", "issue_id": "#1083", "issue_summary": "Rendering template with compress_whitespace does not remove empty lines", "issue_description": "m13253 commented on 21 Jun 2014\nIt is common that template file consist of empty lines, for example the websocket demo in Tornado package:\n<div id=\"inbox\">\n    {% for message in messages %}\n        {% include \"message.html\" %}\n    {% end %}\n</div>\nTornado currently produces this:\n<div id=\"inbox\">\n\n<div class=\"message\" id=\"m8769fcc8-57ee-4f4e-814d-bcfbae0c8598\">message1</div>\n\n\n<div class=\"message\" id=\"me329adf7-9811-46b4-a332-d4a3e4261b4a\">message2</div>\n\n\n</div>\nAs you see, there are 5 empty lines.\nI suggest that empty lines should be compressed along with spaces when compress_whitespace is set.", "issue_status": "Closed", "issue_reporting_time": "2014-06-21T04:07:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "809": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1082", "issue_id": "#1082", "issue_summary": "Empty reply on malformed HTTP request", "issue_description": "denis-sumin commented on 20 Jun 2014\nWhen an incorrect HTTP request is performed, tornado makes no reply (log + return in code). I suggest returning an 400 error code.\nFor example, when working behind an nginx proxy-server, it causes a 502 error code to the end-user and a record in nginx's error log, which is incorrect (should be 400 and a warning).", "issue_status": "Closed", "issue_reporting_time": "2014-06-20T11:21:24Z", "fixed_by": "#2058", "pull_request_summary": "Return HTTP 400 on bad request lines", "pull_request_description": "Contributor\njehiah commented on 26 May 2017\nThis closes #1082 by returning a HTTP 400 (and then closing the connection) when the server encounters a bad request line instead of closing the connection immediatley.", "pull_request_status": "Merged", "issue_fixed_time": "2017-06-10T21:18:43Z", "files_changed": [["2", "tornado/http1connection.py"], ["2", "tornado/httputil.py", "100644", "\u2192", "100755"], ["37", "tornado/test/httpserver_test.py"]]}, "810": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1081", "issue_id": "#1081", "issue_summary": "Truely coroutine based Chat Demo", "issue_description": "v3ss0n commented on 19 Jun 2014\nHello Tornado.\nI am new to coroutine based programming and i hate callbacks since javascript.\ncan we have a coroutine based chat demo? that way its easier to learn coroutine.\nI tried changing it to coroutine but failing at it , FYI my SO question on it :\nhttp://stackoverflow.com/questions/24312619/tornado-chatdemo-to-work-with-coroutines", "issue_status": "Closed", "issue_reporting_time": "2014-06-19T17:37:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "811": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1080", "issue_id": "#1080", "issue_summary": "Issue Labels", "issue_description": "ilam commented on 17 Jun 2014\nI think having Issue Labels in the repository categorized would be great for this project, since all Issues related to one category may help in focusing at it.\nAnd since Issue Labels can be created and assigned by Contributors only, there will be no issue of messing up the Label space :)", "issue_status": "Closed", "issue_reporting_time": "2014-06-17T00:56:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "812": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1079", "issue_id": "#1079", "issue_summary": "Potential memory leak in ioloop and httpclient module.", "issue_description": "dongying commented on 16 Jun 2014\nDown below codes show a potential memory leak example.\nTested in:\nOSX 10.9.3 Python 2.7.5 tornado 3.1\nOSX 10.9.3 Python 2.7.5 tornado 3.2.2\nRHEL 5 Python 2.7.5 tornado 3.1\nFirst copy the codes into a file named torleak.py and run it.\npython torleak.py\nRequest using tornado.httpclient.AsyncHTTPClient and tornado.gen.coroutine .\nab -n 100 http://127.0.0.1:8008/request/async\nThis will not cause memory leak.\nBut if you request using the buildin tornado.httpclient.HTTPClient or create a IOLoop to run_sync, even though you call io_loop.close() after fetch(), memory leak happens .\nab -n 100 http://127.0.0.1:8008/request/\nShow the garbage of unreleased tornado objects.\ncurl http://127.0.0.1:8008/garbage | grep tornado\nAnd you will see something like this:\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100  3466  100  3466    0     0   110k      0 --:--:-- --:--:-- --:--:--  112k\n    101: <class 'tornado.platform.kqueue.KQueueIOLoop'>\n    101: <class 'tornado.platform.kqueue._KQueue'>\n    101: <class 'tornado.netutil.BlockingResolver'>\n    101: <class 'tornado.simple_httpclient.SimpleAsyncHTTPClient'>\n    101: <class 'tornado.platform.posix.Waker'>\n    8: <class 'tornado.options._Option'>\n    2: <class 'tornado.web.URLSpec'>\n    2: <class 'tornado.httputil.HTTPHeaders'>\n    1: <class 'tornado.ioloop._Timeout'>\n    1: <class 'tornado.httpserver.HTTPRequest'>\n    1: <class 'tornado.httpserver.HTTPConnection'>\n    1: <class 'tornado.httpserver.HTTPServer'>\n    1: <class 'tornado.iostream.IOStream'>\n    1: <class 'tornado.web._UIModuleNamespace'>\n    1: <class 'tornado.web.ChunkedTransferEncoding'>\n    1: <class 'tornado.web.Application'>\n    1: <class 'tornado.options.OptionParser'>\n    1: <class 'tornado.httputil._NormalizedHeaderCache'>\n    1: <class 'tornado.gen._NullYieldPoint'>\n    1: <class 'tornado.ioloop.PeriodicCallback'>\n    1: <class 'tornado.log.LogFormatter'>\n    1: <class 'tornado.concurrent.DummyExecutor'>\n    1: <class 'tornado.stack_context._State'>\n    1: <class 'tornado.util.ObjectDict'>\nWhich shows a lot of unreleased SimpleAsyncHTTPClient and IOLoop objects in memory.\nExample codes:\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\nimport functools\nimport gc\nimport inspect\nimport random\n\nimport tornado.gen\nimport tornado.httpclient\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\n\n\ndef _incremental_updating_stats(stats, obj, depth=0, no_referrers=False, no_referents=False, sample_rate=None, class_name=None, inspector=None):\n    if inspector and not inspector(obj):\n        return None\n\n    obj_stats = stats.setdefault(\n        type(obj),\n        {'count': 0})\n    obj_stats['count'] += 1\n\n    if depth > 0:\n\n        if class_name:\n            if not hasattr(obj, '__class__') or not (obj.__class__.__name__ == class_name or obj.__class__.__name__.endswith(\".\" + class_name)):\n                return obj_stats\n\n        if sample_rate and random.random() < 1 - sample_rate:\n            return obj_stats\n\n        if not no_referrers:\n            for r_obj in gc.get_referrers(obj):\n                _incremental_updating_stats(obj_stats.setdefault('referrers_stats', {}), r_obj, depth - 1, no_referrers, no_referents, sample_rate, inspector=inspector)\n\n        if not no_referents:\n            for r_obj in gc.get_referents(obj):\n                _incremental_updating_stats(obj_stats.setdefault('referents_stats', {}), r_obj, depth - 1, no_referrers, no_referents, sample_rate, inspector=inspector)\n\n    return obj_stats\n\n\ndef _format_stats(stats, limit=None, depth=0):\n    stats_sorted = [(value['count'], key, value) for key, value in stats.iteritems()]\n    stats_sorted.sort(reverse=True)\n    if limit:\n        stats_sorted = stats_sorted[:limit]\n\n    strings = []\n    for count, key, value in stats_sorted:\n        strings.append(\"%s%r: %r\" % (\" \" * 4 * (depth + 1), count, key))\n\n        if value.get('referrers_stats'):\n            strings.append(\" \" * 4 * (depth + 2) + \"referrers:\")\n            strings.append(_format_stats(value['referrers_stats'], limit, depth + 1))\n\n        if value.get('referents_stats'):\n            strings.append(\" \" * 4 * (depth + 2) + \"referents:\")\n            strings.append(_format_stats(value['referents_stats'], limit, depth + 1))\n\n    return \"\\n\".join(strings)\n\n\nclass GarbageHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        depth = int(self.get_argument('depth', 0))\n        class_name = self.get_argument(\"class\", \"\").strip()\n        no_referrers = self.get_argument(\"no_referrers\", None)\n        no_referents = self.get_argument(\"no_referents\", None)\n        sample_rate = float(self.get_argument(\"sample_rate\", 1))\n        limit = int(self.get_argument(\"limit\", 0)) or None\n        inspector = getattr(inspect, self.get_argument('inspector', \"\"), None)\n\n        info = [\"depth: %r, class_name: %r, no_referrers: %r, no_referents: %r, sample_rate: %r, limit: %r, inspector: %r\" % (depth, class_name, no_referrers, no_referents, sample_rate, limit, inspector)]\n        info.append(\"gc.isenabled(): %r\" % (gc.isenabled(),))\n        info.append(\"gc.get_debug(): %r\" % (gc.get_debug(),))\n        info.append(\"gc.get_threshold(): %r\" % (gc.get_threshold(),))\n        info.append(\"gc.get_count(): %r\" % (gc.get_count(),))\n\n        stats = {}\n        for obj in gc.get_objects():\n            _incremental_updating_stats(\n                stats,\n                obj,\n                depth,\n                no_referrers,\n                no_referents,\n                sample_rate=sample_rate,\n                class_name=class_name,\n                inspector=inspector)\n\n        info.append(\"gc.get_objects():\\n%s\" % _format_stats(stats, limit))\n        info.append(\"gc.garbage: %r\" % (gc.garbage,))\n        gc.collect()\n\n        self.set_header(\"Content-Type\", \"text/plain\")\n        self.write(\"\\n\\n\".join(info))\n        self.finish()\n\n\ndef synchronous(func):\n    @functools.wraps(func)\n    def _(*args, **kw):\n        io_loop = tornado.ioloop.IOLoop()\n        response = io_loop.run_sync(functools.partial(func, io_loop=io_loop, *args, **kw))\n        io_loop.close()\n        return response\n    return _\n\n\ndef fake_request():\n    request = tornado.httpclient.HTTPRequest(\n        url=\"http://quan.sohu.com/api/test\",\n        request_timeout=1)\n    http_client = tornado.httpclient.HTTPClient()\n    response = http_client.fetch(request)\n    return response.body\n\n\n@tornado.gen.coroutine\ndef fake_request_async(io_loop=None):\n    request = tornado.httpclient.HTTPRequest(\n        url=\"http://quan.sohu.com/api/test\",\n        request_timeout=1)\n    http_client = tornado.httpclient.AsyncHTTPClient(io_loop)\n    response = yield http_client.fetch(request)\n    if io_loop:\n        http_client.close()\n    raise tornado.gen.Return(response.body)\n\nfake_request_sync = synchronous(fake_request_async)\n\n\nclass FakeRequestHandler(tornado.web.RequestHandler):\n\n    @tornado.gen.coroutine\n    def get(self, rtype):\n        if rtype == \"async\":\n            response = yield fake_request_async()\n        elif rtype == \"sync\":\n            response = fake_request_sync()\n        else:\n            response = fake_request()\n        self.write(response)\n\n\ndef main():\n    tornado.options.define(\"port\", default=8008, help=\"run on the given port\", type=int)\n    tornado.options.define('debug', type=bool, default=True, help='run in debug mode with autoreload')\n    tornado.httpclient.AsyncHTTPClient.configure(\"tornado.simple_httpclient.SimpleAsyncHTTPClient\", max_clients=3)\n    #tornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n    tornado.options.parse_command_line()\n\n    application = tornado.web.Application(\n        [(r\"/request/(async|sync|)\", FakeRequestHandler),\n         (r\"/garbage\", GarbageHandler)],\n        debug=tornado.options.options.debug)\n    application.listen(tornado.options.options.port, \"0.0.0.0\", xheaders=True)\n\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == \"__main__\":\n    main()", "issue_status": "Closed", "issue_reporting_time": "2014-06-16T12:41:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "813": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1077", "issue_id": "#1077", "issue_summary": "StaticFileHandler path for .apk and. ipa file extension download problems\uff1f", "issue_description": "zairoo commented on 12 Jun 2014\nStaticFileHandler path for .apk and. ipa file extension download problems\uff1f\nDirect output character, how can become download", "issue_status": "Closed", "issue_reporting_time": "2014-06-12T14:37:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "814": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1074", "issue_id": "#1074", "issue_summary": "pip install fails for OSX machine with no compiler", "issue_description": "Contributor\nmatthew-brett commented on 7 Jun 2014\nOn an OSX 10.6 machine with no compiler installed:\n$ python setup.py build                                                                              \nrunning build\nrunning build_py\nrunning build_ext\nTraceback (most recent call last):\n  File \"setup.py\", line 183, in <module>\n    **kwargs\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/core.py\", line 152, in setup\n    dist.run_commands()\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py\", line 953, in run_commands\n    self.run_command(cmd)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py\", line 972, in run_command\n    cmd_obj.run()\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build.py\", line 127, in run\n    self.run_command(cmd_name)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/cmd.py\", line 326, in run_command\n    self.distribution.run_command(command)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py\", line 972, in run_command\n    cmd_obj.run()\n  File \"setup.py\", line 85, in run\n    build_ext.run(self)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/command/build_ext.py\", line 307, in run\n    customize_compiler(self.compiler)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/sysconfig.py\", line 170, in customize_compiler\n    _osx_support.customize_compiler(_config_vars)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_osx_support.py\", line 418, in customize_compiler\n    _find_appropriate_compiler(_config_vars)\n  File \"/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/_osx_support.py\", line 191, in _find_appropriate_compiler\n    \"Cannot locate working compiler\")\nSystemError: Cannot locate working compiler\nThis seems to be because the customize_compiler step is now failing, rather than the build_extension step, and the check / fallback routine overrides build_ext.build_extension. Thus the build_ext.run command fails before it gets to the check / fallback routine.", "issue_status": "Closed", "issue_reporting_time": "2014-06-06T22:04:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "815": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1073", "issue_id": "#1073", "issue_summary": "max_age parameter not used when computing far-future cookie in decode_signed_value", "issue_description": "verdammelt commented on 6 Jun 2014\nIn response to #189 the commit 84c5ddb was made. But it didn't completely solve the issue.\nPreviously both past and future cookies were compared against the magic number 31 (days). In the above commit the max_age parameter was added and used only for the past cookie check.\nIt should also be used when checking future cookie expiration. Or another parameter is needed.", "issue_status": "Closed", "issue_reporting_time": "2014-06-06T18:00:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "816": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1072", "issue_id": "#1072", "issue_summary": "Help In php $ _SERVER ['HTTP_HOST'], tornado how to get?", "issue_description": "zairoo commented on 6 Jun 2014\nHelp In php $ _SERVER ['HTTP_HOST'], Tornado how to get?\nTKS", "issue_status": "Closed", "issue_reporting_time": "2014-06-06T13:43:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "817": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1070", "issue_id": "#1070", "issue_summary": "Websocket connection closes exactly after one minute", "issue_description": "vaidik commented on 5 Jun 2014\nI have a websocket server implementation using Tornado. It seems to work fine for my use-case. The only problem that I have recently started seeing is that after the last message that I get from my client, exactly after one minute of that, the websocket connection closes and the on_close handler that I have implemented gets fired.\nOn the client (browser), I get 1006 i.e. abnormal termination.\nI thought that its either a bug in my server code or the client code as the connection seemed to be breaking after exactly one minute which is too accurate to be abnormal. So I thought I might have added a timeout.\nI am not sure what might be happening. Being new to Tornado also doesn't help much with ways to debug the probable issue.", "issue_status": "Closed", "issue_reporting_time": "2014-06-05T10:11:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "818": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1067", "issue_id": "#1067", "issue_summary": "Google OAuth Changes", "issue_description": "Contributor\npatrickfuller commented on 28 May 2014\nFirst off, thanks for all of your work on tornado! I've been using it as the core of a raspberry pi webcam server, and I use tornado.auth.GoogleMixin + a white list to handle authentication.\nAs of May 19, Google closed registration to new OpenID 2.0 clients. (link and semi-relevant stackoverflow). I believe this affects new programs that use tornado.auth.GoogleMixin, as well as all of the OAuth examples that use it. At the very least, the documentation needs an update. This:\nNo application registration is necessary to use Google for authentication or to access Google resources on behalf of a user.\nis no longer true for new clients.", "issue_status": "Closed", "issue_reporting_time": "2014-05-27T23:23:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "819": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1065", "issue_id": "#1065", "issue_summary": "Relax restrictions on WebSocketHandler methods", "issue_description": "Member\nbdarnell commented on 25 May 2014\nMany methods of WebSocketHandler are disallowed; now that applications can cleanly intercept the pre-websocket phase of the request in prepare(), we should allow these methods at that time (and then they would become disallowed once the websocket handshake has begun). This would allow applications to return HTTP error responses (e.g. for authentication failures).", "issue_status": "Closed", "issue_reporting_time": "2014-05-25T00:58:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "820": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1064", "issue_id": "#1064", "issue_summary": "\"Stop\" exception in RequestHandler", "issue_description": "Member\nbdarnell commented on 25 May 2014\nIn the mailing list thread \"Stopping the request on get_current_user()\", it was suggested that there should be an exception that would simply finish the response with its current output (instead of clearing the output and generating an error page). (in retrospect finish() could have raised this error instead of returning0.", "issue_status": "Closed", "issue_reporting_time": "2014-05-25T00:52:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "821": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1063", "issue_id": "#1063", "issue_summary": "Stack-context-local variable pattern", "issue_description": "Member\nbdarnell commented on 25 May 2014\nStack contexts can be used to provide thread-local-like variables, but this is not obvious. We should provide a standard implementation of this pattern or at least document how to build your own.\nNotable implementations:\nhttps://gist.github.com/simon-weber/7755289 (discussed on the mailing list)\nhttps://github.com/viewfinderco/viewfinder/blob/master/backend/base/context_local.py", "issue_status": "Closed", "issue_reporting_time": "2014-05-25T00:40:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "822": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1062", "issue_id": "#1062", "issue_summary": "PyPi Index Broken HTTP 404", "issue_description": "AaronKulick commented on 19 May 2014\nSince the recent reorganization of the release binaries/tarballs for tornado have been published, the tornado 2.2 tree (as are releases that are not the most recent for a particular version) is broken due to 404. The download URLs need to be updated in the simple index file to reflect the new path https://github.com/tornadoweb/tornado/archive'.\nFor example, for the 2.2 release:\nhttp://github.com/downloads/facebook/tornado/tornado-2.2.tar.gz\nThis should instead point to:\nhttps://github.com/tornadoweb/tornado/archive/v2.2.0.tar.gz\nAll of the following links in the https://pypi.python.org/simple/tornado/ need to be updated:\n1.1 download_url\n1.2.1 download_url\n1.2 download_url\n2.0 download_url\n2.1.1 download_url\n2.1 download_url\n2.2.1 download_url\n2.2 download_url\n2.3 download_url\n2.4.1 download_url\n2.4 download_url", "issue_status": "Closed", "issue_reporting_time": "2014-05-19T14:52:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "823": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1059", "issue_id": "#1059", "issue_summary": "Google App Engine demo can't import fcntl when deployed to GAE", "issue_description": "marklit commented on 15 May 2014\nI've spun up a Google App Engine instance using the demo in demos/appengine and I'm getting the following exception when I load the web endpoint:\nTraceback (most recent call last):\n  ...\n    import fcntl\nImportError: No module named fcntl\nHas anyone gotten that demo to run on GAE? The ImportError: No module named fcntl exception leads me to believe that tornado/platform/auto module should be selecting another platform for GAE but I'm not sure which. Also, I believe the usage of fcntl related to asynchronous operations which I'm not sure are supported on GAE.\nAny guidance on this would be appreciated.", "issue_status": "Closed", "issue_reporting_time": "2014-05-15T10:33:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "824": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1058", "issue_id": "#1058", "issue_summary": "Changes in master branch gen module break code previously working", "issue_description": "FZambia commented on 15 May 2014\nHello, @bdarnell and others! Sorry for such an abstract issue subject. But at moment I can not describe a problem better.\nI am developing project Centrifuge ( https://github.com/FZambia/centrifuge ) on top of Tornado. Today I tried to update Tornado to master branch and test that everything works fine. Unfortunately it doesn't.\nIn Centrifuge I use redis wrapper by @mrjoes - https://github.com/mrjoes/toredis . This is a very simple wrapper - client has a list of callbacks which fire with data as soon as data comes from Redis (hiredis parser split data coming from redis into separate messages).\nI have a benchmark where many clients connect to Centrifuge and send messages. And when many cients connected and message rate is high in tornado 3.3 some Tasks yield results from other different Tasks from another coroutine. To describe it simple let's write some abstract code:\n@coroutine\ndef func_first():\n    value = yield Task(redis.get, \"key\", \"value\")\n\n@coroutine\ndef func_second():\n    # this value seem to be a result yielded by Task from coroutine above \n    value = yield Task(redis.expire, \"key\", \"value\")\nAt moment I don't find a way how to reproduce this in a simple way - just started researching. Also I am not so sure that this problem must be fixed in Tornado and not in toredis or in my application code.\nSo, things work well in tornado 3.1.1, 3.2.0, 3.2.1 - I then started to search for a commit where a problem starts and found this one - 184d796 .\nHere is a change in Tornado gen.py after which my problem appears:\nif isinstance(yielded, YieldPoint):\n    self.future = TracebackFuture()\n\n    def start_yield_point():\n        try:\n            yielded.start(self)\n            if yielded.is_ready():\n                self.future.set_result(\n                    yielded.get_result())\n            else:\n                self.yield_point = yielded\n        except Exception:\n            self.exc_info = sys.exc_info()\n\n    if self.stack_context_deactivate is None:\n        # Start a stack context if this is the first\n        # YieldPoint we've seen.\n        with stack_context.ExceptionStackContext(\n                self.handle_exception) as deactivate:\n            self.stack_context_deactivate = deactivate\n            def cb():\n                start_yield_point()\n                self.run()\n            self.io_loop.add_callback(cb)\n            return\n    else:\n        start_yield_point()\ninstead of just:\nif isinstance(yielded, YieldPoint):\n    self.future = TracebackFuture()\n    try:\n        yielded.start(self)\n        if yielded.is_ready():\n            self.future.set_result(\n                yielded.get_result())\n        else:\n            self.yield_point = yielded\n    except Exception:\n        self.exc_info = sys.exc_info()\nI do not understand clearly what's going on in this place. Could these changes introduce a problem described above?", "issue_status": "Closed", "issue_reporting_time": "2014-05-14T19:15:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "825": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1057", "issue_id": "#1057", "issue_summary": "Duplicate payload in some websocket packets", "issue_description": "jbaiter commented on 13 May 2014\nI ran into a weird issue in my application where sometimes events (which are triggered via a websocket message) were fired twice.\nThe logs indicated that while my Tornado-backend was only issuing one write_message call, the (JavaScript)-Client was receiving two messages.\nI inspected the traffic with Wireshark and found that in those cases, a single WebSocket packet was containing two payloads, as can be seen in this screenshot:\nhttp://i.imgur.com/R1QAuv7.png\nThis packet contained both the payload from the preceding and the following packet, hence the duplicate events.\nYou can find the traffic dump under this link, the relevant packet is no. 170:\nhttp://jbaiter.de/jbaiter.de/websocket_weirdness.pcap\nHere is the code that sends the messages:\ndef send_event(self, event):\n    data = json.dumps(event, cls=CustomJSONEncoder)\n    # SocketHandler is a custom 'WebSocketHandler' that tracks open connections\n    for sock in SocketHandler.clients:\n        sock.write_message(data)", "issue_status": "Closed", "issue_reporting_time": "2014-05-13T16:03:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "826": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1056", "issue_id": "#1056", "issue_summary": "The latest chatdemo.py doesn't work", "issue_description": "ke4roh commented on 13 May 2014\nThe demos/chatdemo/chatdemo.py from commit 5c7d6d3 works.\nAfter that, it doesn't work on my environment (fedora 20, python 2.7.5 or 3.3.2) but gives this message:\nTraceback (most recent call last):\n  File \"chatdemo.py\", line 119, in <module>\n    class AuthLoginHandler(BaseHandler, tornado.auth.GoogleMixin):\n  File \"chatdemo.py\", line 120, in AuthLoginHandler\n    @gen.coroutine\nAttributeError: 'module' object has no attribute 'coroutine'\n(Line numbers are from master branch (c9af9a7 is the latest touch to chatdemo.py). On 974c229, what shows as line 120 in the stack above is 121.)", "issue_status": "Closed", "issue_reporting_time": "2014-05-12T18:30:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "827": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1052", "issue_id": "#1052", "issue_summary": "Windows doesn't use standard error numbers: suggested quick fix", "issue_description": "Contributor\nukoethe commented on 12 May 2014\nWindows (in my case: Windows 7, 64-bit and Visual Studio 2012) does not use the standard socket error numbers (e.g. errno.EWOULDBLOCK). Instead, there are corresponding error numbers prefixed with WSA (e.g. errno.WSAEWOULDBLOCK). Since tornado only checks for the standard ones, its test suite (runtests.sh) fails on Windows.\nI was able to get the test suite running with the following quick fix: I first added a file tornado/portable_errno.py containing\nimport errno\nfrom errno import *\n\nfor _k in dir(errno):\n    if _k.startswith('WSA'):\n        _e = _k[3:]\n        if hasattr(errno, _e):\n            # override standard error code with corresponding Windows code\n            exec(_e + ' = ' + _k)\nand then changed every occurence of import errno in the other source files with\nimport tornado.portable_errno as errno\nHowever, it is probably cleaner to check for both types of errors instead of just overriding.", "issue_status": "Closed", "issue_reporting_time": "2014-05-11T19:03:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "828": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1049", "issue_id": "#1049", "issue_summary": "Improve API for timeouts", "issue_description": "Contributor\nschlamar commented on 9 May 2014\nAlternative API to add delayed callback\nIMO the decision back in #329 was bad. A method should not serve multiple purposes based on the type of an argument. Plus, it is really inconvenient to write loop.add_timeout(datetime.timedelta(seconds=x), callback).\nMy proposal is to introduce a method equivalent to PEP-3156's call_later. Maybe something like add_delayed_callback(seconds, callback) (preferably shorter, but I didn't come up with a better name matching Tornado's API style). Additionally, passing timedelta objects to add_timeout should be marked as deprecated.\nSupport for _args and *_kwargs\nIt is strange that add_callback supports passing _args and *_kwargs while add_timeout not. So I would recommend adding support for them to the add_timeout method (and possibly to the new one from above).\nI can contribute if any of these proposals get accepted.", "issue_status": "Closed", "issue_reporting_time": "2014-05-09T12:55:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "829": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1048", "issue_id": "#1048", "issue_summary": "Strange exceptions propagation with coroutines", "issue_description": "Contributor\nprotoss-player commented on 7 May 2014\nWhile trying to figure out how to make IOStream's set_close_callback raise exceptions inside a chain of coroutines, I came across some strange exceptions propagation in Tornado 3.2.\nConsider the following test script, which raises exceptions from timeout handlers, which is pretty much the same as waiting for a close callback.\nNOTE: This test code works as expected with Tornado 3.3-dev1: all exceptions from timeouts reach IOLoop as uncaught. Yet I haven't found any relevant tests in gen_test.py, hence I'm not sure whether the issue has already been properly dealt with or it's just me being lucky with my test case.\n#!/usr/bin/env python\n# coding: utf-8\n\nfrom time import time\n\nfrom tornado.ioloop import IOLoop\nfrom tornado import gen\n\n\n@gen.coroutine\ndef A():\n    def handle_error():\n        print 'ERROR A'\n        raise Exception('Error in A')\n\n    print 'A - Start'\n    IOLoop.current().add_timeout(time() + 1, handle_error)\n    print 'A - End'\n\n\n@gen.coroutine\ndef B():\n    print 'B - Start'\n\n    #def handle_error():\n    #    print 'ERROR B'\n    #    raise Exception(\"Error in B\")\n    #IOLoop.current().add_timeout(time() + 2, handle_error)\n    yield gen.Task(IOLoop.current().add_timeout, time() + 3)\n    print 'B - End'\n\n\n@gen.coroutine\ndef test_root():\n    print 'Root - Start'\n\n    try:\n        yield A()\n    except Exception as e:\n        print '(Should not be there) A exception:', e\n\n    try:\n        yield B()\n    except Exception as e:\n        print '(Should not be there) B exception:', e\n\n    print 'Root - End'\n\n\nif __name__ == '__main__':\n    try:\n        test_root()\n    except Exception as e:\n        print 'Root exception:', e\n    IOLoop.instance().start()\nI expected that the exception from A's handle_error would either reach IOLoop as an uncaught one, or, less likely, be caught by try .. catch around test_root.\nAlso, I expected that execution flow would be linear & synchronized at yield points, i.e. the output would look like:\nRoot - Start\nA - Start\nA - End\nB - Start\nERROR A\nERROR:tornado.application:Exception in callback <function null_wrapper at 0xb6f24a04>\nTraceback (most recent call last):\n    ...\nException: Error in A\nB - End\nRoot - End\nBoth assumptions proved to be wrong:\nThe exception was actually caught by try .. except block around yield B().\nRoot reached its end-point before B.\nHere's the output:\nRoot - Start\nA - Start\nA - End\nB - Start\nERROR A\n(Should not be there) B exception: Error in A\nRoot - End\nB - End\nWhat's even more strange, after I uncommented several lines in B() the output was:\nRoot - Start\nA - Start\nA - End\nB - Start\nERROR A\n(Should not be there) B exception: Error in A\nRoot - End\nERROR B\nB's exception was swallowed...\n... but execution never reached B - End.", "issue_status": "Closed", "issue_reporting_time": "2014-05-07T16:14:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "830": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1047", "issue_id": "#1047", "issue_summary": "websocket miss upgrade", "issue_description": "wmslei commented on 7 May 2014\nI have a websocket server in China, and when I connect from China, the request header has upgrade, but when I connect from Australia, the request header not found upgrade,\nwhy this happen? I need help, thanks.", "issue_status": "Closed", "issue_reporting_time": "2014-05-07T09:38:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "831": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1046", "issue_id": "#1046", "issue_summary": "Unexplained latency when serving large files (1GB+)", "issue_description": "Contributor\nchrisseto commented on 7 May 2014\nI'm writing a video streaming application with tornado and I've hit some trouble with the actual streaming portion.\nUsing just a static file handler the stream takes about 70 seconds to start.\nOverride the hashing/etag/caching methods in staticfilehandler, like so:\nclass StaticFileNoHash(StaticFileHandler):\n\n    def compute_etag(self):\n        return None\n\n    @classmethod\n    def get_content_version(cls, abspath):\n        return 1\n\n    @classmethod\n    def _get_cached_version(cls, abs_path):\n        return None\nReduces the time to about 15 seconds, locally the latency wasn't noticeable.\nUsing python-twisted there was not latency at all, the stream began instantly.\nSo the next idea was to override the get and get_content method as follows:\n    def get(self, path, include_body=True):\n        #Assume that path is correct, validation will be handeled elsewhere\n        self.absolute_path = os.path.abspath(path)\n        self.path = self.absolute_path\n        if self.absolute_path is None:\n            return\n\n        self.modified = self.get_modified_time()\n        self.set_headers()\n\n        if self.should_return_304():\n            self.set_status(304)\n            return\n\n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n\n        if request_range:\n            start, end = request_range\n            size = self.get_content_size()\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size, ))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\"Content-Range\",\n                                httputil._get_content_range(start, end, size))\n        else:\n            start = end = None\n\n        content = self.get_content(self.absolute_path, start, end)\n        for chunk in content:\n            self.write(chunk)\n\n    @classmethod\n    def get_content(cls, abspath, start=None, end=None):\n        read = 0\n        chunk_size = 64 * 1024\n        with open(abspath, \"rb\") as file:\n            file.seek(start or 0)\n            while end is None or read < end:\n                if end and chunk_size + read > end:\n                    chunk_size = end - read\n                chunk = file.read(chunk_size)\n                if chunk:\n                    read += len(chunk)\n                    yield chunk\n                else:\n                    if end is None:\n                        return\n                    assert (start or 0) + read == end\n                    return\nThe plan was to cut out some redundant checks.\nIronically that seemed to increase the latency, to about 2 seconds locally.\nSo I profiled the calls to get()\n80875 function calls (80844 primitive calls) in 0.591 seconds\n81140 function calls (81109 primitive calls) in 0.566 seconds\nNow that's odd no calls to get() are > 1 second.\nAny thoughts where the latency/lag is coming from? I'm at a complete loss.", "issue_status": "Closed", "issue_reporting_time": "2014-05-06T22:48:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "832": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1043", "issue_id": "#1043", "issue_summary": "Security Contact", "issue_description": "tempaccount123 commented on 5 May 2014\nSorry if this does not belong here. Could somebody provide me with a (technical) security contact for TornadoWeb?", "issue_status": "Closed", "issue_reporting_time": "2014-05-04T21:12:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "833": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1040", "issue_id": "#1040", "issue_summary": "nginx sample file change", "issue_description": "rboa commented on 1 May 2014\nin the docs at: http://www.tornadoweb.org/en/stable/overview.html?highlight=nginx#running-tornado-in-production\nthe proxy_redirect should be 'off' instead of 'false'", "issue_status": "Closed", "issue_reporting_time": "2014-04-30T22:36:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "834": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1039", "issue_id": "#1039", "issue_summary": "\"yield None\" fails in Tornado 3.2, works fine in 3.1.1", "issue_description": "bryndin commented on 22 Apr 2014\nDue to the new optimization in tornado.gen in Tornado 3.2, my function returns None instead of finished Future in 3.1.1. Yielding None causes BadYieldError exception.\nIn gen.py:\nyielded in yielded = self.gen.send(next) (line 531) becomes None, while there is no handling for None in lines lines 550-560\nsimplified example where get() is called:\n@gen.coroutine\ndef auth(self, handle_success=None):\n    if handle_success:\n            return\n    else:\n            yield foo()\n\n@gen.coroutine\ndef get(self):\n    f = self.auth(True)\n    # here f is None (3.2) instead of Future (3.1.1)\n    yield f", "issue_status": "Closed", "issue_reporting_time": "2014-04-22T01:45:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "835": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1038", "issue_id": "#1038", "issue_summary": "run_sync leaking file descriptors", "issue_description": "mdesnoyer-neon commented on 18 Apr 2014\nHi,\nI'm running tornado 3.1.1 on Ubuntu 12.04 and it looks like run_sync is leaking file descriptors. Any help figuring out why would be much appreciated. I came across this because I was trying to make a function decorator that would wrap coroutines so that the resulting functions can be called either asynchronously or synchronously. I'm using run_sync on a new io_loop in order to force the coroutine to run synchronously from the point of view of the caller. That code looks like:\ndef optional_sync(func):\n    '''A decorator that makes an asyncronous function optionally synchronous.\n\n    If you have an asynchronous function that has a special \"callback\"\n    argument, this decorator will change \"callback\" so that it's\n    optional. If callback is None, then the function will be\n    synchronous. If it is not None, the function will be asyncronous.\n\n    To use it, make sure this decorator is on the outside. For example\n    @optional_sync\n    @tornado.gen.coroutine\n    def do_something_async(url):\n      response = yield tornado.httpclient.AsyncHTTPClient().fetch(url)\n      raise tornado.gen.Return(random.shuffle(response))\n\n    Then, a synchronous call would look like:\n    weird_response = do_something_async('http://hi.com')\n\n    And an asynchronous call would be:\n    do_something_async('http://hi.com', callback=process_response)\n\n    or if it is in a @tornado.gen.coroutine, \n\n    weird_response = yield tornado.gen.Task(do_something_async,\n    'http://hi.com')\n\n    Note that inside the function, you must use\n    tornado.ioloop.IOLoop.current() to get the current io\n    loop. Otherwise it will hang.\n    '''\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if 'callback' in kwargs:\n            if kwargs['callback'] is not None:\n                return func(*args, **kwargs)\n            kwargs.pop('callback')\n\n        with bounded_io_loop() as io_loop:\n            return io_loop.run_sync(lambda : func(*args, **kwargs))\n\n    return wrapper\n\n\n@contextlib.contextmanager\ndef bounded_io_loop():\n    '''This context manager allows you to have a new ioloop set as the\n    current one.\n\n    When the context manager is done, the last current io_loop is returned.\n\n    Example:\n    with bounded_io_loop() as ioloop:\n      ioloop.run_sync()\n    '''\n    old_ioloop = tornado.ioloop.IOLoop.current()\n\n    temp_ioloop = tornado.ioloop.IOLoop()\n    temp_ioloop.make_current()\n\n    try:\n        yield temp_ioloop\n\n    finally:\n        old_ioloop.make_current()\nThen, I have a test case that will cause the leak. It's not a fully automated test case yet, but it does exercise the issue:\n@utils.sync.optional_sync\n@tornado.gen.coroutine\ndef call_google():\n    client = tornado.httpclient.AsyncHTTPClient()\n    response = yield tornado.gen.Task(\n        client.fetch,\n        tornado.httpclient.HTTPRequest('http://www.google.com'))\n    raise tornado.gen.Return(response)\n\ndef test_file_descriptors_leaking(self):\n    for i in range(10):\n        call_google()\nIf I run pdb and break on the self._call_google() line and then used lsof -p to look at the file descriptors opened by the process. The number of file descriptors open will keep increasing, even if I force a garbage collection to happen in pdb.\nOn a side note, if I can get this leak plugged, do you want the optional_sync functionality to be submitted to tornado? If so, what module would you prefer it in? tornado.gen?. I'd be happy to submit it", "issue_status": "Closed", "issue_reporting_time": "2014-04-18T17:02:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "836": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1033", "issue_id": "#1033", "issue_summary": "simple_httpclient _on_close handler loses error information", "issue_description": "Member\nbdarnell commented on 10 Apr 2014\nIn _on_close, we turn the exception into a string, which makes it difficult to programmatically tell what has gone wrong. When we have a richer exception available, we should raise it instead.\nSee http://stackoverflow.com/questions/22967568/get-socket-level-errors-from-tornado-httpclient", "issue_status": "Closed", "issue_reporting_time": "2014-04-10T02:14:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "837": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1031", "issue_id": "#1031", "issue_summary": "Add session support", "issue_description": "viyatb commented on 9 Apr 2014\nCurrently Tornado doesn't provide out-of-box support for session management. However various community developed extensions for Redis/Memcached session support exists.\nThe Tornado fork at https://github.com/milancermak/tornado has session handling capabilities. But sadly, the fork is over 3 years old.", "issue_status": "Closed", "issue_reporting_time": "2014-04-09T14:26:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "838": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1028", "issue_id": "#1028", "issue_summary": "A typo", "issue_description": "xros commented on 8 Apr 2014\non this page,\nhttps://github.com/facebook/tornado/blob/master/tornado/httpclient.py\nthe word 'wil' at the line 169 should be 'will'.", "issue_status": "Closed", "issue_reporting_time": "2014-04-08T07:43:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "839": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1026", "issue_id": "#1026", "issue_summary": "tornado file upload problem in higher dimensions", "issue_description": "ghost commented on 2 Apr 2014\nhi friends,\nadding files feature I did with tornado put into practice. example is the simplest way. 1GB and above the problem can not upload files. tornado not crash. on the browser screen \"This webpage is not available\" writes.\nhow can I upload files with tornado high-dimensional. What is this solution?\nsample code\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport os.path\nfrom tornado.options import define, options\n\ndefine(\"port\", default=8888, help=\"run on the given port\", type=int)\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r\"/\", HomeHandler),\n            (r\"/upload\", UploadHandler)\n        ]\n        tornado.web.Application.__init__(self, handlers)\n\nclass HomeHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.finish('<html><form enctype=\"multipart/form-data\" action=\"/upload\" method=\"post\">Upload File: <input type=\"file\" name=\"file1\" /><input type=\"submit\" value=\"upload\" />');\n\nclass UploadHandler(tornado.web.RequestHandler):\n    def post(self):\n        file1 = self.request.files['file1'][0]\n        # now you can do what you want with the data, we will just save the file to an uploads folder\n        output_file = open(\"/uploads/\" + file1['filename'], 'w')\n        output_file.write(file1['body'])\n        self.finish('Your file has been uploaded. Thank you')\n\ndef main():\n    http_server = tornado.httpserver.HTTPServer(Application())\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n\nif __name__ == \"__main__\":\n    main()", "issue_status": "Closed", "issue_reporting_time": "2014-04-02T13:38:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "840": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1024", "issue_id": "#1024", "issue_summary": "Tornado web server sometimes did not manage the request", "issue_description": "leehit commented on 28 Mar 2014\nWe are making a program that mobilephone send json package to web server which used tornado.We find a question that sometimes the tornado web server can not manage the request.When I put 'enter' or 'ctrl +z' on console,all the request that did not be managed will be managed .I want to know what cause this problem,and what should I do to solve it", "issue_status": "Closed", "issue_reporting_time": "2014-03-28T02:02:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "841": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1018", "issue_id": "#1018", "issue_summary": "Speedups fail to build due to warnings treated as errors on Python 3.4.0", "issue_description": "akheron commented on 18 Mar 2014\nI get the following error while running pip install tornado on Python 3.4.0. It seems to me that -Werror causes warnings to be treated as errors, and this breaks the build.\n  Running setup.py install for tornado\n    building 'tornado.speedups' extension\n    gcc -pthread -Wno-unused-result -Werror=declaration-after-statement -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/home/petri/tmp/gobridge/venv/include -I/home/petri/multipy/pythons/3.4.0/include/python3.4m -c tornado/speedups.c -o build/temp.linux-x86_64-3.4/tornado/speedups.o\n    tornado/speedups.c: In function \u2018websocket_mask\u2019:\n    tornado/speedups.c:14:5: error: ISO C90 forbids mixed declarations and code [-Werror=declaration-after-statement]\n    tornado/speedups.c:18:5: error: ISO C90 forbids mixed declarations and code [-Werror=declaration-after-statement]\n    tornado/speedups.c: At top level:\n    tornado/speedups.c:41:1: warning: function declaration isn\u2019t a prototype [-Wstrict-prototypes]\n    cc1: some warnings being treated as errors\n    command 'gcc' failed with exit status 1\n    deleting tornado.egg-info/requires.txt\n    /home/petri/tmp/gobridge/venv/build/tornado/setup.py:102: UserWarning:\n    ********************************************************************\n    WARNING: The tornado.speedups extension module could not\n    be compiled. No C extensions are essential for Tornado to run,\n    although they do result in significant speed improvements for\n    websockets.\n    The output above this warning shows how the compilation failed.\n\n    Here are some hints for popular operating systems:\n\n    If you are seeing this message on Linux you probably need to\n    install GCC and/or the Python development package for your\n    version of Python.\n\n    Debian and Ubuntu users should issue the following command:\n\n        $ sudo apt-get install build-essential python-dev\n\n    RedHat, CentOS, and Fedora users should issue the following command:\n\n        $ sudo yum install gcc python-devel\n\n    If you are seeing this message on OSX please read the documentation\n    here:\n\n    http://api.mongodb.org/python/current/installation.html#osx\n    ********************************************************************", "issue_status": "Closed", "issue_reporting_time": "2014-03-18T06:57:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "842": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1015", "issue_id": "#1015", "issue_summary": "Consider using certifi instead of packaging an own trustdb", "issue_description": "hynek commented on 16 Mar 2014\nYou\u2019re shipping Mozilla\u2019s trust database with tornado so you can verify certificates. That\u2019s awesome but it burdens you with keeping it up to date (and it isn\u2019t very fresh at the moment either).\nI would like to suggest to depend on certifi instead that\u2019s also used by requests. That takes off the burden to keep yours up to date and people won\u2019t have Mozilla\u2019s trust DBs of various freshness all over site-packages.", "issue_status": "Closed", "issue_reporting_time": "2014-03-16T13:01:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "843": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1014", "issue_id": "#1014", "issue_summary": "Dangerous defaults in TLS client code", "issue_description": "hynek commented on 12 Mar 2014\nHi, I\u2019m surveying Python\u2019s TLS implementations and saw that your client code uses DEFAULT:!SSLv2 for ciphers.\nThat\u2019s pretty bad because that also enables export ciphers et al. howsmyssl\u2019s take on it can be found here.\nI\u2019m also pretty sure you don\u2019t disable TLS compression and the false stems from my OpenSSL disabling it for everyone.\nDue to #764, this can\u2019t be fixed by API users.\nFor reference, urlib3 went this way: urllib3/urllib3@2088570", "issue_status": "Closed", "issue_reporting_time": "2014-03-12T13:49:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "844": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1013", "issue_id": "#1013", "issue_summary": "Tornado websocket doesn't work on the ubuntu", "issue_description": "zhangxiansheng commented on 11 Mar 2014\n\nThe program is right,I have run it success on my PC,but on the server (Ubuntu\uff09it doesn't work. Help", "issue_status": "Closed", "issue_reporting_time": "2014-03-11T01:41:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "845": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1009", "issue_id": "#1009", "issue_summary": "Allow top level JSON arrays again", "issue_description": "ntrrgc commented on 8 Mar 2014\nAt the moment Tornado forbids writing JSON lists due to a potential cross-site vulnerability explained in an article from 2008.\nNote, however, that vulnerability is now 8 years old (first records I find on it are from 2006), and in the 2008 article it only affected Firefox <= 2.0 (not even IE6!), which ended security support the same year.\nDoes it make sense for us to maintain this kind of limitation because of an ancient vulnerability in browsers that has been fixed 6 years ago?\nRelated: #109", "issue_status": "Closed", "issue_reporting_time": "2014-03-08T18:21:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "846": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1007", "issue_id": "#1007", "issue_summary": "AttributeError: 'module' object has no attribute 'netutil_test'", "issue_description": "Contributor\nyaccz commented on 8 Mar 2014\n* python2_6: running distutils-r1_run_phase python_test\nobj: <module 'tornado.test' from '/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python2_6/lib/tornado/test/__init__.py'>\npart: netutil_test\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/runpy.py\", line 122, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/lib/python2.6/runpy.py\", line 34, in _run_code\n    exec code in run_globals\n  File \"/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python2_6/lib/tornado/test/runtests.py\", line 123, in <module>\n    tornado.testing.main(**kwargs)\n  File \"/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python2_6/lib/tornado/testing.py\", line 599, in main\n    unittest.main(defaultTest=\"all\", argv=argv, **kwargs)\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 97, in __init__\n    self.parseArgs(argv)\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 152, in parseArgs\n    self.createTests()\n  File \"/usr/lib/python2.6/site-packages/unittest2/main.py\", line 161, in createTests\n    self.module)\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 153, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 138, in loadTestsFromName\n    test = obj()\n  File \"/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python2_6/lib/tornado/test/runtests.py\", line 49, in all\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 153, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib/python2.6/site-packages/unittest2/loader.py\", line 121, in loadTestsFromName\n    parent, obj = obj, getattr(obj, part)\nAttributeError: 'module' object has no attribute 'netutil_test'", "issue_status": "Closed", "issue_reporting_time": "2014-03-08T00:20:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "847": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1005", "issue_id": "#1005", "issue_summary": "TypeError: __init__() got an unexpected keyword argument 'warnings'", "issue_description": "Contributor\nyaccz commented on 8 Mar 2014\nTraceback (most recent call last):\n  File \"/usr/lib/python3.3/runpy.py\", line 160, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/lib/python3.3/runpy.py\", line 73, in _run_code\n    exec(code, run_globals)\n  File \"/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python3_3/lib/tornado/test/runtests.py\", line 123, in <module>\n    tornado.testing.main(**kwargs)\n  File \"/var/tmp/portage/www-servers/tornado-3.1.1/work/tornado-3.1.1-python3_3/lib/tornado/testing.py\", line 606, in main\n    unittest.main(defaultTest=\"all\", argv=argv, **kwargs)\nTypeError: __init__() got an unexpected keyword argument 'warnings'\nHappens on installation of python-{3.2,3.3} with unittest2 installed.", "issue_status": "Closed", "issue_reporting_time": "2014-03-07T23:32:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "848": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1004", "issue_id": "#1004", "issue_summary": "follow_redirects=False raises HTTPError", "issue_description": "meehow commented on 6 Mar 2014\nHTTPClient raises HTTPError: HTTP 302: Found in case if there is a redirect on a website and disabled redirects by adding follow_redirects=False to fetch().", "issue_status": "Closed", "issue_reporting_time": "2014-03-06T17:41:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "849": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1002", "issue_id": "#1002", "issue_summary": "why the static_file \"v\" value do not change", "issue_description": "wmslei commented on 5 Mar 2014\nWhen I do not use nginx Reverse proxy tornado\uff0cwhile I change the static_file\uff08like main.js\uff09\uff0cand I refresh the web page, the static_file changed, but when I use nginx, I refresh web page, the static_file do not change, why it happen? Is it a bug?\nNeed reply,\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2014-03-05T07:15:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "850": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1001", "issue_id": "#1001", "issue_summary": "Example", "issue_description": "adityapn commented on 3 Mar 2014\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2014-03-03T10:13:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "851": {"issue_url": "https://github.com/tornadoweb/tornado/issues/993", "issue_id": "#993", "issue_summary": "build errors when installing on windows via pip", "issue_description": "ibell commented on 25 Feb 2014\nFound existing installation: tornado 3.1.1\nUninstalling tornado:\nSuccessfully uninstalled tornado\nRunning setup.py install for tornado\nbuilding 'tornado.speedups' extension\nc:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\BIN\\cl.exe /c /nologo /Ox /MD /W3 /GS- /DNDEBUG -IC:\\Python27\\include -IC:\\Python27\\PC /Tctornado/speedups.c /Fobuild\\temp.win32-2.7\\Release\\tornado/speedups.obj\nspeedups.c\ntornado/speedups.c(14) : error C2275: 'PyObject' : illegal use of this type as an expression\nc:\\python27\\include\\object.h(108) : see declaration of 'PyObject'\ntornado/speedups.c(14) : error C2065: 'result' : undeclared identifier\ntornado/speedups.c(15) : error C2065: 'result' : undeclared identifier\ntornado/speedups.c(18) : error C2143: syntax error : missing ';' before 'type'\ntornado/speedups.c(20) : error C2065: 'buf' : undeclared identifier\ntornado/speedups.c(20) : error C2109: subscript requires array or pointer type\ntornado/speedups.c(23) : error C2065: 'result' : undeclared identifier\ntornado/speedups.c(23) : warning C4047: 'return' : 'PyObject _' differs in levels of indirection from 'int'\ntornado/speedups.c(26) : error C2061: syntax error : identifier 'methods'\ntornado/speedups.c(26) : error C2059: syntax error : ';'\ntornado/speedups.c(26) : error C3409: empty attribute block is not allowed\ntornado/speedups.c(26) : error C2513: '/_global*/ ' : no variable declared before '='\ntornado/speedups.c(47) : error C2065: 'methods' : undeclared identifier\ntornado/speedups.c(47) : warning C4047: 'function' : 'PyMethodDef *' differs in levels of indirection from 'int'\ntornado/speedups.c(47) : warning C4024: 'Py_InitModule4' : different types for formal and actual parameter 2\ncommand '\"c:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\BIN\\cl.exe\"' failed with exit status 2\nC:\\Users\\Belli\\build\\tornado\\setup.py:102: UserWarning:\nWARNING: The tornado.speedups extension module could not\nbe compiled. No C extensions are essential for Tornado to run,\nalthough they do result in significant speed improvements for\nwebsockets.\nThe output above this warning shows how the compilation failed.\nHere are some hints for popular operating systems:\nIf you are seeing this message on Linux you probably need to\ninstall GCC and/or the Python development package for your\nversion of Python.\nDebian and Ubuntu users should issue the following command:\n  $ sudo apt-get install build-essential python-dev\nRedHat, CentOS, and Fedora users should issue the following command:\n  $ sudo yum install gcc python-devel\nIf you are seeing this message on OSX please read the documentation\nhere:\nhttp://api.mongodb.org/python/current/installation.html#osx\n\"The output above \"\nwarning: no files found matching 'README' under directory 'demos'\nRunning setup.py install for backports.ssl-match-hostname\nccessfully installed tornado backports.ssl-match-hostname\neaning up...\n\\Users\\Belli>", "issue_status": "Closed", "issue_reporting_time": "2014-02-24T23:33:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "852": {"issue_url": "https://github.com/tornadoweb/tornado/issues/992", "issue_id": "#992", "issue_summary": "websocket on_close", "issue_description": "wmslei commented on 24 Feb 2014\nI use the websocket server, if I close a socket like self.close(), the on_close method could be called, and if the client close a socket,the on_close method will be called, is this right?", "issue_status": "Closed", "issue_reporting_time": "2014-02-24T04:17:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "853": {"issue_url": "https://github.com/tornadoweb/tornado/issues/991", "issue_id": "#991", "issue_summary": "UnicodeDecodeError in template", "issue_description": "jason64 commented on 24 Feb 2014\nIf the template_path setting is an unicode string and some template file contains non-ASCII characters, then tornado raises the following exception:\n...\n  File \"/home/venv/local/lib/python2.7/site-packages/tornado/template.py\", line 633, in write_line\n    print(\"    \" * indent + line + line_comment, file=self.file)\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xd0 in position 18: ordinal not in range(128)\nCause of the exception: the line variable is a str object containing non-ASCII characters and the line_comment variable is an unicode object.", "issue_status": "Closed", "issue_reporting_time": "2014-02-23T22:48:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "854": {"issue_url": "https://github.com/tornadoweb/tornado/issues/989", "issue_id": "#989", "issue_summary": "long connection", "issue_description": "wmslei commented on 21 Feb 2014\nCan I realize \"long connection(persistent connection, not long poll)\" use tornado.web.RequestHandler? Because I need contain the connection, I need receive \"heart message\" which send by client, So, if tornado.web.RequestHandler can do it, How can I do? And have some demo like this?\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2014-02-21T10:18:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "855": {"issue_url": "https://github.com/tornadoweb/tornado/issues/988", "issue_id": "#988", "issue_summary": "HEAD request on large static files are very slow", "issue_description": "MatsDahlberg commented on 21 Feb 2014\nI have a tornado application that receives HEAD requests on very large static files (15-25 GB files). These files happens to be located on a remote server that is mounted over sshfs.\nThe HEAD request took 140-250 seconds which seemed strange to me. I found that even though it was a HEAD request tornado would read the whole file just to determine the length of it.\nFrom web.py, lines 1947-1952:\n        content_length = 0\n        for chunk in content:\n            if include_body:\n                self.write(chunk)\n            else:\n                content_length += len(chunk)\nIn my server I have changed this to:\n        content_length = 0\n        if include_body:\n            for chunk in content:\n                self.write(chunk)\n        else:\n            content_length = os.stat(self.absolute_path).st_size\nNow the HEAD request takes 2 ms instead of 140-250 seconds.", "issue_status": "Closed", "issue_reporting_time": "2014-02-21T09:58:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "856": {"issue_url": "https://github.com/tornadoweb/tornado/issues/987", "issue_id": "#987", "issue_summary": "Calling close() on an IOStream doesn't cancel pending read callbacks", "issue_description": "mulka commented on 19 Feb 2014\nI don't know if this is a bug or expected behavior, but I think I'm running into a situation where I want to close a stream, and then immediately reconnect. The problem is that when I call close on it, it doesn't cancel cancel read callbacks and so I end up getting AssertionError: Already reading. Is this something that can be fixed in tornado, or do I need to figure out a workaround. Any ideas?", "issue_status": "Closed", "issue_reporting_time": "2014-02-19T09:19:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "857": {"issue_url": "https://github.com/tornadoweb/tornado/issues/986", "issue_id": "#986", "issue_summary": "get_argument() can't return default value if HTTP request argument is empty", "issue_description": "ushuz commented on 14 Feb 2014\nmc = self.get_argument(\"mc\", None)\nInstead of getting the expectedNone, mc gets an empty string. It's not fair default value goes into effect only if the argument is missing.", "issue_status": "Closed", "issue_reporting_time": "2014-02-14T10:56:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "858": {"issue_url": "https://github.com/tornadoweb/tornado/issues/985", "issue_id": "#985", "issue_summary": "how can i pass arguments through blocks?", "issue_description": "yupbank commented on 13 Feb 2014\ni mean is there any better way to pass arguments through blocks?\ncurrently, from the doc, i can only find one way by define my own UImodel...so is there any convenient way that just past arguments?\ni know in Mako there is <%def name=\"xxx(a1, a2)\" %> <%end%>", "issue_status": "Closed", "issue_reporting_time": "2014-02-13T13:37:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "859": {"issue_url": "https://github.com/tornadoweb/tornado/issues/983", "issue_id": "#983", "issue_summary": "Add ability to retrieve original response headers/data after an error occurs", "issue_description": "Contributor\nccampbell commented on 5 Feb 2014\nJust ran into a case where I want to render an error in the same format that the request is expecting.\nIn my handler function I set\nself.set_header('Content-Type', 'application/json')\nIn RequestHandler.write_error I want to render out the error as json, but the Content-Type is set as text/html.\nI understand that clearing out the response headers is definitely wanted in more situations than not (especially with cache headers and other things).\nJust curious what you think about possibly passing in the original response headers/content into write_error as an argument.\nRight now, I think I should be able to override RequestHandler.send_error to store the old headers so that I can access them and achieve what I want.", "issue_status": "Closed", "issue_reporting_time": "2014-02-04T19:00:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "860": {"issue_url": "https://github.com/tornadoweb/tornado/issues/982", "issue_id": "#982", "issue_summary": "gzip Content-Encoding for text/event-stream", "issue_description": "tbuenger commented on 30 Jan 2014\nShort:\ntext/event-stream should be added to the set of applicable content-types in:\ntornado.web.GZipContentEncoding.CONTENT_TYPES\nLong:\nCurrently, tornado does not allow gzip-compression for Server-Sent Events.\nThe standardized (http://www.w3.org/TR/eventsource/) protocol is based on plain text and uses the MIME type text/event-stream. Since it is implemented using plain text and often json, those HTTP streams would benefit from compression.\nBut gzip compression in tornado is only applied to a set of white-listed text-like MIME types. And the text/event-stream type is missing.", "issue_status": "Closed", "issue_reporting_time": "2014-01-29T23:45:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "861": {"issue_url": "https://github.com/tornadoweb/tornado/issues/981", "issue_id": "#981", "issue_summary": "AsyncTestCase intermittent AssertionError while in wait", "issue_description": "danielnelson commented on 30 Jan 2014\nWith this test case:\nimport tornado.testing\nimport threading\n\nclass Sleeper(threading.Thread):\n  def __init__(self, callback):\n    super(Sleeper, self).__init__()\n    self.callback = callback\n\n  def run(self):\n    self.callback()\n\nclass AsyncTestCaseAssert(tornado.testing.AsyncTestCase):\n  def setUp(self):\n    super(AsyncTestCaseAssert, self).setUp()\n\n  def test_bug(self):\n    thread = Sleeper(self.stop)\n    thread.start()\n    self.wait()\n    assert True\n\n  def test_bug2(self):\n    thread = Sleeper(self.stop)\n    thread.start()\n    self.wait()\n    assert True\nIf you run it repeatedly, sometimes you will trigger this error:\nTraceback (most recent call last):\n  File \"tmp.py\", line 19, in test_bug\n    self.wait()\n  File \"tornado/testing.py\", line 267, in wait\n    assert self.__stopped\nAssertionError\nYou can trigger it faster by placing a short sleep in AsyncTestCase.stop right before:\nself.__stopped = True\nI think this variable needs to either have a mutex, be set to True before\nstopping the ioloop, or the assert needs to be removed in AsyncTestCase.wait.", "issue_status": "Closed", "issue_reporting_time": "2014-01-29T22:14:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "862": {"issue_url": "https://github.com/tornadoweb/tornado/issues/978", "issue_id": "#978", "issue_summary": "Rounding issues with poll_timeout in IOLoop", "issue_description": "Contributor\nschlamar commented on 23 Jan 2014\nIf the calculated timeout from a scheduled timer is smaller than the resolution of the poll implementation, zero is passed to the underlying poll/select system call. This means that the IOLoop spins ineffectively multiple times until the scheduled timeout is finally resolved.\nSee this bug report against tulip for details: http://bugs.python.org/issue20311", "issue_status": "Closed", "issue_reporting_time": "2014-01-23T13:55:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "863": {"issue_url": "https://github.com/tornadoweb/tornado/issues/975", "issue_id": "#975", "issue_summary": "how to use \"-rotating\" in command line?", "issue_description": "bells commented on 15 Jan 2014\ntornado.options.Error: Unrecognized command line option: 'rotating'", "issue_status": "Closed", "issue_reporting_time": "2014-01-15T12:40:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "864": {"issue_url": "https://github.com/tornadoweb/tornado/issues/974", "issue_id": "#974", "issue_summary": "what's long polling performance of tornado?", "issue_description": "KeepPeace commented on 15 Jan 2014\nnow i find that about 10000 connection can be accepted by one tornado process,\ni don't know whether the result is good or not.\nwhat do u think?\nIntel(R) Xeon(R) CPU E5606 @ 2.13GHz\ncode:\n@tornado.web.asynchronous\ndef post(self):\nself.timeout = IOLoop.instance().add_timeout(deadline=(IOLoop.instance().time()+27), callback=self.on_timeout)\ndef on_timeout(self):\nself.finish(self.notification_chunk())", "issue_status": "Closed", "issue_reporting_time": "2014-01-15T09:27:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "865": {"issue_url": "https://github.com/tornadoweb/tornado/issues/967", "issue_id": "#967", "issue_summary": "Docs Typo: Uppercase the First Character", "issue_description": "needpy commented on 28 Dec 2013\nI think the first character of sentence \"if and for blocks get translated exactly into Python\" in http://www.tornadoweb.org/en/stable/template.html should be uppercased.\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2013-12-28T04:21:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "866": {"issue_url": "https://github.com/tornadoweb/tornado/issues/961", "issue_id": "#961", "issue_summary": "In locale.format_date relative is forced to False if locale starts with 'ru'", "issue_description": "Contributor\nantonv6 commented on 21 Dec 2013\nlocale module is making some assumptions behind the scenes based on locale code. Some of them are useful and self-explanatory (like automatic switching 12/24 hour clock formats).\nBut there's one thing I can't understand. I suggest you at least consider this a documentation bug, unless I'm missing something. This is a snippet from locale.py:\ndef format_date(self, date, gmt_offset=0, relative=True, shorter=False,\n                full_format=False):\n    \"\"\"Formats the given date (which should be GMT).\n\nBy default, we return a relative time (e.g., \"2 minutes ago\"). You\ncan return an absolute date string with ``relative=False``.\n\n[snip]\n\"\"\"\n    if self.code.startswith(\"ru\"):\n        relative = False\nThe very first pair of lines in the method just forces relative to False in some particular cases. Why? Blame button reveals that the lines in question were there even before moving code to git/github, so maybe they are obsolete now?", "issue_status": "Closed", "issue_reporting_time": "2013-12-21T17:13:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "867": {"issue_url": "https://github.com/tornadoweb/tornado/issues/956", "issue_id": "#956", "issue_summary": "_curl_header_callback error (python3.3)", "issue_description": "x-term commented on 17 Dec 2013\nTraceback (most recent call last):\nFile \"/usr/lib/python3.3/site-packages/tornado/curl_httpclient.py\", line 324, in\nlambda line: _curl_header_callback(headers, line))\nFile \"/usr/lib/python3.3/site-packages/tornado/curl_httpclient.py\", line 458, in _curl_header_callback\nif header_line.startswith(\"HTTP/\"):\nTypeError: startswith first arg must be bytes or a tuple of bytes, not str\nHTTP 599: Failed writing header", "issue_status": "Closed", "issue_reporting_time": "2013-12-17T11:36:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "868": {"issue_url": "https://github.com/tornadoweb/tornado/issues/953", "issue_id": "#953", "issue_summary": "BaseIOStream.read_until methods should return Future and take optional keyword arg callback", "issue_description": "picomancer commented on 12 Dec 2013\nI'm writing a Tornado TCP server. (Not HTTP.) There are not a tremendous amount of examples on the Internet, and those that exist tend to use callbacks instead of generators. I prefer generators.\nI think the read_until functions and the write function should be callable from a function with the @tornado.gen.coroutine marker with an API similar to the following:\n@tornado.gen.coroutine\ndef echo_server_main_loop(self):\n    try:\n        while True:\n            line = yield read_until(self.stream, \"\\n\")\n            message_id = next(self.message_id_alloc)\n            yield write(self.stream, line)\n    except tornado.iostream.StreamClosedError:\n        pass\n    return\nIn fact, the documentation for the gen module led me to believe that this behavior was supported. The documentation as of this writing says that:\ndef myfunc(self):\n    http_client.fetch(\"http://example.com\", callback=self.on_fetch)\n    return\n\ndef on_fetch(self, response):\n    # process the response...\ncan be transformed into:\n@tornado.gen.coroutine\ndef myfunc(self):\n    response = yield http_client.fetch(\"http://example.com\")\n    # process the response...\nI assumed that a similar transformation could be done with the Tornado functions for non-HTTP TCP reading and writing, since the documentation does say that \"Most asynchronous functions in Tornado return a Future...Task works with any function that takes a callback keyword argument...\"\nUnfortunately neither of the above statements applies to the read_until functions, which means in practice that these features are useless for non-HTTP TCP servers! The write function is wrappable by a task, but it does not return a Future either.\nThis documentation seemed to imply the first code snippet is a supported, or even preferred, usage of the Tornado API -- but this only seems to be the case with the HTTP versions of the methods I'm actually using. Tracking down the problem took me quite a while.\nI propose modifying the API for read_until and write as follows: The callback parameter should be made optional with a default of some non-callable sentinel object CB_FUTURE defined at the module level (for example CB_FUTURE = 1). (1) When the callback parameter is CB_FUTURE, a Future will be returned. (2) When the callback parameter is not CB_FUTURE, then None will be returned and the given callback will be called when the operation completes.\nBecause of change (1), the first code snippet will work as desired. Because of change (2), existing code which uses these functions will not break, because the existing API requires two positional arguments to be present, and the second positional argument will be something other than the sentinel object for code that was written before this change was proposed.\nIf the above API change is too constraining, I would prefer adding prominent warnings to the gen package docs that the read_until and write methods do not support the gen API.\nFinally, to see wrappers I've written that support the new API, take a look at https://github.com/picomancer/echoserver", "issue_status": "Closed", "issue_reporting_time": "2013-12-12T01:07:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "869": {"issue_url": "https://github.com/tornadoweb/tornado/issues/952", "issue_id": "#952", "issue_summary": "parse_command_line() side effect", "issue_description": "mulka commented on 11 Dec 2013\nI've noticed that parse_command_line() has a side effect of changing the log level even if no command arguments are given. This caused me to miss the autoreload info messages when I decided not to include the parse_command_line() function because I didn't think I needed it.\nWondering if this side effect was intentional, and if it is possible to remove.\nExample:\nimport logging\n\nfrom tornado.options import parse_command_line\n\nlogging.info('before parse_command_line')\nparse_command_line()\nlogging.info('after parse_command_line')", "issue_status": "Closed", "issue_reporting_time": "2013-12-11T03:59:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "870": {"issue_url": "https://github.com/tornadoweb/tornado/issues/951", "issue_id": "#951", "issue_summary": "UnboundLocalError: local variable referenced before assignment", "issue_description": "Contributor\nantonv6 commented on 9 Dec 2013\nI think I got a bug, but it's so easy to reproduce I'm not sure if it's a documented feature instead (ha).\nConsider this code:\napp.py:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.render(\"template.html\", item=\"spam\", items=[\"foo\", \"bar\"])\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(9000)\n    tornado.ioloop.IOLoop.instance().start()\ntemplate.html:\n{{ item }}\n\n{% for item in items %}\n  {{ item }}\n{% end %}\nI'm using Tornado 3.1.1 and this app, when accessed, produces an UnboundLocalError:\nTraceback (most recent call last):\n  File \"/tmp/venv/local/lib/python2.7/site-packages/tornado/web.py\", line 1141, in _when_complete\n    callback()\n  File \"/tmp/venv/local/lib/python2.7/site-packages/tornado/web.py\", line 1162, in _execute_method\n    self._when_complete(method(*self.path_args, **self.path_kwargs),\n  File \"./hello.py\", line 6, in get\n    self.render(\"template.html\", item=\"spam\", items=[\"foo\", \"bar\"])\n  File \"/tmp/venv/local/lib/python2.7/site-packages/tornado/web.py\", line 538, in render\n    html = self.render_string(template_name, **kwargs)\n  File \"/tmp/venv/local/lib/python2.7/site-packages/tornado/web.py\", line 645, in render_string\n    return t.generate(**namespace)\n  File \"/tmp/venv/local/lib/python2.7/site-packages/tornado/template.py\", line 273, in generate\n    return execute()\n  File \"template_html.generated.py\", line 4, in _tt_execute\n    _tt_tmp = item  # template.html:1\nUnboundLocalError: local variable 'item' referenced before assignment\nIf you move {{ item }} in the template to the bottom, after the for block, it somewhat works, but outputs \"foo bar bar\", and \"spam\" is never seen.\nNow, I know an easy workaround of just renaming the variable, but I'm curious as to what is the reason for the exception here. Thanks.", "issue_status": "Closed", "issue_reporting_time": "2013-12-09T12:04:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "871": {"issue_url": "https://github.com/tornadoweb/tornado/issues/948", "issue_id": "#948", "issue_summary": "tornado.web.RequestHandler write None", "issue_description": "felixcarmona commented on 30 Nov 2013\nIf in the handler you do:\nself.write(None)\nwhen the RequestHandler calls the finish() method, this line:\nelif \"Content-Length\" not in self._headers:\ncontent_length = sum(len(part) for part in self._write_buffer)\ncrashes, because the self._write_buffer contains the following list: [None]\nTypeError: object of type 'NoneType' has no len()\nyou can't do len() on None, what should be this? 0?", "issue_status": "Closed", "issue_reporting_time": "2013-11-29T18:43:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "872": {"issue_url": "https://github.com/tornadoweb/tornado/issues/947", "issue_id": "#947", "issue_summary": "Time out processing could be more robust to slow callbacks.", "issue_description": "paul-ollis commented on 29 Nov 2013\nI have seen this occur in version 3.1.1\nThe affected code is in ioloop.py, method start, which begins at line 549. More\nspecifically the issue arises in the code loop, starting starting at line 605\nwhich handles expired timeouts.\nIf an invoked callback takes an unreasonable time to execute and adds a new\ntimout for itself such that the expirey time has elapsed before it returns then\nthe the affected code will (I believe) loop forever. Adding the line::\nnow = self.time()\nimmediately after line 618, which invokes _run_callback fixes this, at least\nfor non-pathological code.\nFYI I discovered this whilst trying to use Tornado to replace the bulk of some\ncode I am refactoring. Otherwise, I would probably have naturally used the\nPeriodicCallback class and not encountered this issue.\nIf this 'fix' is considered worthwhile, I am happy to add a matching regression\ntest and patch file.", "issue_status": "Closed", "issue_reporting_time": "2013-11-29T00:04:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "873": {"issue_url": "https://github.com/tornadoweb/tornado/issues/946", "issue_id": "#946", "issue_summary": "Sorry, it is already fixed :)", "issue_description": "blsalvio commented on 27 Nov 2013\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2013-11-27T04:25:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "874": {"issue_url": "https://github.com/tornadoweb/tornado/issues/943", "issue_id": "#943", "issue_summary": "BaseIOStream.read_bytes() filling buffer and throwing IOException when unnecessary?", "issue_description": "MysticHLE commented on 23 Nov 2013\nI'm not sure if this is by design or not, but from testing and looking at the source code for iostream.py, it seems that Tornado is doing something extremely unexpected when performing read_bytes(), particularly in _try_inline_read().\nFirst, Tornado would try to read from the buffer. If no data is in the buffer, it would proceed to reading from the socket/descriptor into the buffer until an exception occurs or if there is nothing to read from the socket. Strangely, this can potentially fill the buffer completely, irrespective of the number of bytes to read specified in the parameter of read_bytes().\nAfterwards, Tornado would try to read from the buffer again, invoke the specified callback (assuming we're not using a streaming callback) in the parameter to read_bytes(), and then call _maybe_add_error_listener(), which potentially (if the stream isn't closed) adds another ioloop.IOLoop.READ event to the IOLoop, eventually triggering another _read_to_buffer() within _handle_read(), and may now fill the buffer and close the stream with an IOException (line 462), preventing any further reads from the stream.\nOur use case is using read_bytes() and read_until() to upload a large file using chunk encoding...so it seems strange that reading data from the socket to the buffer would ignore the requested amount of data being read and close the stream prematurely. Is this a bug, or is this by design and we are using the library incorrectly?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2013-11-22T20:50:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "875": {"issue_url": "https://github.com/tornadoweb/tornado/issues/942", "issue_id": "#942", "issue_summary": "StaticFileHandler", "issue_description": "MA3STR0 commented on 22 Nov 2013\nNot sure if it's a bug or a feature, but currently StaticFileHandler disallows dynamic routing to favicon.ico and robots.txt.\nIt registers handlers for \"/(favicon\\.ico)\" and r\"/(robots\\.txt)\" in init method, so an application with StaticFileHandler enabled cannot override those URLs with custom handlers without subclassing StaticFileHandler.\nIt's a question of design: should a handler for static files by default take exclusive responsibility for these exceptional URLs, or should it make it optional/configurable?", "issue_status": "Closed", "issue_reporting_time": "2013-11-22T11:44:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "876": {"issue_url": "https://github.com/tornadoweb/tornado/issues/939", "issue_id": "#939", "issue_summary": "add datetime serialization support to tornado.escsape.json_encode (patch included)", "issue_description": "thehesiod commented on 19 Nov 2013\ntornado's default jsonification of the response doesn't support datetime conversion due to the underlying JSON implementation. I propose fixing this oversight with what the following monkey patch achieves. I think the underlying JSON implementation is what really should be fixed, but at least tornado with this patch will behave in a reasonable manner for datetime objects.\nimport json, datetime\nfrom tornado import escape\nDT_HANDLER = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) or isinstance(obj, datetime.date) else None\ndef json_encode(value):\nreturn json.dumps(value, default=DT_HANDLER).replace(\"</\", \"</\")\nescape.json_encode = json_encode", "issue_status": "Closed", "issue_reporting_time": "2013-11-19T06:48:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "877": {"issue_url": "https://github.com/tornadoweb/tornado/issues/938", "issue_id": "#938", "issue_summary": "Websocket client/server inconsistencies", "issue_description": "guettli commented on 18 Nov 2013\nIn stack_context.py exceptions get sometimes swallowed.\nAfter modifying this line, I could find the root of the problem:\ndiff --git a/tornado/stack_context.py b/tornado/stack_context.py\nindex b1e82b0..83b9d88 100644\n--- a/tornado/stack_context.py\n+++ b/tornado/stack_context.py\n@@ -300,7 +300,7 @@ def wrap(fn):\n             if top is None:\n                 try:\n                     ret = fn(*args, **kwargs)\n-                except:\n+                except IOError:\n                     exc = sys.exc_info()\n                     top = contexts[1]\nOf course this is just a small hack, which can't make it into the real code.\nHere is the exception which happens inside a websocket client:\nException in callback <functools.partial object at 0x1469ec0>\nTraceback (most recent call last):\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/ioloop.py\", line 461, in _run_callback\n    callback()\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/stack_context.py\", line 302, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/iostream.py\", line 353, in wrapper\n    callback(*args)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/stack_context.py\", line 302, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/websocket.py\", line 719, in _on_frame_data\n    self._handle_message(opcode, data)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/websocket.py\", line 735, in _handle_message\n    self.async_callback(self.handler.on_message)(decoded)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/websocket.py\", line 325, in wrapper\n    self.request.path, exc_info=True)\n  File \"/home/modwork_eins_dmes/src/tornado/tornado/httpclient.py\", line 485, in __getattr__\n    request_attr = getattr(self.request, name)\nAttributeError: 'HTTPRequest' object has no attribute 'path'\nIn websocket.py line 325 request.path gets accessed to create an error message. But the websocket request does not have this attribute. One possible fix would be to use getattr(request, 'path', None) in websocket Line 325.\n1", "issue_status": "Closed", "issue_reporting_time": "2013-11-18T10:47:23Z", "fixed_by": "#1964", "pull_request_summary": "websocket: fix client message callback error", "pull_request_description": "Contributor\ndv321 commented on 25 Feb 2017 \u2022\nedited\nFixes #938\nThis fixes the problem of exceptions being swallowed in websocket client on_message callbacks. As @bdarnell pointed out in the issue, there should be some changes made to WebSocketProtocol to know what attributes it does and does not have, but this will at least prevent the AttributeError which causes the callback to silently be called again with None whenever any exceptions are raised in the original callback.", "pull_request_status": "Merged", "issue_fixed_time": "2017-02-25T22:34:48Z", "files_changed": [["2", "tornado/websocket.py"]]}, "878": {"issue_url": "https://github.com/tornadoweb/tornado/issues/935", "issue_id": "#935", "issue_summary": "Docs typo", "issue_description": "needpy commented on 14 Nov 2013\nIn document's pdf version https://media.readthedocs.org/pdf/tornado/stable/tornado.pdf , you would find that a single quote sign is wrong in page 14, after \"Debug mode is not compatible with HTTPServer\", but it is right in document's html version http://www.tornadoweb.cn/en/documentation .\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2013-11-14T06:55:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "879": {"issue_url": "https://github.com/tornadoweb/tornado/issues/933", "issue_id": "#933", "issue_summary": "Documentation change", "issue_description": "andoryu commented on 10 Nov 2013\nWhile using the concurrent module I discovered, via error messages, that the @run_on_executor decorator requires that the underlying handler have both an executor and an ioloop variable.\nThe documentation should really reflect this requirement.\nI guess that there could be other similar undocumented requirements too.", "issue_status": "Closed", "issue_reporting_time": "2013-11-10T09:27:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "880": {"issue_url": "https://github.com/tornadoweb/tornado/issues/932", "issue_id": "#932", "issue_summary": "Exploting non streaming validation of header.", "issue_description": "kernelsauce commented on 7 Nov 2013\nHi.\nIn Tornado github HEAD you can through some simple juggling force Tornado to exit because there is no more memory to allocate.\nRecipe:\nCreate a random string (128MB - 1B), must not contain double CRLF.\nOpen sockets towards Tornado.\nSend random string on all sockets, never close sockets.\nWait for server to use all memory available.\nIf the server OS has swapping enabled expect that the server will become severely sluggish.\nIn the perfect world, a HTTP parser with support for streaming would be used and the parser should continously be updated as bytes become available. This way you could in the least set a max amount of header fields to accept and also discard invalid headers before max buffer limit or CRLF is reached (I think 128MB is a lot).\nAlso Tornado will accept any valid header containing content-length less than 128MB - 1B any read until all the bytes are accepted. This will occur even if there are no matching request handlers... Maybe for the future Tornado would read these bytes on demand?\nIf Tornado is forwarded requests via nginx or others I would expect this not to be a issue...\nj", "issue_status": "Closed", "issue_reporting_time": "2013-11-07T09:45:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "881": {"issue_url": "https://github.com/tornadoweb/tornado/issues/930", "issue_id": "#930", "issue_summary": "Templates - Populated html attributes only quote the first word of a string", "issue_description": "joegoldbeck commented on 6 Nov 2013\n{% for sentence in ['multiple words are here']%}\n  <div class={{sentence}}></div>\n{% end %}\nResults in:\n<div class=\"multiple\" words are here></div>", "issue_status": "Closed", "issue_reporting_time": "2013-11-06T04:03:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "882": {"issue_url": "https://github.com/tornadoweb/tornado/issues/929", "issue_id": "#929", "issue_summary": "WebSocketClientConnection request timeout values", "issue_description": "ghost commented on 6 Nov 2013\n\"connect_timeout\" and \"request_timeout\" values are required in request for WebSocketClientConnection connection, but not documented in http://www.tornadoweb.org/en/stable/websocket.html#client-side-support\nWithout these timeout values getting 'unorderable types: NoneType() < NoneType()' error with this code below;\n    request = httpclient.HTTPRequest(\n        url = \"wss://...\",\n        method = \"GET\",\n        validate_cert = False,\n        client_key = \"/ca/client-key.pem\",\n        client_cert = \"/ca/client-cert.pem\")\n        #connect_timeout = 10,\n        #request_timeout = 10)\n    conn = websocket.WebSocketClientConnection(ioloop.IOLoop.current(), request)\n    conn.connect_future.add_done_callback(conncallback)", "issue_status": "Closed", "issue_reporting_time": "2013-11-05T19:23:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "883": {"issue_url": "https://github.com/tornadoweb/tornado/issues/927", "issue_id": "#927", "issue_summary": "Uninformative error doing GET with body, or POST without.", "issue_description": "Contributor\najdavis commented on 5 Nov 2013\nIf you GET a URL with a request body:\nyield http_client.fetch(url, body='data')\nTornado just raises AssertionError. Same for a POST with no body. This is a likely mistake for someone coming from a framework that automatically POSTs whenever a body is supplied. The traceback is no help:\n  File \"tornado/gen.py\", line 496, in run\n    next = self.yield_point.get_result()\n  File \"tornado/gen.py\", line 395, in get_result\n    return self.runner.pop_result(self.key).result()\n  File \"concurrent/futures/_base.py\", line 397, in result\n    return self.__get_result()\n  File \"concurrent/futures/_base.py\", line 356, in __get_result\n    raise self._exception\nAssertionError\nI think the asserts in SimpleHTTPClient should include a message about what the user did wrong. CurlHTTPClient should assert the same conditions, with the same messages.", "issue_status": "Closed", "issue_reporting_time": "2013-11-04T19:55:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "884": {"issue_url": "https://github.com/tornadoweb/tornado/issues/924", "issue_id": "#924", "issue_summary": "Calling Future.result() from synchronous function", "issue_description": "dzharkov commented on 31 Oct 2013\nHi!\nI've got some problems when using coroutine-based TracebackFuture in a synchronous function.\nFor example I have the following coroutine:\n   @gen.coroutine\n   def foo(url):\n           yield self.http_client.fetch(url)\nand synchronous function\n   def bar():\n      f = foo('http://google.com')\n      return f.result()\nThe first problem is that it freezes when I call f.result() becuase application works in a single thread and it becomes locked forever when self._condition.wait(timeout) is being called in a Future\nSecond Problem is that TracebackFuture overrides result()-method, so 'timeout' argument is unavailable when using @gen.coroutine.\nThank you for comments!\nP.S. Sorry for my poor english :(\n1", "issue_status": "Closed", "issue_reporting_time": "2013-10-31T17:00:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "885": {"issue_url": "https://github.com/tornadoweb/tornado/issues/922", "issue_id": "#922", "issue_summary": "Coroutines block on OS X 10.9", "issue_description": "jakubroztocil commented on 31 Oct 2013\nI'm fetching a URL with 10s delay using AsyncHTTPClient. The calls are blocking, however.\nimport tornado.ioloop\nimport tornado.web\nimport tornado.gen\nimport tornado.httpclient\n\n\nclass Handler(tornado.web.RequestHandler):\n\n    @tornado.gen.coroutine\n    def get(self):\n        print('START')\n        yield tornado.gen.Task(\n            tornado.httpclient.AsyncHTTPClient().fetch,\n            'https://httpbin.org/delay/10' \n        )\n        print('FINISH')\n        self.finish()\n\n\napp = tornado.web.Application(handlers=[('/', Handler)])\napp.listen(8888)\ntornado.ioloop.IOLoop.instance().start()\nTo test, I run it and open http://localhost:8888 in two browser tabs. This is the actual output:\n$ python test.py\nSTART\nFINISH\nSTART\nFINISH\nThe expected output is:\nSTART\nSTART\nFINISH\nFINISH\nTested on tornado==3.1.1, Python 2.7.5, OS X 10.9 Mavericks.\nThe same code tested on Ubuntu works as expected.", "issue_status": "Closed", "issue_reporting_time": "2013-10-30T22:28:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "886": {"issue_url": "https://github.com/tornadoweb/tornado/issues/921", "issue_id": "#921", "issue_summary": "missing exception handling from parse_body_arguments in httputil.py", "issue_description": "thehesiod commented on 26 Oct 2013\nThere are some sites which return invalid \"form\" data for type \"application/x-www-form-urlencoded\" which results in parse_body_arguments in python 3.3 throwing an exception while executing:\nuri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=True)\nwith the exception:\nUnicodeDecodeError: 'utf8' codec can't decode byte 0x82 in position 1: invalid start byte.\nlooking at the code I believe its meant to instead log a warning and continue since in many cases the callee is just expecting to look at the body text directly (like me), and not have the form data parsed.\nI fixed it temporarily with the following:\ntry:\n    uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=True)\nexcept:\n    gen_log.warning(\"Invalid application/x-www-form-urlencoded\")\n    uri_arguments = { }\nHere's the sample code that triggers this error with a server which reports a 599 error with body text chars >= 0x82:\nclass TransparentProxyHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'POST']\n\n    @tornado.web.asynchronous\n    def get(self):\n        def handle_response(response):\n            if response.error and not isinstance(response.error, tornado.httpclient.HTTPError):\n                self.set_status(500)\n                self.write('Internal server error:\\n' + str(response.error))\n                self.finish()\n            else:\n                self.set_status(response.code)\n                for header in response.headers:\n                    v = response.headers.get(header)\n                    if v:\n                        self.set_header(header, v)\n\n                if response.body: self.write(response.body)\n                self.finish()\n\n        req = tornado.httpclient.HTTPRequest(url=self.request.uri,\n                method=self.request.method, body=self.request.body,\n                headers=self.request.headers, follow_redirects=False,\n                allow_nonstandard_methods=True)\n\n        client = tornado.httpclient.AsyncHTTPClient()\n        try:\n            client.fetch(req, handle_response)\n        except tornado.httpclient.HTTPError as e:\n            if hasattr(e, 'response') and e.response:\n                handle_response(e.response)\n            else:\n                self.set_status(500)\n                self.write('Internal server error:\\n' + str(e))\n                self.finish()\n\n    @tornado.web.asynchronous\n    def post(self):\n        return self.get()\nThis is with tornado-3.1.1-py3.3. If this fix could be rolled in that would be awesome!\nHere's a monkey patched fix btw:\nimport tornado.httputil\n\nfrom tornado.escape import native_str, parse_qs_bytes, utf8\nfrom tornado.log import gen_log\ndef parse_body_arguments(content_type, body, arguments, files):\n    if content_type.startswith(\"application/x-www-form-urlencoded\"):\n        try:\n            uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=True)\n        except:\n            gen_log.warning(\"Invalid application/x-www-form-urlencoded\")\n            uri_arguments = { }\n\n        for name, values in uri_arguments.items():\n            if values:\n                arguments.setdefault(name, []).extend(values)\n    elif content_type.startswith(\"multipart/form-data\"):\n        fields = content_type.split(\";\")\n        for field in fields:\n            k, sep, v = field.strip().partition(\"=\")\n            if k == \"boundary\" and v:\n                tornado.httputil.parse_multipart_form_data(utf8(v), body, arguments, files)\n                break\n        else:\n            gen_log.warning(\"Invalid multipart/form-data\")\n\ntornado.httputil.parse_body_arguments = parse_body_arguments", "issue_status": "Closed", "issue_reporting_time": "2013-10-26T00:23:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "887": {"issue_url": "https://github.com/tornadoweb/tornado/issues/920", "issue_id": "#920", "issue_summary": "sys.stderr does not always have an attribute isatty()", "issue_description": "salientgreen commented on 26 Oct 2013\nTraceback (most recent call last):\nFile \"MEDIA_APP/server.py\", line 50, in\nmain();\nFile \"MEDIA_APP/server.py\", line 36, in main\ntornado.options.parse_command_line()\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/options.py\", line 511, in parse_command_line\nreturn options.parse_command_line(args, final=final)\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/options.py\", line 252, in parse_command_line\nself.run_parse_callbacks()\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/options.py\", line 313, in run_parse_callbacks\ncallback()\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 331, in wrapped\nraise_exc_info(exc)\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 302, in wrapped\nret = fn(_args, *_kwargs)\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/log.py\", line 179, in enable_pretty_logging\nchannel.setFormatter(LogFormatter())\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/log.py\", line 79, in init\nself._color = color and _stderr_supports_color()\nFile \"/var/www/media_server/venv/local/lib/python2.7/site-packages/tornado/log.py\", line 54, in _stderr_supports_color\nif curses and sys.stderr.isatty():\nAttributeError: 'UnicodeStdout' object has no attribute 'isatty'\nI patched this locally to resolve the issue. I'm not positive this is the best way to handle it but the server runs.\nBefore\n51\n52    def _stderr_supports_color():\n53        color = False\n54        if curses and sys.stderr.isatty():\n55            try:\n56                curses.setupterm()\nAfter\n51\n52    def _stderr_supports_color():\n53        color = False\n54        if curses and hasattr(sys.stdout, \"isatty\") and sys.stderr.isatty():\n55            try:\n56                curses.setupterm()", "issue_status": "Closed", "issue_reporting_time": "2013-10-25T20:42:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "888": {"issue_url": "https://github.com/tornadoweb/tornado/issues/919", "issue_id": "#919", "issue_summary": "RequestHandler doesn't parse HTTP PUT arguments from body", "issue_description": "y4n9squared commented on 25 Oct 2013\nIn a PUT, self.request.body contains the correct request body but self.request.arguments is missing all of the fields, causing self.get_argument to throw.\nExample\nput_data = {\n    'arg1': 'foo',\n    'arg2': 'bar'\n}\nbody = urllib.urlencode(put_data)\nhttp_client.fetch(\"/\", method = \"PUT\", body = body)\n\nclass MyRequestHandler(RequestHandler):\n    def put(self):\n         # self.request.body shows 'arg1=foo&arg2=bar' but self.request.arguments is {}\n        self.get_argument(\"arg1\")\nI saw a fix for a related issue from many years ago.\nAm I missing something?", "issue_status": "Closed", "issue_reporting_time": "2013-10-25T18:21:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "889": {"issue_url": "https://github.com/tornadoweb/tornado/issues/918", "issue_id": "#918", "issue_summary": "IOLoop NotImplemented", "issue_description": "desprezj commented on 25 Oct 2013\nHello,\nI was looking at the new Tornado 3.1 against Tornado 2.4 that I am using.\nThere are still a lot of methods in IOLoop of Tornado 3.1 that are NotImplemented yet.\nIs it planned to implement them soon?\n(add_handler, timeout, ...)\nThanks for your help", "issue_status": "Closed", "issue_reporting_time": "2013-10-25T16:20:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "890": {"issue_url": "https://github.com/tornadoweb/tornado/issues/917", "issue_id": "#917", "issue_summary": "Warning: no previously-included files matching '_auto2to3*'", "issue_description": "zourbuth commented on 23 Oct 2013\nI have this error twice while installing on Windows platform:\nwarning: no previously-included files matching '_auto2to3*' found anywhere i\nn distribution\nAny idea? Thank You.", "issue_status": "Closed", "issue_reporting_time": "2013-10-23T04:23:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "891": {"issue_url": "https://github.com/tornadoweb/tornado/issues/916", "issue_id": "#916", "issue_summary": "Why stop when retrieve 403", "issue_description": "leon4py commented on 22 Oct 2013\ncoding=utf-8\nfrom tornado import gen\nimport tornado.ioloop\nimport tornado.httpclient\n@gen.coroutine\ndef rqbaidu():\nurl = 'http://iou99.tk'\nhttp_cli = tornado.httpclient.AsyncHTTPClient()\nresp = yield http_cli.fetch(url) #stop here\nprint resp\nif resp.error:\nprint 'error'\nelse:\nprint resp.body + \"----\"\nif name == 'main':\nf = rqbaidu()\ntornado.ioloop.IOLoop.instance().start()\nAs the code show above, this should print 'error' or resp.body,\nbut this program stop at 'resp = yield http_cli.fetch(url) #stop here'\nWhy, a bug??", "issue_status": "Closed", "issue_reporting_time": "2013-10-22T03:01:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "892": {"issue_url": "https://github.com/tornadoweb/tornado/issues/914", "issue_id": "#914", "issue_summary": "Allow users to set JSONEncoder", "issue_description": "dizlv commented on 14 Oct 2013\nCurrently json_encode mehtod doesn't allow to set JSONEncoder, though it could be very useful. For example, SELECT statement returns datetime objects, which by default can not be serialized by json_encode. For this purposes you need to write something like this:\nclass DateTimeEncoder(json.JSONEncoder):\n    \"\"\"\n    JSONEncoder. Allows to JSONIFY datetime objects.\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            return obj.isoformat()\n        return json.JSONEncoder.default(self, obj)\nAnd then use json.dumps(obj, cls=DateTimeEncoder).", "issue_status": "Closed", "issue_reporting_time": "2013-10-13T22:41:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "893": {"issue_url": "https://github.com/tornadoweb/tornado/issues/909", "issue_id": "#909", "issue_summary": "Allow UIModules to accept child html", "issue_description": "Contributor\nysimonson commented on 7 Oct 2013\nThere could be many new use-cases for UIModules if they could accept child template logic, like blocks.\ne.g. it would be pretty nice if you could wrap up the html involved in rendering a bootstrap modal into a UIModule, but it would have to take a potentially long html string as its body. If the UIModule could instead accept a body parameter in its render() method that includes the rendered template logic, you could do something like this:\n{% module FrameModalRenderer(\"modal title\", buttons=[\"close\", \"save\"]) %}\n  <p>this is the modal body</p>\n{% end %}\nWhich would generate something like this:\n<div class=\"modal fade\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\">&times;</button>\n        <h4 class=\"modal-title\">modal title</h4>\n      </div>\n      <div class=\"modal-body\">\n        <p>this is the modal body</p>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn\">close</button>\n        <button type=\"button\" class=\"btn\">save</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->\nAs it stands now, UIModules are not practical for such a use case as the html body would have to be passed in as a parameter.\nAngular.js allows for a similar mechanism when defining new elements. The big gain out of this is that people can wrap their favorite libraries' (e.g. bootstrap's) required html - severely reducing the amount of copypasta code - and reduce the burden of breaking changes made by the libraries themselves - e.g. from bootstrap 2 to 3.", "issue_status": "Closed", "issue_reporting_time": "2013-10-07T17:54:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "894": {"issue_url": "https://github.com/tornadoweb/tornado/issues/906", "issue_id": "#906", "issue_summary": "How to implement Flash socket policy server ?", "issue_description": "dhanababu-nyros commented on 24 Sep 2013\nI am currently working on whiteboard app. I am implemented app using Websocket using Tornado framework. The app working on IE10, because it supports WS protocol. But I need to give the support for IE9. But IE9 didn't support WS protocol. So for support IE9 am using Flash socket policy(https://github.com/gimite/web-socket-js).\nBut I got this error as shown below,\n[WebSocket] cannot connect to Web Socket server at ws://localhost/realtime/ (SecurityError: Error #2048)\nmake sure the server is running and Flash socket policy file is correctly placed\nIs there any builtin flash socket policy server ? Please help me. Thanks.", "issue_status": "Closed", "issue_reporting_time": "2013-09-24T09:53:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "895": {"issue_url": "https://github.com/tornadoweb/tornado/issues/905", "issue_id": "#905", "issue_summary": "use cygwin to install tornado,the 'Hello Word' don't run!!!", "issue_description": "coffeesweet commented on 24 Sep 2013\nI use cygwin to install tornado,python's version is 2.7.5 eg:\n$pip install tornado\nit's success(warning: no previously-included files matching '_auto2to3*' found anywhere in distribution)\nthen ,I try to run \"Hello\", eg:\n$ python foo.py\n$\nthere is no any info to show!!!,the listenner don't run yet\nthe foo.py 's content is:\nimport tornado.ioloop\nimport tornado.web\nclass MainHandler(tornado.web.RequestHandler):\ndef get(self):\nself.write(\"Hello, world\")\napplication = tornado.web.Application([\n(r\"/\", MainHandler),\n])\nif name == \"main\":\napplication.listen(8888)\ntornado.ioloop.IOLoop.instance().start()", "issue_status": "Closed", "issue_reporting_time": "2013-09-24T01:26:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "896": {"issue_url": "https://github.com/tornadoweb/tornado/issues/901", "issue_id": "#901", "issue_summary": "Download pdf file in IE10 is not working", "issue_description": "dhanababu-nyros commented on 17 Sep 2013\nI am currently working in tornado and python3.2+. I have the pdf download in tornado. When I click save button in my app the file is downloaded(Chrome and Firefox) but not working in IE10. I am using async websocket programming. Please see the below error,\nProcessing event save\nDEBUG:websocket:Processing event save\nERROR:tornado.application:Uncaught exception in /realtime/\nTraceback (most recent call last):\nFile \"/usr/lib/python3.2/xml/etree/ElementTree.py\", line 1668, in feed\nself._parser.Parse(data, 0)\nxml.parsers.expat.ExpatError: duplicate attribute: line 1, column 112\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\nFile \"/home/dhana/WhiteBoard/elocon-env/lib/python3.2/site-packages/tornado/websocket.py\", line 303, in wrapper\nreturn callback(_args, *_kwargs)\nFile \"/home/dhana/WhiteBoard/collabdraw/websockethandler.py\", line 109, in on_message\nx = svg2pdf(svg, write_to='test.pdf')\nFile \"/home/dhana/WhiteBoard/elocon-env/lib/python3.2/site-packages/cairosvg/init.py\", line 43, in\nsurface_type.convert(_args, *_kwargs))(_surface_type)\nFile \"/home/dhana/WhiteBoard/elocon-env/lib/python3.2/site-packages/cairosvg/surface/init.py\", line 74, in convert\ntree = Tree(**kwargs)\nFile \"/home/dhana/WhiteBoard/elocon-env/lib/python3.2/site-packages/cairosvg/parser.py\", line 167, in init\ntree = ElementTree.fromstring(bytestring)\nFile \"/usr/lib/python3.2/xml/etree/ElementTree.py\", line 1337, in XML\nparser.feed(text)\nFile \"/usr/lib/python3.2/xml/etree/ElementTree.py\", line 1670, in feed\nself._raiseerror(v)\nFile \"/usr/lib/python3.2/xml/etree/ElementTree.py\", line 1543, in _raiseerror\nraise err\nFile \"\", line None\nxml.etree.ElementTree.ParseError: duplicate attribute: line 1, column 112\nLeaving room one\nAnd I got the browser error,\nWebSocket Error: Network Error 12030, The connection with the server was terminated abnormally", "issue_status": "Closed", "issue_reporting_time": "2013-09-17T10:37:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "897": {"issue_url": "https://github.com/tornadoweb/tornado/issues/899", "issue_id": "#899", "issue_summary": "Incorrect date in date header", "issue_description": "gabtremblay commented on 16 Sep 2013\nweb.py\n245: # set the date header\n\"Date\": httputil.format_timestamp(time.time()),\nWill fall in httputil to:\nif isinstance(ts, numbers.Real):\npass\nWhich will call :\nemail.utils.formatdate(time.time(), usegmt=True)\n'Mon, 16 Sep 2013 12:42:11 GMT'\nSadly, the correct time would be\n'Mon, 16 Sep 2013 08:42:11 GMT'\nThe reason is because python email.utils.formatdate does not use localtime by default.\nOne could be tempted to use\nemail.utils.formatdate(time.time(), localtime=True, usegmt=True)\nbut this makes python ignore the \"usegmt=True\".\nit then output the correct date, in the wrong format:\n'Mon, 16 Sep 2013 08:52:57 -0400'\nThe right call would be\nemail.utils.formatdate(calendar.timegm(time.localtime()), usegmt=True)\nAnd in order for this to happen, the easyest way is to replace in web.py@245\n\"Date\": httputil.format_timestamp(time.time()),\nwith\n\"Date\": httputil.format_timestamp(time.localtime()),", "issue_status": "Closed", "issue_reporting_time": "2013-09-16T12:57:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "898": {"issue_url": "https://github.com/tornadoweb/tornado/issues/897", "issue_id": "#897", "issue_summary": "Websocket + Proxy = Method not supported for Web Sockets", "issue_description": "mrsinham commented on 6 Sep 2013\nIf I call a websocket created by tornado behind a proxy (Squid in this case), I have this error :\n2013-09-06 15:09:23,834 Exception in callback <functools.partial object at 0x134da48>\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 458, in _run_callback\n    callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 331, in wrapped\n    raise_exc_info(exc)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 302, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 341, in wrapper\n    callback(*args)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 331, in wrapped\n    raise_exc_info(exc)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 302, in wrapped\n    ret = fn(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/httpserver.py\", line 327, in _on_headers\n    self.request_callback(self._request)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1567, in __call__\n    handler = spec.handler_class(self, request, **spec.kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 102, in __init__\n    **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 143, in __init__\n    self.clear()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 253, in clear\n    self.set_header(\"Connection\", \"Keep-Alive\")\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 268, in _not_supported\n    raise Exception(\"Method not supported for Web Sockets\")\nException: Method not supported for Web Sockets\nEverything is fine without the proxy. Any idea ? Thanks !", "issue_status": "Closed", "issue_reporting_time": "2013-09-06T13:18:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "899": {"issue_url": "https://github.com/tornadoweb/tornado/issues/895", "issue_id": "#895", "issue_summary": "Daemon mode in Tornado ?", "issue_description": "dhanababu-nyros commented on 2 Sep 2013\nI am new to tornado. I need to start the tornado server in daemon mode.Is any built-in packages in tornado for daemon.", "issue_status": "Closed", "issue_reporting_time": "2013-09-02T12:05:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "900": {"issue_url": "https://github.com/tornadoweb/tornado/issues/894", "issue_id": "#894", "issue_summary": "How to redirect page after header set ?", "issue_description": "dhanababu-nyros commented on 28 Aug 2013\nI am new to tornado. I want to reload the page after downloading the file. How can I solve this. Please any one help me thanks. Please see my code as shown below,\nclass MainHandler(tornado.web.RequestHandler):\ndef get(self, token_id):\nself.set_header('Content-Type', 'application/pdf')\nself.set_header('Content-Disposition', 'attachment; filename=\"drawing-%s.pdf\"' % token_id)\nwith open(\"test.pdf\", 'rb') as f:\nwhile True:\ndata = f.read()\nif not data:\nbreak\nself.write(data)\nself.finish()\nself.redirect('/index')\nAnd I got the error \"Exception: Cannot redirect after headers have been written\".", "issue_status": "Closed", "issue_reporting_time": "2013-08-28T10:34:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "901": {"issue_url": "https://github.com/tornadoweb/tornado/issues/893", "issue_id": "#893", "issue_summary": "netutil.is_valid_ip() Returns True on Blank String", "issue_description": "moloch-- commented on 25 Aug 2013\n>>> from tornado import netutil\n>>> netutil.is_valid_ip(\"\")\nTrue", "issue_status": "Closed", "issue_reporting_time": "2013-08-24T19:51:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "902": {"issue_url": "https://github.com/tornadoweb/tornado/issues/890", "issue_id": "#890", "issue_summary": "Websocket close reason", "issue_description": "kzahel commented on 23 Aug 2013\nIn an old branch I had I was using websocket close reason. It was pretty convenient sometimes. It would be simple to add.\nhttps://github.com/kzahel/tornado_gen/blob/master/tornado/websocket.py#L646\nspec says there's an optional reason!\nhttp://www.w3.org/TR/2011/WD-websockets-20110929/#dom-closeevent-reason", "issue_status": "Closed", "issue_reporting_time": "2013-08-23T05:50:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "903": {"issue_url": "https://github.com/tornadoweb/tornado/issues/886", "issue_id": "#886", "issue_summary": "How to download the pdf file ?", "issue_description": "dhanababu-nyros commented on 21 Aug 2013\nHere I am try to download the pdf file using below code,\nclass MainHandler(tornado.web.RequestHandler):\ndef get(self):\nwith open('test.pdf', 'r') as f:\nself.set_header(\"Content-Type\", 'application/pdf; charset=\"utf-8\"')\nself.set_header(\"Content-Disposition\", \"attachment; filename=test.pdf\")\nself.write(f.read())\nBut it gives the below error,\nUnicodeDecodeError: 'utf8' codec can't decode byte 0xb5 in position 10: invalid start byte\nPlease solve my problem.", "issue_status": "Closed", "issue_reporting_time": "2013-08-21T12:08:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "904": {"issue_url": "https://github.com/tornadoweb/tornado/issues/883", "issue_id": "#883", "issue_summary": "Is there something wrong with the alias for render_string of templates?", "issue_description": "SZ-Edward commented on 19 Aug 2013\nWhy does tornado.escape.xhtml_escape have two different aliases? (See Templates)\nExpressions can be any Python expression, including function calls. Template code is executed in a namespace that includes the following objects and functions (Note that this list applies to templates rendered using RequestHandler.render and render_string. If you're using the template module directly outside of a RequestHandler many of these entries are not present).\nescape: alias for tornado.escape.xhtml_escape\nxhtml_escape: alias for tornado.escape.xhtml_escape", "issue_status": "Closed", "issue_reporting_time": "2013-08-19T07:50:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "905": {"issue_url": "https://github.com/tornadoweb/tornado/issues/882", "issue_id": "#882", "issue_summary": "web.__call__'s usage of escape.url_unescape", "issue_description": "dkador commented on 18 Aug 2013\nI'm upgrading my app from Tornado 2.4.1 to 3.1. Everything's pretty smooth, with one caveat (and I didn't see this listed in the release notes anywhere):\nIn web.call, it looks like @bdarnell changed the default behavior of escape.url_unescape to pass plus=False along (see 917fe80). I understand that this is technically correct behavior according to spec. But it broke some of my tests, which means this is a backwards-incompatible change. Obviously I was relying on incorrect behavior, but I wanted to raise attention to this.\nI can change my app without too much trouble. That being said, if @bdarnell wants to retain old behavior from Tornado < 3.1, then a fix may be required here. What do you think, Ben?", "issue_status": "Closed", "issue_reporting_time": "2013-08-18T05:37:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "906": {"issue_url": "https://github.com/tornadoweb/tornado/issues/881", "issue_id": "#881", "issue_summary": "StaticFileHandler", "issue_description": "wmslei commented on 17 Aug 2013\nI want to use StaticFileHandler serve pircure and audio files, Whether it is necessary to use @tornado.web.asynchronous decorate the 'get' method in StaticFileHandler.", "issue_status": "Closed", "issue_reporting_time": "2013-08-17T13:00:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "907": {"issue_url": "https://github.com/tornadoweb/tornado/issues/880", "issue_id": "#880", "issue_summary": "{% module Template(...) %} broken in v3.1.0 with global name '_tt_modules' is not defined", "issue_description": "ichernev commented on 15 Aug 2013\nhttps://gist.github.com/ichernev/6242609", "issue_status": "Closed", "issue_reporting_time": "2013-08-15T17:12:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "908": {"issue_url": "https://github.com/tornadoweb/tornado/issues/879", "issue_id": "#879", "issue_summary": "How to handle the self.ws_connection.write_message ?", "issue_description": "dhanababu-nyros commented on 15 Aug 2013\nI am using the tornado-3.1. I am getting the error as shown below,\nException in thread Thread-1:\nTraceback (most recent call last):\nFile \"/usr/lib/python3.2/threading.py\", line 740, in _bootstrap_inner\nself.run()\nFile \"/usr/lib/python3.2/threading.py\", line 693, in run\nself._target(_self._args, *_self._kwargs)\nFile \"/home/nyros/Desktop/python3/whiteboard/websockethandler.py\", line 44, in redis_listener\nlistener.send_message(message['data'])\nFile \"/home/nyros/Desktop/python3/whiteboard/websockethandler.py\", line 149, in send_message\nself.write_message(message)\nFile \"/home/nyros/Desktop/python3/venv3/lib/python3.2/site-packages/tornado/websocket.py\", line 165, in write_message\nself.ws_connection.write_message(message, binary=binary)\nAttributeError: 'NoneType' object has no attribute 'write_message'\nIs it version problem or my own code problem. Please solve my problem ?", "issue_status": "Closed", "issue_reporting_time": "2013-08-15T13:54:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "909": {"issue_url": "https://github.com/tornadoweb/tornado/issues/878", "issue_id": "#878", "issue_summary": "It should be possible to add future without callback", "issue_description": "Kentzo commented on 15 Aug 2013\nImagine we're enumerating millions of records and we need to schedule processing for each of them via futures.\nRather than accumulating futures and therefore waiting unless enumuration ends (which itself uses futures) it should be possible to add future to the loop inplace.\nRight now, the dirty hack is to call IOLoop().current().add_future(future, _empty_future_callback). where empty future callback does nothing. add_future should allow (and default to) None callback.", "issue_status": "Closed", "issue_reporting_time": "2013-08-15T12:49:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "910": {"issue_url": "https://github.com/tornadoweb/tornado/issues/877", "issue_id": "#877", "issue_summary": "Chinese character error", "issue_description": "wmslei commented on 15 Aug 2013\nI use get_argument method get the post argument\nlike: name = self.get_argument('name', None)\nand I post the name as Chinese character like \u201c\u6d4b\u8bd5\u59d3\u540d\u201d\nthen I set r = hashlib.sha1(name).hexdigest()\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)\nNeed your help, Thanks.", "issue_status": "Closed", "issue_reporting_time": "2013-08-15T10:45:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "911": {"issue_url": "https://github.com/tornadoweb/tornado/issues/876", "issue_id": "#876", "issue_summary": "AsyncHttpClient how to make a request with login cookies?", "issue_description": "toplinuxsir commented on 14 Aug 2013\nAsyncHttpClient how to make a request with login cookies?\nfor example:\nI want to download something from url, but the url need logined cookies , so first request url1 (login url) and get the cookies ,and then make the url request,\nbut how to do that in coding ?", "issue_status": "Closed", "issue_reporting_time": "2013-08-14T00:55:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "912": {"issue_url": "https://github.com/tornadoweb/tornado/issues/875", "issue_id": "#875", "issue_summary": "ThreadedResolver race condition on IOLoop shutdown", "issue_description": "Member\nbdarnell commented on 13 Aug 2013\nThere is an occasional race condition in the tests when the IOLoop is shut down and a ThreadedResolver is used. The error message is \"IOError: close() called during concurrent operation on the same file object.\"\nThe problem is that in the worker thread, add_callback releases the lock before writing to the waker pipe. If the IOLoop happens to wake up for other reasons it could run the callback and proceed to the end of the test (which closes the reactor) before the worker thread writes to the waker pipe (There is probably something else going on since I see this happening more often than I would expect from the timing involved).\nPossible fixes include shutting down the threadpool after every test (i.e. undoing be52944 and slowing down the test suite), or holding the callback_lock while writing to the waker pipe (increasing contention on the callback_lock but reducing redundant writes to the pipe)", "issue_status": "Closed", "issue_reporting_time": "2013-08-13T04:50:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "913": {"issue_url": "https://github.com/tornadoweb/tornado/issues/871", "issue_id": "#871", "issue_summary": "Windows support in documentation", "issue_description": "Contributor\nschlamar commented on 9 Aug 2013\nWhy is the existent Windows support not mentioned in the documentation?", "issue_status": "Closed", "issue_reporting_time": "2013-08-09T07:17:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "914": {"issue_url": "https://github.com/tornadoweb/tornado/issues/870", "issue_id": "#870", "issue_summary": "websocket on_close in slug?", "issue_description": "mehmetkose commented on 8 Aug 2013\nHello, I would like to send WebSocket listeners with the flow of the page only.\nthe most logical way to do this is to use the structure of slug and I think dictionary.\ne.g :\nlistenners = {\n\"page-234\" : [client1, client2, client3],\n\"page-235\" : [client5, client4, client2],\n\"page-236\" : [client7, client2, client1]\n}\nI've added a list of the listener into a connection is established.\nSlug with a key provided in the open.\nclass UpdateHandler(tornado.websocket.WebSocketHandler,BaseHandler):\ncache = []\ncache_size = 200\nlistenners = {}\ndef open(self,slug):\n    try:\n        UpdateHandler.listenners[slug].append(self)\n    except Exception, e:\n        UpdateHandler.listenners[slug] = []\n        UpdateHandler.listenners[slug].append(self)\n\ndef on_close(self,slug):\n    UpdateHandler.listenners[slug].remove(self)\n\n.....\n.....\non_close in a get slug, causes error.\n[E 130807 20:43:34 iostream:308] Uncaught exception, closing connection.\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-2.4-py2.7.egg/tornado/iostream.py\", line 305, in wrapper\ncallback(_args)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-2.4-py2.7.egg/tornado/websocket.py\", line 229, in on_connection_close\nself.on_close()\nTypeError: on_close() takes exactly 2 arguments (1 given)\n[E 130807 20:43:34 ioloop:435] Exception in callback <tornado.stack_context._StackContextWrapper object at 0x953ecac>\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-2.4-py2.7.egg/tornado/ioloop.py\", line 421, in _run_callback\ncallback()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-2.4-py2.7.egg/tornado/iostream.py\", line 305, in wrapper\ncallback(_args)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-2.4-py2.7.egg/tornado/websocket.py\", line 229, in on_connection_close\nself.on_close()\nTypeError: on_close() takes exactly 2 arguments (1 given)\non_close can slug you think should be made?", "issue_status": "Closed", "issue_reporting_time": "2013-08-08T14:41:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "915": {"issue_url": "https://github.com/tornadoweb/tornado/issues/868", "issue_id": "#868", "issue_summary": "Accept international RFC 2231 headers", "issue_description": "Contributor\ngagern commented on 7 Aug 2013\nRFC 2388 Section 4.4 states:\nif the file name of the sender's operating system is not in US-ASCII, the file name might be approximated, or encoded using the method of RFC 2231.\nThe current tornado.httputil._parse_header implementation does not allow for the second of these alternatives: it does not properly decode a header of the form\nContent-Disposition: form-data; name=\"fieldname\";\n file*=utf-8''T%C3%A4st.txt\nThe same holds for non-ascii names of form fields. You can use the email.utils.decode_params function to perform this kind of decoding, as well as handle the continuations described in that same RFC.\nThis report here is the counterpart to urllib3/urllib3#119, where this bug caused a test to fail once a proper standards-conforming encoding was implemented.", "issue_status": "Closed", "issue_reporting_time": "2013-08-07T02:12:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "916": {"issue_url": "https://github.com/tornadoweb/tornado/issues/867", "issue_id": "#867", "issue_summary": "Add spawn_callback method", "issue_description": "Member\nbdarnell commented on 5 Aug 2013\nThe NullContext/add_callback dance required to break free of a surrounding stack context is non-obvious and verbose; we should add a helper method to do the equivalent of\nwith NullContext():\nio_loop.add_callback(callback)\nIn the actual implementation this could be reversed, since all that's needed is to remove the stack_context.wrap:\ndef add_callback(self, callback):\nself.spawn_callback(stack_context.wrap(callback))\nDiscussion: https://groups.google.com/forum/#!searchin/python-tornado/abuse$20of$20prepare/python-tornado/iBt7He2KZ40/pApgKFdya9YJ", "issue_status": "Closed", "issue_reporting_time": "2013-08-04T19:31:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "917": {"issue_url": "https://github.com/tornadoweb/tornado/issues/866", "issue_id": "#866", "issue_summary": "Better error message for fetch() on closed AsyncHTTPClient", "issue_description": "Member\nbdarnell commented on 5 Aug 2013\nCalling fetch() on a closed AsyncHTTPClient raises a confusing error message (AttributeError on NoneType). This is made doubly confusing by the magic instance-sharing (in which case the close probably happened on what looks like a completely different instance). This should raise a more explicit error and the docs should be updated to explicitly discourage the use of AsyncHTTPClient.close.\nDiscussion: https://groups.google.com/forum/#!searchin/python-tornado/asynchttpclient$20only$20first$20request$20works/python-tornado/42r2Cxv90Aw/N_8LXTIzKXIJ", "issue_status": "Closed", "issue_reporting_time": "2013-08-04T19:26:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "918": {"issue_url": "https://github.com/tornadoweb/tornado/issues/863", "issue_id": "#863", "issue_summary": "tornado.escape.json_encode should allow to pass ensure_ascii", "issue_description": "Kentzo commented on 2 Aug 2013\nIt would be useful, because in unicode app you cannot rely on default behavior.", "issue_status": "Closed", "issue_reporting_time": "2013-08-01T19:13:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "919": {"issue_url": "https://github.com/tornadoweb/tornado/issues/862", "issue_id": "#862", "issue_summary": "Handling Transfer-Encoding: chunked requests", "issue_description": "kzahel commented on 31 Jul 2013\nI was using python httplib, which by default does POST multipart requests using transfer-encoding: chunked. Tornado unfortunately triggers the application request callback before reading the POST body (which is chunked, and may actually never finish, if the requester is bad :-). I could see how this could cause buffer overflows, so perhaps leaving this out was intentional?\nWould you be open to me consider a patch and pull request to httpserver.py to handle this case?", "issue_status": "Closed", "issue_reporting_time": "2013-07-30T20:29:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "920": {"issue_url": "https://github.com/tornadoweb/tornado/issues/861", "issue_id": "#861", "issue_summary": "IOStream.connect((hostname, port)) does blocking DNS resolution", "issue_description": "Member\nbdarnell commented on 26 Jul 2013\nThis method should be updated to use a Resolver before connecting (moving the relevant logic from SimpleAsyncHTTPClient)", "issue_status": "Closed", "issue_reporting_time": "2013-07-26T18:21:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "921": {"issue_url": "https://github.com/tornadoweb/tornado/issues/860", "issue_id": "#860", "issue_summary": "IOLoop should provide thread safe method to check whether it's running", "issue_description": "Kentzo commented on 19 Jul 2013\nIt would be handy e.g. to check from a secondary ioloop whether main ioloop is running and if not, stop itself.", "issue_status": "Closed", "issue_reporting_time": "2013-07-19T14:28:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "922": {"issue_url": "https://github.com/tornadoweb/tornado/issues/855", "issue_id": "#855", "issue_summary": "SSLIOStream doesn't automatically initiate handshake", "issue_description": "Contributor\npitrou commented on 17 Jul 2013\nTitle says it all. This is apparently a known issue, since iostream_test has an explicit workaround for it:\n        if isinstance(streams[0], SSLIOStream):\n            # HACK: The SSL handshake won't complete (and\n            # therefore the client connect callback won't be\n            # run)until the server side has tried to do something\n            # with the connection.  For these tests we want both\n            # sides to connect before we do anything else with the\n            # connection, so we must cause some dummy activity on the\n            # server.  If this turns out to be useful for real apps\n            # it should have a cleaner interface.\n            streams[0]._add_io_state(IOLoop.READ)\nbut, still, it would be better if this were fixed. Not only because doing the handshake as soon as possible is better for latency, but also because there are situations where this behaviour is annoying: i.e. you're waiting for the connection to be established before doing something with it, but it won't be marked established before you do something with it (so as to initiate the handshake).", "issue_status": "Closed", "issue_reporting_time": "2013-07-17T12:45:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "923": {"issue_url": "https://github.com/tornadoweb/tornado/issues/854", "issue_id": "#854", "issue_summary": "Passing content-length header to GET from tornado 3.0.1 throws 500 internal server error", "issue_description": "sunitav commented on 16 Jul 2013\nMaking a simple GET request with the Python requests library version 1.1.0 (that includes the default header 'Content-Length':'0') causes the Tornado server 3.0.1 to throw a 500 internal server error.", "issue_status": "Closed", "issue_reporting_time": "2013-07-16T11:12:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "924": {"issue_url": "https://github.com/tornadoweb/tornado/issues/852", "issue_id": "#852", "issue_summary": "POST requests are much slower than GET", "issue_description": "Contributor\nccampbell commented on 13 Jul 2013\nI'm pretty sure this is related to #685, but wanted to file a ticket for it separately.\nAt @vimeo we are in the process of rolling out a new application built on top of Tornado.\nI had noticed in our New Relic monitoring that our POST requests seem to be some of the slowest requests even though they don't actually do much at all. New Relic marks the time spent as Tornado/Request/Input. After speaking with them they explained that it is time spent pre reading the request content before it is actually passed off to the request handler function.\nAs a test I switched some of these log requests to use GET and the average response time decreased from around 20-30ms to 3ms. You can see it in the following graphs:\nPOST\nGET\nAll I added to the handler was\n@tornado.web.asynchronous\n@tornado.gen.engine\ndef get(self, log_type):\n    return self.post(log_type)\nIt would be nice to get this patched since using GET to send log data to the server doesn't feel quite right.\nThanks", "issue_status": "Closed", "issue_reporting_time": "2013-07-12T19:31:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "925": {"issue_url": "https://github.com/tornadoweb/tornado/issues/850", "issue_id": "#850", "issue_summary": "Error when using TwitterMixin from 3.1 version.", "issue_description": "fspirit commented on 11 Jul 2013\nI get TypeError: _on_request_token() takes exactly 5 arguments (4 given).", "issue_status": "Closed", "issue_reporting_time": "2013-07-11T11:51:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "926": {"issue_url": "https://github.com/tornadoweb/tornado/issues/849", "issue_id": "#849", "issue_summary": "Leaking file descriptors when using asynchronous stdin STREAM", "issue_description": "FZambia commented on 11 Jul 2013\nHello!\nPlease, look at this code example. I've tested it on Centos 6 and Ubuntu 12.04 using current master branch of Tornado.\nfrom __future__ import print_function\nfrom tornado.gen import Task, Return, coroutine\nfrom tornado.ioloop import IOLoop\nimport tornado.process\nimport os\n\n\nSTREAM = tornado.process.Subprocess.STREAM\n\n\n@coroutine\ndef call_subprocess(cmd, stdin_data=None):\n\n    sub_process = tornado.process.Subprocess(\n        cmd, stdin=STREAM, stdout=STREAM, stderr=STREAM\n    )\n\n    if stdin_data:\n        yield Task(sub_process.stdin.write, stdin_data)\n        sub_process.stdin.close()\n\n    result, error = yield [\n        Task(sub_process.stdout.read_until_close),\n        Task(sub_process.stderr.read_until_close)\n    ]\n\n    raise Return((result, error))\n\n\n@coroutine\ndef main():\n\n    pid = os.getpid()\n    cmd = ['ls', '/proc/%s/fd' % pid]\n\n    for i in range(100):\n        yield call_subprocess('wc', stdin_data=\"123\\n\")\n        result, error = yield call_subprocess(cmd)\n        print('num of fds:', len(result.split('\\n')))\n\n    print('process pid:', pid)\n\nif __name__ == \"__main__\":\n    ioloop = IOLoop.instance()\n    ioloop.add_callback(main)\n    ioloop.start()\nOn my machine output is something like:\n...\nnum of fds: 107\nnum of fds: 108\nnum of fds: 109\nprocess pid: 17548\nFile descriptors not closing and remain open which leads to leaking. Or am I doing something wrong?", "issue_status": "Closed", "issue_reporting_time": "2013-07-11T09:22:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "927": {"issue_url": "https://github.com/tornadoweb/tornado/issues/846", "issue_id": "#846", "issue_summary": "pycurl dependence", "issue_description": "pythonmobile commented on 7 Jul 2013\nAre there any plans to get rid of pycurl dependence. Doesn't look like its an alive project?", "issue_status": "Closed", "issue_reporting_time": "2013-07-07T18:10:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "928": {"issue_url": "https://github.com/tornadoweb/tornado/issues/844", "issue_id": "#844", "issue_summary": "PollIOLoop.start still holds on to memory while blocking", "issue_description": "mjhostet commented on 6 Jul 2013\nThe fix to #836 is inadequate.\nAs in my suggested patch, the \"callback\" variable needs to be cleared in addition to \"callbacks\". In Python, loop iteration variables like \"callback\" continue to hold the value of the last iteration even after the loop ends, so even after this fix the most recently executed callback will still be prevented from being garbage collected until another callback is received.", "issue_status": "Closed", "issue_reporting_time": "2013-07-06T14:16:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "929": {"issue_url": "https://github.com/tornadoweb/tornado/issues/843", "issue_id": "#843", "issue_summary": "Support for wrapping extend in if statement", "issue_description": "Contributor\nstevepeak commented on 3 Jul 2013\nRequest to support the following example:\n{% if True %}\n  {% extends \"base.html\" %}\n{% end %}\n{% block title %}A bolder title{% end %}\n\n{% block student %}\n  <li><span style=\"bold\">{{ escape(student.name) }}</span></li>\n{% end %}\nNotice how the {% extends \"base.html\" %} is wrapped in an if statement. This enhancement is nice for documents that are requested via ajax and do not need the full body or extended template to be included.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2013-07-03T16:46:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "930": {"issue_url": "https://github.com/tornadoweb/tornado/issues/842", "issue_id": "#842", "issue_summary": "except BaseException instead of Exception", "issue_description": "Contributor\nFlorianLudwig commented on 2 Jul 2013\nI suggest using try/except on BaseException instead of Exception. Since currently if a custom exception (accidentally) inherits from BaseException instead of Exception and gets thrown the tornado server comes to a halt - which I think should not happen under any circumstances.", "issue_status": "Closed", "issue_reporting_time": "2013-07-02T15:55:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "931": {"issue_url": "https://github.com/tornadoweb/tornado/issues/841", "issue_id": "#841", "issue_summary": "ERROR - Error in periodic callback", "issue_description": "rlrosa commented on 2 Jul 2013\nHi.\nI'm working with tornadio2 which uses the tornado ws implementation.\ni found the issue i'm having (mrjoes/tornadio2#68), it points to tornado.\ni get this error:\nError in periodic callback (periodic::_run:89)#012Traceback (most recent call last):#012  File \"/usr/lib/python2.7/dist-packages/tornadio2/periodic.py\", line 85, in _run#012    next_call = self.callback()#012  File \"/usr/lib/python2.7/dist-packages/tornadio2/session.py\", line 277, in _heartbeat#012    self.send_message(proto.heartbeat())#012  File \"/usr/lib/python2.7/dist-packages/tornadio2/session.py\", line 195, in send_message#012    self.flush()#012  File \"/usr/lib/python2.7/dist-packages/tornadio2/session.py\", line 205, in flush#012    self.handler.send_messages(self.send_queue)#012  File \"/usr/lib/python2.7/dist-packages/tornadio2/persistent.py\", line 163, in send_messages#012    self.write_message(m)#012  File \"/usr/lib/python2.7/dist-packages/tornado/websocket.py\", line 165, in write_message#012    self.ws_connection.write_message(message, binary=binary)#012AttributeError: 'NoneType' object has no attribute 'write_message'\ni'm not sure why the server gets into this situation, but it doesn't get out. keeps on logging this error forever.\nany tips/suggestions?\nthanks.\nsal\u00fa", "issue_status": "Closed", "issue_reporting_time": "2013-07-01T21:27:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "932": {"issue_url": "https://github.com/tornadoweb/tornado/issues/839", "issue_id": "#839", "issue_summary": "tornado get argument with special prefix", "issue_description": "epirus commented on 28 Jun 2013\nhere is my question:\nhttp://stackoverflow.com/questions/17352361/tornado-get-argument-with-special-prefix", "issue_status": "Closed", "issue_reporting_time": "2013-06-28T08:22:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "933": {"issue_url": "https://github.com/tornadoweb/tornado/issues/837", "issue_id": "#837", "issue_summary": "Allow the tornado.web.Application to use a custom error handler", "issue_description": "djt5019 commented on 28 Jun 2013\nHi everyone!\nI was messing around a bit and I noticed that the Application.__call__ method will always fall back to the stock ErrorHandler class when there is no applicable handler for the request.\nMy question is would there be value in allowing the Application object to take a RequestHandler and use that in place of the hard coded error handler?\nThis can be emulated by defining a \"catch-all\" RequestHandler with a .* regex pattern however I am not really a fan of that since it needs to be the last handler in the handlers list.\nI was think something along the lines of:\nclass Application(object):\n\n    def __init__(self, handlers=None, default_host=\"\", transforms=None,\n                 wsgi=False, **settings):\n        # Some of the other __init__ stuff...\n        self._error_handler = settings.get('error_handler', ErrorHandler)\n        if not isinstance(self._error_handler, RequestHandler):\n            raise Exception(\"That's not a proper request handler!\") \n        # rest of the __init__ code \n\n    def __call__(self, request):\n        # __call__ code\n        for spec in handlers:\n            # look for an applicable handler\n\n        if not handler:\n           handler = self._error_handler(self, request, status_code=404)\nIt could in turn be used kind of like:\nfrom tornado.web import Application, ErrorHandler\n\nclass JsonErrorHandler(ErrorHandler):\n\n    def write_error(self, status_code, **kwargs):\n        self.set_status(status_code)\n        self.write({'error': 'Hey man, quit it!'})\n\napp = Application(handlers=[], error_hander=JsonErrorHandler)", "issue_status": "Closed", "issue_reporting_time": "2013-06-27T19:19:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "934": {"issue_url": "https://github.com/tornadoweb/tornado/issues/836", "issue_id": "#836", "issue_summary": "PollIOLoop.start holds on to memory while blocking", "issue_description": "mjhostet commented on 27 Jun 2013\nI noticed I had a large number of Python objects that were unexpectedly not being garbage collected. I tracked down the problem to PollIOLoop holding on to the memory for its most recent batch of callbacks while it blocks waiting for new callbacks to come in. So anything that a callback transitively points to cannot be freed until you post another callback.\nI propose the following simple change to release callback memory before blocking in poll().\n--- tornado/tornado/ioloop.py.orig  2013-06-27 12:18:17.120725000 -0400\n+++ tornado/tornado/ioloop.py   2013-06-27 12:19:16.324277000 -0400\n@@ -600,18 +600,21 @@\n\n             # Prevent IO event starvation by delaying new callbacks\n             # to the next iteration of the event loop.\n             with self._callback_lock:\n                 callbacks = self._callbacks\n                 self._callbacks = []\n             for callback in callbacks:\n                 self._run_callback(callback)\n\n+            # Allow these to get garbage collected before poll() blocks below.\n+            callback = callbacks = None\n+\n             if self._timeouts:\n                 now = self.time()\n                 while self._timeouts:\n                     if self._timeouts[0].callback is None:\n                         # the timeout was cancelled\n                         heapq.heappop(self._timeouts)\n                         self._cancellations -= 1\n                     elif self._timeouts[0].deadline <= now:\n                         timeout = heapq.heappop(self._timeouts)", "issue_status": "Closed", "issue_reporting_time": "2013-06-27T16:28:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "935": {"issue_url": "https://github.com/tornadoweb/tornado/issues/835", "issue_id": "#835", "issue_summary": "Google auth doc in stable version", "issue_description": "jegoruglov commented on 27 Jun 2013\nHi,\nThe code sample in new Google auth doc uses @tornado.gen.coroutine decorator, and it yields self.authenticate_redirect() - https://github.com/facebook/tornado/blob/stable/tornado/auth.py#L46\nThis results in following error, which does not interrupt the app, but still throws exception to stdout:\nERROR:tornado.application:Uncaught exception GET /login?next=%2F (127.0.0.1)\nHTTPRequest(protocol='http', host='localhost:9997', method='GET', uri='/login?next=%2F', version='HTTP/1.1', remote_ip='127.0.0.1', body='', headers={'Connection': 'keep-alive', 'Accept-Language': 'en-US,en;q=0.8', 'Accept-Encoding': 'gzip,deflate,sdch', 'Host': 'localhost:9997', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8', 'User-Agent': 'Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1500.52 Safari/537.36'})\nTraceback (most recent call last):\nFile \"/home/jegor/projects/tornado/tornado/web.py\", line 1077, in _stack_context_handle_exception\nraise_exc_info((type, value, traceback))\nFile \"/home/jegor/projects/tornado/tornado/stack_context.py\", line 258, in wrapped\nfn(_args, *_kwargs)\nFile \"/home/jegor/projects/tornado/tornado/web.py\", line 1229, in future_complete\nf.result()\nFile \"/home/jegor/projects/tornado/tornado/concurrent.py\", line 129, in result\nraise_exc_info(self.__exc_info)\nFile \"/home/jegor/projects/tornado/tornado/gen.py\", line 224, in wrapper\nrunner.run()\nFile \"/home/jegor/projects/tornado/tornado/gen.py\", line 508, in run\nyielded = self.gen.send(next)\nFile \"main.py\", line 42, in get\nyield self.authenticate_redirect()\nFile \"/home/jegor/projects/tornado/tornado/auth.py\", line 136, in authenticate_redirect\nself.redirect(self._OPENID_ENDPOINT + \"?\" + urllib_parse.urlencode(args))\nFile \"/home/jegor/projects/tornado/tornado/web.py\", line 504, in redirect\nraise Exception(\"Cannot redirect after headers have been written\")\nException: Cannot redirect after headers have been written\nERROR:tornado.general:Cannot send error response after headers written\nI fixed it by removing yield from https://github.com/facebook/tornado/blob/stable/tornado/auth.py#L46\nWhy should it be yielded?", "issue_status": "Closed", "issue_reporting_time": "2013-06-27T12:32:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "936": {"issue_url": "https://github.com/tornadoweb/tornado/issues/834", "issue_id": "#834", "issue_summary": "tornado.process.Subprocess leaks file descriptors if Subprocess.STREAM is used and Popen raises an exception", "issue_description": "gclinch commented on 26 Jun 2013\nWhen calling the following, a 'FileNotFoundError' is raised as expected:\nfrom tornado.process import Subprocess\nSubprocess(\"non_existant_binary\", stdout=Subprocess.STREAM)\nHowever the STREAM pipe is left open. After many calls of this nature, Subprocess switches to raising 'OSError: [Errno 24] Too many open files' from a _pipe_cloexec() call.\nI believe Subprocess should catch the exception from Popen, close any in/out/err pipes and then re-raise the Popen exception to the caller.", "issue_status": "Closed", "issue_reporting_time": "2013-06-26T12:06:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "937": {"issue_url": "https://github.com/tornadoweb/tornado/issues/833", "issue_id": "#833", "issue_summary": "Escape apostrophe", "issue_description": "tlynn commented on 25 Jun 2013\nApostrophes are valid attribute delimiters in (X)HTML, so the escape/xhtml_escape routine should escape them (preferably as &#39; rather than &apos; due to the HTML 4 bug).\nBackticks have also been supported as attribute delimiters by some browsers, despite being non-standard, so they might merit escaping too.", "issue_status": "Closed", "issue_reporting_time": "2013-06-25T14:05:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "938": {"issue_url": "https://github.com/tornadoweb/tornado/issues/830", "issue_id": "#830", "issue_summary": "BUG REPORT Application __call__ method pass the regex.groups as params to post/get...cause error", "issue_description": "Ethan-Zhang commented on 22 Jun 2013\nA simple example http://host:port/v1.0/path/223-342-324-234/\nuser will write in URLSpec partner like /v1.0/path/(\\d{3}-){3}\\d{3} with regex group.\nBut in tornado, the Application call method will recongnize a sub group like /(xxx)/(xxx) as params args then pass it to post/get/.....If a user did define params list in method, it will casue error.\nI don't think this method is correct. If one user give this regex /(\\dab)+(\\dcd)+/, RequestHandler will parse it to two params.\nSo, guys, shall we change another way to got the args or drop it?", "issue_status": "Closed", "issue_reporting_time": "2013-06-22T05:02:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "939": {"issue_url": "https://github.com/tornadoweb/tornado/issues/829", "issue_id": "#829", "issue_summary": "Incorrect error message in _when_complete", "issue_description": "Contributor\nerkyrath commented on 21 Jun 2013\nweb.py line 1145:\nraise ValueError('Expected None, got %r' % result)\nThis interpolates the wrong field. \"result\" is always a Future at this point. It should be reporting that result.result() is not None.", "issue_status": "Closed", "issue_reporting_time": "2013-06-21T18:19:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "940": {"issue_url": "https://github.com/tornadoweb/tornado/issues/828", "issue_id": "#828", "issue_summary": "tornado memory leaks when serve html5 page with <video>", "issue_description": "luwenjin commented on 21 Jun 2013\nI was trying to write a static file server with tornado, but memory leaks when it serves html5 videos, the code is pretty simple.\nserver.py\nimport tornado.ioloop\nimport tornado.web\n\nif __name__ == \"__main__\":\n    application = tornado.web.Application([\n        (r\"/(.*)\", tornado.web.StaticFileHandler, {'path': '.'}),\n    ])\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\nvideo.html\n<html>\n<body>\n<video src=\"demo.mp4\"></video>\n</body>\n</html>\nDetails:\nMy platform: windows 7 64bit, chrome 27, python 2.7, tornado 2.4\nWhen the html page was loaded, python.exe's memory goes up.\nEvery time I reload the page, memory goes up again ( + 5MB for every reload in my situation )\nOn reloading, an error was raised by tornado ( see the last part )\nIf I play the video, I can see the memory going down during the playing (but always higher than last reload)\nError Traceback on Page Reloading\nWARNING:tornado.general:error on read\nTraceback (most recent call last):\n  File \"D:\\PROJECTS\\Working\\PyF5\\tornado\\iostream.py\", line 391, in _handle_read\n    if self._read_to_buffer() == 0:\n  File \"D:\\PROJECTS\\Working\\PyF5\\tornado\\iostream.py\", line 447, in _read_to_buffer\n    chunk = self.read_from_fd()\n  File \"D:\\PROJECTS\\Working\\PyF5\\tornado\\iostream.py\", line 683, in read_from_fd\n    chunk = self.socket.recv(self.read_chunk_size)\nerror: [Errno 10053] ", "issue_status": "Closed", "issue_reporting_time": "2013-06-21T02:04:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "941": {"issue_url": "https://github.com/tornadoweb/tornado/issues/827", "issue_id": "#827", "issue_summary": "Streaming callbacks may never run", "issue_description": "redbaron commented on 18 Jun 2013\nBecause data is read in tight loops, there could be a case when EAGAIN is never returned if producer is fast enough. If it happens IOStream consumes max_buffer_size bytes and exits with error without having a chance to call streaming callback.\n                while not self.closed():\n                    if self._read_to_buffer() == 0:\n                        break\nHere is the minimal script which demonstrates the problem. Note that not on all systems it misbehaves. On Mac OS X it runs fine, simply because it happen that read syscall returns EAGAIN, but on our Linux servers it is not happening and Reached maximum read buffer size error is raised.\n#!/usr/bin/env python\n\nfrom tornado.process import Subprocess\nfrom tornado.log import enable_pretty_logging; enable_pretty_logging()\nimport logging\nlog = logging.getLogger(\"tornado.application\")\n\n\ndef main():\n    pipe = Subprocess([\"/bin/cat\", \"/dev/zero\"], stdout=Subprocess.STREAM).stdout\n    pipe.read_until_close(\n            lambda _: log.warn(\"Stream is closing\"),\n            lambda chunk: log.info(\"Streamed chunk size %d\", len(chunk)))\n    pipe.io_loop.start()\n\n\nif __name__ == '__main__':\n    main()", "issue_status": "Closed", "issue_reporting_time": "2013-06-18T07:55:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "942": {"issue_url": "https://github.com/tornadoweb/tornado/issues/826", "issue_id": "#826", "issue_summary": "Partial override of StaticFileHandler.get results in AttributeError(absolute_path)", "issue_description": "mayfield commented on 18 Jun 2013\nI have some StaticFileHandler subclasses that partially override the get() method. Sometimes they return internally compiled templates when appropriate and otherwise they call super().get() which will do the regular StaticFilterHandler stuff. After upgrading to tornado 3.1.0 (from 3.0.1) I get the following AttributeError that results from the 'absolute_path' attribute not being set.\nTraceback (most recent call last):\n  File \"/local/home/mayfield/project/rome/mayfield-rome/packages_venv/lib/python2.7/site-packages/tornado/web.py\", line 1141, in _when_complete\n    callback()\n  File \"/local/home/mayfield/project/rome/mayfield-rome/packages_venv/lib/python2.7/site-packages/tornado/web.py\", line 1167, in _execute_finish\n    self.finish()\n  File \"/local/home/mayfield/project/rome/mayfield-rome/packages_venv/lib/python2.7/site-packages/tornado/web.py\", line 741, in finish\n    self.set_etag_header()\n  File \"/local/home/mayfield/project/rome/mayfield-rome/packages_venv/lib/python2.7/site-packages/tornado/web.py\", line 1084, in set_etag_header\n    etag = self.compute_etag()\n  File \"/local/home/mayfield/project/rome/mayfield-rome/packages_venv/lib/python2.7/site-packages/tornado/web.py\", line 1862, in compute_etag\n    version_hash = self._get_cached_version(self.absolute_path)\nAttributeError: 'DiagHandler' object has no attribute 'absolute_path'\nThis attribute is not setup until mid body of the get() method in StaticFileHandler. I can easily work around this by setting up the attribute myself (in get(), prepare(), or initialize(), but I feel like this needlessly violates DRY.\nI'm sure you could tell me I shouldn't do this and the superclass must always be invoked even for something seemingly virtual like get(); I will go away if you insist I shouldn't do this, but I've found this pattern to be quite useful in the past and the fact that this sort of thing was so easy to do without complication has been, in my opinion, one of the reasons for tornado's popularity.\nIf you accept the issue I'd be happy to submit a pull request with a fix.", "issue_status": "Closed", "issue_reporting_time": "2013-06-18T03:45:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "943": {"issue_url": "https://github.com/tornadoweb/tornado/issues/825", "issue_id": "#825", "issue_summary": "Tests fail with partial installation of Twisted", "issue_description": "djc commented on 17 Jun 2013\nThis happens on Linux (Gentoo), testing before packaging it:\nTraceback (most recent call last):\n  File \"/usr/lib64/python2.7/runpy.py\", line 162, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/lib64/python2.7/runpy.py\", line 72, in _run_code\n    exec code in run_globals\n  File \"/var/tmp/portage/www-servers/tornado-3.1/work/tornado-3.1-python2_7/lib/tornado/test/runtests.py\", line 123, in <module>\n    tornado.testing.main(**kwargs)\n  File \"/var/tmp/portage/www-servers/tornado-3.1/work/tornado-3.1-python2_7/lib/tornado/testing.py\", line 606, in main\n    unittest.main(defaultTest=\"all\", argv=argv, **kwargs)\n  File \"/usr/lib64/python2.7/site-packages/unittest2/main.py\", line 97, in __init__\n    self.parseArgs(argv)\n  File \"/usr/lib64/python2.7/site-packages/unittest2/main.py\", line 152, in parseArgs\n    self.createTests()\n  File \"/usr/lib64/python2.7/site-packages/unittest2/main.py\", line 161, in createTests\n    self.module)\n  File \"/usr/lib64/python2.7/site-packages/unittest2/loader.py\", line 148, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib64/python2.7/site-packages/unittest2/loader.py\", line 133, in loadTestsFromName\n    test = obj()\n  File \"/var/tmp/portage/www-servers/tornado-3.1/work/tornado-3.1-python2_7/lib/tornado/test/runtests.py\", line 49, in all\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 128, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 100, in loadTestsFromName\n    parent, obj = obj, getattr(obj, part)\nAttributeError: 'module' object has no attribute 'netutil_test'", "issue_status": "Closed", "issue_reporting_time": "2013-06-17T10:46:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "944": {"issue_url": "https://github.com/tornadoweb/tornado/issues/822", "issue_id": "#822", "issue_summary": "Support for HTTP/1.0 Simple-Request", "issue_description": "awicenec commented on 11 Jun 2013\nThis is reporting a slight HTTP/1.0 incompatibility.\nExcerpt from the http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#Request:\nA request message from a client to a server includes, within the first line of that message, the method to be applied to\n the resource, the identifier of the resource, and the protocol version in use. For backwards compatibility with the\n more limited HTTP/0.9 protocol, there are two valid formats for an HTTP request:\n\n       Request        = Simple-Request | Full-Request\n\n       Simple-Request = \"GET\" SP Request-URI CRLF\n\n       Full-Request   = Request-Line              ; Section 5.1\n                        *( General-Header         ; Section 4.3\n                         | Request-Header         ; Section 5.2\n                         | Entity-Header )        ; Section 7.1\n                        CRLF\n                        [ Entity-Body ]           ; Section 7.2\n\nIf an HTTP/1.0 server receives a Simple-Request, it must respond with an HTTP/0.9 Simple-Response. An HTTP/1.0\n client capable of receiving a Full-Response should never generate a Simple-Request.\nThe Simple-Request is currently not supported by tornado and even worse it keeps completely silent about the cause (no Warning nor Error raised). Most other web-servers I've tried do support the Simple-Request. My use case is being able to just using plain telnet to get a very fast response from a server, typing as little as possible like in the example below. As stated in the standard the server responds with a Simple-Response (HTTP/0.9, no header):\ntelnet 127.0.0.1 5432\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nGET /\n\nHello World\nConnection closed by foreign host.\nIn order to achieve the above I've modified the tornado httpserver.py like:\n63,64c63,67\n<            request.write(\"HTTP/1.1 200 OK\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (\n<                          len(message), message))\n\n---\n>      if request.version != \"HTTP/0.9\":\n>                request.write(\"HTTP/1.1 200 OK\\r\\n\")\n>          request.write(\"Content-Length: %d\\r\\n\\r\\n\" % (\n>                          len(message))\n>      request.write(message, request.version)\n292c295,302\n<                 method, uri, version = start_line.split(\" \")\n\n---\n>       sline = start_line.split(\" \")\n>       if len(sline) == 3:\n>                     method, uri, version = sline\n>       elif len(sline) == 2:\n>           method, uri = sline\n>           version = \"HTTP/0.9\" # Fallback\n>       else:\n>           raise ValueError\n293a304\n>       print(\"ValueError in HTTP Header!\")\n294a306,307\n>             except:\n>                 print(\"Unexpected error:\", sys.exc_info()[0])", "issue_status": "Closed", "issue_reporting_time": "2013-06-11T05:37:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "945": {"issue_url": "https://github.com/tornadoweb/tornado/issues/821", "issue_id": "#821", "issue_summary": "HTTP extensions in HTTPError", "issue_description": "igungor commented on 10 Jun 2013\nHTTPError exception class only accepts the codes defined in httplib.responses. Wouldn't it be better to support 422-Unprocessable Entity or other extensions[0]?\nI think it would be better to extend httplib2.responses with the new http status codes.\n[0] http://en.wikipedia.org/wiki/List_of_HTTP_status_codes", "issue_status": "Closed", "issue_reporting_time": "2013-06-10T13:41:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "946": {"issue_url": "https://github.com/tornadoweb/tornado/issues/818", "issue_id": "#818", "issue_summary": "Tornado debug", "issue_description": "ghost commented on 1 Jun 2013\nHello Everyone,\nI am trying find way out what return values from pam authentication getting tornado. How will correct way will be put it in debug mode ?\nThank you in advance.", "issue_status": "Closed", "issue_reporting_time": "2013-06-01T17:28:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "947": {"issue_url": "https://github.com/tornadoweb/tornado/issues/816", "issue_id": "#816", "issue_summary": "Centos6.2Memory Leak", "issue_description": "edisonlz commented on 31 May 2013\n17:40 [root@xx]$ pmap -x 1993\n1993:   /opt/python2.7/bin/python main.py -port=9003 -worker=40 -logging=error -log_file_prefix=/opt/logs/tornado//9003.log\nAddress           Kbytes     RSS   Dirty Mode   Mapping\n0000000000400000    1480     972       0 r-x--  python\n0000000000772000     240     216     172 rw---  python\n00000000007ae000      60      56      56 rw---    [ anon ]\n00000000021ff000   15968   15876   15876 rw---    [ anon ]\n[x] 0000000003197000   11812   11432   11432 rw---    [ anon ]\nMemory Dump CMD:\npmap -x 1993\ngrep rw-p /proc/1993/maps\n gdb --batch --pid 1993 -ex \"dump memory c.dump 0x02707000 0x027a7000\"\nMemory Dump Content:\nvim c.dump\nGET /openapi-wireless/keywords/suggest?pid=65a965fbf632be6f&guid=942556ec0a88bc05633d5334b130d2bd&mac=02:03:7F:CC:90:C6&imei=867567010221612&ver=3.0&operator=_46000&network=WIFI&keywords=%E4%B8%83%E5%8D%81%E4%BA%8C%E5%AE^H?0?f^?^@^@?Y?^B^@^@^@^@AE%A2 HTTP/1.0^M\nX-Forwarded-For: 118.196.221.226, 10.103.13.86^M\nX-Real-IP: 118.196.221.226^M\nHost: search_youku_com^M\nConnection: close^M\nX-NginX-Proxy: true^M\nUser-Agent: Youku;3.0;Android;2.3.6;A9300^M\nAccept-Encoding: gzip^M\n^M\n^@?0?f^?^@^@^A^A^@^@^@^@^@^@ ?V^B^@^@^@^@?^@^@^@^@^@^@^@ S?^B^@^@^@^@?{{^B^@^@^@^@^H^O(?f^?^@^@^X?C^B^@^@^@^@??0?f^?^@^@?^L(?f^?^@^@^H^O(?f^?^@^@^@??^A^@^@^@^@??0?f^?^@^@?F4^B^@^@^@^@^H^O(?f^?^@^@???^A^@^@^@^@??0?f^?^@^@??>^B^@^@^@^@^H^O(?f^?^@^@???^A^@^@^@^@??0?f^?^@^@???^A^@^@^@^@^H^O(?f^?^@^@?}B^B^@^@^@^@??0?f^?^@^@@^N(?f^?^@^@ en-GB, 1^@^@^@^@^@^@^@????8^@^@^@P^K^?^B^@^@^@^@\nAccept: */*^M\n^M\nReturn Data in memory, and memory increase by time ,if the data not sent by tornado or ...... !", "issue_status": "Closed", "issue_reporting_time": "2013-05-31T09:42:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "948": {"issue_url": "https://github.com/tornadoweb/tornado/issues/815", "issue_id": "#815", "issue_summary": "Revisit exception logging in simple_httpclient", "issue_description": "Member\nbdarnell commented on 31 May 2013\nThe exception will be available in the response object, so simple_httpclient._handle_exception probably doesn't need to log the whole stack trace. We should be able to remove that and a bunch of ExpectLog calls in the tests.", "issue_status": "Closed", "issue_reporting_time": "2013-05-31T03:17:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "949": {"issue_url": "https://github.com/tornadoweb/tornado/issues/814", "issue_id": "#814", "issue_summary": "A simpler way for doing url mapping", "issue_description": "prongs commented on 30 May 2013\nWould love to have a decorator like way to define url mappings. e.g. https://github.com/prongs/Testimonial/blob/master/handlers.py#L48\nmappings = []\n\n\ndef url(url):\n    def decorator(cl):\n        mappings.append((url, cl))\n        return cl\n    return decorator\n\n\n\n@url(\"/main\")\nclass ExampleHandler(RequestHandler):\n    pass", "issue_status": "Closed", "issue_reporting_time": "2013-05-30T12:42:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "950": {"issue_url": "https://github.com/tornadoweb/tornado/issues/813", "issue_id": "#813", "issue_summary": "A simpler way for doing url mapping", "issue_description": "prongs commented on 30 May 2013\nWould love to have a decorator like way to define url mappings. e.g. https://github.com/prongs/Testimonial/blob/master/handlers.py#L48\nmappings = []\n\n\ndef url(url):\n    def decorator(cl):\n        mappings.append((url, cl))\n        return cl\n    return decorator\n\n\n\n@url(\"/main\")\nclass ExampleHandler(RequestHandler):\n    pass", "issue_status": "Closed", "issue_reporting_time": "2013-05-30T12:40:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "951": {"issue_url": "https://github.com/tornadoweb/tornado/issues/812", "issue_id": "#812", "issue_summary": "A simpler way for doing url mapping", "issue_description": "prongs commented on 30 May 2013\nWould love to have a decorator like way to define url mappings. e.g. https://github.com/prongs/Testimonial/blob/master/handlers.py#L48\nmappings = []\n\n\ndef url(url):\n    def decorator(cl):\n        mappings.append((url, cl))\n        return cl\n    return decorator\n\n\n\n@url(\"/main\")\nclass ExampleHandler(RequestHandler):\n    pass", "issue_status": "Closed", "issue_reporting_time": "2013-05-30T12:38:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "952": {"issue_url": "https://github.com/tornadoweb/tornado/issues/811", "issue_id": "#811", "issue_summary": "A simpler way for doing url mapping", "issue_description": "prongs commented on 30 May 2013\nWould love to have a decorator like way to define url mappings. e.g. https://github.com/prongs/Testimonial/blob/master/handlers.py#L48\nmappings = []\n\n\ndef url(url):\n    def decorator(cl):\n        mappings.append((url, cl))\n        return cl\n    return decorator\n\n\n\n@url(\"/main\")\nclass ExampleHandler(RequestHandler):\n    pass", "issue_status": "Closed", "issue_reporting_time": "2013-05-30T12:38:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "953": {"issue_url": "https://github.com/tornadoweb/tornado/issues/810", "issue_id": "#810", "issue_summary": "Server logging and slow server work.", "issue_description": "toxi-kb commented on 30 May 2013\nHello! We develop a web application based on tornadio2 and tornado 2.4. In the main the application works stable but it gives some mistakes rather often. The list of the mistakes is below. Logs from tornadio2 are given for the full scope.\nAs we see there are no references to the our code and we can\u2019t understand what give that mistakes.\nSometimes (rhythmically) the application gives as a lot of such mistakes (frequency of mistakes increases in times) that makes server work slowly.\nWe think that the main operation that makes server slower is logging. Can you tell us if we think correct and the logging slows the server?\nCan you give us an advise how to avoid or reduce such mistakes?\nWe looked for the answer at thematic forums and among the issues to the libraries tornado and tornadio2 and had found some statements. The statements tell us that such mistakes are not critical, don\u2019t affect the client-server communication and don\u2019t give any negative effect. Is it true?\nIf it\u2019s true how can we suppress or inhibit the logging process?\nERROR:tornado.application:Exception in callback \nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 453, in _run_callback\n    callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 241, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 316, in wrapper\n    callback(*args)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 241, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/httpserver.py\", line 217, in _on_connection_close\n    callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 241, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 256, in on_connection_close\n    self.on_close()\n  File \"/usr/local/lib/python2.7/dist-packages/tornadio2/persistent.py\", line 151, in on_close\n    self._detach()\n  File \"/usr/local/lib/python2.7/dist-packages/tornadio2/persistent.py\", line 117, in _detach\n    self.session.remove_handler(self)\n  File \"/usr/local/lib/python2.7/dist-packages/tornadio2/session.py\", line 173, in remove_handler\n    raise Exception('Attempted to remove invalid handler')\nException: Attempted to remove invalid handler\nERROR:tornado.application:Uncaught exception in /socket.io/1/websocket/ce83bfa8b8109109f5d4a278204558ec\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 285, in wrapper\n    return callback(_args, *_kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornadio2/persistent.py\", line 87, in open\n    raise HTTPError(401, \"Invalid Session\")\nHTTPError: HTTP 401: Unauthorized (Invalid Session)\nERROR:tornado.application:Exception in callback \nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 453, in _run_callback\n    callback()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 241, in wrapped\n    callback(_args, *_kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 316, in wrapper\n    callback(_args)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 241, in wrapped\n    callback(_args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/httpserver.py\", line 320, in _on_headers\n    self.request_callback(self._request)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/web.py\", line 1479, in __call__\n    handler._execute(transforms, _args, *_kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornadio2/persistent.py\", line 81, in _execute\n    super(TornadioWebSocketHandler, self)._execute(transforms, _args, *_kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 143, in _execute\n    self.ws_connection.accept_connection()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 492, in accept_connection\n    self._accept_connection()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 541, in _accept_connection\n    self._receive_frame()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/websocket.py\", line 582, in _receive_frame\n    self.stream.read_bytes(2, self._on_frame_start)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 162, in read_bytes\n    self._try_inline_read()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 393, in _try_inline_read\n    self._check_closed()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 543, in _check_closed\n    raise StreamClosedError(\"Stream is closed\")\nStreamClosedError: Stream is closed", "issue_status": "Closed", "issue_reporting_time": "2013-05-30T11:50:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "954": {"issue_url": "https://github.com/tornadoweb/tornado/issues/807", "issue_id": "#807", "issue_summary": "Hide request body on error dump", "issue_description": "Contributor\nysimonson commented on 30 May 2013\nCurrently the HTTP request body is dumped to the log when an exception occurs as part of the HTTPRequest object, e.g.\nHTTPRequest(protocol='http', host='<my site>', method='POST', uri='/user', version='HTTP/1.1', remote_ip='10.91.14.104', body='...\nThis has made stack traces a bit of a pain to work with when there's file uploads.\nWould you accept a pull request to remove this?", "issue_status": "Closed", "issue_reporting_time": "2013-05-29T18:43:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "955": {"issue_url": "https://github.com/tornadoweb/tornado/issues/801", "issue_id": "#801", "issue_summary": "update_handler errors when using digest auth with curl", "issue_description": "Contributor\npitrou commented on 24 May 2013\nI get the following kind of errors when using digest auth with the curl async client:\nTraceback (most recent call last):\n  File \"/home/antoine/tornado/tornado/curl_httpclient.py\", line 130, in _handle_socket\n    self.io_loop.update_handler(fd, ioloop_event)\n  File \"/home/antoine/tornado/tornado/ioloop.py\", line 526, in update_handler\n    self._impl.modify(fd, events | self.ERROR)\nIOError: [Errno 2] No such file or directory\nI did a bit of debugging and I think I understand the problem. When using digest auth, curl runs a first request without any auth headers, so as to first get the server's digest parameters (nonce, etc.). Then it runs a second request with the appropriate auth headers. However, that second request is done on a new connection. What happens is that the second connection re-uses the same fd as the first one. Therefore tornado thinks that fd is already registered on the epoll object, even though it isn't.\nI thought of using pycurl's OPENSOCKETFUNCTION callback to reinitialize the fd's status after we create the socket, but unfortunately it seems pycurl must call dup() on that function's result (i.e. if OPENSOCKETFUNCTION returns fd 8, curl later calls _handle_socket with fd 9). So perhaps _handle_socket() should simply catch ENOENT when update_handler fails and fallback on add_handler. (but of course this would be epoll-specific)", "issue_status": "Closed", "issue_reporting_time": "2013-05-24T15:37:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "956": {"issue_url": "https://github.com/tornadoweb/tornado/issues/800", "issue_id": "#800", "issue_summary": "Invalid cookie expiration if locale set", "issue_description": "Contributor\nchinyue commented on 24 May 2013\nBefore 3.0, cookie expiration is formatted by using email.utils. Starts from 3.0, cookie expiration is formatted using time.strftime, which formats according to locale and the result is invalid expiration to many browsers.\n>>> import time\n>>> import calendar\n>>> import email.utils\n>>> import datetime\n>>> dt = datetime.datetime.utcnow()\n>>> time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", dt.utctimetuple())\n'Fri, 24 May 2013 02:22:55 GMT'\n>>> email.utils.formatdate(calendar.timegm(dt.utctimetuple()), localtime=False, usegmt=True)\n'Fri, 24 May 2013 02:22:55 GMT'\nWith locale set:\n>>> import locale\n>>> locale.setlocale(locale.LC_ALL, 'zh_TW.UTF-8')\n'zh_TW.UTF-8'\n>>> time.strftime(\"%a, %d %b %Y %H:%M:%S GMT\", dt.utctimetuple())\n'\\xe4\\xba\\x94, 24  5 2013 02:22:55 GMT'\n>>> email.utils.formatdate(calendar.timegm(dt.utctimetuple()), localtime=False, usegmt=True)\n'Fri, 24 May 2013 02:22:55 GMT'", "issue_status": "Closed", "issue_reporting_time": "2013-05-24T02:34:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "957": {"issue_url": "https://github.com/tornadoweb/tornado/issues/799", "issue_id": "#799", "issue_summary": "CVE-2013-2098 possible abuse of match_hostname() for DoS usings certs with many wildcards", "issue_description": "juliantaylor commented on 23 May 2013\ntornado ships a copy of pythons _dnsname_to_pat from python in tornado/netutils.py which is affected by CVE-2013-2098:\nCVE request: http://www.openwall.com/lists/oss-security/2013/05/15/6\nUpstream: http://bugs.python.org/issue17980", "issue_status": "Closed", "issue_reporting_time": "2013-05-23T18:12:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "958": {"issue_url": "https://github.com/tornadoweb/tornado/issues/797", "issue_id": "#797", "issue_summary": "template static_url relative paths", "issue_description": "Contributor\newang commented on 22 May 2013\nIs there a way to remove the leading slash generated by static_url? I looked through the source and ended up setting \"static_url_prefix\" to \"static/\" instead of the default \"/static/\".e\nHowever, seems like the URL prefix of \"static/\" doesn't end up matching any handlers, so a 404 gets returned.\nI'm running into a problem where if I run separate apps under different sub-directory URL, then the leading slash returned from static_url() results in the URLs not actually being relative.\nFor example, I have an app running under http://localhost/app, then the URL returned by static_url() will be \"/static/images/logo.png\" when it should be \"static/images/logo.png\".", "issue_status": "Closed", "issue_reporting_time": "2013-05-22T10:13:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "959": {"issue_url": "https://github.com/tornadoweb/tornado/issues/792", "issue_id": "#792", "issue_summary": "Why not support patch method in curl_httpclient", "issue_description": "Contributor\ncloudaice commented on 18 May 2013\nwhen I use PATCH method in CurlAsyncHTTPClient. it raise no this method. any one have good idea except using simplehttpclient.", "issue_status": "Closed", "issue_reporting_time": "2013-05-17T21:43:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "960": {"issue_url": "https://github.com/tornadoweb/tornado/issues/791", "issue_id": "#791", "issue_summary": "duplicated self.file.find_named_blocks call in template.Template", "issue_description": "HonestManXin commented on 17 May 2013\nIn #L284\nthis method has already been called in for loop block ancestor.find_named_blocks, because self._get_ancestors return self.file,so this is a duplicated call.", "issue_status": "Closed", "issue_reporting_time": "2013-05-17T14:22:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "961": {"issue_url": "https://github.com/tornadoweb/tornado/issues/787", "issue_id": "#787", "issue_summary": "Coroutine hangs up when fetching a firewalled HTTPS url", "issue_description": "aglyzov commented on 15 May 2013\nThis gist https://gist.github.com/aglyzov/5585806 illustrates a bug (?) in Tornado 3.0.1.\nTwo things are needed for this bug to trigger:\nHTTPS url\nwhich is firewalled\nIn that case a Timeout exception generated in the simple_httpclient does not get caught in the calling coroutine which is then get hung up.\nThis particular URL in the example uses a bot-net protection cloud service which expects a client to set a User-Agent header (see the commented out line in the code).\nThus omitting the header triggers the bug.", "issue_status": "Closed", "issue_reporting_time": "2013-05-15T18:00:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "962": {"issue_url": "https://github.com/tornadoweb/tornado/issues/785", "issue_id": "#785", "issue_summary": "Add support for Range/Accept-Ranges to web.StaticFileHandler", "issue_description": "Contributor\nwolever commented on 14 May 2013\nWould a patch adding support for the request header Range: bytes=\u2026 and the response header Accept-Ranges: bytes to the web.StaticFileHandler be considered?\nI'm working on a project which uses the StaticFileHandler to serve audio that is used with the HTML5 <audio> tag, which only supports seeking when the Accept-Ranges: bytes header is included.", "issue_status": "Closed", "issue_reporting_time": "2013-05-14T01:05:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "963": {"issue_url": "https://github.com/tornadoweb/tornado/issues/775", "issue_id": "#775", "issue_summary": "ioloop resets logging configuration, assuming root logger is always required", "issue_description": "Contributor\ngmr commented on 1 May 2013\nhttps://github.com/facebook/tornado/blob/master/tornado/ioloop.py#L544\nIMO a package should not implicitly change configured logging behavior.\nI assume the correct behavior is to not do the logging.basicConfig here at all, but if you really want to keep users from complaining, I wonder if you should just use logging.getLogger('tornado').handlers which would check to see if a tornado logger has any handlers.\nA better check for what you're doing if you want to keep it global and not focused on tornado is to check logging._handlers. Any handler that emits logging statements would be in the _handlers dictionary.\nIf you really want to keep users from complaining about logging when they don't know what they're doing, I'd probably check any(logging._handlers, logging.getLogger('tornado').handlers). But honestly I think the code should be moved to tornado.log and complaining users should be educated about stdlib logging or told to use tornado.log.enable_pretty_logging or a new tornado.log.setup or something to get rid of the warning.\nFWIW In my cause I remove the root logger on purpose and the tornado IO loop is resetting my logging configuration. Checking for either logging._handlers or logging.getLogger('tornado') would prevent this from happening. Checking getLogger('tornado').handlers would require I add a tornado logger to my dictConfig, which I'm not opposed to.\nLet me know if you're not opposed to the change and if you want a pull request, what your preferred method of fixing the problem is. As someone who uses stdlib logging in ways beyond how tornado expects it to be used, this is a major pain where I put in hacks to reconfigure logging after I start the ioloop for apps.", "issue_status": "Closed", "issue_reporting_time": "2013-04-30T18:44:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "964": {"issue_url": "https://github.com/tornadoweb/tornado/issues/774", "issue_id": "#774", "issue_summary": "IOStream read_until_close problem", "issue_description": "wynemo commented on 30 Apr 2013\naccording to the documents, http://www.tornadoweb.org/en/stable/_modules/tornado/iostream.html#BaseIOStream.read_until_close\nif streaming_callback is given, the argument to final callback is empty\nbut seems not always the case\ntest code is here : https://gist.github.com/wynemo/5488772\nit shows sometimes streaming_callback is given, but not be called, and the final callback's argument is not empty.", "issue_status": "Closed", "issue_reporting_time": "2013-04-30T14:17:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "965": {"issue_url": "https://github.com/tornadoweb/tornado/issues/772", "issue_id": "#772", "issue_summary": "Read less aggressively in IOStream._handle_read", "issue_description": "Member\nbdarnell commented on 29 Apr 2013\n_handle_read tries to read as much as it can into the buffer before checking to see if its buffered data can satisfy the pending read (this is important for performance; see commit 41463a9). However, on a fast network this can lead to the buffer growing quickly and exceeding max_buffer_size, even if we are going to process it with a series of reads that don't require that much buffered data (we're also missing an opportunity to apply TCP backpressure to the sender).\nWe should try running read_from_buffer more often to balance buffer growth vs read_until efficiency. It should at least be run before attempting a read_to_buffer that might put the stream over its limit. When the pending read is a read_bytes we can try read_from_buffer every time. We may want to add a size parameter to read_until and read_until_regex (either as a hint or a hard limit).", "issue_status": "Closed", "issue_reporting_time": "2013-04-29T03:47:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "966": {"issue_url": "https://github.com/tornadoweb/tornado/issues/771", "issue_id": "#771", "issue_summary": "IOStream runs its close callback too soon.", "issue_description": "Member\nbdarnell commented on 29 Apr 2013\nIOStream allows for reads after close only as long as there is an unbroken chain of callbacks. If anything else happens in the meantime, the close callback will be run even if there is buffered data. _maybe_run_close_callback should check the status of the buffer and only run the close callback if either the buffer is empty or if there is a pending read that cannot be satisfied from the buffer.\nSee discussion in #747.", "issue_status": "Closed", "issue_reporting_time": "2013-04-29T03:35:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "967": {"issue_url": "https://github.com/tornadoweb/tornado/issues/768", "issue_id": "#768", "issue_summary": "Reserved variables in the templates", "issue_description": "paulocheque commented on 29 Apr 2013\nI am trying to override the render method in a Base RequestHandler, so I can add some variables to all templates. But I am having some strange errors for some variables, that I believe are reserved by Tornado. Am I correct? How can I get a list of these variables?\nkwargs['xx'] = 42\nreturn super(X, self).render(template_name, **kwargs)\n{{ xx }} => prints 42\n\nkwargs['authenticated'] = 42\nreturn super(X, self).render(template_name, **kwargs)\n{{ authenticated }} => error: undefined variable\n\nkwargs['current_user'] = 42\nreturn super(X, self).render(template_name, **kwargs)\n{{ current_user }} => error: undefined variable\nThanks in advance", "issue_status": "Closed", "issue_reporting_time": "2013-04-28T20:12:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "968": {"issue_url": "https://github.com/tornadoweb/tornado/issues/766", "issue_id": "#766", "issue_summary": "getaddrinfo issue under solaris in tornado.netutil.ExecutorResolver", "issue_description": "fcicq commented on 28 Apr 2013\nTornado 3.0.1, using with tornado.websocket.websocket_connect and WebSocketClientConnection\nWARNING:tornado.general:uncaught exception\nTraceback (most recent call last):\n  File \"/opt/local/lib/python2.7/site-packages/tornado/stack_context.py\", line 239, in wrapped\n    callback(*args, **kwargs)\n  File \"/opt/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 158, in <lambda>\n    lambda future: callback(future.result()))\n  File \"/opt/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 129, in result\n    raise_exc_info(self.__exc_info)\n  File \"/opt/local/lib/python2.7/site-packages/tornado/concurrent.py\", line 138, in submit\n    future.set_result(fn(*args, **kwargs))\n  File \"/opt/local/lib/python2.7/site-packages/tornado/netutil.py\", line 211, in resolve\n    addrinfo = socket.getaddrinfo(host, port, family)\ngaierror: [Errno 9] service name not available for the specified socket type\npassing socktype & proto would work.\naddrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM, 0)", "issue_status": "Closed", "issue_reporting_time": "2013-04-28T05:44:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "969": {"issue_url": "https://github.com/tornadoweb/tornado/issues/765", "issue_id": "#765", "issue_summary": "Tornado does not handle node-http-proxy websockes on linux", "issue_description": "srossross commented on 27 Apr 2013\nIf I start a server python wsserver.py and then run python wsclient.py --host localhost --port 8888 the tornado server and client behave as expected.\nHowever, if I start up a proxy server as well: node node_modules/http-proxy/bin/node-http-proxy --port 8889 --host localhost --target localhost:8888 then python wsclient.py --host localhost --port 8889 does connect, but no messages get passed.\nThis works fine on Max osx however fails on ubuntu and centos.\nsee this stackoverflow question for details", "issue_status": "Closed", "issue_reporting_time": "2013-04-27T17:33:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "970": {"issue_url": "https://github.com/tornadoweb/tornado/issues/764", "issue_id": "#764", "issue_summary": "ssl_options in httpclient.HTTPRequest", "issue_description": "Member\nbdarnell commented on 27 Apr 2013\nIt should be possible to pass more SSL options through HTTPRequest (specific example: ssl_version, for servers that only accept a specific version instead of the ssl3/tls1 hybrid handshake we use). Ideally this would be the same ssl_options/SSLContext option as seen in the server-side configuration.", "issue_status": "Closed", "issue_reporting_time": "2013-04-27T03:09:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "971": {"issue_url": "https://github.com/tornadoweb/tornado/issues/762", "issue_id": "#762", "issue_summary": "Document AsyncHTTPClient(defaults=dict)", "issue_description": "Member\nbdarnell commented on 27 Apr 2013\nThe defaults argument to the AsyncHTTPClient constructor(s) is not documented. The docs for AsyncHTTPClient also say that constructor args other than io_loop and force_instance are deprecated, which is not exactly true (other args are fine iff force_instance is true)", "issue_status": "Closed", "issue_reporting_time": "2013-04-27T02:48:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "972": {"issue_url": "https://github.com/tornadoweb/tornado/issues/761", "issue_id": "#761", "issue_summary": "Only GET/HEAD in authenticated decorator", "issue_description": "paulocheque commented on 27 Apr 2013\nWhy the decorator tornado.web.authenticated(method) only supports GET/HEAD?\nif self.request.method in (\"GET\", \"HEAD\"):", "issue_status": "Closed", "issue_reporting_time": "2013-04-26T22:48:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "973": {"issue_url": "https://github.com/tornadoweb/tornado/issues/760", "issue_id": "#760", "issue_summary": "Strange Leak on HTTPConnect/IOStream", "issue_description": "Contributor\nwsantos commented on 26 Apr 2013\nI don't get why, the first HTTPConnection will never be collected ex.:\nThe IOStream from the left will never be collected from GC, any glue ? i can't see any reason for wrapper/cell poit to the IOStream.", "issue_status": "Closed", "issue_reporting_time": "2013-04-26T17:08:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "974": {"issue_url": "https://github.com/tornadoweb/tornado/issues/759", "issue_id": "#759", "issue_summary": "No way to catch exceptions when calling coroutine from gen.Task", "issue_description": "ghost commented on 25 Apr 2013\nfrom tornado import gen\nfrom tornado.ioloop import IOLoop\n\n@gen.coroutine\ndef throw():\n    10/0 # Exception here\n    return 'hello'\n\n\n@gen.coroutine\ndef test():\n    print \"i'm ok\"\n    res = yield gen.Task(throw)\n    print \"here too\" # it is never executed\n\n\ntest()\n\nIOLoop.instance().start()\nThere must be a way to catch exceptions.", "issue_status": "Closed", "issue_reporting_time": "2013-04-25T09:52:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "975": {"issue_url": "https://github.com/tornadoweb/tornado/issues/757", "issue_id": "#757", "issue_summary": "Errno 10054 (Connection reset by peer) while using IE", "issue_description": "finlay commented on 24 Apr 2013\nOn windows, and when connecting with IE, you get errors like these:\n  WARNING:root:Read error on 652: [Errno 10054] An existing connection was forcibly   closed by the remote host\n  WARNING:root:error on read\n  Traceback (most recent call last):\n    File \"C:\\Anaconda\\lib\\site-packages\\tornado\\iostream.py\", line 361, in _handle_read\n       if self._read_to_buffer() == 0:\n    File \"C:\\Anaconda\\lib\\site-packages\\tornado\\iostream.py\", line 428, in _read_to_buffer\n      chunk = self._read_from_socket()\n    File \"C:\\Anaconda\\lib\\site-packages\\tornado\\iostream.py\", line 409, in _read_from_socket\n      chunk = self.socket.recv(self.read_chunk_size)\n  error: [Errno 10054] An existing connection was forcibly closed by the remote host\nIt looks like the error number maps to WSAECONNRESET: \"An existing connection was forcibly closed by the remote host.\"\nThe error messages clutter up the error log, no other effects.\nPull request on its way.\nFinlay", "issue_status": "Closed", "issue_reporting_time": "2013-04-24T05:59:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "976": {"issue_url": "https://github.com/tornadoweb/tornado/issues/755", "issue_id": "#755", "issue_summary": "Add interface to set TCP_NODELAY for websockets", "issue_description": "Member\nbdarnell commented on 24 Apr 2013\nTCP_NODELAY is sometimes appropriate for websockets (although it shouldn't be on by default). We should probably have a way to set this that doesn't involve reaching in to self.stream.socket.setsockopt.", "issue_status": "Closed", "issue_reporting_time": "2013-04-24T02:11:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "977": {"issue_url": "https://github.com/tornadoweb/tornado/issues/754", "issue_id": "#754", "issue_summary": "Pickup proxy settings from http_proxy environment variable", "issue_description": "prongs commented on 24 Apr 2013\nI made an app with facebook login and since I'm behind proxy, I'm having trouble getting access token. My handler class is subclassed from FacebookGraphMixin and in the function get_authenticated_user, it calls the function fetch of an http client obtained by self.get_auth_http_client. Now I thought I could overwrite get_auth_http_client to manually set proxy in the resulting client but I don't see any way of setting proxy for AsyncHTTTPClient. The proxy can only be set on an HTTPClient which is instantiated by AsyncHTTPClient in the function fetch. Now it does not make sense to also have to subclass AsyncHTTPClient and HTTPClient, I suggest while initializing HTTPClient, we set proxy_host and proxy_port according to the environment variable http_proxy. This is a standard way of setting proxy for python applications. Many python applications including pip and easy_install also use this, .", "issue_status": "Closed", "issue_reporting_time": "2013-04-23T18:55:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "978": {"issue_url": "https://github.com/tornadoweb/tornado/issues/753", "issue_id": "#753", "issue_summary": "file web.py, line 1390 has no meaning", "issue_description": "guotie commented on 23 Apr 2013\nThis line:\nhandlers.append(spec)\nhas no meaning.", "issue_status": "Closed", "issue_reporting_time": "2013-04-23T08:41:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "979": {"issue_url": "https://github.com/tornadoweb/tornado/issues/751", "issue_id": "#751", "issue_summary": "TypeError caused by a None close_callback", "issue_description": "paulocheque commented on 20 Apr 2013\nTornado 3.0\nI am trying to integrate Flask with Tornado. It works properly in my localhost, but in Heroku it cause the following error. Any ideas?\nfrom flask import Flask\napp = Flask(__name__)\ntr = tornado.wsgi.WSGIContainer(app)\n(r\".*\", tornado.web.FallbackHandler, dict(fallback=tr)),\nERROR tornado.application - Exception in callback <functools.partial object at 0x26b3cb0>\nApr 19 20:30:38 gatournament app/web.1: Traceback (most recent call last):\nApr 19 20:30:38 gatournament app/web.1: File \"/app/.heroku/python/lib/python2.7/site-packages/tornado/ioloop.py\", line 453, in _run_callback\nApr 19 20:30:38 gatournament app/web.1: callback()\nApr 19 20:30:38 gatournament app/web.1: File \"/app/.heroku/python/lib/python2.7/site-packages/tornado/stack_context.py\", line 241, in wrapped\nApr 19 20:30:38 gatournament app/web.1: callback(_args, *_kwargs)\nApr 19 20:30:38 gatournament app/web.1: File \"/app/.heroku/python/lib/python2.7/site-packages/tornado/iostream.py\", line 316, in wrapper\nApr 19 20:30:38 gatournament app/web.1: callback(_args)\nApr 19 20:30:38 gatournament app/web.1: File \"/app/.heroku/python/lib/python2.7/site-packages/tornado/stack_context.py\", line 241, in wrapped\nApr 19 20:30:38 gatournament app/web.1: callback(_args, **kwargs)\nApr 19 20:30:38 gatournament app/web.1: File \"/app/.heroku/python/lib/python2.7/site-packages/tornado/httpserver.py\", line 217, in _on_connection_close\nApr 19 20:30:38 gatournament app/web.1: callback()\nApr 19 20:30:38 gatournament app/web.1: TypeError: 'NoneType' object is not callable", "issue_status": "Closed", "issue_reporting_time": "2013-04-20T03:35:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "980": {"issue_url": "https://github.com/tornadoweb/tornado/issues/743", "issue_id": "#743", "issue_summary": "Handle stream greater then max_buffer_size.", "issue_description": "Contributor\nwsantos commented on 18 Apr 2013\nToday we will raise a exception if we hava a stream greater then max_buffer_size, here some @schlama thougths.\nBottle.py - https://github.com/defnull/bottle/blob/d89d676a6510541e679fac1ac1e8a5745eb87f76/bottle.py#L1050\nFlask.py - http://flask.pocoo.org/docs/patterns/fileuploads/#improving-uploads\nso, the idea is to use TempFile if stream is big.", "issue_status": "Closed", "issue_reporting_time": "2013-04-18T16:34:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "981": {"issue_url": "https://github.com/tornadoweb/tornado/issues/742", "issue_id": "#742", "issue_summary": "Which methods should put under @tornado.web.asynchronous", "issue_description": "wmslei commented on 18 Apr 2013\nI'm sorry, because I can't open the google group, so I submit the question here.\nI want to make a long connection, then I add the @tornado.web.asynchronous in my request handler. At the beginning, I put the post() method and my customized methods under @tornado.web.asynchronous, it works well, but just now, I want to use on_finish method and on_connection_close method do something, I also put them under @tornado.web.asynchronous, when I request, the handler finish directly and return nothing. After that, I attempt to put the two methods before @tornado.web.asynchronous, this time it can work normally.\nFollow is the wrong code:\nclass NewsListenHandler(tornado.web.RequestHandler):\n\"\"\"docstring for NewsListenHandler\"\"\"\n@tornado.web.asynchronous\ndef on_connection_close(self):\n    logging.info('---------connection closed------------')\n\ndef on_finish(self):\n    logging.info('-------request finished------------')\n\ndef post(self):\n   self.timer = threading.Timer(30.0, self.timeout)\n   self.timer.start()\n\ndef timeout(self):\n    logging.info(\"------------listenHandler timer timeout-----------\")\n    if not self.request.connection.stream.closed():\n        self.finish(\"finish\")\nFollow is the right code:\nclass NewsListenHandler(tornado.web.RequestHandler):\n\"\"\"docstring for NewsListenHandler\"\"\"\ndef on_connection_close(self):\n    logging.info('---------connection closed------------')\n\ndef on_finish(self):\n    logging.info('-------request finished------------')\n\n@tornado.web.asynchronous\ndef post(self):\n   self.timer = threading.Timer(30.0, self.timeout)\n   self.timer.start()\n\ndef timeout(self):\n    logging.info(\"------------listenHandler timer timeout-----------\")\n    if not self.request.connection.stream.closed():\n        self.finish(\"finish\")\nSo, I want to know which methods should put under @tornado.web.asynchronous, and which shouldn't.\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2013-04-18T12:00:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "982": {"issue_url": "https://github.com/tornadoweb/tornado/issues/740", "issue_id": "#740", "issue_summary": "Memory leak when process big file upload", "issue_description": "JerryKwan commented on 18 Apr 2013\nsomething is wrong in tornado v3.0.1\nwhen i upload a large file (about 101M, larger than default max_buffer_size), then tornado server raise an exception as follows:\nERROR:tornado.application:Error in connection callback\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/tcpserver.py\", line 228, in _handle_connection\nself.handle_stream(stream, address)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/httpserver.py\", line 157, in handle_stream\nself.no_keep_alive, self.xheaders, self.protocol)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/httpserver.py\", line 190, in init\nself.stream.read_until(b\"\\r\\n\\r\\n\", self._header_callback)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/iostream.py\", line 148, in read_until\nself._try_inline_read()\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/iostream.py\", line 398, in _try_inline_read\nif self._read_to_buffer() == 0:\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0.1-py2.7.egg/tornado/iostream.py\", line 432, in _read_to_buffer\nraise IOError(\"Reached maximum read buffer size\")\nIOError: Reached maximum read buffer size\nbut after several big file upload request, there is a big memory increase in tornado server, so i think may be there is a memory leak in processing big file\nany suggestions? how could i fix it up?", "issue_status": "Closed", "issue_reporting_time": "2013-04-18T08:34:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "983": {"issue_url": "https://github.com/tornadoweb/tornado/issues/737", "issue_id": "#737", "issue_summary": "IOLoop.close is broken on Windows", "issue_description": "Contributor\nschlamar commented on 17 Apr 2013\nBecause you cannot use the file descriptor for the os.* methods.\nTraceback (most recent call last):\n  File \"...\\ioloop.py\", line 512, in close\n    os.close(fd)\nOSError: [Errno 9] Bad file descriptor", "issue_status": "Closed", "issue_reporting_time": "2013-04-17T14:33:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "984": {"issue_url": "https://github.com/tornadoweb/tornado/issues/736", "issue_id": "#736", "issue_summary": "Http header name is wrongly changed", "issue_description": "arrowolfox commented on 17 Apr 2013\nHere I have a problem when using HTTP server. My HTTP header's name is My-UId,but it was changed to My-Uid when reached my App. I saw your Httpmodule has a split and capitalize logic.Is it friendly to change user-defined header name silently?or is for other consideration?Thanks!", "issue_status": "Closed", "issue_reporting_time": "2013-04-17T04:24:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "985": {"issue_url": "https://github.com/tornadoweb/tornado/issues/734", "issue_id": "#734", "issue_summary": "setup.py install fail in python3.3.1 (window xp professtinal 32bit)", "issue_description": "tianyuanzhonglu commented on 15 Apr 2013\nI wonder whether it's a issue of tornado, the prompts:\nD:\\tornado>c:\\Python33\\python.exe setup.py install\nrunning install\nrunning bdist_egg\nrunning egg_info\nwriting tornado.egg-info\\PKG-INFO\nwriting top-level names to tornado.egg-info\\top_level.txt\nwriting dependency_links to tornado.egg-info\\dependency_links.txt\nreading manifest file 'tornado.egg-info\\SOURCES.txt'\nreading manifest template 'MANIFEST.in'\nwarning: no previously-included files matching 'auto2to3*' found anywhere in distribution\nwriting manifest file 'tornado.egg-info\\SOURCES.txt'\ninstalling library code to build\\bdist.win32\\egg\nrunning install_lib\nrunning build_py\ncreating build\\bdist.win32\\egg\ncreating build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\auth.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\autoreload.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\ca-certificates.crt -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\concurrent.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\curl_httpclient.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\escape.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\gen.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\httpclient.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\httpserver.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\httputil.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\ioloop.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\iostream.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\locale.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\log.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\netutil.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\options.py -> build\\bdist.win32\\egg\\tornado\ncreating build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\auto.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\caresresolver.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\common.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\epoll.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\interface.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\kqueue.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\posix.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\select.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\twisted.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform\\windows.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\platform__init_.py -> build\\bdist.win32\\egg\\tornado\\platform\ncopying build\\lib\\tornado\\process.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\simple_httpclient.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\stack_context.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\tcpserver.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\template.py -> build\\bdist.win32\\egg\\tornado\ncreating build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\auth_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\concurrent_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncreating build\\bdist.win32\\egg\\tornado\\test\\csv_translations\ncopying build\\lib\\tornado\\test\\csv_translations\\fr_FR.csv -> build\\bdist.win32\\egg\\tornado\\test\\csv_translations\ncopying build\\lib\\tornado\\test\\curl_httpclient_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\escape_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\gen_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncreating build\\bdist.win32\\egg\\tornado\\test\\gettext_translations\ncreating build\\bdist.win32\\egg\\tornado\\test\\gettext_translations\\fr_FR\ncreating build\\bdist.win32\\egg\\tornado\\test\\gettext_translations\\fr_FR\\LC_MESSAGES\ncopying build\\lib\\tornado\\test\\gettext_translations\\fr_FR\\LC_MESSAGES\\tornado_test.mo -> build\\bdist.win32\\egg\\tornado\\test\\gettext_translations\\fr_FR\\LC_MESSAGES\ncopying build\\lib\\tornado\\test\\gettext_translations\\fr_FR\\LC_MESSAGES\\tornado_test.po -> build\\bdist.win32\\egg\\tornado\\test\\gettext_translations\\fr_FR\\LC_MESSAGES\ncopying build\\lib\\tornado\\test\\httpclient_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\httpserver_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\httputil_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\import_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\ioloop_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\iostream_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\locale_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\log_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\netutil_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\options_test.cfg -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\options_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\process_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\README -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\runtests.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\simple_httpclient_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\stack_context_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncreating build\\bdist.win32\\egg\\tornado\\test\\static\ncopying build\\lib\\tornado\\test\\static\\robots.txt -> build\\bdist.win32\\egg\\tornado\\test\\static\ncreating build\\bdist.win32\\egg\\tornado\\test\\templates\ncopying build\\lib\\tornado\\test\\templates\\utf8.html -> build\\bdist.win32\\egg\\tornado\\test\\templates\ncopying build\\lib\\tornado\\test\\template_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\test.crt -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\test.key -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\testing_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\twisted_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\util.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\util_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\websocket_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\web_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test\\wsgi_test.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\test__init__.py -> build\\bdist.win32\\egg\\tornado\\test\ncopying build\\lib\\tornado\\testing.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\util.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\web.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\websocket.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado\\wsgi.py -> build\\bdist.win32\\egg\\tornado\ncopying build\\lib\\tornado__init__.py -> build\\bdist.win32\\egg\\tornado\nbyte-compiling build\\bdist.win32\\egg\\tornado\\auth.py to auth.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\autoreload.py to autoreload.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\concurrent.py to concurrent.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\curl_httpclient.py to curl_httpclient.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\escape.py to escape.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\gen.py to gen.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\httpclient.py to httpclient.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\httpserver.py to httpserver.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\httputil.py to httputil.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\ioloop.py to ioloop.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\iostream.py to iostream.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\locale.py to locale.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\log.py to log.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\netutil.py to netutil.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\options.py to options.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\auto.py to auto.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\caresresolver.py to caresresolver.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\common.py to common.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\epoll.py to epoll.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\interface.py to interface.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\kqueue.py to kqueue.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\posix.py to posix.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\select.py to select.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\twisted.py to twisted.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform\\windows.py to windows.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\platform__init__.py to init.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\process.py to process.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\simple_httpclient.py to simple_httpclient.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\stack_context.py to stack_context.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\tcpserver.py to tcpserver.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\template.py to template.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\auth_test.py to auth_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\concurrent_test.py to concurrent_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\curl_httpclient_test.py to curl_httpclient_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\escape_test.py to escape_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\gen_test.py to gen_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\httpclient_test.py to httpclient_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\httpserver_test.py to httpserver_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\httputil_test.py to httputil_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\import_test.py to import_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\ioloop_test.py to ioloop_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\iostream_test.py to iostream_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\locale_test.py to locale_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\log_test.py to log_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\netutil_test.py to netutil_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\options_test.py to options_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\process_test.py to process_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\runtests.py to runtests.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\simple_httpclient_test.py to simple_httpclient_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\stack_context_test.py to stack_context_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\template_test.py to template_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\testing_test.py to testing_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\twisted_test.py to twisted_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\util.py to util.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\util_test.py to util_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\websocket_test.py to websocket_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\web_test.py to web_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test\\wsgi_test.py to wsgi_test.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\test__init__.py to init.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\testing.py to testing.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\util.py to util.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\web.py to web.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\websocket.py to websocket.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado\\wsgi.py to wsgi.cpython-33.pyc\nbyte-compiling build\\bdist.win32\\egg\\tornado__init__.py to init.cpython-33.pyc\ncreating build\\bdist.win32\\egg\\EGG-INFO\ncopying tornado.egg-info\\PKG-INFO -> build\\bdist.win32\\egg\\EGG-INFO\ncopying tornado.egg-info\\SOURCES.txt -> build\\bdist.win32\\egg\\EGG-INFO\ncopying tornado.egg-info\\dependency_links.txt -> build\\bdist.win32\\egg\\EGG-INFO\ncopying tornado.egg-info\\top_level.txt -> build\\bdist.win32\\egg\\EGG-INFO\nzip_safe flag not set; analyzing archive contents...\nTraceback (most recent call last):\nFile \"setup.py\", line 71, in\n**kwargs\nFile \"c:\\Python33\\lib\\distutils\\core.py\", line 148, in setup\ndist.run_commands()\nFile \"c:\\Python33\\lib\\distutils\\dist.py\", line 917, in run_commands\nself.run_command(cmd)\nFile \"c:\\Python33\\lib\\distutils\\dist.py\", line 936, in run_command\ncmd_obj.run()\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\install.py\", line 73, in run\nself.do_egg_install()\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\install.py\", line 93, in do_egg_install\nself.run_command('bdist_egg')\nFile \"c:\\Python33\\lib\\distutils\\cmd.py\", line 313, in run_command\nself.distribution.run_command(command)\nFile \"c:\\Python33\\lib\\distutils\\dist.py\", line 936, in run_command\ncmd_obj.run()\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\bdist_egg.py\", line 227, in run\nos.path.join(archive_root,'EGG-INFO'), self.zip_safe()\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\bdist_egg.py\", line 266, in zip_safe\nreturn analyze_egg(self.bdist_dir, self.stubs)\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\bdist_egg.py\", line 402, in analyze_egg\nsafe = scan_module(egg_dir, base, name, stubs) and safe\nFile \"c:\\Python33\\lib\\site-packages\\distribute-0.6.27-py3.3.egg\\setuptools\\command\\bdist_egg.py\", line 429, in scan_module\ncode = marshal.load(f); f.close()\nValueError: bad marshal data (unknown type code)", "issue_status": "Closed", "issue_reporting_time": "2013-04-15T05:02:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "986": {"issue_url": "https://github.com/tornadoweb/tornado/issues/732", "issue_id": "#732", "issue_summary": "Expose IOStream's max_buffer_size setting via HTTPServer", "issue_description": "Member\nbdarnell commented on 14 Apr 2013\nIt should be possible to start an HTTPServer with a higher or lower buffer size than the default.", "issue_status": "Closed", "issue_reporting_time": "2013-04-14T18:16:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "987": {"issue_url": "https://github.com/tornadoweb/tornado/issues/730", "issue_id": "#730", "issue_summary": "Allow customization of logging behavior in RequestHandler._handle_request_exception", "issue_description": "Member\nbdarnell commented on 14 Apr 2013\nHTTPErrors are logged less verbosely than other errors. Some applications may wish to define their own error classes and handle them specially in write_error, and these exceptions should be treated more like HTTPError than a general uncaught exception. There should be some sort of hook to determine whether an exception needs the full stack trace to be logged.", "issue_status": "Closed", "issue_reporting_time": "2013-04-14T18:07:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "988": {"issue_url": "https://github.com/tornadoweb/tornado/issues/729", "issue_id": "#729", "issue_summary": "Google OpenID switches from GET to POST when the response is large", "issue_description": "Member\nbdarnell commented on 14 Apr 2013\nhttps://developers.google.com/google-apps/marketplace/testing#openid_post\nThis is a problem both because the docs only talk about overriding GET, and XSRF checking needs to be disabled.", "issue_status": "Closed", "issue_reporting_time": "2013-04-14T17:55:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "989": {"issue_url": "https://github.com/tornadoweb/tornado/issues/726", "issue_id": "#726", "issue_summary": "In blog demo, the _() not works as expect", "issue_description": "zhkzyth commented on 14 Apr 2013\nHi, i try to run the blog demo, but got some srange output from _ function.\n{{ _('<a href=\"%(url)s\">Sign in</a> to compose/edit') % {\"url\": \"/auth/login?next=\" + url_escape(request.uri)} }}\nAfter the translate, the a tag and other entities were escaped.Is this a bug, or it is the duty for the developer use js to render it correctly?", "issue_status": "Closed", "issue_reporting_time": "2013-04-13T19:56:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "990": {"issue_url": "https://github.com/tornadoweb/tornado/issues/724", "issue_id": "#724", "issue_summary": "RequestHandler's set_cookie method with wrong formatted expires attribute", "issue_description": "fabiant7t commented on 12 Apr 2013\nWhen using RequestHandler.set_cookie to set an expiring cookie, Tornado formats that expires datetime value the way it is used in HTTP. It must be formatted the way Netscape did it, with hyphens between day, month and year, not spaces.\nInstead of \n'Set-Cookie': 'foo=bar; expires=Sat, 14 Jul 2012 08:33:00 GMT; Path=/'\nit must be\n'Set-Cookie': 'foo=bar; expires=Sat, 14-Jul-2012 08:33:00 GMT; Path=/'\nExpires never became a standard and should get replaced by Max-Age, although it is still widely used.", "issue_status": "Closed", "issue_reporting_time": "2013-04-12T16:36:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "991": {"issue_url": "https://github.com/tornadoweb/tornado/issues/722", "issue_id": "#722", "issue_summary": "tornado.database Importerror: No module named database", "issue_description": "jgentes commented on 11 Apr 2013\nI'm using a fork of Bret Taylor's 'socialcookbook' (https://github.com/finiteloop/socialcookbook) which uses \"import tornado.database\" - and it's worked perfectly until yesterday (the 3.01 build?) and now I'm getting an ImportError: no module named database when I compile on Heroku.\nAny ideas?\nThanks,\n-James", "issue_status": "Closed", "issue_reporting_time": "2013-04-10T23:15:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "992": {"issue_url": "https://github.com/tornadoweb/tornado/issues/721", "issue_id": "#721", "issue_summary": "application.listen and httpserver.listen", "issue_description": "wmslei commented on 10 Apr 2013\nMy question is some demos use httpserver when some don't use it, they use application.listen directly.I want to know what difference between them? Thanks.", "issue_status": "Closed", "issue_reporting_time": "2013-04-10T02:50:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "993": {"issue_url": "https://github.com/tornadoweb/tornado/issues/718", "issue_id": "#718", "issue_summary": "HTTPResponse.request is _RequestProxy type in 3.0", "issue_description": "Contributor\ncodeb2cc commented on 8 Apr 2013\nI have some codes like:\nif response.error and elapsed_time < TIMEOUT and retrial < MAX_RETRIAL:\n    self._http_client.fetch(\n        response.request,\n        partial(self.on_response, callback=callback, retrial=retrial + 1),\n    )\nBut in Tornado 3.0, HTTPResponse.request is now an instance of _RequestProxy instead of the old HTTPRequest. Codes above will not pass fetch's validation:\nhttpclient.py:170\nif not isinstance(request, HTTPRequest):\n    request = HTTPRequest(url=request, **kwargs)\nThen url becomes an object and will raise an assertion error when try to _unicode. I think it's better to specify the change in DOC and release notes. Or maybe update the fetch to accept an _RequestProxy type request.", "issue_status": "Closed", "issue_reporting_time": "2013-04-08T09:22:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "994": {"issue_url": "https://github.com/tornadoweb/tornado/issues/717", "issue_id": "#717", "issue_summary": "blog demo error", "issue_description": "wmslei commented on 7 Apr 2013\nFile \"blog.py\", line 17, in\nimport markdown\nImportError: No module named markdown", "issue_status": "Closed", "issue_reporting_time": "2013-04-07T11:30:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "995": {"issue_url": "https://github.com/tornadoweb/tornado/issues/716", "issue_id": "#716", "issue_summary": "StaticFileHandler errors with non-ascii path", "issue_description": "wmslei commented on 7 Apr 2013\nUncaught exception GET /static/chat.js?v=8dadd (192.168.1.25)\nHTTPRequest(protocol='http', host='192.168.1.110:8888', method='GET', uri='/static/chat.js?v=8dadd', version='HTTP/1.1', remote_ip='192.168.1.25', body='', headers={'Accept-Language': 'en-US,en;q=0.5', 'Accept-Encoding': 'gzip, deflate', 'Host': '192.168.1.110:8888', 'Accept': '/', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:19.0) Gecko/20100101 Firefox/19.0', 'Connection': 'keep-alive', 'Referer': 'http://192.168.1.110:8888/', 'Cookie': 'chatdemo_user=\"eyJjbGFpbWVkX2lkIjogImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vYWNjb3VudHMvbzgvaWQ/aWQ9QUl0T2F3bGptbHZHTmtuTkRkckw0cC1ub2xzSzVNSjBYZ2FlcEc0IiwgImZpcnN0X25hbWUiOiAiXHU3OGNhIiwgImxhc3RfbmFtZSI6ICJcdTViNTkiLCAibmFtZSI6ICJcdTc4Y2EgXHU1YjU5In0=|1365320273|c93e31f9e6d462c8c95ed14e534a7d8fc3cf312c\"; _xsrf=edeb3a8aa7b646dd980191b93f15e830'})\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0-py2.7.egg/tornado/web.py\", line 1077, in _execute\n_self.path_args, *_self.path_kwargs)\nFile \"/usr/local/lib/python2.7/dist-packages/tornado-3.0-py2.7.egg/tornado/web.py\", line 1622, in get\nabspath = os.path.abspath(os.path.join(self.root, path))\nFile \"/usr/lib/python2.7/posixpath.py\", line 78, in join\npath += b\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 15: ordinal not in range(128)\n[E 130407 17:04:37 web:1514] 500 GET /static/chat.js?v=8dadd (192.168.1.25) 0.84ms", "issue_status": "Closed", "issue_reporting_time": "2013-04-07T09:06:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "996": {"issue_url": "https://github.com/tornadoweb/tornado/issues/715", "issue_id": "#715", "issue_summary": "chat demo 500", "issue_description": "wmslei commented on 7 Apr 2013\n500 GET /static/chat.js?v=8dadd (192.168.1.25).\nmy server ip is 192.168.1.110 now.", "issue_status": "Closed", "issue_reporting_time": "2013-04-07T05:31:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "997": {"issue_url": "https://github.com/tornadoweb/tornado/issues/714", "issue_id": "#714", "issue_summary": "chat demo 500", "issue_description": "wmslei commented on 7 Apr 2013\n500 GET /static/chat.js?v=8dadd (192.168.1.25) ,but now my ip is 192.168.1.12", "issue_status": "Closed", "issue_reporting_time": "2013-04-07T04:31:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "998": {"issue_url": "https://github.com/tornadoweb/tornado/issues/713", "issue_id": "#713", "issue_summary": "OverflowError execption in web.py", "issue_description": "juhasch commented on 6 Apr 2013\nI am using Tornado 2.4.1 and get an OverflowError exception in web.py when trying to load a processing.js sketch using Tornado on Windows 7. I can't reproduce it on Linux.\nWhat happens is that calling\nims_value = self.request.headers.get(\"If-Modified-Since\")\nreturns\n\"Fri, 01 Jan 1960 00:00:00 GMT\"\nThis causes an OverflowError exeption in time.mktime:\ndate_tuple = email.utils.parsedate(ims_value)\ntime.mktime(date_tuple)", "issue_status": "Closed", "issue_reporting_time": "2013-04-06T08:16:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "999": {"issue_url": "https://github.com/tornadoweb/tornado/issues/712", "issue_id": "#712", "issue_summary": "curl_httpclient going into an infinite loop", "issue_description": "wilem82 commented on 4 Apr 2013\nhttps://github.com/facebook/tornado/blob/v3.0.0/tornado/curl_httpclient.py#L175\npycurl has a bug that causes integer overflow and\nself._multi.timeout()\nto return large negative values, which starts a really, really long chain of _handle_timeout() calls and tornado to stop responding.\nSee also http://curl.haxx.se/mail/curlpython-2013-04/0000.html .\nUntil pycurl is fixed, it would be a good idea to do:\nif new_timeout >= 0:", "issue_status": "Closed", "issue_reporting_time": "2013-04-04T11:48:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1000": {"issue_url": "https://github.com/tornadoweb/tornado/issues/711", "issue_id": "#711", "issue_summary": "500 GET /static/chat.js?v=8dadd", "issue_description": "wmslei commented on 3 Apr 2013\ndemo chat\n500 GET /static/chat.js?v=8dadd", "issue_status": "Closed", "issue_reporting_time": "2013-04-03T11:02:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1001": {"issue_url": "https://github.com/tornadoweb/tornado/issues/710", "issue_id": "#710", "issue_summary": "websocket demo 404", "issue_description": "wmslei commented on 3 Apr 2013\nWhen post message,happen 404error", "issue_status": "Closed", "issue_reporting_time": "2013-04-03T09:58:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1002": {"issue_url": "https://github.com/tornadoweb/tornado/issues/709", "issue_id": "#709", "issue_summary": "chat demo can't auto refresh message", "issue_description": "wmslei commented on 3 Apr 2013\nI download the lastest version and install it.Then I run the chat demo,the message page couldn't auto refresh message.The early version can do.", "issue_status": "Closed", "issue_reporting_time": "2013-04-03T09:57:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1003": {"issue_url": "https://github.com/tornadoweb/tornado/issues/708", "issue_id": "#708", "issue_summary": "Incorrect StringIO import in testing.py", "issue_description": "genericmoniker commented on 3 Apr 2013\nI'm getting Lots of errors while using the LogTrapTestCase:\nTypeError: unicode argument expected, got 'str'\nI believe this is because of these lines in testing.py:\ntry:\nfrom io import StringIO # py3\nexcept ImportError:\nfrom cStringIO import StringIO # py2\nThe first import works fine on Python 2.7.3, but now all log messages are expected to be unicode. Elsewhere in the Tornado source the construct is:\ntry:\nfrom cStringIO import StringIO # py2\nexcept ImportError:\nfrom io import StringIO # py3", "issue_status": "Closed", "issue_reporting_time": "2013-04-02T20:51:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1004": {"issue_url": "https://github.com/tornadoweb/tornado/issues/705", "issue_id": "#705", "issue_summary": "JSON encoder should accept (optional) arguments", "issue_description": "mminer commented on 1 Apr 2013\nIt's impossible to send arguments to Tornado's json_encode function that one might send to Python's built-in json.dumps. In particular, the latter's default argument accepts a function that can be used to tell the encoder how to handle (for example) datetimes, and I would like to continue doing this while using json_encode.\nDitto for json_decode.", "issue_status": "Closed", "issue_reporting_time": "2013-04-01T04:11:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1005": {"issue_url": "https://github.com/tornadoweb/tornado/issues/699", "issue_id": "#699", "issue_summary": "HTTPServer._on_headers should catch ValueError from HTTPHeaders.parse()", "issue_description": "scavpy commented on 19 Mar 2013\ntornado/httpserver.py, line 283\nThe call to HTTPHeaders.parse() is not in a try block, so if there's a malformed header, the exception isn't caught. It would be better to do this:\ntry:\n    headers = httputil.HTTPHeaders.parse(data[eol:])\nexcept ValueError:\n    raise _BadRequestException(\"Malformed header\")\nwhich is consistent with how other problems in the headers are handled. ValueError is the most likely, because that's what you get if a header line contains no colon; the tuple unpack inside parse_line() fails.", "issue_status": "Closed", "issue_reporting_time": "2013-03-19T11:20:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1006": {"issue_url": "https://github.com/tornadoweb/tornado/issues/694", "issue_id": "#694", "issue_summary": "self.finish not terminating the http connection", "issue_description": "shaileshgupta commented on 11 Mar 2013\nUpon executing self.write_error(401), the connection is not terminated, but proceeds to next line. This is not the expected behavior. Can anyone confirm.", "issue_status": "Closed", "issue_reporting_time": "2013-03-11T14:11:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1007": {"issue_url": "https://github.com/tornadoweb/tornado/issues/692", "issue_id": "#692", "issue_summary": "Tornado download speed limits and traffic records", "issue_description": "toadzhou commented on 10 Mar 2013\nWEBDISK need to purchase a speed limits and traffic features. Don't know how to implement tornado! ?\ndef get(self):\nself.set_header(\"Content-Type\", \"application/zip\")\nself.set_header(\"Content-Disposition\", \"haha.zip\")\nself.write(\"XXXXXXX\")\nQOS & Real-time network traffic\nSorry!Please forgive me do not understand English!", "issue_status": "Closed", "issue_reporting_time": "2013-03-10T09:38:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1008": {"issue_url": "https://github.com/tornadoweb/tornado/issues/689", "issue_id": "#689", "issue_summary": "When sharing IOLoop, Requests on port x are serviced in the wrong thread.", "issue_description": "ghost commented on 4 Mar 2013\nI ran into this issue while developing a library on top of tornado. The documentation clearly states that it's unsafe to call most methods from a different thread, but the handler doesn't call to any tornado methods. (and python's print not being thread-safe is irrelavent here).\nVersions affected\n2.4.1, git master dbff2b5, probably earlier version as well.\nThe scenario:\nMultiple HTTPServer, each listening to a different port\nShared global IOLoop shared, via tornado.ioloop.IOLoop().instance().\nAll server have a handler with an identical URLSpec , \"/a\" in the example below\nWhen invoked, the request handler merely prints the ident of the current thread\nto stdout.\nSymptoms:\nWhen issuing a request to a server at a specific port, the reported thread ident\nis not constant, and cycles randomly through the all the threads of the other\nservers who have a matching URLSpec.\nI'm relying on per-server, thread-local data to be available to handlers and this\nbehaviour breaks that.\nExpected behaviour\nrequsts made to a server on a given port would always be handled\nfrom within the thread of that server, and none other.\nMitigation\nUsing multple IOLoops , rather then the global singleton loop, one per\nserver has so far eliminated these issues.\nSteps to reproduce\nThe following script reproduces the problem, the number of servers\nrunning only needs to be >=2, but more servers make the problem\nmore apparent.\nAfter running the script, open up a browser to http://127.0.0.1:9000,\nand repeatedly hit refresh. The console output will show the ident of\nthe thread serving the requiest, which is randomly cycling through threads.\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport threading\nimport errno\nimport time\nfrom tornado.httpserver import HTTPServer\nfrom tornado.web import  RequestHandler\n\nclass H(RequestHandler):\n    def get(self):\n        print( str(threading.current_thread().ident))\n\nclass SRV( threading.Thread):\n    def __init__(self, port=None, address='127.0.0.1', **kwds):\n        \"\"\"\n        If port== None, will pick one automatically\n        \"\"\"\n        import tornado.web\n        import tornado.ioloop\n\n        super(SRV, self).__init__()\n\n        self.name = \"Server Thread\"\n        self.daemon = True\n\n        # this is the important bit\n        self.ioloop = tornado.ioloop.IOLoop().instance()\n        self.application = tornado.web.Application(debug=False)\n        self._server = HTTPServer(self.application)\n\n        # vs. this, which behaves as I would accept\n        # self.ioloop = tornado.ioloop.IOLoop()#.instance()\n        # self.application = tornado.web.Application(debug=False)\n        # self._server = HTTPServer(self.application,io_loop=self.ioloop)\n\n        self._address_requested = address\n        self._port_used = None\n        self._address_used = None\n\n\n    def run(self):\n        import socket\n        from tornado.web import URLSpec\n\n        self.application.add_handlers(\"\", [URLSpec('/a',H )]) # re-register everything\n\n        for portnum in range(9000,10000):\n            try:\n                self._server.listen(portnum,'127.0.0.1')\n                print('Server listening on port {0}'.format(portnum))\n                self._port_used = portnum\n                self._address_used = self._address_requested\n                self.ioloop.start()\n\n                return\n            except socket.error as  e:\n                if e.errno != errno.EADDRINUSE:\n                    logger.error(str(e))\n                    break\n\nservers=[]\nfor i in range(10):\n    servers.append(SRV())\n    servers[-1].start()\n\nwhile(True):\n    time.sleep(1)  # block main thread til KBInterrupt", "issue_status": "Closed", "issue_reporting_time": "2013-03-04T13:12:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1009": {"issue_url": "https://github.com/tornadoweb/tornado/issues/688", "issue_id": "#688", "issue_summary": "url quote in wsgi.HTTPRequest", "issue_description": "dram commented on 4 Mar 2013\nWhen quoting PATH_INFO in HTTPRequest, some safe characters may also be quoted, it will cause url routing mismatch.\nAccording to a answer at SO [1], and code from Python2.7.3 (urllib.py L182) , additional safe argument is needed:\nquote(fullurl, safe=\"%/:=&?~#+!$,;'@()*[]|\")\n[1] http://stackoverflow.com/a/845595", "issue_status": "Closed", "issue_reporting_time": "2013-03-04T07:43:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1010": {"issue_url": "https://github.com/tornadoweb/tornado/issues/687", "issue_id": "#687", "issue_summary": "@authenticated should raise HTTPError(401), not HTTPError(403)", "issue_description": "clarkorz commented on 1 Mar 2013\naccording to rfc2616 section 10.4.2 and 10.4.4, @authenticated should raise 401 when authentication failed, not 403.\n403 means you can't get the resource even if you have passed the authentication.", "issue_status": "Closed", "issue_reporting_time": "2013-03-01T15:39:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1011": {"issue_url": "https://github.com/tornadoweb/tornado/issues/679", "issue_id": "#679", "issue_summary": "Tornado Middleware", "issue_description": "Contributor\nysimonson commented on 11 Feb 2013\nI've seen this mentioned a few times ([1], [2]), but I think it's worth revisiting.\nMy company manages multiple tornado-backed sites, and one problem we've had is the management of middleware-like logic across sites. For example, we use SQLAlchemy for our ORM. Currently on each of the sites we create a base controller that overrides on_finish to ensure per-request DB transactions are closed out.\nNow, we could create a single common base controller that all controllers across all of the sites inherit. But there's a couple of problems:\nThe middleware-like logic across the sites can sometimes be different. e.g. some sites use the default static_url implementation for Tornado, whereas others override it to play well with a CDN deployment.\nWe'd have to separate out the base controller into a python package so it's easily distributable. This feels heavy.\nIdeally, there would just be a way to hook this sort of logic into a site without resorting to creating a base controller - i.e. there would a middleware system. I think this would bring about better modularity, and in turn, get people to share tiny bits of tornado logic that might otherwise remain proprietary. I know we certainly would be happy to move our middleware-like logic into something open source.\nThis would be a pretty major change, so I'd like some opinions on whether this could feasibly be merged in - and what it might look like - before continuing forward. But I'm willing to code something up and submit a pull request.\nOne thing to bear in mind is that this might deprecate OutputTransforms, because they would be redundant. That would mean either this would have to be a breaking change, or the middleware engine would have to be designed to support backwards-compatibility with OutputTransforms.\n1: #49\n2: https://groups.google.com/forum/?fromgroups=#!topic/python-tornado/YPKQYHG6Hg0", "issue_status": "Closed", "issue_reporting_time": "2013-02-11T17:56:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1012": {"issue_url": "https://github.com/tornadoweb/tornado/issues/674", "issue_id": "#674", "issue_summary": "tornado.testing.LogTrapTestCase doesn't work with nose.plugin.logcapture", "issue_description": "clarkorz commented on 4 Feb 2013\nif the TastCase inherits tornado.testing.LogTrapTestCase and runing under nose, test will fail because:\nFile \"/Developer/python/beginner_env/lib/python2.7/site-packages/tornado/testing.py\", line 355, in run\nassert isinstance(handler, logging.StreamHandler)\nAssertionError\nAccording to tornado document, \"This class assumes that only one log handler is configured and that it is a StreamHandler. This is true for both logging.basicConfig and the \u201cpretty logging\u201d configured by tornado.options.\"\nI think they have familiar effect, using each one is ok. So it's a conflict. Fix it or document it:)", "issue_status": "Closed", "issue_reporting_time": "2013-02-04T15:42:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1013": {"issue_url": "https://github.com/tornadoweb/tornado/issues/673", "issue_id": "#673", "issue_summary": "IOLoop subclasses", "issue_description": "Contributor\nminrk commented on 24 Jan 2013\nI maintain zeromq/pyzmq, which ships a copy of tornado.ioloop (as of 2.4.1), and I've been looking into the changes coming for tornado 3.0, and what they might mean for pyzmq.\nThe changes made for zmq compatibility are minimal:\nIOLoop.close(socket) adds a check for fd.close(), so that it can close zmq sockets. This is easy enough with a subclass, since the close method is small.\npoll() can raise particular errors. base IOLoop handles EINTR specially, but I add a switch to interpret zmq.ETERM as an instruction to exit the loop. It wouldn't be awesome to override start(), because it's a tiny change in a massive method.\nMy question is, would you be amenable to making it easier to add this ETERM functionality? Either via config (e.g. IOLoop.errno_handlers[zmq.ETERM] = loop.stop) or breaking up loop.start() into smaller bites (e.g. try: poll(); except: self._handle_poll_error())?", "issue_status": "Closed", "issue_reporting_time": "2013-01-24T06:09:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1014": {"issue_url": "https://github.com/tornadoweb/tornado/issues/672", "issue_id": "#672", "issue_summary": "PollIOLoop.stop() aborts the current event loop iteration.", "issue_description": "jordens commented on 24 Jan 2013\nTHe docstring to stop() says \"Stop the loop after the current event loop iteration is complete.\" But PollIOLoop.stop() aborts the eventloop mid flight before any polling happens. This makes it impossible to do the following to have the loop do a single iteration as no IO is done:\nloop.add_timeout(0, loop.stop)\nloop.start()\nI submitted this for pyzmq which copied the eventloop and was asked to submit it here:.\nzeromq/pyzmq#297\nIf this is not the right solution, how can I run a single iteration of the loop?", "issue_status": "Closed", "issue_reporting_time": "2013-01-24T05:28:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1015": {"issue_url": "https://github.com/tornadoweb/tornado/issues/671", "issue_id": "#671", "issue_summary": "python3 pycurl tests fail on ubuntu", "issue_description": "juliantaylor commented on 24 Jan 2013\nubuntu has an unofficial pycurl python3 port which causes a failure in the curl testsuite of tornado 2.4.1.\nin this port Curl().setopt takes a unicode string instead of bytes as utf() returns\nthis leads to these failures:\n  File \"/usr/lib/python3/dist-packages/tornado/curl_httpclient.py\", line 273, in _curl_setup_request\n    curl.setopt(pycurl.URL, utf8(request.url))\nTypeError: invalid arguments to setopt\n\n\n  File \"/usr/lib/python3/dist-packages/tornado/curl_httpclient.py\", line 293, in _curl_setup_request\n    [utf8(\"%s: %s\" % i) for i in request.headers.get_all()])\nTypeError: list items must be string objects\nas the patch is unofficial and not yet accepted upstream (see http://sourceforge.net/tracker/?func=detail&aid=3188495&group_id=28236&atid=392779) there is probably not much you should do\nI just filed this issue so you know about it and maybe have an opinion on ubuntu's patch.", "issue_status": "Closed", "issue_reporting_time": "2013-01-23T20:50:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1016": {"issue_url": "https://github.com/tornadoweb/tornado/issues/666", "issue_id": "#666", "issue_summary": "Allow options to be mutable", "issue_description": "Contributor\nemehrkay commented on 13 Jan 2013\nWith a simple flag we could be able to change an existing option later in code\n   #tornado.options._Options\n\n    def define(self, name, default=None, type=None, help=None, metavar=None,\n               multiple=False, group=None, mutable=False):\n        if name in self and not mutable:\n            ...\nThanks", "issue_status": "Closed", "issue_reporting_time": "2013-01-13T01:46:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1017": {"issue_url": "https://github.com/tornadoweb/tornado/issues/663", "issue_id": "#663", "issue_summary": "AsynHTTPTestCase tests fail on asynchronous handlers?", "issue_description": "tomekwojcik commented on 8 Jan 2013\nI've stumbled upon a weird problem that occurs when using AsyncHTTPTestCase to test a handler that's asynchronous.\nExample code to reproduce the bug:\napplication.py\nimport tornado.httpclient\nimport tornado.ioloop\nimport tornado.web\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        http = tornado.httpclient.AsyncHTTPClient()\n        http.fetch(\"http://httpbin.org/get\",\n                   callback=self.on_response)\n\n    def on_response(self, response):\n        if response.error: raise tornado.web.HTTPError(500)\n        self.write(response.body)\n        self.finish()\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n], debug=True)\n\nif __name__ == \"__main__\":\n    application.listen(12345)\n    tornado.ioloop.IOLoop.instance().start()\ntest_application.py\n# -*- coding: utf-8 -*-\n\nimport tornado.testing\nimport unittest\n\nimport application\n\n\nclass AsyncAppTestCase(tornado.testing.AsyncHTTPTestCase):\n    def get_app(self):\n        return application.application\n\n    def test_async_response(self):\n        self.http_client.fetch(self.get_url('/'), self.stop)\n        response = self.wait()\n        assert response.body == 'OK'\n\nif __name__ == '__main__':\n    unittest.main()\nRunning $ python test_application.py yields the following result:\nF\n======================================================================\nFAIL: test_async_response (__main__.AsyncAppTestCase)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_acync.py\", line 15, in test_async_response\n    response = self.wait()\n  File \"/Users/bilbo/Projects/playground/lib/python2.7/site-packages/tornado/testing.py\", line 205, in wait\n    self.__rethrow()\n  File \"/Users/bilbo/Projects/playground/lib/python2.7/site-packages/tornado/testing.py\", line 149, in __rethrow\n    raise_exc_info(failure)\n  File \"/Users/bilbo/Projects/playground/lib/python2.7/site-packages/tornado/testing.py\", line 186, in timeout_func\n    timeout)\nAssertionError: Async operation timed out after 5 seconds\n\n----------------------------------------------------------------------\nRan 1 test in 5.012s\n\nFAILED (failures=1)\nQuerying the server with curl or anything works as expected.\nI've checked with PDB and it looks like the MainHandler.on_response method isn't invoked in tests.\nAny ideas?\nNOTE: As you can see the code is pretty much copy-pasted from examples given in the docs. The same happens in a production app I'm working on which code is pretty much the same (except using AsyncMongo instead of HTTPClient) but I cannot share it.", "issue_status": "Closed", "issue_reporting_time": "2013-01-08T11:35:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1018": {"issue_url": "https://github.com/tornadoweb/tornado/issues/661", "issue_id": "#661", "issue_summary": "WebSockets ucaught exception in", "issue_description": "truhlikfredy commented on 6 Jan 2013\nI have ping application, so server side after receiving relies the data back. I think I get this error when I receive message and try to rely it back while the connection waits in the close handshake (or somewhere there, but around time when it closes the connection).\nERROR:root:Uncaught exception in /\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/websocket.py\", line 258, in wrapper\n    return callback(*args, **kwargs)\n  File \"./t_ping.py-2.py\", line 24, in on_message\n    self.write_message(message)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/websocket.py\", line 144, in write_message\n    self.ws_connection.write_message(message, binary=binary)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/websocket.py\", line 526, in write_message\n    self._write_frame(True, opcode, message)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/websocket.py\", line 516, in _write_frame\n    self.stream.write(frame)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/iostream.py\", line 202, in write\n    self._check_closed()\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-2.4.1-py2.6.egg/tornado/iostream.py\", line 571, in _check_closed\n    raise IOError(\"Stream is closed\")\nIOError: Stream is closed\nThe server side source is:\n#!/usr/bin/env python\n\nimport os.path\nfrom tornado.httpserver import HTTPServer\nfrom tornado.ioloop import IOLoop\nfrom tornado.web import Application\nfrom tornado.websocket import WebSocketHandler\n\nimport datetime\n\nclass Handler(WebSocketHandler):\n    clients=[]\n\n    def open(self):\n        self.clients.append(self)\n        print \"New connection opened for user #:\"+str(self.clients.index(self))\n        IOLoop.instance().add_timeout(datetime.timedelta(seconds=5), self.test)\n\n    def on_message(self, message):\n        self.write_message(message)\n\n    def on_close(self):\n        print \"Connection closed for user #\"+str(self.clients.index(self))\n        self.clients.remove(self)\n\n    def test(self):\n        print(\"scheduled!\")\n\nprint \"Server started.\"\nHTTPServer(Application([(\"/\", Handler)])).listen(8001)\nIOLoop.instance().start()\nThe line number will not match because I removed comments and other stuff, but the line 24 was inside the on_message part.", "issue_status": "Closed", "issue_reporting_time": "2013-01-06T04:42:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1019": {"issue_url": "https://github.com/tornadoweb/tornado/issues/660", "issue_id": "#660", "issue_summary": "Memory leak in gen engine with try/finally block when connections are closed", "issue_description": "Contributor\ntahajahangir commented on 5 Jan 2013\n(Also posted on http://stackoverflow.com/q/14162950/326792)\nThis code, shows memory leak in tornado's gen module, when connections are closed without reading the response:\nimport gc\nfrom tornado import web, ioloop, gen\n\nclass MainHandler(web.RequestHandler):\n    @web.asynchronous\n    @gen.engine\n    def get(self):\n        gc.collect()\n        print len(gc.garbage)  # print zombie objects count\n        self.a = '*' * 500000000  # ~500MB data\n        CHUNK_COUNT = 100\n        try:\n            for i in xrange(CHUNK_COUNT):\n                self.write('*' * 10000)  # write ~10KB of data\n                yield gen.Task(self.flush)  # wait for reciever to recieve\n            print 'finished'\n        finally:\n            print 'finally'\n\napplication = web.Application([\n    (r\"/\", MainHandler),\n    ])\n\napplication.listen(8888)\nioloop.IOLoop.instance().start()\nand now, run a simple test client, multiple times\n#!/usr/bin/python\nimport urllib\nurlopen('http://127.0.0.1:8888/')  # exit without reading response\nNow, server output shows, incremental memory usage:\n0\nWARNING:root:Write error on 8: [Errno 104] Connection reset by peer\n1\nWARNING:root:Read error on 8: [Errno 104] Connection reset by peer\nWARNING:root:error on read\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/iostream.py\", line 361, in _handle_read\n    if self._read_to_buffer() == 0:\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/iostream.py\", line 428, in _read_to_buffer\n    chunk = self._read_from_socket()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/iostream.py\", line 409, in _read_from_socket\n    chunk = self.socket.recv(self.read_chunk_size)\nerror: [Errno 104] Connection reset by peer\n2\nERROR:root:Uncaught exception GET / (127.0.0.1)\nHTTPRequest(protocol='http', host='127.0.0.1:8888', method='GET', uri='/', version='HTTP/1.0', remote_ip='127.0.0.1', body='', headers={'Host': '127.0.0.1:8888', 'User-Agent': 'Python-urllib/1.17'})\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/web.py\", line 1021, in _stack_context_handle_exception\n    raise_exc_info((type, value, traceback))\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/web.py\", line 1139, in wrapper\n    return method(self, *args, **kwargs)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/gen.py\", line 120, in wrapper\n    runner.run()\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.4.1-py2.7.egg/tornado/gen.py\", line 345, in run\n    yielded = self.gen.send(next)\n  File \"test.py\", line 10, in get\n    self.a = '*' * 500000000\nMemoryError\nERROR:root:500 GET / (127.0.0.1) 3.91ms\nIf you set CHUNK_COUNT to 1, the 10KB of data can be written to OS connection buffer, and 'finished' and 'finally' texts will be printed to console, and because generator is completed, no memory leak occurs.\nBut the strange part is that if your remove the try/finally block, the problem disappears!! (even with CHUNK_COUNT set to 100)\nIs this a bug on CPython or tornado or ...?!", "issue_status": "Closed", "issue_reporting_time": "2013-01-05T03:34:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1020": {"issue_url": "https://github.com/tornadoweb/tornado/issues/658", "issue_id": "#658", "issue_summary": "parse_command_line in option method fail in windows", "issue_description": "kid143 commented on 27 Dec 2012\nI found the options.parse_command_line method always throws tornado.options.Error: Option 'host' requires a value. This was when I was passing a \"-myoption=option\" like argument to my program, and I found that the sys.argv automatically partitioned the option argment. so the equal variable in Tornado's source code will always be None. This happened on my computer running both python 2.7.3 and python 3.3 and on windows platform, while my Tornado version is 2.4.1. Linux platform not tested.", "issue_status": "Closed", "issue_reporting_time": "2012-12-27T07:46:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1021": {"issue_url": "https://github.com/tornadoweb/tornado/issues/657", "issue_id": "#657", "issue_summary": "Use absolute URI for the location header", "issue_description": "tkf commented on 21 Dec 2012\nRun the following code:\nimport tornado.ioloop\nimport tornado.web\n\n\nclass RedirectHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        print \"Redirecting...\"\n        self.redirect('/')\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        print \"GET\"\n        print self.request.body\n        self.write(\"Hello, world\")\n        self.finish()\n\n\napplication = tornado.web.Application([\n    (r\"/\", MainHandler),\n    (r\"/redirect\", RedirectHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(9999)\n    tornado.ioloop.IOLoop.instance().start()\nThen:\n% curl -i http://127.0.0.1:9999/redirect\nHTTP/1.1 302 Found\nContent-Length: 0\nContent-Type: text/html; charset=UTF-8\nLocation: /\nServer: TornadoServer/2.4.1\nIt looks like Location should be\nLocation: http://127.0.0.1:9999/\nSee: http://tools.ietf.org/html/rfc2616#section-14.30", "issue_status": "Closed", "issue_reporting_time": "2012-12-20T19:29:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1022": {"issue_url": "https://github.com/tornadoweb/tornado/issues/656", "issue_id": "#656", "issue_summary": "Uncaught exception while using a unix socket", "issue_description": "Contributor\nmcella commented on 20 Dec 2012\nUncaught exception, closing connection.\nTraceback (most recent call last):\n  File \"/lib/python2.6/site-packages/tornado/iostream.py\", line 311, in wrapper\n    callback(*args)\n  File \"/lib/python2.6/site-packages/tornado/httpserver.py\", line 249, in _on_headers\n    remote_ip = self.address[0]\nIndexError: string index out of range\nThis exception occurs sometimes while listening on a unix socket.\nI think it was introduced @e5d5d3241f81fa7ad5052079ba9cf6b2daf7c25b, could it be that when the client connection has been already closed the socket.family attribute is missing and getattr fallbacks to socket.AF_INET as default value?", "issue_status": "Closed", "issue_reporting_time": "2012-12-20T15:12:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1023": {"issue_url": "https://github.com/tornadoweb/tornado/issues/651", "issue_id": "#651", "issue_summary": "IOStream.error is often wrong", "issue_description": "Contributor\najdavis commented on 8 Dec 2012\nHi Ben, I know that adding sys.exc_info() as IOStream.error was my idea, but in my experience I was wrong to recommend it. The following example prints, \"closed, error: integer division or modulo by zero\":\nfrom datetime import timedelta\nfrom tornado import gen, ioloop, iostream\nimport socket\n\nloop = ioloop.IOLoop.instance()\n\n@gen.engine\ndef f():\n    sock = socket.socket()\n    stream = iostream.IOStream(sock)\n    yield gen.Task(stream.connect, ('tornadoweb.org', 80))\n\n    try: 1 / 0\n    except ZeroDivisionError: pass\n\n    def closed():\n        print 'closed, error:', stream.error\n\n    stream.set_close_callback(closed)\n    stream.close()\n    loop.add_timeout(timedelta(seconds=1), loop.stop)\n\nf()\nloop.start()\nI believe IOStream.error is correct if and only if IOStream.close() is called from within an exception handler.\nI'm not sure the best next step, I propose either:\nAdd an arg store_error=False to close(), which if True tells the stream to assign self.error from sys.exc_info(). Call close(store_error=True) within exception handlers, and just close() elsewhere.\nRemove IOStream.error, turns out it wasn't a good idea", "issue_status": "Closed", "issue_reporting_time": "2012-12-07T22:09:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1024": {"issue_url": "https://github.com/tornadoweb/tornado/issues/650", "issue_id": "#650", "issue_summary": "[feature request] in module ``tornado.gen`` -- need for function ``gen.NoWait(..)``", "issue_description": "Contributor\npolymorphm commented on 7 Dec 2012\ngood day!\nin module tornado.gen -- need function like:\nyield gen.NoWait(key) # oppositely  yield gen.Wait(key)\nexample of using:\nexample code without gen.NoWait(..) (the situation is now) :\nfrom tornado import gen\n\ntask_A_key = object()\ntask_A_cb = yield gen.Callback(task_A_key)\ntask_A_func(..., ..., ..., callback=task_A_cb)\n\n# parallel we doing task \"B\"\nresult_of_B = yield gen.Task(task_B_func, ..., ..., ...)\n\nif result_of_B == ... :\n    # we will NO wait for task_A_func() !\n    task_A_cb()\n\nyield gen.Wait(task_A_key)\nthis example code but with gen.NoWait(..) :\nfrom tornado import gen\n\ntask_A_key = object()\ntask_A_func(..., ..., ..., callback=yield gen.Callback(task_A_key))\n\n# parallel we doing task \"B\"\nresult_of_B = yield gen.Task(task_B_func, ..., ..., ...)\n\nif result_of_B == ... :\n    # we will NO wait for task_A_func() !\n    yield gen.NoWait(task_A_key)\nelse:\n    yield gen.Wait(task_A_key)\ni think -- function yield gen.NoWait(key) -- will making code more clear, in case if we not need wait all operations\nthanks in advance!", "issue_status": "Closed", "issue_reporting_time": "2012-12-07T16:54:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1025": {"issue_url": "https://github.com/tornadoweb/tornado/issues/649", "issue_id": "#649", "issue_summary": "async MySQL driver ( pure C ) for Tornado.", "issue_description": "abaelhe commented on 6 Dec 2012 \u2022\nedited\nPASS", "issue_status": "Closed", "issue_reporting_time": "2012-12-06T11:38:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1026": {"issue_url": "https://github.com/tornadoweb/tornado/issues/648", "issue_id": "#648", "issue_summary": "recommend async MySQL driver ( pure C ) for Tornado.", "issue_description": "abaelhe commented on 6 Dec 2012 \u2022\nedited\nPASS", "issue_status": "Closed", "issue_reporting_time": "2012-12-06T11:12:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1027": {"issue_url": "https://github.com/tornadoweb/tornado/issues/647", "issue_id": "#647", "issue_summary": "remote_ip breaks if \"X-Forwarded-For\" is a list", "issue_description": "Member\nbdarnell commented on 6 Dec 2012\nFrom the mailing list:\nThe \"X-Forwarded-For\" header can be a comma-separated list of IP addresses. This happens when Tornado is behind a reverse proxy such as HAProxy. The first IP in the list will be the original client IP, and the last one will be the proxy closest to Tornado.\nAfter this change, this comma-separated list is not considered valid, and so it's discarded. Then remote_ip falls back to the IP of the proxy, which is not what we want.\nAs a result we have to write our own method to return the IP and use that everywhere. It would be nice if Tornado could handle it, especially to make it easier for others so they don't have to figure out this problem themselves.", "issue_status": "Closed", "issue_reporting_time": "2012-12-06T01:56:06Z", "fixed_by": "#745", "pull_request_summary": "support ip lists in X-Forwarded-For headers", "pull_request_description": "Contributor\ndavidwilemski commented on 18 Apr 2013\nFixes #647 and revises #655", "pull_request_status": "Merged", "issue_fixed_time": "2013-04-24T02:13:35Z", "files_changed": [["4", "tornado/httpserver.py"], ["15", "tornado/test/httpserver_test.py"]]}, "1028": {"issue_url": "https://github.com/tornadoweb/tornado/issues/646", "issue_id": "#646", "issue_summary": "json_encode, json_decode should pass kwargs through to the underlying libraries", "issue_description": "Contributor\newang commented on 3 Dec 2012\nIs there any reason why the json_encode/json_decode helpers in the escape module isn't passing kwargs through to the underlying json/simplejson libraries?\nThis could be useful in exposing functionalities such as indentation, etc...", "issue_status": "Closed", "issue_reporting_time": "2012-12-03T02:23:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1029": {"issue_url": "https://github.com/tornadoweb/tornado/issues/645", "issue_id": "#645", "issue_summary": "xsrf cookie not set", "issue_description": "kid143 commented on 28 Nov 2012\nWhen setting the xsrf_cookies to True, tornado does not set _xsrf cookie, but keep checking the _xsrf field in request. Of cause the _xsrf field is empty since there aren't any cookies there. So i keep getting 403 errors. Does anybody encounter such problems? I'm using tornado 2.4 and python 2.7.3.\nPS: I thought it might be someting wrong on tornado's cookie function. But when I disabled the xsrf function and reboot my app, the cookie function works fine, and I tried again with xsrf on, the problem came back, but will disappear if I manually call the xsrf_token function. So I don't think my cookie's not working. So the only reason I can imagine is the xsrf_token is not properly called when the app starts. Does anyone get this wierd problem? I don't find any reports or solutions on Google.", "issue_status": "Closed", "issue_reporting_time": "2012-11-28T03:40:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1030": {"issue_url": "https://github.com/tornadoweb/tornado/issues/644", "issue_id": "#644", "issue_summary": "Automatic documentation generates trash for parameter \"autoescape\" for Template constructor", "issue_description": "socketpair commented on 26 Nov 2012\nYou can find this on the page http://www.tornadoweb.org/documentation/template.html :\nclass tornado.template.Template(template_string, name='', loader=None, compress_whitespace=None, autoescape=<object object at 0x10d821a70>)", "issue_status": "Closed", "issue_reporting_time": "2012-11-26T16:09:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1031": {"issue_url": "https://github.com/tornadoweb/tornado/issues/641", "issue_id": "#641", "issue_summary": "Setting no_keep_alive option on HTTPServer does not set \"Connection: close\" header", "issue_description": "swisspol commented on 23 Nov 2012\nAccording to the specs http://tools.ietf.org/html/rfc2616#section-8.1:\nHTTP/1.1 applications that do not support persistent connections MUST include the \"close\" connection option in every message.\nSo the way I read this: if configuring HTTPServer with no_keep_alive, it doesn't support persistent connections by definition and must set the \"Connection: close\" header.", "issue_status": "Closed", "issue_reporting_time": "2012-11-22T19:24:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1032": {"issue_url": "https://github.com/tornadoweb/tornado/issues/640", "issue_id": "#640", "issue_summary": "Not work async for one IP", "issue_description": "DrobyshevAlex commented on 21 Nov 2012\nAsynchronous does not work for GET method if both requests are from the same IP address.\nBut with POST method is all ok.\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.web\nimport logging\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r\"/\", MainHandler),\n        ]\n        settings = dict()\n        tornado.web.Application.__init__(self, handlers, **settings)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        print(\"MainHandler\")\n\ndef main():\n    application = tornado.web.Application([\n        (r\"/\", MainHandler),\n    ])\n    http_server = tornado.httpserver.HTTPServer(application)\n    http_server.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\n\n\nif __name__ == \"__main__\":\n    main()", "issue_status": "Closed", "issue_reporting_time": "2012-11-21T15:32:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1033": {"issue_url": "https://github.com/tornadoweb/tornado/issues/638", "issue_id": "#638", "issue_summary": "tornado.web.ErrorHandler shouldn't set XSRF token.", "issue_description": "brettlaforge commented on 20 Nov 2012\nWhenever you have the XSRF feature turned on and POST to a url that is not handled within your code. (404). The \"tornado.web.ErrorHandler\" raises the error that the XSRF token is missing.\nWorse yet, if you GET to a url that is not handled within your code. (404) The token is created.\nThe code that handles XSRF is in \"tornado.web.RequestHandler\" and \"tornado.web.ErrorHandler\" inherits from \"tornado.web.RequestHandler\". I suggest that the \"xsrf_token\" and \"check_xsrf_cookie\" methods are overridden to ignore creating the XSRF and ignore checking for the XSRF token.\nIf you want me to code this up and submit and pull request let me know.", "issue_status": "Closed", "issue_reporting_time": "2012-11-20T00:03:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1034": {"issue_url": "https://github.com/tornadoweb/tornado/issues/635", "issue_id": "#635", "issue_summary": "add_callback() not entirely thread-safe", "issue_description": "Contributor\npitrou commented on 13 Nov 2012\nIt seems that when io_loop.add_callback() is called in a thread while io_loop.close() is being called in another thread, you can get the following race condition:\nTraceback (most recent call last):\n  File \"/usr/lib/python2.7/threading.py\", line 551, in __bootstrap_inner\n    self.run()\n  File \"/usr/lib/python2.7/threading.py\", line 504, in run\n    self.__target(*self.__args, **self.__kwargs)\n  File \"surycat/utils/sockclient.py\", line 256, in _run\n    self._loop.close()\n  File \"/usr/lib/python2.7/dist-packages/tornado/ioloop.py\", line 195, in close\n    self._waker.close()\n  File \"/usr/lib/python2.7/dist-packages/tornado/platform/posix.py\", line 68, in close\n    self.writer.close()\nIOError: close() called during concurrent operation on the same file object.", "issue_status": "Closed", "issue_reporting_time": "2012-11-13T09:26:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1035": {"issue_url": "https://github.com/tornadoweb/tornado/issues/633", "issue_id": "#633", "issue_summary": "Silent failure when reading cookies if one cookie is invalid", "issue_description": "Contributor\nccampbell commented on 13 Nov 2012\nTornado uses SimpleCookie to parse out cookies from the header. If one of the cookies here is invalid it causes all the cookies to fail.\nI ran into this specifically when a cookie was set using a : in the name, but basically whenever Cookie.SimpleCookie().load() throws an exception all the cookies cannot be read because they are set to an empty dictionary.\nself._cookies = Cookie.SimpleCookie()\nif \"Cookie\" in self.headers:\n    try:\n        self._cookies.load(\n            native_str(self.headers[\"Cookie\"]))\n    except Exception:\n        self._cookies = {}\nThis isn't a problem if you are using Tornado to set all cookies because there are sanity checks to prevent you from setting a cookie with an invalid name, but most browsers/other cookie libraries are actually not as strict about cookies as this python library is.\nThis could be bad if you have a session cookie of some sort and then in javascript you set a cookie that python considers invalid such as test:cookie. From here on out all cookie reading fails silently until you delete test:cookie.\nIdeally I think all cookies should work, but that would require writing a custom cookie parser. Second best I think would be if all the cookies work except for the invalid ones and there is a warning logged to notify the developer that it failed.", "issue_status": "Closed", "issue_reporting_time": "2012-11-12T19:40:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1036": {"issue_url": "https://github.com/tornadoweb/tornado/issues/632", "issue_id": "#632", "issue_summary": "IOStream read errors logged twice", "issue_description": "Contributor\npitrou commented on 12 Nov 2012\nWhen recv() fails in IOStream, the error is logged twice: first in _read_to_buffer() where it gets logged and then re-raised, second in _handle_read() where it gets caught and logged again.", "issue_status": "Closed", "issue_reporting_time": "2012-11-12T17:32:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1037": {"issue_url": "https://github.com/tornadoweb/tornado/issues/631", "issue_id": "#631", "issue_summary": "IOStream's close callback does not get the reason for closing", "issue_description": "Contributor\npitrou commented on 12 Nov 2012\nThe close callback that one can register on an IOStream does not get any information about the reason the stream / socket was closed. ECONNRESET is not the same thing as a regular EOF.\nCompare with Twisted's connectionLost: http://twistedmatrix.com/documents/12.1.0/api/twisted.internet.interfaces.IProtocol.html#connectionLost\nThe callback could optionally get, either an exception instance (None if regular EOF), or an errno number (0 if regular EOF).", "issue_status": "Closed", "issue_reporting_time": "2012-11-12T14:25:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1038": {"issue_url": "https://github.com/tornadoweb/tornado/issues/629", "issue_id": "#629", "issue_summary": "Preprocess templates", "issue_description": "syrusakbary commented on 11 Nov 2012\nHello,\nI want to apply a function to the template source before is parsed by the Tornado Template engine.\nLike Jinja2 Preprocessor method http://jinja.pocoo.org/docs/api/#low-level-api\nCan I do something like this without touching the template loader?\nIf not, should be good add this option the templates (preprocess = [method1,method2,..])\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2012-11-10T19:57:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1039": {"issue_url": "https://github.com/tornadoweb/tornado/issues/621", "issue_id": "#621", "issue_summary": "Way to override default headers set in WSGIContainer", "issue_description": "mitar commented on 29 Oct 2012\nWSGIContainer sets some default headers if application does not set them. There should be a way to set what are those defaults.\nRelated: #619", "issue_status": "Closed", "issue_reporting_time": "2012-10-28T22:11:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1040": {"issue_url": "https://github.com/tornadoweb/tornado/issues/620", "issue_id": "#620", "issue_summary": "Circular reference in ExceptionStackContext / gen.Runner", "issue_description": "ssadler commented on 29 Oct 2012\nI'm trying to write an SQLAlchemy style connection pool for psycopg2 which uses weakref to detect when connections are unused and recycle them. It's working nicely except in the case that it's used in a gen.engine and an exception is thrown from the poller. The code is StackContext aware so the exceptions are propagated to the generator, but due to a circular reference the cursor wrapper \"fairy\" instances are not dereferenced and the ConnectionPool is exhausted.\nThis is the code: https://github.com/ssadler/squirrel/\nThe method test_100_queries in the tests times out.\nHere's an objgraph render which shows what's referencing the CursorFairy in the bottom right:\nhttp://imgur.com/gYeCk\nI did find 2 ways to overcome the issue:\nJudicious use of gc.collect() after exceptions are propagated, to force collection of the contexts.\nContinually return new CursorFairy instances which reference the same cursors, to avoid cursors getting caught in complicated sets of references so they can be freed the normal way.\nI tried to fix it in Tornado by never holding the traceback from sys.exc_info(), and by always calling sys.exc_clear(), it didn't work.\nAny ideas? Are circular references a known issue using gen.engine? Thanks\nEDIT:\nThis is using Tornado master (2.4.0.1), Python 2.7.2, Mac OSX.", "issue_status": "Closed", "issue_reporting_time": "2012-10-28T20:22:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1041": {"issue_url": "https://github.com/tornadoweb/tornado/issues/619", "issue_id": "#619", "issue_summary": "WSGIContainer overrids server name returned by set_default_headers", "issue_description": "mitar commented on 28 Oct 2012\nI have such code:\n            class FallbackHandlerWithServerName(web.FallbackHandler):\n                def set_default_headers(self):\n                    if conf.get('servername', None):\n                        self.set_header('Server', conf.get('servername', None))\n\n            wsgi_app = tornado_wsgi.WSGIContainer(django_wsgi.get_wsgi_application())\n            conf['locations'] += (\n                ('.*', FallbackHandlerWithServerName, {'fallback': wsgi_app}),\n            )\nBut WSGIContainer overrides that header. It should probably call RequestHandler.clear() somewhere instead.", "issue_status": "Closed", "issue_reporting_time": "2012-10-27T19:56:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1042": {"issue_url": "https://github.com/tornadoweb/tornado/issues/618", "issue_id": "#618", "issue_summary": "SimpleAsyncHTTPClient queue bug with request.url", "issue_description": "nathancahill commented on 24 Oct 2012\nInteresting bug in tornado/simple_httpclient.py (v2.4, Mac OSX 10.8.2, Python 2.7.3):\nWhile looping through the request queue in SimpleAsyncHTTPClient, self.queue.popleft()\nreturns a HTTPRequest object. Then, _HTTPConnection tries to parse the object's URL:\nLine 140:\nparsed = urlparse.urlsplit(_unicode(self.request.url))\nThis fails, however, because self.request.url is actually a tuple of HTTPRequest objects!\nMy work around is to grab the first object in the tuple, and then the URL from that. Obviously\nnot a fix, just trying to understand what's going on:\nparsed = urlparse.urlsplit(_unicode(self.request.url[0].url))\nTo reproduce:\nthis_request = tornado.httpclient.HTTPRequest(url = 'http://www.google.com')\ntornado.httpclient.AsyncHTTPClient().fetch(this_request, self.handle_response)\nError:\nWARNING:root:uncaught exception\nTraceback (most recent call last):\nFile \"tornado/simple_httpclient.py\", line 318, in cleanup\n    yield\nFile \"tornado/simple_httpclient.py\", line 140, in __init__\n    parsed = urlparse.urlsplit(_unicode(self.request.url))\nFile \"tornado/escape.py\", line 183, in to_unicode\n    assert isinstance(value, bytes)", "issue_status": "Closed", "issue_reporting_time": "2012-10-24T08:13:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1043": {"issue_url": "https://github.com/tornadoweb/tornado/issues/615", "issue_id": "#615", "issue_summary": "startup failure", "issue_description": "NdyGen commented on 22 Oct 2012\nOn my synology with Python 2.7 tornado fails to startup. There's no epoll support in the kernel of the synology.\nI did a quick hack in ioloop and changed\nif hasattr(select, \"epoll\"):\n# Python 2.6+ on Linux\n_poll = select.epoll\nelif hasattr(select, \"kqueue\"):\ninto\nif hasattr(select, \"kqueue\"):\nmaybe you can come up with a more elegant/ permanent fix.", "issue_status": "Closed", "issue_reporting_time": "2012-10-21T18:58:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1044": {"issue_url": "https://github.com/tornadoweb/tornado/issues/613", "issue_id": "#613", "issue_summary": "WSGI module does not work (missing Cookie)", "issue_description": "tr00per commented on 18 Oct 2012\nI've checked out the latest revision and run commands as shown below.\n>>> import tornado\n>>> tornado.version_info\n(2, 4, 0, 1)\n>>> import tornado.wsgi\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"tornado/wsgi.py\", line 34, in <module>\n    import Cookie\nImportError: No module named Cookie\nIn version 2.3 the offending line read\nimport http.cookies", "issue_status": "Closed", "issue_reporting_time": "2012-10-18T06:45:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1045": {"issue_url": "https://github.com/tornadoweb/tornado/issues/612", "issue_id": "#612", "issue_summary": "runtests.sh does not woth (Py3.2)", "issue_description": "tr00per commented on 18 Oct 2012\nI've checked out the latest revision and run ./runtests.sh. I got:\nTraceback (most recent call last):\n  File \"/usr/lib/python3.2/runpy.py\", line 160, in _run_module_as_main\n    \"__main__\", fname, loader, pkg_name)\n  File \"/usr/lib/python3.2/runpy.py\", line 73, in _run_code\n    exec(code, run_globals)\n  File \"/home/tr00per/projects/tornado/tornado/test/runtests.py\", line 7, in <module>\n    from tornado.httpclient import AsyncHTTPClient\n  File \"tornado/httpclient.py\", line 406\n    except HTTPError, e:\n                    ^\nSyntaxError: invalid syntax", "issue_status": "Closed", "issue_reporting_time": "2012-10-18T06:41:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1046": {"issue_url": "https://github.com/tornadoweb/tornado/issues/611", "issue_id": "#611", "issue_summary": "Retain original HTTP Header of request (as string, not parsed dict)", "issue_description": "reorx commented on 15 Oct 2012\nSo that people can logging and check it out.", "issue_status": "Closed", "issue_reporting_time": "2012-10-15T13:27:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1047": {"issue_url": "https://github.com/tornadoweb/tornado/issues/610", "issue_id": "#610", "issue_summary": "Header handling case sensitivity", "issue_description": "jagguli commented on 14 Oct 2012\nCurrently headers are case sensitive in tornado, but shouldn't it be case insensitive\nHeres the RFC:\nhttp://www.ietf.org/rfc/rfc2616.txt\nhttp://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive", "issue_status": "Closed", "issue_reporting_time": "2012-10-14T01:36:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1048": {"issue_url": "https://github.com/tornadoweb/tornado/issues/607", "issue_id": "#607", "issue_summary": "tornado\u4e2d\u4f7f\u7528tenjin\u6a21\u677fxsrf\u95ee\u9898", "issue_description": "toadzhou commented on 9 Oct 2012\ntornado\u4e2d\u81ea\u5e26\u7684\u6a21\u677f\u5fc5\u987b\u8981\u5f00\u542fdebug\u6a21\u5f0f\u624d\u53ef\u4ee5\u5b9e\u65f6\u6a21\u677f\u66f4\u65b0\uff0c\u800c\u4e14\u81ea\u5e26\u7684\u6a21\u677f\u7684\u901f\u5ea6\u8981\u6bd4tenjin\u6162\u5f88\u591a\u3002\u4f46\u6211\u5728\u4f7f\u7528\u7684\u65f6\u5019xsrf\u7684xsrf_form_html\u8fd9\u4e2a\u95ee\u9898\u89e3\u51b3\u4e0d\u4e86\u3002", "issue_status": "Closed", "issue_reporting_time": "2012-10-09T13:29:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1049": {"issue_url": "https://github.com/tornadoweb/tornado/issues/604", "issue_id": "#604", "issue_summary": "Exception in callback <tornado.stack_context._StackContextWrapper using websockets in python2-tornado 2.3", "issue_description": "more10 commented on 4 Oct 2012\nI am running tornado with python 2.7 and chromium as client on an Arch i686:\n[root@archdev maxiserver]# pacman -Q python2-tornado\npython2-tornado 2.3-1\n[root@archdev maxiserver]# pacman -Q python2 \npython2 2.7.3-2\n[root@archdev maxiserver]# pacman -Q chromium\nchromium 22.0.1229.79-1\nThere is a problem with websockets. The application works, but I get errors in the log, which may confuse my customer:\n[E 121004 10:28:37 iostream:307] Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 304, in wrapper\n        callback(*args)\n      File \"/usr/lib/python2.7/site-packages/tornado/websocket.py\", line 609, in _on_frame_data\n        self._receive_frame()\n      File \"/usr/lib/python2.7/site-packages/tornado/websocket.py\", line 529, in _receive_frame\n        self.stream.read_bytes(2, self._on_frame_start)\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 166, in read_bytes\n        self._try_inline_read()\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 381, in _try_inline_read\n        self._check_closed()\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 564, in _check_closed\n        raise IOError(\"Stream is closed\")\n    IOError: Stream is closed\n[E 121004 10:28:37 ioloop:435] Exception in callback <tornado.stack_context._StackContextWrapper object at 0xa5becd4>\n    Traceback (most recent call last):\n      File \"/usr/lib/python2.7/site-packages/tornado/ioloop.py\", line 421, in _run_callback\n        callback()\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 304, in wrapper\n        callback(*args)\n      File \"/usr/lib/python2.7/site-packages/tornado/websocket.py\", line 609, in _on_frame_data\n        self._receive_frame()\n      File \"/usr/lib/python2.7/site-packages/tornado/websocket.py\", line 529, in _receive_frame\n        self.stream.read_bytes(2, self._on_frame_start)\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 166, in read_bytes\n        self._try_inline_read()\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 381, in _try_inline_read\n        self._check_closed()\n      File \"/usr/lib/python2.7/site-packages/tornado/iostream.py\", line 564, in _check_closed\n        raise IOError(\"Stream is closed\")\n    IOError: Stream is closed", "issue_status": "Closed", "issue_reporting_time": "2012-10-04T10:20:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1050": {"issue_url": "https://github.com/tornadoweb/tornado/issues/601", "issue_id": "#601", "issue_summary": "finish() on closed connection raises IOError(\"Stream is closed\")", "issue_description": "Contributor\njparise commented on 2 Oct 2012\nIf the remote client closes the connection while the server is performing an asynchronous operation, an IOError(\"Stream is closed\") error is raised when the request handler completes the operation and calls finish().\nUncaught exception GET / (127.0.0.1)\n    HTTPRequest(protocol='http', host='localhost:5000', method='GET', uri='/', version='HTTP/1.1', remote_ip='127.0.0.1', body='', headers={'Host': 'localhost:5000', 'Accept': '*/*', 'User-Agent': 'curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5'})\n    Traceback (most recent call last):\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/web.py\", line 1021, in _stack_context_handle_exception\n        raise_exc_info((type, value, traceback))\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/stack_context.py\", line 258, in _nested\n        yield vars\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/stack_context.py\", line 228, in wrapped\n        callback(*args, **kwargs)\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/gen.py\", line 382, in inner\n        self.set_result(key, result)\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/gen.py\", line 315, in set_result\n        self.run()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/gen.py\", line 345, in run\n        yielded = self.gen.send(next)\n      File \"closed.py\", line 15, in get\n        self.finish(\"Done\")\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/web.py\", line 722, in finish\n        self.request.finish()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/httpserver.py\", line 422, in finish\n        self.connection.finish()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/httpserver.py\", line 193, in finish\n        self._finish_request()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/httpserver.py\", line 229, in _finish_request\n        self.stream.read_until(b(\"\\r\\n\\r\\n\"), self._header_callback)\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/iostream.py\", line 153, in read_until\n        self._try_inline_read()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/iostream.py\", line 382, in _try_inline_read\n        self._check_closed()\n      File \"/Users/jon/work/venv/lib/python2.7/site-packages/tornado/iostream.py\", line 565, in _check_closed\n        raise IOError(\"Stream is closed\")\n    IOError: Stream is closed\nThis is reproducible for me using the following request handler code:\n    @tornado.web.asynchronous\n    @tornado.gen.engine\n    def get(self):\n        http = tornado.httpclient.AsyncHTTPClient()\n        response = yield tornado.gen.Task(http.fetch, \"http://en.wikipedia.org/\")\n        self.finish(\"Done\")\nI can work around this in a custom RequestHandler subclass:\n    def finish(self, chunk=None):\n        if not self.request.connection.stream.closed():\n            super(RequestHandler, self).finish(chunk)\nThis is similar to #81 but occurs on the latest Tornado 2.4 code base.", "issue_status": "Closed", "issue_reporting_time": "2012-10-01T18:47:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1051": {"issue_url": "https://github.com/tornadoweb/tornado/issues/598", "issue_id": "#598", "issue_summary": "auth.TwitterMixin is broken in python 3", "issue_description": "pfrantz commented on 28 Sep 2012\nThe TwitterMixin is broken in python 3. When the response is returned an access_token dictionary is created with binary keys and values. This seems to be fine until the _oauth_get_user is called as it assumes the dictionary keys are strings and return value is also a string.\nI have patched the routine as follows, but not sure if there are other problems lurking around due to access tokens being bytes.\ndef _oauth_get_user(self, access_token, callback):\n    callback = self.async_callback(self._parse_user_response, callback)\n    self.twitter_request(\n        \"/users/show/\" + escape.to_basestring(access_token[b(\"screen_name\")]),\n        access_token=access_token, callback=callback)\ndon't know the code well enough to know whether its better to have access_tokens all converted to strings or leave them in byte format.", "issue_status": "Closed", "issue_reporting_time": "2012-09-28T06:00:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1052": {"issue_url": "https://github.com/tornadoweb/tornado/issues/597", "issue_id": "#597", "issue_summary": "_handle_read and _try_inline_read does not allow processing of data as long as new data arrives", "issue_description": "fredde-fisk commented on 24 Sep 2012\n_handle_read and _try_inline_read never allows processing of data as long as new data continues to arrive. The reason is the loop in those methods that will continue reading as long as there are more data in the stream:\nwhile True:\n    if self._read_to_buffer() == 0:\n        break\nSo a read_bytes call can end up buffering 100 MiB of data and throwing an \"IOError: Reached maximum read buffer size\" exception even though it only wanted to read 2 bytes.\nI discovered this problem when running a websocket server where the client sends a continuous stream of messages.", "issue_status": "Closed", "issue_reporting_time": "2012-09-24T09:51:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1053": {"issue_url": "https://github.com/tornadoweb/tornado/issues/594", "issue_id": "#594", "issue_summary": "raising HTTPError() has no way to get log_message or *args to client.", "issue_description": "dsully commented on 11 Sep 2012\nIn tornado/web.py : _handle_request_exception(), the call to self.send_error() doesn't pass along either the log_message or *args, such that those potential strings can be sent to the client (Specifically for sending additional data to a JSON-oriented client).\nIf I override write_error(), I can output a JSON formatted message, but I need to call send_error() directly in my RequestHandler, instead of just raising a HTTPError.\nI can work up a patch if this is something that isn't distasteful in some way.\nThanks.", "issue_status": "Closed", "issue_reporting_time": "2012-09-11T17:05:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1054": {"issue_url": "https://github.com/tornadoweb/tornado/issues/589", "issue_id": "#589", "issue_summary": "body in blocking httpclient with get", "issue_description": "dimatosaurus commented on 24 Aug 2012\ni got an asserterror when using a body ( even an empty one ) with httpclient\nand 'GET' method. Is that a bug?", "issue_status": "Closed", "issue_reporting_time": "2012-08-24T16:56:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1055": {"issue_url": "https://github.com/tornadoweb/tornado/issues/587", "issue_id": "#587", "issue_summary": "iostream.SSLIOStream client do ssl.wrap_socket() too late after connect() and therefore cannot write()", "issue_description": "ilfirin-ms commented on 17 Aug 2012\nWhen I connect to ssl server [netutil.TCPServer] with SSLIOStream (client), I have to sleep some time after connect, or\nexception is raised when tried to send data:\nTraceback (most recent call last):\n  File \"./test_server_gui.py\", line 103, in test_accept_connection_and_data_with_stream\n    stream.write(b'test')\n  File \"/usr/local/lib/python3.2/dist-packages/tornado/iostream.py\", line 210, in write\n    self._handle_write()\n  File \"/usr/local/lib/python3.2/dist-packages/tornado/iostream.py\", line 671, in _handle_write\n    self._do_ssl_handshake()\n  File \"/usr/local/lib/python3.2/dist-packages/tornado/iostream.py\", line 641, in _do_ssl_handshake\n    self.socket.do_handshake()\nAttributeError: 'socket' object has no attribute 'do_handshake'\nexample code:\ndef test_accept_connection_and_data_with_stream(WORKAROUND=0):\n    \"Test if server is listening and accepting data with SSLIOStream\"\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    stream = SSLIOStream(s,\n                         ssl_options={\n                             'ca_certs': 'fake_certificate_autority',\n                             'cert_reqs' : ssl.CERT_REQUIRED\n                         })\n\n    stream.connect((server_ip, server_port))\n\n    if WORKAROUND:\n        time.sleep(0.1)\n\n    # test write\n    stream.write(b'test')\n\n    # test reply, not part of example\n    time.sleep(0.1)\n    data = b''.join(stream._read_buffer)\n    assert(data == b'got test')\n\n    stream.close()\nI have also tried to run test in another IOLoop but same behaviour.\nTest with pure socket example from Python docs works.", "issue_status": "Closed", "issue_reporting_time": "2012-08-17T18:09:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1056": {"issue_url": "https://github.com/tornadoweb/tornado/issues/584", "issue_id": "#584", "issue_summary": "Lookup Error: unknown encoding: latin1", "issue_description": "R1ckyG commented on 15 Aug 2012\nI'm trying to benchmark a simple Tornado Server made using tornado.httpserver and I get the following error, when using apache bench with 1000 or more concurrent connections on a Solaris machine.\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/site-packages/tornado-2.3-py2.7.egg/tornado/iostream.py\", line 304, in wrapper\nFile \"/usr/local/lib/python2.7/site-packages/tornado-2.3-py2.7.egg/tornado/httpserver.py\", line 227, in _on_headers\nLookupError: unknown encoding: latin1\nI believe this is due to a race condition that leaves the python codec table in an invalid state. My understanding is that latin1 is included in the python standard library, so it should be present as long as nothing is modifying pythons codec table.\nThanks!!\nLink to server code: https://www.dropbox.com/s/xrgj59sv0y5y31n/server_ioloop.py", "issue_status": "Closed", "issue_reporting_time": "2012-08-15T18:25:33Z", "fixed_by": "#1910", "pull_request_summary": "netutil: Preload the \"latin1\" codec", "pull_request_description": "Contributor\najdavis commented on 10 Dec 2016\nnetutil: Preload the \"latin1\" codec\nFor reasons not yet understood, some Solaris users get intermittent\n\"LookupError: unknown encoding: latin1\", this has been reported to\nfix it.\nFixes #584", "pull_request_status": "Merged", "issue_fixed_time": "2016-12-13T12:52:37Z", "files_changed": [["3", "tornado/netutil.py"]]}, "1057": {"issue_url": "https://github.com/tornadoweb/tornado/issues/578", "issue_id": "#578", "issue_summary": "When using compression, Vary: Accept-Encoding should be added", "issue_description": "gorillamania commented on 7 Aug 2012\nHi,\nIt's accepted practice that when you support compression, Vary: Accept-Encoding http header is sent. From:\nhttps://developers.google.com/speed/docs/best-practices/caching\n\"Set the Vary: Accept-Encoding response header. This instructs the proxies to cache two versions of the resource: one compressed, and one uncompressed. The correct version of the resource is delivered based on the client request header. This is a good choice for applications that are singly homed and depend on public proxies for user locality.\"\nApache does this:\nhttp://httpd.apache.org/docs/2.2/mod/mod_deflate.html#proxies\nThe functionality can be enabled with the following patch:\n*************** class GZipContentEncoding(OutputTransfor\n*** 1670,1675 ****\n--- 1670,1676 ----\n(\"Content-Encoding\" not in headers)\nif self._gzipping:\nheaders[\"Content-Encoding\"] = \"gzip\"\n        headers[\"Vary\"] = \"Accept-Encoding\"\n      self._gzip_value = BytesIO()\n      self._gzip_file = gzip.GzipFile(mode=\"w\", fileobj=self._gzip_value)\n      chunk = self.transform_chunk(chunk, finishing)\nI'm using tornado==2.2", "issue_status": "Closed", "issue_reporting_time": "2012-08-06T23:27:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1058": {"issue_url": "https://github.com/tornadoweb/tornado/issues/566", "issue_id": "#566", "issue_summary": "There's no way to JSON encode/decode custom object types", "issue_description": "WhyNotHugo commented on 21 Jul 2012\nIf my RequestHandler attempts to write JSON object that the json serializer can't handle, an exception is thrown.\nNormally, an argument \"default\" can be passed over to the json serializer, that would be able to handle these sort of object (ie: datetime objects), however, there's no way to pass this argument when using the write method from an overridden RequestHandler.\nWhile I can json-serialize my own objects, and set the Content-Type header myself, part of the functionality of tornado is lost by doing so, and I end up with slightly duplicate code.\nThere are, a few relatively simple solutions that can fix this, however, IMO, being able to pass a default function as a setting to tornado is the cleanest of them all; it slightly enhances tornado, and simplifies these sort of (rather common) scenarios.", "issue_status": "Closed", "issue_reporting_time": "2012-07-21T00:25:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1059": {"issue_url": "https://github.com/tornadoweb/tornado/issues/565", "issue_id": "#565", "issue_summary": "Make 'next' paramater name configurable when forwarding to login_url", "issue_description": "Contributor\nrbu commented on 19 Jul 2012\nTornado makes the login_url configrable, but the query string name for the referer page is hardcoded to \"next\". This makes it harder to integrate tornado with a login form that is running on another site/framework, such as repoze.who-friendlyform which expects the parameter to be \"came_from\".\nIt would be nice if the parameter were configurable.", "issue_status": "Closed", "issue_reporting_time": "2012-07-19T12:55:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1060": {"issue_url": "https://github.com/tornadoweb/tornado/issues/564", "issue_id": "#564", "issue_summary": "Method to render string as template?", "issue_description": "Contributor\nemehrkay commented on 18 Jul 2012\nI was able to hack together a simple method, but I was wondering if what I did looks correct and if it would be useful to have something like this in web.ReqeustHandler?\nI've added this to my main request handler class and it seems to work as expected\n    def _template_string(self, string, **kwargs):\n        template = web.template.Template(string, autoescape=None)\n        args = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        args.update(**kwargs)\n        args.update(self.ui)\n        return template.generate(**args)\nI use it with parsed markdown files that may contain template-based functionality like {{ modules.UI_MODULE() }}\nThe problems with this approach is that I am basically repeating code found in web.ReqeustHandler.render and I am not hooking into any of the cached named templates. Is there a better way to handle this?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2012-07-17T23:43:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1061": {"issue_url": "https://github.com/tornadoweb/tornado/issues/563", "issue_id": "#563", "issue_summary": "Method to render a string as a template?", "issue_description": "Contributor\nemehrkay commented on 18 Jul 2012\nI was able to hack together a simple method, but I was wondering if what I did looks correct and if it would be useful to have something like this in web.ReqeustHandler?\nI've added this to my main request handler class and it seems to work as expected\n    def _template_string(self, string, **kwargs):\n        template = web.template.Template(string, autoescape=None)\n        args = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        args.update(**kwargs)\n        args.update(self.ui)\n        return template.generate(**args)\nI use it with parsed markdown files that may contain template-based functionality like {{ modules.UI_MODULE() }}\nThe problems with this approach is that I am basically repeating code found in web.ReqeustHandler.render and I am not hooking into any of the cached named templates. Is there a better way to handle this?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2012-07-17T23:42:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1062": {"issue_url": "https://github.com/tornadoweb/tornado/issues/550", "issue_id": "#550", "issue_summary": "Windows: SO_REUSEADDR allows listening on occupied port", "issue_description": "Contributor\nminrk commented on 28 Jun 2012\nContext:\nTry to run two instances of helloworld.py example\nSymptom:\nLinux/OS X (expected): second instance raises Address already in use.\nWindows: second instance runs happily, but receives no requests until the first instance shuts down.\nCause:\nSetting SO_REUSEADDR seems to result in different behavior between Windows and other platforms.\nI don't know if it makes sense to simply skip setting REUSEADDR on Windows or what, but it would be nice if tornado's behavior was consistent.", "issue_status": "Closed", "issue_reporting_time": "2012-06-27T23:34:20Z", "fixed_by": "#551", "pull_request_summary": "Don't set SO_REUSEADDR on Windows", "pull_request_description": "Contributor\nminrk commented on 28 Jun 2012\nWindows interprets REUSEADDR differently, allowing simultaneous instances.\nEDIT: SO_EXCLUSIVEADDR is an alternative, but it seems like doing nothing is actually the best choice.\ncloses #550", "pull_request_status": "Merged", "issue_fixed_time": "2012-06-29T06:57:11Z", "files_changed": [["3", "tornado/netutil.py"]]}, "1063": {"issue_url": "https://github.com/tornadoweb/tornado/issues/548", "issue_id": "#548", "issue_summary": "tornado.stack_context.wrap restricts kwargs for function", "issue_description": "Contributor\npolymorphm commented on 27 Jun 2012\ngood day! :)\ntornado.stack_context.wrap restricts kwargs for function\nsee this example:\nimport tornado.stack_context\n\ndef on_error(t, e, tb):\n    pass\n\nwith tornado.stack_context.ExceptionStackContext(on_error):\n    @tornado.stack_context.wrap\n    def test_func_A(my_callback=None):\n        print 'SUCCESS (A) !', my_callback\n\n    @tornado.stack_context.wrap\n    def test_func_B(callback=None):\n        print 'SUCCESS (B) !', callback\n\n    @tornado.stack_context.wrap\n    def test_func_C(contexts=None):\n        print 'SUCCESS (C) !', contexts\n\ntry:\n    test_func_A(my_callback='test A') # will be SUCCESS!\nexcept Exception as e:\n    print 'ERROR: ', e\n\ntry:\n    test_func_B(callback='test B') # will be ERROR!\nexcept Exception as e:\n    print 'ERROR: ', e\n\ntry:\n    test_func_C(contexts='test C') # will be ERROR!\nexcept Exception as e:\n    print 'ERROR: ', e\noutput of this example is:\nSUCCESS (A) ! test A\nERROR:  wrapped() got multiple values for keyword argument 'callback'\nERROR:  wrapped() got multiple values for keyword argument 'contexts'", "issue_status": "Closed", "issue_reporting_time": "2012-06-27T01:01:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1064": {"issue_url": "https://github.com/tornadoweb/tornado/issues/538", "issue_id": "#538", "issue_summary": "curl_httpclient 2.3 - IOError with socks5 proxy", "issue_description": "artyomboyko commented on 16 Jun 2012\nI'm using latest curl_httpclient but i still get this error. I'm using curl + socks5 proxies. I've added this string to curl_httpclient source code:\n...\ncurl.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_SOCKS5)\n...\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/site-packages/tornado-2.3-py2.7.egg/tornado/curl_httpclient.py\", line 106, in _handle_socket\nself.io_loop.update_handler(fd, ioloop_event)\nFile \"/usr/local/lib/python2.7/site-packages/tornado-2.3-py2.7.egg/tornado/ioloop.py\", line 205, in update_handler\nself._impl.modify(fd, events | self.ERROR)\nIOError: [Errno 2] No such file or directory\nIs this because of SOCKS5 or this is tornado bug ?\nI've tried on CentOS, FreeBSD, Ubuntu, everywhere i get an error.", "issue_status": "Closed", "issue_reporting_time": "2012-06-16T16:34:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1065": {"issue_url": "https://github.com/tornadoweb/tornado/issues/537", "issue_id": "#537", "issue_summary": "add_handler() IOError", "issue_description": "nathanfolkman commented on 15 Jun 2012\nWorking on some XMPP related code that promotes an existing IOStream to a SSLIOStream I came across a bug that only manifests itself on Linux and not Mac OS X. I believe this is related to the fact that Python's select uses poll() or epoll() on Linux and kqueue() on Mac OS X. Specifically it looks like epoll.register() will throw an IOError if you try to register a file descriptor that's already registered - see: http://docs.python.org/library/select.html#module-select.\nThe following patch to use modify() seems to fix the issue:\ntornado/ioloop.py:\n179 def add_handler(self, fd, handler, events):\n180 \"\"\"Registers the given handler to receive the given events for fd.\"\"\"\n181 self._handlers[fd] = stack_context.wrap(handler)\n182\n183 try:\n184 self._impl.register(fd, events | self.ERROR)\n185 except:\n186 self._impl.modify(fd, events | self.ERROR)", "issue_status": "Closed", "issue_reporting_time": "2012-06-14T23:58:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1066": {"issue_url": "https://github.com/tornadoweb/tornado/issues/534", "issue_id": "#534", "issue_summary": "test_gaierror failure in 2.3 and 0b432be307", "issue_description": "juliantaylor commented on 9 Jun 2012\non ubuntu 12.04 the testsuite fails since 2.3, the suite 2.2.1 did succeed\ncurrent git HEAD 0b432be is also affected\nPYTHONPATH=$PWD python -m tornado.test.runtests\n.................................................................................................................F[I 120609 16:45:37 testing:313] RUNNING TEST: test_gaierror (tornado.test.iostream_test.TestIOStream)\n..................................................................................................................................................................................................................................\n======================================================================\nFAIL: test_gaierror (tornado.test.iostream_test.TestIOStream)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"tornado/test/iostream_test.py\", line 107, in test_gaierror\n    self.assertTrue(isinstance(stream.error, socket.gaierror), stream.error)\nAssertionError: False is not true\n\n----------------------------------------------------------------------\nRan 340 tests in 2.051s\n\nFAILED (failures=1)\n[E 120609 16:45:38 testing:386] FAIL", "issue_status": "Closed", "issue_reporting_time": "2012-06-09T14:46:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1067": {"issue_url": "https://github.com/tornadoweb/tornado/issues/524", "issue_id": "#524", "issue_summary": "tornado 2.3: Test suite fails due to ImportWarnings", "issue_description": "Arfrever commented on 2 Jun 2012\ntornado/test/runtests.py is now too strict. It should ignore ImportWarnings, which would occur for namespace packages generated by setuptools.\n$ PYTHONPATH=\".\" python2.7 tornado/test/runtests.py\nTraceback (most recent call last):\n  File \"tornado/test/runtests.py\", line 59, in <module>\n    tornado.testing.main()\n  File \"/tmp/tornado-2.3/tornado/testing.py\", line 381, in main\n    unittest.main(defaultTest=\"all\", argv=argv)\n  File \"/usr/lib64/python2.7/unittest/main.py\", line 94, in __init__\n    self.parseArgs(argv)\n  File \"/usr/lib64/python2.7/unittest/main.py\", line 149, in parseArgs\n    self.createTests()\n  File \"/usr/lib64/python2.7/unittest/main.py\", line 158, in createTests\n    self.module)\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 128, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 113, in loadTestsFromName\n    test = obj()\n  File \"tornado/test/runtests.py\", line 34, in all\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 128, in loadTestsFromNames\n    suites = [self.loadTestsFromName(name, module) for name in names]\n  File \"/usr/lib64/python2.7/unittest/loader.py\", line 91, in loadTestsFromName\n    module = __import__('.'.join(parts_copy))\n  File \"/tmp/tornado-2.3/tornado/test/twisted_test.py\", line 31, in <module>\n    from twisted.internet.defer import Deferred\n  File \"/usr/lib64/python2.7/site-packages/twisted/internet/defer.py\", line 25, in <module>\n    from twisted.python import log, failure, lockfile\n  File \"/usr/lib64/python2.7/site-packages/twisted/python/log.py\", line 17, in <module>\n    from zope.interface import Interface\n  File \"/usr/lib64/python2.7/site-packages/zope/__init__.py\", line 2, in <module>\n    import pkg_resources\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 2756, in <module>\n    add_activation_listener(lambda dist: dist.activate())\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 705, in subscribe\n    callback(dist)\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 2756, in <lambda>\n    add_activation_listener(lambda dist: dist.activate())\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 2259, in activate\n    map(declare_namespace, self._get_metadata('namespace_packages.txt'))\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 1848, in declare_namespace\n    _handle_ns(packageName, path_item)\n  File \"/usr/lib64/python2.7/site-packages/pkg_resources.py\", line 1805, in _handle_ns\n    loader = importer.find_module(packageName)\n  File \"/usr/lib64/python2.7/pkgutil.py\", line 186, in find_module\n    file, filename, etc = imp.find_module(subname, path)\nImportWarning: Not importing directory '/usr/lib64/python2.7/site-packages/peak': missing __init__.py", "issue_status": "Closed", "issue_reporting_time": "2012-06-02T03:36:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1068": {"issue_url": "https://github.com/tornadoweb/tornado/issues/523", "issue_id": "#523", "issue_summary": "Have option for HTTP redirect to HTTPS", "issue_description": "ellisonbg commented on 1 Jun 2012\nIt would be nice if requests to HTTP could automatically redirect to HTTPS when SSL is enabled in a Tornado server.\n1", "issue_status": "Closed", "issue_reporting_time": "2012-06-01T05:54:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1069": {"issue_url": "https://github.com/tornadoweb/tornado/issues/522", "issue_id": "#522", "issue_summary": "Module thread not at python3.x", "issue_description": "FangsCode commented on 1 Jun 2012\nAt ioloop.py, use \"thread.get_ident()\" to get current thread id. But the module thread is removed begin python3.0. So, use \"threading.current_thread().ident()\" instead.", "issue_status": "Closed", "issue_reporting_time": "2012-06-01T03:35:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1070": {"issue_url": "https://github.com/tornadoweb/tornado/issues/520", "issue_id": "#520", "issue_summary": "string exceptions used in gen_test.py", "issue_description": "juliantaylor commented on 28 May 2012\ntornado/test/gen_test.py and its copies uses string exceptions which have been removed from python 2.6:\nhttp://docs.python.org/whatsnew/2.6.html (see deprecations and removals)\ngrep \"raise \\\"\" tornado/test/gen_test.py -n\n171:                raise \"did not get expected exception\"\n182:                raise \"did not get expected exception\"\n196:            raise \"did not get expected exception\"\nthey should be replaced by Exception(\"string\")", "issue_status": "Closed", "issue_reporting_time": "2012-05-27T23:16:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1071": {"issue_url": "https://github.com/tornadoweb/tornado/issues/518", "issue_id": "#518", "issue_summary": "StaticHandler - default_filename issue", "issue_description": "JackWink commented on 26 May 2012\nIs there any documentation on this functionality (#155)? I'm having trouble with it...\n (r'/dir', web.StaticHandler, dict(path=\"static/dir/\", default_filename=\"index.html\"))\ngives me an error:\n 20:55:23 web.1     | Traceback (most recent call last):\n 20:55:23 web.1     |   File \"/Library/Python/2.7/site-packages/tornado/web.py\", line 988, in _execute\n 20:55:23 web.1     |     getattr(self, self.request.method.lower())(*args, **kwargs)\n 20:55:23 web.1     | TypeError: get() takes at least 2 arguments (1 given)\nI realize this is because path is non-optional for the StaticHandler and because I don't have a capture in my regex, I suppose it won't work...\nAdding a capture doesn't quite solve my problem either:\n(r'/dir(.+)', web.StaticHandler, dict(path=\"static/dir/\", default_filename=\"index.html\"))\nresults in:\n21:08:46 web.1     | WARNING:root:403 GET /dir/ (127.0.0.1): / is not in root static directory\nAm I using this completely wrong, or was the functionality broke somewhere along the way?\nI don't see any test cases related to the default_filename parameter, so I suppose I it might be a bug... but I'm going to assume the problem is between the keyboard and the chair for now.\nWould really appreciate some help, thanks!", "issue_status": "Closed", "issue_reporting_time": "2012-05-26T01:17:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1072": {"issue_url": "https://github.com/tornadoweb/tornado/issues/515", "issue_id": "#515", "issue_summary": "Low perfomance on big chunks writing", "issue_description": "Contributor\nei-grad commented on 25 May 2012\n_merge_buffer produces too much memcpy operations on heavy data chunks if you pass them to IOStream.write\nDetails: https://groups.google.com/d/topic/python-tornado/NEgKGiFkHXI/discussion", "issue_status": "Closed", "issue_reporting_time": "2012-05-25T15:07:40Z", "fixed_by": "#516", "pull_request_summary": "Split large chunks of data in IOStream.write", "pull_request_description": "Contributor\nei-grad commented on 25 May 2012\nCloses #515.", "pull_request_status": "Merged", "issue_fixed_time": "2012-05-26T18:12:45Z", "files_changed": [["6", "tornado/iostream.py"]]}, "1073": {"issue_url": "https://github.com/tornadoweb/tornado/issues/511", "issue_id": "#511", "issue_summary": "Tornado logs filled with [Errno 104] Connection reset by peer", "issue_description": "dkador commented on 11 May 2012\nI'm running a couple tornado servers behind supervisor on Ubuntu 10.04. My log files are full of this:\n[W 120511 01:50:34 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:34 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:39 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:39 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:44 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:44 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:49 iostream:382] Read error on 13: [Errno 104] Connection reset by peer\n[W 120511 01:50:49 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:54 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:54 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:59 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\n[W 120511 01:50:59 iostream:382] Read error on 9: [Errno 104] Connection reset by peer\nFollowed by:\n[E 120511 01:52:51 netutil:217] Error in connection callback\n    Traceback (most recent call last):\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/netutil.py\", line 215, in _handle_connection\n        self.handle_stream(stream, address)\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/httpserver.py\", line 144, in handle_stream\n        self.no_keep_alive, self.xheaders)\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/httpserver.py\", line 171, in __init__\n        self.stream.read_until(b(\"\\r\\n\\r\\n\"), self._header_callback)\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/iostream.py\", line 161, in read_until\n        if self._read_to_buffer() == 0:\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/iostream.py\", line 378, in _read_to_buffer\n        chunk = self._read_from_socket()\n      File \"/home/keen/virtualenvs/service/local/lib/python2.7/site-packages/tornado/iostream.py\", line 359, in _read_from_socket\n        chunk = self.socket.recv(self.read_chunk_size)\n    error: [Errno 104] Connection reset by peer\nAs far as I can tell it's not really interfering with my users (I'm pretty low volume right now though). Tornado 2.2.\nNot sure how to proceed, happy to provide more information with guidance.", "issue_status": "Closed", "issue_reporting_time": "2012-05-11T06:55:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1074": {"issue_url": "https://github.com/tornadoweb/tornado/issues/509", "issue_id": "#509", "issue_summary": "URL path starting with double-slash can never been matched", "issue_description": "raptium commented on 9 May 2012\nURLs like http://www.example.com//haha (note there are 2 slashes) will never been matched and always get a HTTP 404 error.\nat httpserver.py around line 394\nscheme, netloc, path, query, fragment = urlparse.urlsplit(native_str(uri))\nself.path = path\nself.query = query\narguments = parse_qs_bytes(query)\ntornado.web.httpserver.HTTPRequest gets its path attribute from the result of urlparse.urlsplit(), however urlsplit returns an empty path if the uri starts with 2 slashes.\n>>> uri = '/haha?a=b&c=d'\n>>> print urlsplit(uri)\nSplitResult(scheme='', netloc='', path='/haha', query='a=b&c=d', fragment='')\n>>> uri = '//haha?a=b&c=d'\n>>> print urlsplit(uri)\nSplitResult(scheme='', netloc='haha', path='', query='a=b&c=d', fragment='')\n>>> ", "issue_status": "Closed", "issue_reporting_time": "2012-05-09T12:53:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1075": {"issue_url": "https://github.com/tornadoweb/tornado/issues/508", "issue_id": "#508", "issue_summary": "_stack_context_handle_exception fails to create types requiring more than one argument", "issue_description": "dgquintas commented on 9 May 2012\nThis problem is also related to the changes 2to3 introduces adapting _stack_context_handle_exception.\nLine raise type, value, traceback becomes raise type(value).with_traceback(traceback). However, certain exceptions, such as UnicodeDecodeError can't be constructed with a single argument. In Python 3, the correct syntax would be raise type(*value.args).with_traceback(traceback). However, I've failed to come up with a Python 2 equivalent that 2to3 would automatically translate correctly. In fact, something like raise type, *value.args, traceback isn't even valid.", "issue_status": "Closed", "issue_reporting_time": "2012-05-09T06:04:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1076": {"issue_url": "https://github.com/tornadoweb/tornado/issues/507", "issue_id": "#507", "issue_summary": "tornado.gen and ExceptionStackContext make things painfully slow", "issue_description": "ceymard commented on 8 May 2012\nchanging ExceptionStackContext's code to the following makes everything smooth again :\n    def __init__(self, exception_handler):\n        self.exception_handler = exception_handler\n\n    def __enter__(self):\n        pass\n        #self.old_contexts = _state.contexts\n        #_state.contexts = (self.old_contexts +\n        #                   ((ExceptionStackContext, self.exception_handler),))\n\n    def __exit__(self, type, value, traceback):\n        try:\n            if type is not None:\n                return self.exception_handler(type, value, traceback)\n        finally:\n            pass\n            # _state.contexts = self.old_contexts\nI do not understand all the magic's that's going on here, but my problem is that the contexts, by being copied all the time can get to slow everything down to a crawl.\nWhat am I doing wrong ? Why is there so much ExceptionStackContext being run ?", "issue_status": "Closed", "issue_reporting_time": "2012-05-08T16:42:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1077": {"issue_url": "https://github.com/tornadoweb/tornado/issues/504", "issue_id": "#504", "issue_summary": "SimpleAsyncHTTPCLient raise a CertificateError for \"dotted\" subdomains with a wildcard certificate", "issue_description": "Contributor\nghost commented on 4 May 2012\nThe current implementation of certificate checking used by SimpleAsyncHTTPClient will not match \"dotted\" subdomains to a wildcard SSL certificate.\nThe problem arises in the _dnsname_to_pat function in simple_httpclient.py. The function expands a \"\" fragment in a wildcard certificate (e.g. \".s3.amazonaws.com\") to a non-empty dotless fragment, used for regex matching of the hostname.\nHence, for a bucket on AWS S3 with the url https://dotted.bucket.name.s3.amazonaws.com, the sub-subdomain dotted.bucket.name will not match the \"*.s3.amazonaws.com\" wildcard certificate.\nUsing Amazon's own python client code, and other clients I've tested, dotted subdomains validates to the wildcard certificate without problems.\nThe issue could be resolved by replacing\ndef _dnsname_to_pat(dn):\n    pats = []\n    for frag in dn.split(r'.'):\n        if frag == '*':\n            # When '*' is a fragment by itself, it matches a non-empty dotless\n            # fragment.\n            pats.append('[^.]+')\n        else:\n            # Otherwise, '*' matches any dotless fragment.\n            frag = re.escape(frag)\n            pats.append(frag.replace(r'\\*', '[^.]*'))\n    return re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)\nwith\ndef _dnsname_to_pat(dn):\n    pats = []\n    for frag in dn.split(r'.'):\n        if frag == '*':\n            # When '*' is a fragment by itself, it matches a non-empty\n            # fragment.\n            pats.append('.+')\n        else:\n            # Otherwise, '*' matches any dotless fragment.\n            frag = re.escape(frag)\n            pats.append(frag.replace(r'\\*', '[^.]*'))\n    return re.compile(r'\\A' + r'\\.'.join(pats) + r'\\Z', re.IGNORECASE)", "issue_status": "Closed", "issue_reporting_time": "2012-05-04T09:12:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1078": {"issue_url": "https://github.com/tornadoweb/tornado/issues/502", "issue_id": "#502", "issue_summary": "\"KeyError: 6\" on ioloop.py:541, why?", "issue_description": "jpuigcerver commented on 2 May 2012\nHi,\nI'm getting a weird KeyError exception and I don't know exactly why is produced. This was produced when sending a POST request to a HTTP server, using the method http_fetch from HTTPClient.\nCheck https://github.com/mogelbrod/TweetRank/blob/master/crawler/RankerNotifier.py to see how the requests are sent.\nTraceback (most recent call last):\nFile \"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/curl_httpclient.py\", line >95, in _handle_socket\nself.io_loop.remove_handler(fd)\nFile \"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/ioloop.py\", line 193, in >remove_handler\nself._impl.unregister(fd)\nFile \"/opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/tornado/ioloop.py\", line 541, in >unregister\nevents = self._active.pop(fd)\nKeyError: 6\nWhy is this Exception raised? What should I do to solve this problem?\nThank you very much!", "issue_status": "Closed", "issue_reporting_time": "2012-05-02T18:25:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1079": {"issue_url": "https://github.com/tornadoweb/tornado/issues/501", "issue_id": "#501", "issue_summary": "in python 3.2, get_cookie() returns \"str\", but get_secure_cookie() returns \"bytes\"", "issue_description": "321cyb commented on 1 May 2012\nTornado version 2.2\nPython version 3.2.2\nset_cookie(\"name\", \"value\")\nget_cookie(\"name\")\n\"value\" is returned\nset_secure_cookie(\"name\", \"value\")\nget_secure_cookie(\"name\")\nb\"value\" is returned\nThis should be a minor defect, str should always be returned.", "issue_status": "Closed", "issue_reporting_time": "2012-05-01T03:51:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1080": {"issue_url": "https://github.com/tornadoweb/tornado/issues/496", "issue_id": "#496", "issue_summary": "Possible bug in tornado.testing.wait", "issue_description": "Contributor\nahassany commented on 18 Apr 2012\nI've not figure out what's wrong with this test case, I'm not sure if it's a bug or I'm doing something wrong!\nThe Request handler implements has asynchronous GET, the get adds a callback for the next IOLoop round. This works fine if I'm running a regular app, but it times out in the unit testing.\nimport tornado.web\nfrom tornado.ioloop import IOLoop\nfrom tornado.testing import AsyncHTTPTestCase\n\nclass LazyHandler(tornado.web.RequestHandler):\n\n    def _lazy_finish(self):\n        self.write(\"finishing request\\n\")\n        self.finish()\n\n    @tornado.web.asynchronous\n    def get(self):\n        self.write(\"Lazy Handler\\n\")\n        IOLoop.instance().add_callback(self._lazy_finish)\n\nclass LazyHandlerTest(AsyncHTTPTestCase):\n    def get_app(self):\n        return tornado.web.Application([('/', LazyHandler)])\n\n    def test_get_no_wait(self):\n        \"\"\"This works fine\"\"\"\n        self.http_client.fetch(self.get_url('/') , self.stop)\n\n    def test_get_using_client(self):\n        \"\"\"This will timeout\"\"\"\n        self.http_client.fetch(self.get_url('/') , self.stop)\n        self.wait()\n\n    def test_get_using_fetch(self):\n        \"\"\"This will timeout\"\"\"\n        self.fetch('/')", "issue_status": "Closed", "issue_reporting_time": "2012-04-18T02:34:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1081": {"issue_url": "https://github.com/tornadoweb/tornado/issues/493", "issue_id": "#493", "issue_summary": "AsyncHTTPClient.configure max_clients not working", "issue_description": "jimmyR commented on 15 Apr 2012\nThe documentation says this is deprecated - but it works:\ntornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\nhttp_client = tornado.httpclient.AsyncHTTPClient(max_clients=1000)\nAnd this should now be the new version - but this does not work:\ntornado.httpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\",max_clients=1000)\nhttp_client = tornado.httpclient.AsyncHTTPClient()\nError:\nFile \"/opt/python/lib/python2.7/site-packages/tornado-2.2-py2.7.egg/tornado/httpclient.py\", line 148, in new\ninstance.initialize(io_loop, max_clients, **args)\nTypeError: initialize() got multiple values for keyword argument 'max_clients'\nBug? Or my misunderstanding?\njimmyR", "issue_status": "Closed", "issue_reporting_time": "2012-04-14T19:44:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1082": {"issue_url": "https://github.com/tornadoweb/tornado/issues/492", "issue_id": "#492", "issue_summary": "RequestHandler.flush not calling callback if no data to write", "issue_description": "ceymard commented on 12 Apr 2012\nThis has stuck me for quite a while, because flush would not call its callback if I didn't write anything between two calls.\nI don't really know which is the best : calling the callback directly ? Or raising an exception maybe ?\nRight now, we have\n        if headers or chunk:\n            self.request.write(headers + chunk, callback=callback)\nSo it would either be\n        if headers or chunk:\n            self.request.write(headers + chunk, callback=callback)\n       else:\n            raise Exception(\"Don't call flush if you have nothing to actually flush\")\nor\n        if headers or chunk:\n            self.request.write(headers + chunk, callback=callback)\n       else:\n            callback() # Or something a little more complex than that ?\nThoughts ?", "issue_status": "Closed", "issue_reporting_time": "2012-04-12T11:30:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1083": {"issue_url": "https://github.com/tornadoweb/tornado/issues/490", "issue_id": "#490", "issue_summary": "Broken Unicode handling in reverse_url function", "issue_description": "callum commented on 10 Apr 2012\n  File \"/tornado/web.py\", line 1371, in reverse_url\n    return self.named_handlers[name].reverse(*args)\n  File \"/tornado/web.py\", line 1931, in reverse\n    return self._path % tuple([str(a) for a in args])\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)\nI'm using a temporary fix at the moment that looks like this:\nclass URLSpec(tornado.web.URLSpec):\n    def reverse(self, *args):\n        assert self._path is not None, \\\n            \"Cannot reverse url regex \" + self.regex.pattern\n        assert len(args) == self._group_count, \"required number of arguments \"\\\n            \"not found\"\n        if not len(args):\n            return self._path\n        return self._path % tuple([a.encode('utf-8') for a in args])\nReplacing str(a) for a.encode('utf-8').", "issue_status": "Closed", "issue_reporting_time": "2012-04-10T01:34:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1084": {"issue_url": "https://github.com/tornadoweb/tornado/issues/489", "issue_id": "#489", "issue_summary": "parse_multipart_form_data doesn't properly handle final boundary", "issue_description": "Contributor\njeffhunter commented on 9 Apr 2012\nparse_multipart_form_data (in httputil.py) assumes that either nothing or a single \\r\\n appears after the final form boundary. According to RFC 1341, if additional information appears after the final form boundary, it should be ignored.\nhttp://www.w3.org/Protocols/rfc1341/7_2_Multipart.html\n\"There appears to be room for additional information prior to the first encapsulation boundary and following the final boundary. These areas should generally be left blank, and implementations should ignore anything that appears before the first boundary or after the last one.\"\nIn particular, AFNetworking (an iOS library), puts two \\r\\n after the final boundary, which causes parse_multipart_form_data to fail.\nAFNetworking/AFNetworking@54194a3#diff-0\nI don't think AFNetworking really needs to do that, but it's within the bounds of the RFC.\nI have worked around it by making the following change. I'm not sure if it's the best way to fix it, but it works for me:\n-    if data.endswith(b(\"\\r\\n\")):\n-        footer_length = len(boundary) + 6\n-    else:\n-        footer_length = len(boundary) + 4\n-    parts = data[:-footer_length].split(b(\"--\") + boundary + b(\"\\r\\n\"))\n+    final_boundary_index = data.rfind(b(\"--\") + boundary + b(\"--\"))\n+    if final_boundary_index == -1:\n+        logging.warning(\"Invalid multipart/form-data\")\n+        return\n+    parts = data[:final_boundary_index].split(b(\"--\") + boundary + b(\"\\r\\n\"))```", "issue_status": "Closed", "issue_reporting_time": "2012-04-08T21:36:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1085": {"issue_url": "https://github.com/tornadoweb/tornado/issues/486", "issue_id": "#486", "issue_summary": "Implement SPDY protocol", "issue_description": "Contributor\nalekstorm commented on 4 Apr 2012\nA Tornado implementation of Google's proposal for SPDY, a replacement for HTTP, would be a fantastic project for anyone unafraid of digging into Tornado's (well-organized) internals to spearhead. Since SPDY specifies a new binary framing scheme while preserving HTTP's method-based request-response semantics*, SPDYServer would be a drop-in replacement for HTTPServer, completely transparent to Application. Supporting alternate protocols is healthy for the growth of Tornado in general.\nProposed standard setup:\napp = MyApplication()\nHTTPServer(app).listen(port=80, spdy_port=88)\nSPDYServer(app).listen(port=88)\nIOLoop.instance().start()\nIf the spdy_port parameter to HTTPServer is not None, it will advertise SPDY support on the given port by adding an Alternate-Protocol: 88:spdy/2 header to each outgoing response. The client can then switch the protocol of future requests.\nI'd recommend fully implementing draft version 2 first, since it's what Chromium currently speaks, and I haven't been able to find a timetable for version 3 implementation.\nWe're not the only HTTP server/framework out there, so it would be great if the SPDY frame serialization and parsing logic could be factored out into a general-purpose library - Mark Nottingham's code would be a good start.\n*SPDY does add a server push capability not present in HTTP (spec). Support for this should be added last, and might work through a new method on RequestHandler (which can detect a SPDY connection by checking if request.version == \"SPDY/2\"). This makes sense semantically, because each server push must be associated with an open client-initiated stream. Haven't given this much thought yet.", "issue_status": "Closed", "issue_reporting_time": "2012-04-03T20:01:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1086": {"issue_url": "https://github.com/tornadoweb/tornado/issues/485", "issue_id": "#485", "issue_summary": "Sphinx autodoc error", "issue_description": "yuvadm commented on 1 Apr 2012\nwebsite $ make                    \nsphinx-build -b html -W -d sphinx/build/doctrees sphinx sphinx/build/html\nRunning Sphinx v1.1.3\nloading pickled environment... not yet created\nbuilding [html]: targets for 39 source files that are out of date\nupdating environment: 39 added, 0 changed, 0 removed\nTraceback (most recent call last):                                            \n  File \"/usr/local/Cellar/python/2.7.2/lib/python2.7/site-packages/sphinx/ext/autodoc.py\", line 321, in import_object\n    __import__(self.modname)\n  File \"/Users/yuval/dev/tornado/tornado/database.py\", line 22, in <module>\n    import MySQLdb.constants\nImportError: No module named MySQLdb.constants\nreading sources... [100%] wsgi                                                \n\nWarning, treated as error:\n/Users/yuval/dev/tornado/website/sphinx/database.rst:4: WARNING: autodoc can't import/find module 'tornado.database', it reported error: \"No module named MySQLdb.constants\", please check your spelling and sys.path\n\nmake: *** [sphinx] Error 1\nBut:\nPython 2.7.2 (default, Apr  1 2012, 00:09:13) \n[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import MySQLdb.constants\n>>> MySQLdb.version_info\n(1, 2, 3, 'final', 0)\nIs this somehow related to http://readthedocs.org/builds/tornado/77974/ ?", "issue_status": "Closed", "issue_reporting_time": "2012-04-01T09:10:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1087": {"issue_url": "https://github.com/tornadoweb/tornado/issues/483", "issue_id": "#483", "issue_summary": "Retrieving list arguments of POST request", "issue_description": "sv001196 commented on 27 Mar 2012\nMy question is related to the issue #325.\nI am sending a POST request to my server as follows :\nimport urllib\nurl = 'http://localhost:8888/'\nparams = urllib.urlencode({'uid':uid,'to':['rd','sg']})\nresponse = urllib.urlopen(url,params)\nthe_page = response.read()\nNote that I am trying to pass a list of strings via 'to' argument.\nOn my server side, I am trying to read back the list of strings as follows :\nclass MainHandler(tornado.web.RequestHandler):\ndef post(self,resource=None):\nuid = self.get_argument('uid') #this is fine\n    #the below call returns an unicode string [\"['rd', 'sg']\"]\n    to_list = self.get_argument['to'] \nI could not get the original list from \"to_list\" [i tried pickling, json dumping etc].\nBasically, every POST argument is converted into a list and if the client passes a list of objects as one of the parameters, I am not able to retrieve the original list back on the server side.\nQuick suggestion will help me! Thanks.", "issue_status": "Closed", "issue_reporting_time": "2012-03-27T06:36:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1088": {"issue_url": "https://github.com/tornadoweb/tornado/issues/478", "issue_id": "#478", "issue_summary": "BaseCookie parser incompatible with SimpleCookie generator", "issue_description": "jonoberheide commented on 13 Mar 2012\nSimpleCookie is used to generate the Set-cookie headers, but BaseCookie is used to parse them.\nFor example, if a '=' is included in the cookie value, SimpleCookie will quote the whole cookie value: Set-cookie: foo=\"bar\". However, BaseCookie will read that value in as '\"bar\"' instead of 'bar'.\nMore details:\nhttp://hg.python.org/cpython/rev/9559e1152595/", "issue_status": "Closed", "issue_reporting_time": "2012-03-13T05:43:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1089": {"issue_url": "https://github.com/tornadoweb/tornado/issues/474", "issue_id": "#474", "issue_summary": "upload source to pypi", "issue_description": "jtriley commented on 3 Mar 2012\ntornado is not currently hosted on pypi (see failed check on http://crate.io/packages/tornado) - would be nice to upload to pypi rather than point to github downloads.", "issue_status": "Closed", "issue_reporting_time": "2012-03-03T17:28:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1090": {"issue_url": "https://github.com/tornadoweb/tornado/issues/473", "issue_id": "#473", "issue_summary": "Uncaught exceptions when client closes connection", "issue_description": "Contributor\ndavidgaleano commented on 29 Feb 2012\nThis issue is not always easy to reproduce but when we manage to reproduce it the client was always a Google Chrome browser, the server is just a plain http one. It seems the browser may be closing the socket without waiting for the server to reply.\nThis is a traceback for the server running on Mac OS X 10.7:\nTraceback (most recent call last):\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/netutil.py\", line 215, in _handle_connection\nself.handle_stream(stream, address)\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/httpserver.py\", line 144, in handle_stream\nself.no_keep_alive, self.xheaders)\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/httpserver.py\", line 171, in init\nself.stream.read_until(b(\"\\r\\n\\r\\n\"), self._header_callback)\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/iostream.py\", line 161, in read_until\nif self._read_to_buffer() == 0:\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/iostream.py\", line 375, in _read_to_buffer\nchunk = self._read_from_socket()\nFile \"/Users/david/env/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/iostream.py\", line 356, in _read_from_socket\nchunk = self.socket.recv(self.read_chunk_size)\nerror: [Errno 54] Connection reset by peer\nThese are other tracebacks for a server running on Windows 7 64bit:\nTraceback (most recent call last):\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 983, in _execute\nself.prepare()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 1628, in prepare\nself.fallback(self.request)\nFile \"C:\\Devlp\\turbulenz\\devserver\\paste_factory.py\", line 51, in call\nrequest.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 422, in finish\nself.connection.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 186, in finish\nself._finish_request()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 222, in _finish_request\nself.stream.read_until(b(\"\\r\\n\\r\\n\"), self._header_callback)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\iostream.py\", line 160, in read_until\nself._check_closed()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\iostream.py\", line 535, in _check_closed\nraise IOError(\"Stream is closed\")\nIOError: Stream is closed\nTraceback (most recent call last):\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 693, in send_error\nself.write_error(status_code, **kwargs)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 739, in write_error\n\"message\": httplib.responses[status_code],\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 668, in finish\nself.flush(include_footers=True)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 631, in flush\nself.request.write(headers + chunk, callback=callback)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 418, in write\nself.connection.write(chunk, callback=callback)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 176, in write\nassert self._request, \"Request closed\"\nAssertionError: Request closed\nTraceback (most recent call last):\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\iostream.py\", line 304, in wrapper\ncallback(_args)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 280, in _on_request_body\nself.request_callback(self._request)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 1362, in call\nhandler._execute(transforms, *args, *_kwargs)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 992, in _execute\nself._handle_request_exception(e)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 1032, in _handle_request_exception\nself.send_error(500, exc_info=sys.exc_info())\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 697, in send_error\nself.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 669, in finish\nself.request.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 422, in finish\nself.connection.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 183, in finish\nassert self._request, \"Request closed\"\nAssertionError: Request closed\nTraceback (most recent call last):\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\ioloop.py\", line 399, in _run_callback\ncallback()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\iostream.py\", line 304, in wrapper\ncallback(*args)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 280, in _on_request_body\nself.request_callback(self._request)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 1362, in call\nhandler._execute(transforms, _args, *_kwargs)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 992, in _execute\nself._handle_request_exception(e)\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 1032, in _handle_request_exception\nself.send_error(500, exc_info=sys.exc_info())\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 697, in send_error\nself.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\web.py\", line 669, in finish\nself.request.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 422, in finish\nself.connection.finish()\nFile \"C:\\Devlp\\env\\lib\\site-packages\\tornado-2.2-py2.7.egg\\tornado\\httpserver.py\", line 183, in finish\nassert self._request, \"Request closed\"\nAssertionError: Request closed", "issue_status": "Closed", "issue_reporting_time": "2012-02-29T13:00:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1091": {"issue_url": "https://github.com/tornadoweb/tornado/issues/472", "issue_id": "#472", "issue_summary": "websocket.write_message utf8 escapes even for binary payload", "issue_description": "oberstet commented on 29 Feb 2012\nwrite_message always utf-8 escapes message payload regardless of binary/text\nhttps://github.com/facebook/tornado/blob/master/tornado/websocket.py#L524\nseems to be wrong?", "issue_status": "Closed", "issue_reporting_time": "2012-02-29T10:30:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1092": {"issue_url": "https://github.com/tornadoweb/tornado/issues/471", "issue_id": "#471", "issue_summary": "websocket.on_message: no payload type arg", "issue_description": "oberstet commented on 29 Feb 2012\n_handle_message does not forward message payload type (text/binary) to on_message\nhttps://github.com/facebook/tornado/blob/master/tornado/websocket.py#L611\nwhen on a WS connection with mixed payloads, an app can't appropriately process messages", "issue_status": "Closed", "issue_reporting_time": "2012-02-29T10:29:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1093": {"issue_url": "https://github.com/tornadoweb/tornado/issues/466", "issue_id": "#466", "issue_summary": "tornado.testing can swallow exceptions", "issue_description": "dwt commented on 22 Feb 2012\nI've just lost a whole day until I figured out why my test suite suddenly exploded completely.\nHere's what happened:\nA test of mine exercises colanders validation logic to see if correctly rejecting invalid input\nSuddenly my whole test suite exploded\nIt takes hours of debugging until I learn that the AsyncTestCase somehow swallows exceptions raised during logging an exception that is thrown in a test.\nTo be exact, colander throws an exception that throws an exception when you str() it\ntornado.testing swallows that exception, starts the next test and lets me stay to wonder why suddenly test isolation is broken\nwhich happens because teardown isn't run.\nHere's a reduction that nicely demonstrates the problem for me.\nimport unittest\nimport logging\nfrom tornado.testing import AsyncTestCase\n\n\nclass Test(AsyncTestCase):\n\n    def test(self):\n        class FaultingException(Exception):\n            def __str__(self):\n                raise TypeError()\n        # comment the next line to see it dying normaly\n        logging.warn('baz to logging.warn')\n        raise FaultingException()\n\n# Run with $ nosetests test.py\n# watch it die without reporting the exception", "issue_status": "Closed", "issue_reporting_time": "2012-02-22T17:34:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1094": {"issue_url": "https://github.com/tornadoweb/tornado/issues/465", "issue_id": "#465", "issue_summary": "HTTPRequest.full_url misses local port", "issue_description": "Contributor\nphihag commented on 22 Feb 2012\nSince the local port is not included in the return value of full_url, applications relying on that function break when running on non-standard ports. The local port can be determined with\nself.request.connection.stream.socket.getsockname()[1]\nfull_url should include the port iff it is non-standard. It may be useful to provide that value via a property local_port on HTTPRequests for use by applications which must know their local port.", "issue_status": "Closed", "issue_reporting_time": "2012-02-21T23:22:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1095": {"issue_url": "https://github.com/tornadoweb/tornado/issues/464", "issue_id": "#464", "issue_summary": "@addslash / @removeslash decorators", "issue_description": "andrew-d commented on 21 Feb 2012\nHello,\nI was recently using the @AddSlash decorator, and I noticed that it is implemented using self.redirect, which does a 302 Found redirect. I think it would be better to use a 301 Moved Permanently redirect, as the presence of the decorator indicates that the canonical location should be the one with the trailing slash. @removeslash should probably be the same.\nThoughts?", "issue_status": "Closed", "issue_reporting_time": "2012-02-21T07:45:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1096": {"issue_url": "https://github.com/tornadoweb/tornado/issues/463", "issue_id": "#463", "issue_summary": "tornado.database error?", "issue_description": "Contributor\newang commented on 19 Feb 2012\nAny idea why the following happened?\nTraceback (most recent call last):\nFile \"app.py\", line 14, in\nimport tornado.database\nFile \"/Users/ericwang/Desktop/workspace/py_envs/dev/lib/python2.7/site-packages/tornado/database.py\", line 224, in\nCONVERSIONS[field_type] = [(FLAG.BINARY, str)] + CONVERSIONS[field_type]\nTypeError: can only concatenate list (not \"function\") to list", "issue_status": "Closed", "issue_reporting_time": "2012-02-19T07:32:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1097": {"issue_url": "https://github.com/tornadoweb/tornado/issues/462", "issue_id": "#462", "issue_summary": "feature request: ability to set _xsrf cookie expiration", "issue_description": "tzuryby commented on 17 Feb 2012\nI wanted to be able to set _xsrf expiration to 1 day rather than current 30 days.\nI have search the code to see where this happens and found this.\n    @property\n    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            token = self.get_cookie(\"_xsrf\")\n            if not token:\n                token = binascii.b2a_hex(uuid.uuid4().bytes)\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", token, expires_days=expires_days)\n            self._xsrf_token = token\n        return self._xsrf_token\nSo I wonder if there was a way to do so easily, e.g.\ndefine(\"xsrf_cookie_expiration\", default=1, help=\"_xsrf cookie expiration days\", type=int)\nand within the xsrf_token implementation:\nexpires_days = options.xsrf_cookie_expiration if self.current_user else None", "issue_status": "Closed", "issue_reporting_time": "2012-02-17T08:37:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1098": {"issue_url": "https://github.com/tornadoweb/tornado/issues/459", "issue_id": "#459", "issue_summary": "Replace \"copy.copy\" by \"copy.deepcopy\" in simple_httpclient.py", "issue_description": "kolombo commented on 9 Feb 2012\nReplace \"copy.copy\" by \"copy.deepcopy\" in simple_httpclient.py.\nThis case \"HOST\" header to be deleted form Original Request on line 384 of simple_httpclient.py, which cause to Key error exception.", "issue_status": "Closed", "issue_reporting_time": "2012-02-09T12:59:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1099": {"issue_url": "https://github.com/tornadoweb/tornado/issues/451", "issue_id": "#451", "issue_summary": "ResourceWarnings with Python 3.2", "issue_description": "Arfrever commented on 31 Jan 2012\nPYTHONWARNINGS=\"d\" variable or -Wd option enables printing of ResourceWarnings etc.\n$ PYTHONPATH=\".\" python3.2 -Wd tornado/test/runtests.py\n.............................................................................................................................................................................................\n----------------------------------------------------------------------\nRan 189 tests in 1.398s\n\nOK\n[I 120131 16:09:04 testing:372] PASS\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=8, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=10, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=7, family=2, type=2049, proto=0>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=6, family=1, type=2049, proto=0>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=8, family=2, type=2049, proto=0>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=7, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=13, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=10, family=10, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=11, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=12, family=2, type=2049, proto=6>\nsys:1: ResourceWarning: unclosed <socket.socket object, fd=11, family=2, type=2049, proto=0>", "issue_status": "Closed", "issue_reporting_time": "2012-01-31T15:11:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1100": {"issue_url": "https://github.com/tornadoweb/tornado/issues/450", "issue_id": "#450", "issue_summary": "Test suite fails to run with Python 3.2", "issue_description": "Arfrever commented on 31 Jan 2012\n$ PYTHONPATH=\".\" python3.2 tornado/test/runtests.py\nTraceback (most recent call last):\n  File \"tornado/test/runtests.py\", line 33, in <module>\n    tornado.testing.main()\n  File \"/tmp/tornado-2.2/build/lib/tornado/testing.py\", line 347, in main\n    argv = [sys.argv[0]] + parse_command_line(sys.argv)\n  File \"/tmp/tornado-2.2/build/lib/tornado/options.py\", line 147, in parse_command_line\n    enable_pretty_logging()\n  File \"/tmp/tornado-2.2/build/lib/tornado/options.py\", line 347, in enable_pretty_logging\n    channel.setFormatter(_LogFormatter(color=color))\n  File \"/tmp/tornado-2.2/build/lib/tornado/options.py\", line 364, in __init__\n    logging.DEBUG: str(curses.tparm(fg_color, 4), # Blue\nTypeError: 'str' does not support the buffer interface\n$ python3.2 -c 'import sys; print(sys.version)'\n3.2.2+ (3.2:77188bc37c74+, Jan 29 2012, 21:00:23) \n[GCC 4.5.3]\nWith Python 3.1.4:\n$ PYTHONPATH=\".\" python3.1 tornado/test/runtests.py\n...\nRan 183 tests in 0.715s\n\nFAILED (failures=2, errors=84)", "issue_status": "Closed", "issue_reporting_time": "2012-01-31T00:17:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1101": {"issue_url": "https://github.com/tornadoweb/tornado/issues/447", "issue_id": "#447", "issue_summary": "make_static_url disable hash override", "issue_description": "docyes commented on 27 Jan 2012\nI have a use case where I need to tell static_url to not append the v/hash for cache/busting (prefer to leave that to the client).\nIt would be nice to add support for an override to disable cache busting as an optional kwarg hash that defaults to True:\ndef make_static_url(cls, settings, path, hash=True):", "issue_status": "Closed", "issue_reporting_time": "2012-01-27T05:50:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1102": {"issue_url": "https://github.com/tornadoweb/tornado/issues/445", "issue_id": "#445", "issue_summary": "Wrong cookie set logic in web.py", "issue_description": "rkuzmin commented on 25 Jan 2012\nin web.py on 347 there is\nself._new_cookies.append(new_cookie)\nI have a cookie with a 'flash' key, then I'm trying to overwrite it, but in result I have 2 cookies with same key and the browser set the last one:\nflash=; expires=Tue, 25 Jan 2011 08:36:57 GMT; Path=/\nflash=\"eyJtZXNzYWdlIjogW10sICJlcnJvciI6IFtdfQ==|1327480617|8011a5339bcf4a55b93e7aca03589fd7f229410c\"; expires=Thu, 26 Jan 2012 08:36:57 GMT; Path=/\nI my opinion it should be overwritten, but not appended", "issue_status": "Closed", "issue_reporting_time": "2012-01-25T08:46:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1103": {"issue_url": "https://github.com/tornadoweb/tornado/issues/441", "issue_id": "#441", "issue_summary": "CurlAsyncHTTPClient Does Not Send Basic Auth When Password is Blank", "issue_description": "Contributor\nmankyd commented on 23 Jan 2012\nI have a 3rd party api that requires me to send a basic-auth user name but a blank password. However, Tornado's CurlAsyncHTTPClient does not set the basic auth headers when the password is an empty string. Using the SimpleAsyncHTTPClient works as expected.\nIt is the difference between checking if the parameters are None vs. simply checking if they evaluate to False. The curl client checks if they evaluate to False, whereas the simple client checks if the username is None.", "issue_status": "Closed", "issue_reporting_time": "2012-01-22T21:55:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1104": {"issue_url": "https://github.com/tornadoweb/tornado/issues/440", "issue_id": "#440", "issue_summary": "add the support of Sec-WebSocket-Version 13", "issue_description": "kikyous commented on 20 Jan 2012\nfirefox 12 use the Sec-WebSocket-Version 13,tornado is not support", "issue_status": "Closed", "issue_reporting_time": "2012-01-20T12:06:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1105": {"issue_url": "https://github.com/tornadoweb/tornado/issues/438", "issue_id": "#438", "issue_summary": "SSL socket errors", "issue_description": "hjwp commented on 17 Jan 2012\nWe're seeing quite a few socket \"Read error\" and \"Write error\" in our logs. They're usually (but not absolutely always) associated with two C exceptions:\nWARNING:Read error on 25: [Errno 1] _ssl.c:1331: error:140943FC:SSL routines:SSL3_READ_BYTES:sslv3 alert bad record mac\nWARNING:Write error on 21: [Errno 1] _ssl.c:1217: error:1409F07F:SSL routines:SSL3_WRITE_PENDING:bad write retry\nThe latter looks similar to the error discussed in the comments in iostream.py, ie python bug 8240. Could it be a slightly different case of the same bug?\nhttp://bugs.python.org/issue8240\nWhen not associated with a C exception, we see only:\nWARNING:Write error on 18: [Errno 14] Bad address\nThe first exception has a bit of google-juice too:\nhttp://stackoverflow.com/questions/2603119/opening-ssl-urls-with-python\nhttp://pythonpaste.org/news.html#id10\nOne thing that seems to help is running tornado from python 2.7 instead of python 2.6 - errors occur 5 times less frequently, in my last quick test (but sadly are not done away with completely)\nIs there anything that can be done in the tornado code to try and avoid these? Or perhaps some way that we could use tornado differently to avoid them?", "issue_status": "Closed", "issue_reporting_time": "2012-01-17T15:28:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1106": {"issue_url": "https://github.com/tornadoweb/tornado/issues/434", "issue_id": "#434", "issue_summary": "socket.error: [Errno 98] Address already in use", "issue_description": "pkienzle commented on 10 Jan 2012\nI'm getting the following in netutil.py when opening a port:\nFile \"/home/pkienzle/pyenv/socket/lib/python2.7/site-packages/tornado-2.1.1-py2.7.egg/tornado/netutil.py\", line 267, in bind_sockets\n  sock.bind(sockaddr)\nFile \"/usr/lib/python2.7/socket.py\", line 224, in meth\n  return getattr(self._sock,name)(*args)\nsocket.error: [Errno 98] Address already in use\nThe issue is that socket.getaddrinfo() is returning duplicate entries for localhost on my server (python 2.7.2, ubuntu 11.10):\n>>> import socket\n>>> print socket.getaddrinfo('localhost',8014,0,socket.SOCK_STREAM,0,33)\n[(2, 1, 6, '', ('127.0.0.1', 8014)), (2, 1, 6, '', ('127.0.0.1', 8014))]\nMy solution was to use set() to make the list of address unique:\nfor res in set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,\n                              0, flags)):", "issue_status": "Closed", "issue_reporting_time": "2012-01-10T17:36:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1107": {"issue_url": "https://github.com/tornadoweb/tornado/issues/433", "issue_id": "#433", "issue_summary": "an advice about tornadow.database", "issue_description": "jiaxiaolei commented on 10 Jan 2012\nI have been using tornado for nearly 2 years! Now, I begin to read the resource code, and find some code can be more beautiful. show a instance as follows:\nIn the page \u201chttps://github.com/jaixiaolei/tornado/blob/master/tornado/database.py\u201d\uff0cwe can find the code:\ndef close(self):\n    \"\"\"Closes this database connection.\"\"\"\n\n    if getattr(self, \"_db\", None) is not None:\n\n        self._db.close()\n\n        self._db = None\nin my views, if getattr(self, \"_db\", None) is not None: can be replaced to if hasattr(self,\"_db\"):\ndef close(self):\n    \"\"\"Closes this database connection.\"\"\"\n\n    if hasattr(self, \"_db\"):\n\n        self._db.close()\n\n        self._db = None", "issue_status": "Closed", "issue_reporting_time": "2012-01-10T03:12:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1108": {"issue_url": "https://github.com/tornadoweb/tornado/issues/431", "issue_id": "#431", "issue_summary": "SSLIOStream handshaking issue", "issue_description": "nottombrown commented on 8 Jan 2012\nIt appears that do_handshake is not being called properly by SSLIOstream's read_until\nhttp://stackoverflow.com/questions/8767757/python-ssl-socket-server", "issue_status": "Closed", "issue_reporting_time": "2012-01-07T18:48:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1109": {"issue_url": "https://github.com/tornadoweb/tornado/issues/429", "issue_id": "#429", "issue_summary": "websocket messages are always binary", "issue_description": "Contributor\nminrk commented on 7 Jan 2012\nWebsocket messages used to be text, but are now always binary Blobs. This has broken the bundled chat demo, which assumes that event.data is json-parseable text, which it is no longer. Other apps (IPython Notebook) work the same way, and are broken with current tornado, as would, any application that expects text in a websocket message.\nI don't know enough about websockets to say whether the current or previous behavior is correct, but obviously either the example or the code needs some change to get the text out of the blob.", "issue_status": "Closed", "issue_reporting_time": "2012-01-06T20:42:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1110": {"issue_url": "https://github.com/tornadoweb/tornado/issues/427", "issue_id": "#427", "issue_summary": "@route decorator", "issue_description": "rustyrazorblade commented on 5 Jan 2012\nThe @route decorator in the tornado_addons project is incredibly useful. Can this get merged into the main repo?\nSee: https://github.com/nod/tornado_addons", "issue_status": "Closed", "issue_reporting_time": "2012-01-05T03:45:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1111": {"issue_url": "https://github.com/tornadoweb/tornado/issues/425", "issue_id": "#425", "issue_summary": "Serious performance related issue with `_merge_prefix`.", "issue_description": "grampelberg commented on 29 Dec 2011\nI'm getting a large payload via. AsyncHTTPClient and have been very surprised at how slow everything's going (only about 15mb). It takes about 2 minutes for my response callback to be called.\nWhipping out cProfile, it looks like almost all the time is being spent in _merge_prefix. Switching this back to cStringIO (commit 6ac2c58 for anyone interested), takes my execution time down to about 4 seconds (and there aren't any hotspots in cProfile).\nI'd be happy to submit a patch to fix this. Any suggestions on the right way to do it?", "issue_status": "Closed", "issue_reporting_time": "2011-12-28T20:48:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1112": {"issue_url": "https://github.com/tornadoweb/tornado/issues/424", "issue_id": "#424", "issue_summary": "Leave the user to decide witch HTTP redirect code to use", "issue_description": "ghost commented on 28 Dec 2011\nThe redirect function in RequestHandler class only support 301 and 302 redirect code. I think we should support other HTTP redirect code such as 303 and 307.\nI suggest changing the parameter of the redirect function, like add \"status\" parameter, and leave the user to dicide witch redirect code to use.\nTo permit backwards compatibility, I'd suggest this:\ndef redirect(self, url, permanent=False, status=None):\n    \"\"\"Sends a redirect to the given (optionally relative) URL.\"\"\"\n    if self._headers_written:\n        raise Exception(\"Cannot redirect after headers have been written\")\n    if not status:\n        self.set_status(301 if permanent else 302)\n    else:\n        self.set_status(status)\n    # Remove whitespace\n    url = re.sub(r\"[\\x00-\\x20]+\", \"\", utf8(url))\n    self.set_header(\"Location\", urlparse.urljoin(utf8(self.request.uri), url))\n    self.finish()", "issue_status": "Closed", "issue_reporting_time": "2011-12-28T11:38:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1113": {"issue_url": "https://github.com/tornadoweb/tornado/issues/423", "issue_id": "#423", "issue_summary": "WebSockets update needed (rfc 6455)", "issue_description": "clincher commented on 22 Dec 2011\nThere is update of Websokets Protocol from draft to RFC (6455).\nGoogle Chrome update his websockets implementation in new stable release and tornado websockets doesn't work with it.", "issue_status": "Closed", "issue_reporting_time": "2011-12-22T09:55:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1114": {"issue_url": "https://github.com/tornadoweb/tornado/issues/416", "issue_id": "#416", "issue_summary": "Control over automatic Content-Type and ETag generation", "issue_description": "Contributor\nmrjoes commented on 8 Dec 2011\nHi,\nRight now, Tornado will output two headers:\nContent-Type, which is set to text/html by default\nETag which will be calculated for the response by the Tornado.\nContent-Type is not required for all responses. For example, according to RFC, for 304:\nhttp://tools.ietf.org/html/rfc2616#section-10.3.5\n\"... the response MUST NOT include other entity-headers; this prevents\ninconsistencies between cached entity-bodies and updated headers.\"\nThis is, probably, not a big deal, but our application fails on some HTTP unittests.\nCan be worked around by handing ETag logic in a handler and then sending 304 response explicitly, while removing 'Content-Type' from self._headers collection.\nAny better way to do it?\nETag should be optional as well. For long polling, especially for GET requests, application will output all kind of headers that should prevent caching of the response on the client side. So, there's no need to spend CPU cycles calculating ETag. While I can suppress this by setting empty ETag header value (which will be sent out), that's probably not right solution.\nThanks,\nSerge.", "issue_status": "Closed", "issue_reporting_time": "2011-12-08T13:23:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1115": {"issue_url": "https://github.com/tornadoweb/tornado/issues/410", "issue_id": "#410", "issue_summary": "Add support for specific fire times in PeriodicCallback()", "issue_description": "swisspol commented on 4 Dec 2011\nIt would be quite useful to be able to not only say call this function every 24h, but instead say call it every day at midnight.", "issue_status": "Closed", "issue_reporting_time": "2011-12-04T11:28:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1116": {"issue_url": "https://github.com/tornadoweb/tornado/issues/408", "issue_id": "#408", "issue_summary": "[feature] scheduled functions \"cleaner\"", "issue_description": "giampaolo commented on 2 Dec 2011\nThis is part of an enhancement I did for pyftpdlib internal scheduler:\nhttp://code.google.com/p/pyftpdlib/issues/detail?id=189\n...and which I also proposed as a patch for sched stdlib module:\nhttp://bugs.python.org/issue13451\nThe problem I'm proposing to solve is the following:\nif your application is hugely dominated by schedules and cancels, this can be overwhelming for your memory.\nImagine to schedule 1.000.000 functions with a deadline of 1 week.\nThose will be kept in memory for 1 entire week and then discarded.\nThe patch below attempts to mitigate this problem by re-heapifying the internal queue if the number of scheduled functions more than the half of the entire queue.\nNote: not tested.\ndiff --git a/tornado/ioloop.py b/tornado/ioloop.py\nindex 6fd29a0..efd086d 100644\n--- a/tornado/ioloop.py\n+++ b/tornado/ioloop.py\n@@ -117,6 +117,7 @@ class IOLoop(object):\n         self._stopped = False\n         self._thread_ident = None\n         self._blocking_signal_threshold = None\n+        self._cancellations = 0\n\n         # Create a pipe that we send bogus data to when we want to wake\n         # the I/O loop when it is idle\n@@ -258,6 +259,7 @@ class IOLoop(object):\n                     if self._timeouts[0].callback is None:\n                         # the timeout was cancelled\n                         heapq.heappop(self._timeouts)\n+                        self._cancellations -= 1\n                     elif self._timeouts[0].deadline <= now:\n                         timeout = heapq.heappop(self._timeouts)\n                         self._run_callback(timeout.callback)\n@@ -265,6 +267,11 @@ class IOLoop(object):\n                         seconds = self._timeouts[0].deadline - now\n                         poll_timeout = min(seconds, poll_timeout)\n                         break\n+                if self._cancellations > 512 \\\n+                  and self._cancellations > (len(self._timeouts) >> 1):\n+                    self._cancellations = 0\n+                    self._timeouts = [x for x in self._timeouts if not x.cancel\n+                    heapq.heapify(self._timeouts)\n\n             if self._callbacks:\n                 # If any callbacks or timeouts called add_callback,\n@@ -369,6 +376,7 @@ class IOLoop(object):\n         # If this turns out to be a problem, we could add a garbage\n         # collection pass whenever there are too many dead timeouts.\n         timeout.callback = None\n+        self._cancellations += 1\n\n     def add_callback(self, callback):\n         \"\"\"Calls the given callback on the next I/O loop iteration.", "issue_status": "Closed", "issue_reporting_time": "2011-12-02T09:17:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1117": {"issue_url": "https://github.com/tornadoweb/tornado/issues/407", "issue_id": "#407", "issue_summary": "Ability to override encoding used in get_argument() maybe", "issue_description": "peterbe commented on 1 Dec 2011\nI have another site that uses the latin-1 charset. Aka. iso-8859-1. It's got a form that submits to my tornado app (on a complete different domain name). When someone types in unicode, click submit and goes to my tornado server my tornado server fails on self.get_argument('foo') because it's the wrong encoding.\nThis is what self.request.arguments looks like:\n {'foo': ['J\\xf6nk\\xf6ping']}\nSo trying to decode that fails with utf-8.\n>>> x\n'J\\xf6nk\\xf6ping'\n>>> unicode(x, 'utf-8')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nUnicodeDecodeError: 'utf8' codec can't decode byte 0xf6 in position 1: invalid start byte\n>>> unicode(x, 'latin-1')\nu'J\\xf6nk\\xf6ping'\nIf I could do this:\nfoo = self.get_argument('foo', encoding='latin1')\nor this:\ntry:\n    foo = self.get_argument('foo')\nexcept UnicodeDecodeError:\n    foo = self.get_argument('foo', encoding='latin1')\nWhat do you think? I could whip up a pull request to continue the discussion there if you like.", "issue_status": "Closed", "issue_reporting_time": "2011-12-01T00:27:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1118": {"issue_url": "https://github.com/tornadoweb/tornado/issues/405", "issue_id": "#405", "issue_summary": "Can't catch error in gen.Task", "issue_description": "perol commented on 29 Nov 2011\nfrom tornado import ioloop\nfrom tornado import gen\nio_loop = ioloop.IOLoop.instance()\n\ndef async_func(callback):\n    #callback(100)\n    10/0\n    io_loop.add_callback(lambda: callback(100))\n\n@gen.engine\ndef main():\n    try:\n        num = yield gen.Task(async_func)\n    except Exception as e:\n        print e\n    else:\n        print num\n    finally:\n        io_loop.stop()\n\nif __name__=='__main__':\n    main()\n    io_loop.start()\nI expect print error, but it exit because the error can't been caught when using gen.Task", "issue_status": "Closed", "issue_reporting_time": "2011-11-29T03:52:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1119": {"issue_url": "https://github.com/tornadoweb/tornado/issues/395", "issue_id": "#395", "issue_summary": "set_cookie domain", "issue_description": "mywwd commented on 2 Nov 2011\nSetting the cookie works perfectly until I try and set the domain. Here is what I'm doing:\nself.set_cookie('emailaddress', email_address, expires_days=expire_d, domain='mydomain.com')\nIf I remove the domain part or set it to None it works fine, but than I'm not able to use the cookie across subdomains.", "issue_status": "Closed", "issue_reporting_time": "2011-11-02T02:30:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1120": {"issue_url": "https://github.com/tornadoweb/tornado/issues/392", "issue_id": "#392", "issue_summary": "httpserver.py does not validate X-Forwarded-For is an IP address", "issue_description": "ghost commented on 28 Oct 2011\nHi, in httpserver.py we have:\nIf xheaders is True, we support the X-Real-Ip and X Scheme\nheaders, which override the remote IP and HTTP scheme for all requests.\nThese headers are useful when running Tornado behind a reverse proxy or\nload balancer.\n.. attribute:: headers\nHTTPHeader dictionary-like object for request headers. Acts like\na case-insensitive dictionary with additional methods for repeated\nheaders.\n    self.headers = headers or httputil.HTTPHeaders()\n\n    if connection and connection.xheaders:\n        # Squid uses X-Forwarded-For, others use X-Real-IP\n        self.remote_ip = self.headers.get(\n            \"X-Real-Ip\", self.headers.get(\"X-Forwarded-For\", remote_ip))\n        # AWS uses X-Forwarded-Proto\n        self.protocol = self.headers.get(\n            \"X-Scheme\", self.headers.get(\"X-Forwarded-Proto\", protocol))\n        if self.protocol not in (\"http\", \"https\"):\n            self.protocol = \"http\"\n    else:\n        self.remote_ip = remote_ip\n        if protocol:\n            self.protocol = protocol\n        elif connection and isinstance(connection.stream, \n                   iostream.SSLIOStream):\n            self.protocol = \"https\"\n        else:\n            self.protocol = \"http\"\nand httputil.HTTPHeaders is just a key value split up, no validation takes place there, so the X-Forwarded-For, which should be an IP, could be anything (JavaScript, text with a new line, etc.) which could potentially result in log file manipulation, XSS, etc.\nThis is similar to CVE-2011-3187 and CVE-2011-3624 (Rails and Ruby respectively)\nThanks, Kurt Seifried\nkseifried@redhat.com, Red Hat Security Response Team", "issue_status": "Closed", "issue_reporting_time": "2011-10-27T21:29:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1121": {"issue_url": "https://github.com/tornadoweb/tornado/issues/391", "issue_id": "#391", "issue_summary": "Empty POST requests", "issue_description": "Contributor\nei-grad commented on 28 Oct 2011\nHi.\nIn [1]: from tornado.httpclient import HTTPClient\n\nIn [2]: client = HTTPClient()\n\nIn [3]: client.fetch('https://mail.google.com/', method='POST')\nWARNING:root:uncaught exception\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 289, in cleanup\n    yield\n  File \"/usr/lib/python2.6/dist-packages/tornado/stack_context.py\", line 183, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 248, in _on_connect\n    assert self.request.body is not None\nAssertionError\n---------------------------------------------------------------------------\nAssertionError                            Traceback (most recent call last)\n/etc/wolke/<ipython-input-3-173e17e17348> in <module>()\n----> 1 client.fetch('https://mail.google.com/', method='POST')\n\n/usr/lib/python2.6/dist-packages/tornado/httpclient.pyc in fetch(self, request, **kwargs)\n     84         response = self._response\n     85         self._response = None\n---> 86         response.rethrow()\n     87         return response\n     88 \n\n/usr/lib/python2.6/dist-packages/tornado/httpclient.pyc in rethrow(self)\n    356         \"\"\"If there was an error on the request, raise an `HTTPError`.\"\"\"\n    357         if self.error:\n--> 358             raise self.error\n    359 \n    360     def __repr__(self):\n\nAssertionError: \n\nIn [4]: client.fetch('https://mail.google.com/', method='POST', body='asd')\nOut[4]: HTTPResponse(code=200,request_time=0.51736593246459961,buffer=<io.BytesIO object at 0x1db7590>,_body=None,time_info={},request=<tornado.httpclient.HTTPRequest object at 0x1db4a10>,effective_url='https://accounts.google.com/ServiceLogin?service=mail&passive=true&rm=false&continue=https://mail.google.com/mail/&ss=1&scc=1&ltmpl=default&ltmplcache=2',headers={'Expires': 'Mon, 01-Jan-1990 00:00:00 GMT', 'X-Content-Type-Options': 'nosniff', 'Transfer-Encoding': 'chunked', 'Set-Cookie': 'GAPS=1:EwGEAt7e8BZwiyVBaQcLA12vqRsmaQ:ndQYan2zjq2chYsy;Path=/;Expires=Sat, 26-Oct-2013 18:43:22 GMT;Secure;HttpOnly,GALX=m2x1X4J_8I4;Path=/;Secure', 'Strict-Transport-Security': 'max-age=2592000; includeSubDomains', 'X-Auto-Login': 'realm=com.google&args=service%3Dmail%26continue%3Dhttps%253A%252F%252Fmail.google.com%252Fmail%252F', 'Server': 'GSE', 'X-Xss-Protection': '1; mode=block', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache, no-store', 'Date': 'Thu, 27 Oct 2011 18:43:22 GMT', 'X-Frame-Options': 'Deny', 'Content-Type': 'text/html; charset=UTF-8'},error=None)\n\nIn [5]: client.fetch('https://mail.google.com/', method='POST', body='')\nWARNING:root:Write error on 6: [Errno 8] _ssl.c:1209: EOF occurred in violation of protocol\nWARNING:root:uncaught exception\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 289, in cleanup\n    yield\n  File \"/usr/lib/python2.6/dist-packages/tornado/stack_context.py\", line 183, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 271, in _on_connect\n    self.stream.read_until_regex(b(\"\\r?\\n\\r?\\n\"), self._on_headers)\n  File \"/usr/lib/python2.6/dist-packages/tornado/iostream.py\", line 146, in read_until_regex\n    self._check_closed()\n  File \"/usr/lib/python2.6/dist-packages/tornado/iostream.py\", line 504, in _check_closed\n    raise IOError(\"Stream is closed\")\nIOError: Stream is closed\n---------------------------------------------------------------------------\nIOError                                   Traceback (most recent call last)\n/etc/wolke/<ipython-input-5-27e1d9dc9a1a> in <module>()\n----> 1 client.fetch('https://mail.google.com/', method='POST', body='')\n\n/usr/lib/python2.6/dist-packages/tornado/httpclient.pyc in fetch(self, request, **kwargs)\n     84         response = self._response\n     85         self._response = None\n---> 86         response.rethrow()\n     87         return response\n     88 \n\n/usr/lib/python2.6/dist-packages/tornado/httpclient.pyc in rethrow(self)\n    356         \"\"\"If there was an error on the request, raise an `HTTPError`.\"\"\"\n    357         if self.error:\n--> 358             raise self.error\n    359 \n    360     def __repr__(self):\n\nIOError: Stream is closed\nWhy there is no ability to send POST/PUT request with body=None? Is there any notes in RFC about requests with empty body? And it looks like there is a bug in iostream.py when httpclient sending empty POST requests over SSL...", "issue_status": "Closed", "issue_reporting_time": "2011-10-27T18:51:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1122": {"issue_url": "https://github.com/tornadoweb/tornado/issues/386", "issue_id": "#386", "issue_summary": "http clients don't work with HEAD, PUT and DELETE requests - run into timeout", "issue_description": "wmark commented on 21 Oct 2011\nTornado's http clients utilizing _HTTPConnection do not behave correctly with HEAD, PUT and DELETE requests:\nDespite responses to these methods not having a body, _HTTPConnection is waiting for one after having processed the headers. [1]_\nAlthough the client has sent a HTTP 1.1 request neither did he close the connection nor has it used it for requesting more. Two things happen independently and most times not in that order: On server-side, the server closes the connection; on client-side, we run into a timeout (throwing an IOException).\nThe actual and correct response (consisting of headers only) is not used, but a dummy-response with code 599 yielded. [2]_\nFixed by (replace \"anzu\" by \"tornado\"):\nwmark@2464ac9\n.. [1] https://github.com/facebook/tornado/blob/master/tornado/simple_httpclient.py#L333\n.. [2] https://github.com/facebook/tornado/blob/master/tornado/simple_httpclient.py#L292", "issue_status": "Closed", "issue_reporting_time": "2011-10-21T00:31:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1123": {"issue_url": "https://github.com/tornadoweb/tornado/issues/385", "issue_id": "#385", "issue_summary": "updated Websocket in Chrome/Chromium", "issue_description": "Contributor\nminrk commented on 19 Oct 2011\nI run Chrome dev channel, which has updated its websocket version, breaking compatibility with tornado websockets.\nref: http://updates.html5rocks.com/2011/10/WebSockets-updated-to-latest-version-in-Chrome-Canary\nWhich suggests Sec-WebSocket-Version is now 13, but Wikipedia suggests Chromium is using something called hybi 17, which may or may not be the same.\nI imagine you guys are more familiar with what these things actually mean than I am.", "issue_status": "Closed", "issue_reporting_time": "2011-10-19T05:08:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1124": {"issue_url": "https://github.com/tornadoweb/tornado/issues/384", "issue_id": "#384", "issue_summary": "Twisted Reactor breaks twisted.web.xmlrpc", "issue_description": "Contributor\nstiletto commented on 18 Oct 2011\ntornado.platform.twisted.TornadoReactor breaks twisted.web.xmlrpc because it doesn't call connectionLost().\nFollowing code works fine if you remove \"tornado.platform.twisted.install()\":\n# -*- coding: utf-8 -*-\nfrom __future__ import print_function\n\nimport tornado.platform.twisted\ntornado.platform.twisted.install()\n\nfrom twisted.internet import defer,reactor\n\nfrom twisted.web.xmlrpc import Proxy\n\nservice = Proxy('http://www.cookcomputing.com/xmlrpcsamples/RPC2.ashx')\nresult = service.callRemote('examples.getStateName', 13)\nresult.addCallback(lambda x: (print(x),reactor.stop()))\nreactor.run()", "issue_status": "Closed", "issue_reporting_time": "2011-10-18T15:23:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1125": {"issue_url": "https://github.com/tornadoweb/tornado/issues/380", "issue_id": "#380", "issue_summary": "Resiliency to slightly non-RFC compliant HTTP requests", "issue_description": "mitchellh commented on 8 Oct 2011\nI recently ran into a bug with the Python standard library where a standard library was sending RFC non-compliant HTTP requests: http://bugs.python.org/issue13132\nDespite being RFC non-compliant, the requests actually work in the following web servers:\nApache2\nNginx\nTwisted\nI was attempting to write a lightweight cheese shop server using Tornado but this is currently blocking me since the request can't be parsed.\nDespite not being compliant with the RFC, I think that web servers should do their best to serve any requests, just as web browsers do their best to serve malformed responses and markup. I propose that Tornado should handle the following separator cases for headers:\n\\r\\n\n\\n\\n\n\\n\nMitchell", "issue_status": "Closed", "issue_reporting_time": "2011-10-08T15:11:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1126": {"issue_url": "https://github.com/tornadoweb/tornado/issues/377", "issue_id": "#377", "issue_summary": "TwitterMixin dosen't allow to define a oauth_callback", "issue_description": "Contributor\ngutomaia commented on 8 Oct 2011\nFor a testing purpose on the developers machine, it would be nice to allow the TwitterMixin to define the oauth_callback.\nIt's pretty simple, since the work is almost done, just need to pass the callback_uri thru the authorize_redirect method\nI will send a pull request soon.\nThat change on the TwitterMixin would allow the example on site to set a specific callback for the oauth, for example, to use localhost as a callback_uri\n    class TwitterHandler(tornado.web.RequestHandler, tornado.auth.TwitterMixin):\n        @tornado.web.asynchronous\n        def get(self):\n            if self.get_argument(\"oauth_token\", None):\n                self.get_authenticated_user(self.async_callback(self._on_auth))\n                return\n            #now I can redirect the callback to the localclient\n            self.authenticate_redirect(callback_uri=\"http://localhost:8888/login\")\n\n        def _on_auth(self, user):\n            if not user:\n                raise tornado.web.HTTPError(500, \"Twitter auth failed\")\n            # Save the user using, e.g., set_secure_cookie()\nupdated: The mehod name on the example shold be authenticate_redirect insted it was authorize_redirect, thanks @bdarnell", "issue_status": "Closed", "issue_reporting_time": "2011-10-07T19:20:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1127": {"issue_url": "https://github.com/tornadoweb/tornado/issues/376", "issue_id": "#376", "issue_summary": "authdemo.py, logout not working.", "issue_description": "chrisallick commented on 6 Oct 2011\nwhen I click the logout link in the authdemo version I continue to stay logged in. If I go to gmail.com and logout through google and go back to the demo i am logged out and required to authenticate. Then, again, am not able to use the logout link to log out.", "issue_status": "Closed", "issue_reporting_time": "2011-10-06T15:32:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1128": {"issue_url": "https://github.com/tornadoweb/tornado/issues/375", "issue_id": "#375", "issue_summary": "Allow for seperate autoreload arg", "issue_description": "chaselee commented on 6 Oct 2011\nNow that debug in 2.1+ shows stacktraces, it's not ideal to use debug in production. This is actually great behavior; however, since the operation of autoreload is tied to the debug arg, autoreload must now be turned off in production. Autoreload is very useful for production servers since it provides seamless updates whereas a lot of tools like Supervisor require a second of downtime to recognize updates. I think it would make sense to allow the separation of autoreload and debug functionality such that supplying debug to the application constructor still starts autoreload and that supplying autoreload to the constructor starts or stops it. This way, for production I can have debug off, so no stacktraces, and autoreload on, and in development, I can just throw debug on (and possibly shut autoreload off if we want to go that route). Thoughts? It seems as simple as adding this to tornado.web just to give the ability to turn on autoreload independent of debug:\nif self.settings.get(\"autoreload\") and not wsgi:\nimport autoreload\nautoreload.start()\nIf we want to go this route I can start a pull request.", "issue_status": "Closed", "issue_reporting_time": "2011-10-06T06:19:17Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1129": {"issue_url": "https://github.com/tornadoweb/tornado/issues/371", "issue_id": "#371", "issue_summary": "iostream: assert isinstance(num_bytes, int)", "issue_description": "Contributor\nWGH- commented on 3 Oct 2011\nWhat about long type? I don't see any reason to not support it.", "issue_status": "Closed", "issue_reporting_time": "2011-10-03T16:39:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1130": {"issue_url": "https://github.com/tornadoweb/tornado/issues/370", "issue_id": "#370", "issue_summary": "Template eats up consecutive blanks in javascript section", "issue_description": "rushmore commented on 1 Oct 2011\nconsecutive blanks not working correctly as follow:\nvar txt = \"123456789 \"; // leaving 2 blanks at the lend\ndocument.write(txt.length); //prints out 10, not 11 if passed from tornado server, but 11 if access from browser directly as expected", "issue_status": "Closed", "issue_reporting_time": "2011-10-01T08:12:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1131": {"issue_url": "https://github.com/tornadoweb/tornado/issues/366", "issue_id": "#366", "issue_summary": "Duplicate callbacks from ioLoop.PeriodicCallback", "issue_description": "DavidEwing commented on 23 Sep 2011\nWas occasionally seeing multiple callback invocations in a single PeriodicCallback interval.\nThe problem is with the _schedule_next() function. On a fast machine, the current_time can be equal to the _next_timeout!\nThe fix in PeriodicCallback._schedule_next() is to change:\n     while self._next_timeout < current_time:\nto:\n     while self._next_timeout <= current_time:", "issue_status": "Closed", "issue_reporting_time": "2011-09-23T15:00:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1132": {"issue_url": "https://github.com/tornadoweb/tornado/issues/365", "issue_id": "#365", "issue_summary": "Simple HTTP client swallows errors in callback", "issue_description": "williame commented on 23 Sep 2011\nThis affects the Simple HTTPAsyncClient; the curl client does not seem to suffer:\nIf an IO error (e.g. dns lookup failed) occurred in a fetch, then any exception thrown in the callback reaches the ioloop's handle_callback_exception.\nIf an HTTP resposne is received (200 or error e.g. 404 or whatever; anything as long as the io succeeded) then any errors thrown in the callback (e.g. response.rethrow(), or even assert or other exception) will just be printed to the log as 'uncaught'. The ioloop's handle_callback_exception is not invoked.\nIf you schedule a callback to be called - ioloop.add_callback - from the fetch callback, and at a later point that callback, on its own slice of the looper, throws an exception, then that too is not caught by ioloop's handle_callback_exception.", "issue_status": "Closed", "issue_reporting_time": "2011-09-23T07:47:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1133": {"issue_url": "https://github.com/tornadoweb/tornado/issues/361", "issue_id": "#361", "issue_summary": "get_secure_cookie and order of include_name= and value=", "issue_description": "OleLaursen commented on 14 Sep 2011\nHi!\nI just came across some code that used get_secure_cookie(\"foo\", None). Now that include_name has appeared as a third parameter:\ndef get_secure_cookie(self, name, include_name=True, value=None)\nthe meaning of this has changed from passing None as value to passing None to include_name, rendering it false and thus causing all new set_secure_cookies to not be accepted. Maybe it would be a good idea to exchange the order?\nI don't quite understand the purpose of include_name anyway, it seems to me if you pass include_name=False, old cookies may still work but all new cookies will then fail. That seems a bit useless. Maybe I'm not reading the code properly.", "issue_status": "Closed", "issue_reporting_time": "2011-09-14T11:18:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1134": {"issue_url": "https://github.com/tornadoweb/tornado/issues/360", "issue_id": "#360", "issue_summary": "HTTP 599 when fetching Yahoo! Weather RSS.", "issue_description": "tomekwojcik commented on 13 Sep 2011\nHi guys,\nI've encountered a small problem - default AsyncHTTPClient subclass fails to fetch Yahoo! Weather RSS feed. It raises HTTPError 599 exception.\nWorks fine with CurlAsyncHTTPClient.\nGreetings from Poland :).", "issue_status": "Closed", "issue_reporting_time": "2011-09-13T09:22:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1135": {"issue_url": "https://github.com/tornadoweb/tornado/issues/355", "issue_id": "#355", "issue_summary": "Template engine does not have syntax reference", "issue_description": "elhigu commented on 10 Sep 2011\nCurrently half of template engine properties are not documented at all.\nOnly documentation I found was\nhttp://stackoverflow.com/questions/4238831/are-there-good-docs-about-tornado-template\nhttp://joshink.com/posts/9/\nhttp://aspen.io/templating/\nComplete reference should be added to:\nhttp://www.tornadoweb.org/documentation/template.html", "issue_status": "Closed", "issue_reporting_time": "2011-09-09T19:09:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1136": {"issue_url": "https://github.com/tornadoweb/tornado/issues/352", "issue_id": "#352", "issue_summary": "Memory leak on timeout", "issue_description": "Contributor\noyerli commented on 8 Sep 2011\nHi,\nI have a long polling server written in tornado behind an nginx server. My nginx configuration is as follows:\nproxy_pass http://127.0.0.1:8000;\nproxy_buffering off;\nproxy_read_timeout 60s;\nSince I set a proxy_read_timeout it timeouts in 60 seconds if no new messages come from long polling. Then the client initiates a new connection.\nHowever, I noticed that in this configuration tornado memory usage increases by time. I confirmed that by deliberately setting proxy_read_timeout 1s.\nIs there a problem with tornado's handling of stale connections?", "issue_status": "Closed", "issue_reporting_time": "2011-09-07T19:49:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1137": {"issue_url": "https://github.com/tornadoweb/tornado/issues/351", "issue_id": "#351", "issue_summary": "tornado.gen does not work with callbacks that have kwargs", "issue_description": "rgarcia commented on 7 Sep 2011\nI'm playing around with tornado.gen, and it seems to croak on callbacks that are triggered with keyword arguments. Specifically, asyncmongo sends an \"error\" keyword argument to the callback you specify. The tornado.gen.Task class's callback() method isn't set up to handle this. Here is the relevant code:\nclass BaseHandler(tornado.web.RequestHandler):\n    @property\n    def db(self):\n        if not hasattr(self, '_db'):\n            self._db = asyncmongo.Client(pool_id='request_handlers',\n                                             host=options.mongo_host,\n                                             port=options.mongo_port,\n                                             dbname=options.mongo_db)\n        return self._db\n\nclass UserHandler(BaseHandler):\n    @tornado.web.asynchronous\n    @tornado.gen.engine\n    def get(self,user_id):\n        response = yield tornado.gen.Task(self.db.users.find,{'_id':user_id},limit=1)\n        if len(response) != 1:\n            self.set_status(400)\n            self.write({'error': 'no user with this id'})\n            return\n        self.write(dict((k,response[0][k]) for \\\n                            k in [ 'first_name', 'last_name', 'email' ]))\nthe error: \"TypeError: callback() got an unexpected keyword argument 'error'\"\nI'm hacking around trying to figure out a fix to this, but I still haven't wrapped my head around the gen.py code. I tried just adding a **kwargs argument to the callback() function, but that didn't work (the Runner loop timed out). this is similar to the hack I used to make this code work with swirl.", "issue_status": "Closed", "issue_reporting_time": "2011-09-06T21:43:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1138": {"issue_url": "https://github.com/tornadoweb/tornado/issues/348", "issue_id": "#348", "issue_summary": "SimpleHTTPClient doesn't clear connect timeout correctly", "issue_description": "Contributor\njeffhodsdon commented on 31 Aug 2011\nOn https://github.com/facebook/tornado/blob/master/tornado/simple_httpclient.py#L215\nIt attempts to remove a callback... but should remove a timeout.\nhttps://github.com/facebook/tornado/blob/master/tornado/simple_httpclient.py#L199\nThe time out is assigned to self._connect_timeout... which doesn't get cleared. It should assign to self._timeout.", "issue_status": "Closed", "issue_reporting_time": "2011-08-31T01:16:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1139": {"issue_url": "https://github.com/tornadoweb/tornado/issues/345", "issue_id": "#345", "issue_summary": "559 Error Code Facebook auth error: HTTPResponse(code=599,", "issue_description": "Itsmediego commented on 28 Aug 2011\nUsing FacebookGraphLoginHandler on Tornado V2, and i\ngetting this error when i try to authorize the application, copying\nthe url and paste it on browser, i get the access token as well.\nI am runing on :\nLinux cm 2.6.18-238.5.1.el5.028stab085.5 #1 SMP Thu Apr 14 15:42:34\nMSD 2011 i686 GNU/Linu\nnginx 1.0.5\nOpenSSL 0.9.8g 19 Oct 2007\ncurl 7.18.2 (i486-pc-linux-gnu) libcurl/7.18.2 OpenSSL/0.9.8g zlib/\n1.2.3.3 libidn/1.8 libssh2/0.18\nProtocols: tftp ftp telnet dict ldap ldaps http file https\nftps scp sftp u", "issue_status": "Closed", "issue_reporting_time": "2011-08-28T14:19:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1140": {"issue_url": "https://github.com/tornadoweb/tornado/issues/333", "issue_id": "#333", "issue_summary": "database: should return rowcount on execute", "issue_description": "Member\nbdarnell commented on 15 Aug 2011\nexecute() returns lastrowid, which is useful for inserts but not for updates or deletes. We need a method that returns the rowcount instead.", "issue_status": "Closed", "issue_reporting_time": "2011-08-14T21:43:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1141": {"issue_url": "https://github.com/tornadoweb/tornado/issues/331", "issue_id": "#331", "issue_summary": "autoreload Does Not Provide Any Mechanism for Resource Cleanup", "issue_description": "Contributor\nmankyd commented on 13 Aug 2011\nThe autoreload module does not seem to provide any mechanism for shutting down applications in a clean manner before it starts up again. In code, you can see that it attempts to clean up file handles registered with ioloop, and then jumps straight into restarting itself:\n        for fd in io_loop._handlers.keys():\n            try:\n                os.close(fd)\n            except Exception:\n                pass\n        if hasattr(signal, \"setitimer\"):\n            # Clear the alarm signal set by\n            # ioloop.set_blocking_log_threshold so it doesn't fire\n            # after the exec.\n            signal.setitimer(signal.ITIMER_REAL, 0, 0)\n        try:\n            os.execv(sys.executable, [sys.executable] + sys.argv)\nThis is causing issues because connections to other resources (I have some global ZeroMQ sockets open in my application) are not freed up properly and restarting fails. Even calling IOLoop.stop() would help as then I could subclass it and provide the hooks that I need.", "issue_status": "Closed", "issue_reporting_time": "2011-08-13T00:28:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1142": {"issue_url": "https://github.com/tornadoweb/tornado/issues/330", "issue_id": "#330", "issue_summary": "Opcode shouldn't be overridden on continuation frame", "issue_description": "Lawouach commented on 8 Aug 2011\nThe opcode is overridden on each continuation frame the server receives which means that on the final frame, it's not set to the proper opcode (text or binar) but instead set to continuation.\nCan be easily fixed by using:\nif self._fragmented_message_opcode is None:\n      self._fragmented_message_opcode = self._frame_opcode", "issue_status": "Closed", "issue_reporting_time": "2011-08-08T17:58:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1143": {"issue_url": "https://github.com/tornadoweb/tornado/issues/325", "issue_id": "#325", "issue_summary": "Quetion about post fields", "issue_description": "Contributor\nwsantos commented on 3 Aug 2011\nWhy fields are in list in a post ?\n(Pdb++) self.request.arguments\n{'name': ['Cadaf'], 'email': ['Cadaf@cadaf.com']}\nany reason for this ? thnx.", "issue_status": "Closed", "issue_reporting_time": "2011-08-03T00:03:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1144": {"issue_url": "https://github.com/tornadoweb/tornado/issues/321", "issue_id": "#321", "issue_summary": "CurlAsyncHTTPClient timeout", "issue_description": "cheesedoily commented on 29 Jul 2011\nWe are experiencing a problem using a short timeout (75ms timeout) with CurlAsyncHTTPClient. SimpleAsyncHTTPClient does obey the timeout but whenever we use CurlAsyncHTTPClient our responses go up to 300ms.\nWe're using the latest version of libcurl.\nhttpclient.AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\nhttp = httpclient.AsyncHTTPClient(max_clients=1000)\n\nhttp.fetch(httpclient.HTTPRequest(url, method='POST', body={\"post\":\"body\"}, headers={'Content-Type': 'application/json', },\n                       request_timeout=.07), callback=cb))", "issue_status": "Closed", "issue_reporting_time": "2011-07-29T18:17:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1145": {"issue_url": "https://github.com/tornadoweb/tornado/issues/319", "issue_id": "#319", "issue_summary": "autoreload doesn't work on windows", "issue_description": "Member\nbdarnell commented on 28 Jul 2011\nos.execv on windows is broken on windows when arguments contain spaces, and now it can't be fixed for fear of breaking workarounds people have built on top of it: http://bugs.python.org/issue436259\nIt looks like subprocess does the right thing here, so autoreload should probably just use subprocess (and then exit from the parent process) on platforms that don't have a working unix-style os.execv.", "issue_status": "Closed", "issue_reporting_time": "2011-07-28T17:43:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1146": {"issue_url": "https://github.com/tornadoweb/tornado/issues/317", "issue_id": "#317", "issue_summary": "Add template keyword block for outputting code without changes", "issue_description": "benweatherman commented on 28 Jul 2011\nUsing javascript templates is tricky because it often requires you to use similar syntax to Tornado templates. While you can use the {{! and {{% syntax, this is often pretty cumbersome for large chunks of javascript templates. I propose we have a verbatim/raw/cdata keyword that would output my template code unchanged.\nFor more information, see this thread: http://groups.google.com/group/python-tornado/browse_thread/thread/8d0383a76324e0a6/741315ab35621caa?lnk=gst&q=templates#", "issue_status": "Closed", "issue_reporting_time": "2011-07-27T20:26:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1147": {"issue_url": "https://github.com/tornadoweb/tornado/issues/315", "issue_id": "#315", "issue_summary": "KeyError exception in SimpleAsyncHTTPClient._on_fetch_complete()", "issue_description": "ghost commented on 27 Jul 2011\nWe're seeing this exception occur at some relatively rare frequency. No idea how to reproduce it, but the stack trace seems to indicate it's happening at some point during a connection timeout.\nUncaught exception KeyError(<object object at 0xd62a10>,):\n Traceback (most recent call last):\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/ioloop.py\", line 370, in _run_callback\n     callback()\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 159, in wrapped\n     callback(*args, **kwargs)\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/iostream.py\", line 235, in wrapper\n     callback(*args)\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 183, in wrapped\n     callback(*args, **kwargs)\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/stack_context.py\", line 96, in __exit__\n     return self.context.__exit__(type, value, traceback)\n   File \"/usr/lib/python2.7/contextlib.py\", line 35, in __exit__\n     self.gen.throw(type, value, traceback)\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/simple_httpclient.py\", line 265, in cleanup\n     callback(HTTPResponse(self.request, 599, error=e))\n   File \"/usr/local/lib/python2.7/dist-packages/tornado/simple_httpclient.py\", line 113, in _on_fetch_complete\n     del self.active[key]\n KeyError: <object object at 0xd62a10>\nIt appears _on_fetch_complete() is being called twice for the same key.", "issue_status": "Closed", "issue_reporting_time": "2011-07-27T18:00:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1148": {"issue_url": "https://github.com/tornadoweb/tornado/issues/314", "issue_id": "#314", "issue_summary": "Tornado 2.0 template benchmark", "issue_description": "allisson commented on 27 Jul 2011\nHello, I believe there is a performance issue with template render in version 2.0 as i see in this benchmark: https://github.com/mitsuhiko/jinja2/blob/master/examples/bench.py\nResults for tornado 1.2.1\n                   Template Engine BigTable Benchmark                       \nThis benchmark compares some python templating engines with Jinja 2 so\nthat we get a picture of how fast Jinja 2 is for a semi real world\ntemplate.  If a template engine is not installed the test is skipped.\njinja               0.0113 seconds\nmako                0.0120 seconds\ntornado             0.0091 seconds\ntenjin              *not installed*\nspitfire            *not installed*\ndjango              0.4031 seconds\ngenshi              *not installed*\ncheetah             *not installed*\nchameleon           *not installed*\nchameleon_genshi    *not installed*\nWARNING: The results of this benchmark are useless to compare the\nperformance of template engines and should not be taken seriously in any\nway.  It's testing the performance of simple loops and has no real-world\nusefulnes.  It only used to check if changes on the Jinja code affect\nperformance in a good or bad way and how it roughly compares to others.\nResults for tornado 2.0\n                   Template Engine BigTable Benchmark                       \nThis benchmark compares some python templating engines with Jinja 2 so\nthat we get a picture of how fast Jinja 2 is for a semi real world\ntemplate.  If a template engine is not installed the test is skipped.\njinja               0.0113 seconds\nmako                0.0120 seconds\ntornado             0.0617 seconds\ntenjin              *not installed*\nspitfire            *not installed*\ndjango              0.3937 seconds\ngenshi              *not installed*\ncheetah             *not installed*\nchameleon           *not installed*\nchameleon_genshi    *not installed*\nWARNING: The results of this benchmark are useless to compare the\nperformance of template engines and should not be taken seriously in any\nway.  It's testing the performance of simple loops and has no real-world\nusefulnes.  It only used to check if changes on the Jinja code affect\nperformance in a good or bad way and how it roughly compares to others.\nIt's a big diference between 1.2.1 and 2.0 (~ 6.8x)", "issue_status": "Closed", "issue_reporting_time": "2011-07-27T14:30:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1149": {"issue_url": "https://github.com/tornadoweb/tornado/issues/311", "issue_id": "#311", "issue_summary": "GET param without value not in request.arguments", "issue_description": "tax commented on 22 Jul 2011\nSo when a request like: http://example.com/?showsource is made showsource will not show in self.request.arguments\nMaybe this is by design I am not sure a simple workaround to get empty params:\nfrom tornado.escape import parse_qs_bytes\n\nclass MyHandler(web.RequestHandler):\n    def get(self):\n        action = parse_qs_bytes(self.request.query, True)\nOr a change in tornado.httpserver:\n502c502\n<         arguments = parse_qs_bytes(query)\n\n---\n>         arguments = parse_qs_bytes(query, True)\n506c506\n<             if values: self.arguments[name] = values\n\n---\n>             self.arguments[name] = values", "issue_status": "Closed", "issue_reporting_time": "2011-07-22T16:54:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1150": {"issue_url": "https://github.com/tornadoweb/tornado/issues/308", "issue_id": "#308", "issue_summary": "Support Compression Extensions for WebSocket protocol", "issue_description": "ghost commented on 20 Jul 2011\nPlease support Gzip compression in the WebSockets implementation in Tornado. This is supported by\nthe spec, and will improve performance greatly.", "issue_status": "Closed", "issue_reporting_time": "2011-07-19T20:21:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1151": {"issue_url": "https://github.com/tornadoweb/tornado/issues/306", "issue_id": "#306", "issue_summary": "exception in httpclient on certain valid, HTTP-200 server responses for unknown reason", "issue_description": "mlogan commented on 18 Jul 2011\nIf you run the following code:\n#!/usr/bin/python2.6\nfrom tornado import httpclient, ioloop\nurl = 'http://api.imgur.com/2/image/WMn80.json'\n\ndef callback(response):\n    print response.body\n\nhttp = httpclient.AsyncHTTPClient()\nhttp.fetch(url, callback=callback, validate_cert=False, request_timeout=10.0)\nioloop.IOLoop.instance().start()\nYou get the following exception:\nNone\nWARNING:root:uncaught exception\nTraceback (most recent call last):\n  File \"/usr/lib/python2.6/site-packages/tornado/simple_httpclient.py\", line 259, in cleanup\n    yield\n  File \"/usr/lib/python2.6/site-packages/tornado/stack_context.py\", line 183, in wrapped\n    callback(*args, **kwargs)\n  File \"/usr/lib/python2.6/site-packages/tornado/simple_httpclient.py\", line 341, in _on_chunk_length\n    self._on_body(b('').join(self.chunks))\n  File \"/usr/lib/python2.6/site-packages/tornado/simple_httpclient.py\", line 331, in _on_body\n    self.callback(response)\nTypeError: 'NoneType' object is not callable\nHowever, there doesn't appear to be anything wrong with the imgur webserver. The request I paste into nc is the exact request that the tornado httpclient generates.\n; nc api.imgur.com 80\nGET /2/image/WMn80.json HTTP/1.1\nHost: api.imgur.com\nAccept-Encoding: gzip\n\nHTTP/1.1 200 Ok\nServer: nginx\nDate: Mon, 18 Jul 2011 17:38:47 GMT\nContent-Type: application/json\nTransfer-Encoding: chunked\nConnection: close\nSet-Cookie: IMGURSESSION=1suc7a16qoc7k061nai8echn50; path=/; domain=.imgur.com\nAccess-Control-Allow-Origin: *\nPragma: public\nCache-control: private\nExpires: -1\nX-RateLimit-Limit: 500\nX-RateLimit-Remaining: 488\nX-RateLimit-Reset: 1311013013\nSet-Cookie: SERVERID=www1; path=/\n\n1a0\n{\"image\":{\"image\":{\"title\":null,\"caption\":null,\"hash\":\"WMn80\",\"datetime\":\"2011-07-17 05:09:49\",\"type\":\"image\\/jpeg\",\"animated\":\"false\",\"width\":1598,\"height\":1201,\"size\":119551,\"views\":372682,\"bandwidth\":44554505782},\"links\":{\"original\":\"http:\\/\\/i.imgur.com\\/WMn80.jpg\",\"imgur_page\":\"http:\\/\\/imgur.com\\/WMn80\",\"small_square\":\"http:\\/\\/i.imgur.com\\/WMn80s.jpg\",\"large_thumbnail\":\"http:\\/\\/i.imgur.com\\/WMn80l.jpg\"}}}\n0\nI have verified that the fetch code I provided above works with URLs on other servers - it even works with other imgur URLs, such as http://imgur.com/WMn80. imgur appears to return a very similar response to that URL - same Transfer-Encoding, same Server, same Connection headers, so I have no clue what could be going wrong in the former case.\nThanks,\nMark", "issue_status": "Closed", "issue_reporting_time": "2011-07-18T18:00:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1152": {"issue_url": "https://github.com/tornadoweb/tornado/issues/305", "issue_id": "#305", "issue_summary": "UnicodeDecodeError exception with bad url", "issue_description": "yablochkin commented on 15 Jul 2011\nHave problem with bad url arguments. Got uncaught exeption on http://127.0.0.1:8888/%d8cdaa%7Cblack with this simple app:\nimport tornado.ioloop\nimport tornado.web\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self, value):\n        self.write(value)\n\napplication = tornado.web.Application([\n    (r\"/(.*)\", MainHandler),\n])\n\nif __name__ == \"__main__\":\n    application.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\nException:\nERROR:root:Uncaught exception GET /%d8cdaa%7Cblack (127.0.0.1)\nHTTPRequest(protocol='http', host='127.0.0.1:8888', method='GET', uri='/%d8cdaa%7Cblack', version='HTTP/1.1', remote_ip='127.0.0.1', body='', headers={'Accept-Language': 'ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4', 'Accept-Encoding': 'gzip,deflate,sdch', 'Host': '127.0.0.1:8888', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'User-Agent': 'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.124 Safari/534.30', 'Accept-Charset': 'windows-1251,utf-8;q=0.7,*;q=0.3', 'Connection': 'keep-alive', 'Cookie': 'sessionid=14ef6569e7fffe0bdb032e88372b37a9; csrftoken=8150301284c77c2cfda482944148aa27; clicked=\"\\\\054127\"; last_widget=7; last_widget_clicks=0', 'Cache-Control': 'max-age=0'})\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.0-py2.7.egg/tornado/web.py\", line 924, in _execute\n    args = [self.decode_argument(arg) for arg in args]\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.0-py2.7.egg/tornado/web.py\", line 278, in decode_argument\n    return _unicode(value)\n  File \"/usr/local/lib/python2.7/dist-packages/tornado-2.0-py2.7.egg/tornado/escape.py\", line 172, in to_unicode\n    return value.decode(\"utf-8\")\n  File \"/usr/lib/python2.7/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf8' codec can't decode byte 0xd8 in position 0: invalid continuation byte\nERROR:root:500 GET /%d8cdaa%7Cblack (127.0.0.1) 1.41ms\nMaybe you may use something like arg.decode(arg, 'ignore') when escaping arguments?\nPython 2.7.1\nTornado 2.0.0", "issue_status": "Closed", "issue_reporting_time": "2011-07-15T07:07:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1153": {"issue_url": "https://github.com/tornadoweb/tornado/issues/304", "issue_id": "#304", "issue_summary": "IOstream object has no attribute 'connect' ?", "issue_description": "landongn commented on 13 Jul 2011\nI'm working on an async (using IOStream) based mysql client for python. I'm running into a strange error when i try to connect to the mysql server via a standard socket.socket() connection.\nFile \"/home/spot/asyncmysql/pysymy/pysymy/init.py\", line 93, in Connect\nreturn Connection(_args, *_kwargs)\nFile \"/home/spot/asyncmysql/pysymy/pysymy/connections.py\", line 513, in init\nself._connect()\nFile \"/home/spot/asyncmysql/pysymy/pysymy/connections.py\", line 676, in _connect\nraise OperationalError(2003, \"Can't connect to MySQL server on %r (%s)\" % (dumb_socket, e.args[0]))\npysymy.err.OperationalError: (2003, \"Can't connect to MySQL server on <socket._socketobject object at 0x7f981211e670> ('IOStream' object has no attribute 'connect')\")\nThe first instance listing there on that last line is the socket instance. The other is the exception i'm getting when i try to execute the connect with the iostream. here's the relevant code:\n            dumb_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n            t = dumb_socket.gettimeout()\n            dumb_socket.settimeout(self.connect_timeout)\n\n\n            self.dumb_socket = dumb_socket\n            self.async_socket = iostream.IOStream(self.dumb_socket)\n            self.async_socket.connect((self.host, self.port), self.wait_for_packet)\n            self.mainLoop = ioloop.IOLoop.instance().start()\n            self.host_info = \"socket %s:%d\" % (self.host, self.port)\nI'm flummoxed. Any suggestions?", "issue_status": "Closed", "issue_reporting_time": "2011-07-13T02:39:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1154": {"issue_url": "https://github.com/tornadoweb/tornado/issues/301", "issue_id": "#301", "issue_summary": "Support for streamed HTTP", "issue_description": "trott13 commented on 12 Jul 2011\nWhile working with Server Sent Events using Tornado, I discovered, that (at least) the WSGIContainer in wsgi.py\nwill set a Content-Length header field in any case.\nHowever, this is not permitted, if a chunked or streamed HTTP result should be delivered. The Browser will interpret\nthe set Content-Length as \"this is no stream\" and close the socket (which in turn kill the EventSource there and forces\nit to re-connect).\nI changed the setting of Content-Length therefore into:\n    # TRott, 12.7.2011: SSE and Webkit problem:\n    # the response should only have a set Content-Length header field,\n    # if it is not a HTTP-stream. In these cases HTTP is made of chunks\n    # separated by double newlines (like our SSEvents...).\n    # Therefore, if Content-Length is set, we are assumed\n    # _not_ to stream...\n    # We check the content-type for annoncing a stream here and switch of\n    # the Content-Length header field, if it is:\n    #\n    isStream=False\n    for (k,v) in headers:\n        if k==\"Content-Type\" and v.endswith(\"stream\"):\n            isStream=True\n            break\n\n    if not isStream and \"content-length\" not in header_set:\n        headers.append((\"Content-Length\", str(len(body))))\nYou probably should consider a more generalized solution to handle HTTP stream content\nin the future.", "issue_status": "Closed", "issue_reporting_time": "2011-07-12T14:38:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1155": {"issue_url": "https://github.com/tornadoweb/tornado/issues/296", "issue_id": "#296", "issue_summary": "Add support for testing locale", "issue_description": "jameshtl commented on 6 Jul 2011\nWould it be possible to add a testing locale to the LOCALE_NAMES dict in tornado.locale?\nFacebook provide the \"English (Upside Down)\" locale for such a purpose (I believe).\nI've seen other sites provided an \"English (Pirate)\" locale, ie \"en_PR\".", "issue_status": "Closed", "issue_reporting_time": "2011-07-06T13:50:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1156": {"issue_url": "https://github.com/tornadoweb/tornado/issues/293", "issue_id": "#293", "issue_summary": "HTTPS requires either python2.6+ or curl_httpclient", "issue_description": "joesomoza commented on 1 Jul 2011\nFirst of all, I really like your product because it is Jetty for Python. Awesome!\nI have your latest git repository, commit 495b39c\nI use Python 3.2.\nOn an unrelated note, I'm very happy with the byte to string fix you did on auth.py =) It works well on Windows and Ubuntu.\nHowever, when I run your authdemo on my micro-fedora-linux amazon cloud EC2 machine\npython3.2 authdemo.py\nI get the following error:\n[I 110701 03:22:11 web:1306] 302 GET / () 1.07ms\n[I 110701 03:22:11 web:1306] 302 GET /auth/login?next=%2F () 0.82ms\n[W 110701 03:22:50 simple_httpclient:267] uncaught exception\nTraceback (most recent call last):\nFile \"/usr/local/lib/python3.2/site-packages/tornado-2.0git-py3.2.egg/tornado/simple_httpclient.py\", line 265, in cleanup\nyield\nFile \"/usr/local/lib/python3.2/site-packages/tornado-2.0git-py3.2.egg/tornado/simple_httpclient.py\", line 137, in init\nraise ValueError(\"HTTPS requires either python3.6+ or \"\nValueError: HTTPS requires either python2.6+ or curl_httpclient\n[W 110702 03:22:50 auth:152] Invalid OpenID response: HTTPS requires either python3.6+ or curl_httpclient\n[W 110701 03:22:50 web:952] 500 GET /auth/login?next=%2F&openid.ns=http%3A%2F%2Fspecs.openid.net%2Fauth%2F2.0&openid.mode=id_res&openid.op_endpoint=https%3A%2F%2Fwww.google.com%2Faccounts%2Fo8%2Fud&openid.response_nonce=2011-07-01T03%3A22%3A38Z2eTypC53PBQpIw&openid.return_to=) 9.57ms\n^CTraceback (most recent call last):\nFile \"auth/authdemo.py\", line 85, in\nmain()\nFile \"auth/authdemo.py\", line 81, in main\ntornado.ioloop.IOLoop.instance().start()\nFile \"/usr/local/lib/python3.2/site-packages/tornado-2.0git-py3.2.egg/tornado/ioloop.py\", line 283, in start\nevent_pairs = self._impl.poll(poll_timeout)\nKeyboardInterrupt\n[tornadodemos] >>> ls\nappengine benchmark chat helloworld websocket\nauth blog facebook s3server\nMaybe I'm smoking crack?", "issue_status": "Closed", "issue_reporting_time": "2011-07-01T04:28:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1157": {"issue_url": "https://github.com/tornadoweb/tornado/issues/291", "issue_id": "#291", "issue_summary": "Tornado Templates: Consume newline that follows {% %} tags", "issue_description": "Contributor\nchristarnowski commented on 29 Jun 2011\nThe output of Tornado's template processor suffers from excessive newlines for templates with large number of {% %} tags, which are usually placed on separate lines for better readability.\nOne of the possible solutions to this issue is to instruct the parser to consume a newline character that follows %} tag.", "issue_status": "Closed", "issue_reporting_time": "2011-06-29T12:51:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1158": {"issue_url": "https://github.com/tornadoweb/tornado/issues/290", "issue_id": "#290", "issue_summary": "WebSocket Draft 09", "issue_description": "mattbasta commented on 29 Jun 2011\nCurrently, Firefox 6 and up are the only browsers that implement the latest standard of WebSockets. The new draft standard is somewhat backwards incompatible with the \"current\" draft standard, so Firefox Beta, Aurora, and Nightly are all broken with the WebsocketHandler. Soon, Chrome and Opera will adopt the new standard.\nThere aren't a whole lot of huge changes, so it should be pretty simple to simply abstract out the protocol to use whatever the browser requests.\nIf nobody has started work on this, I can take a stab at it.", "issue_status": "Closed", "issue_reporting_time": "2011-06-28T23:42:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1159": {"issue_url": "https://github.com/tornadoweb/tornado/issues/288", "issue_id": "#288", "issue_summary": "tornado.websocket crashes with chatdemo on Python3.2", "issue_description": "orpheuslummis commented on 23 Jun 2011\nAs the title says, tornado.websocket (v2.0) crashes with its chatdemo on Python3.2. My traceback is here. Running on Python 2.7 worked fine though.\nI'm not very Tornado-literate nor WebSocket-savvy, yet, so I fear I cannot help with this issue in the very short-term. Still, the problem might be because Python3 division is true division, and struct.pack(\">I\", key_number) requires an int.\ndef _calculate_part(self, key):\n    \"\"\"Processes the key headers and calculates their key value.\n\n    Raises ValueError when feed invalid key.\"\"\"\n    number = int(''.join(c for c in key if c.isdigit()))\n    spaces = len([c for c in key if c.isspace()])\n    try:\n        key_number = number / spaces # <-- Yields a float\n    except (ValueError, ZeroDivisionError):\n        raise ValueError\n    return struct.pack(\">I\", key_number) # <-- struct.pack(\">I\", ...) wants an int\nGoing further, if I use struct.pack(\">f\", key_number) (doc) I get this error:\nFile \"/home/orftz/virtualenvs/tornado/lib/python3.2/site-packages/tornado/iostream.py\", line 166, in write\n    assert isinstance(data, bytes_type)\nAssertionError", "issue_status": "Closed", "issue_reporting_time": "2011-06-23T15:40:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1160": {"issue_url": "https://github.com/tornadoweb/tornado/issues/287", "issue_id": "#287", "issue_summary": "socket.AI_ADDRCONFIG not supported on Windows XP", "issue_description": "l-hedgehog commented on 23 Jun 2011\nWhen trying tornado 2.0 on Windows XP SP3 + Python 2.5.2, it will report\nFile \"C:\\Python25\\Lib\\site-packages\\tornado\\httpserver.py\", line 187, in bind\n0, socket.AI_PASSIVE | socket.AI_ADDRCONFIG):\nAttributeError: 'module' object has no attribute 'AI_ADDRCONFIG'\nIt is said that \"The AI_ADDRCONFIG flag is defined on the Windows SDK for Windows Vista and later. The AI_ADDRCONFIG flag is supported on Windows Vista and later.\" at [MSDN](http://msdn.microsoft.com/en-us/library/ms738520(v=vs.85\\).aspx)\nThanks!", "issue_status": "Closed", "issue_reporting_time": "2011-06-23T04:46:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1161": {"issue_url": "https://github.com/tornadoweb/tornado/issues/285", "issue_id": "#285", "issue_summary": "Using a unicode object as the domain value when setting a cookie results in an error message that isn't very helpful", "issue_description": "carlio commented on 21 Jun 2011\nUsing a unicode object as the domain value when setting a cookie results in an error message that isn't very helpful:\nimport tornado.web\nimport tornado.ioloop\nimport tornado.httpserver\n\nclass AddUnicodeCookieHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        self.set_cookie('testcookie', value='some_value', domain=u\"fish\")\n        self.write('hello')\n\nif __name__ == '__main__':\n    urllist = (('/',AddUnicodeCookieHandler),)\n    app = tornado.web.Application(urllist)\n\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(9999, 'localhost')\n\n    ioloop = tornado.ioloop.IOLoop.instance()\n    ioloop.start()\nRunning this and access http://localhost:9999/ results in this error:\nTraceback (most recent call last):\n  File \"/home/carl/tmp/tornado-test/env/lib/python2.7/site-packages/tornado/web.py\", line 863, in _execute\n    self.finish()\n  File \"/home/carl/tmp/tornado-test/env/lib/python2.7/site-packages/tornado/web.py\", line 590, in finish\n    self.flush(include_footers=True)\n  File \"/home/carl/tmp/tornado-test/env/lib/python2.7/site-packages/tornado/web.py\", line 555, in flush\n    self.request.write(headers + chunk)\n  File \"/home/carl/tmp/tornado-test/env/lib/python2.7/site-packages/tornado/httpserver.py\", line 490, in write\n    assert isinstance(chunk, str)\nAssertionError\nERROR:root:Cannot send error response after headers written\nObviously using unicode objects is a bit stupid but there could be more checks before it gets all the way to writing the headers.", "issue_status": "Closed", "issue_reporting_time": "2011-06-21T15:03:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1162": {"issue_url": "https://github.com/tornadoweb/tornado/issues/283", "issue_id": "#283", "issue_summary": "Remove obsolete RequestHandler.async_callback method", "issue_description": "Contributor\nchristarnowski commented on 16 Jun 2011\nThis method is obsolete since Tornado 1.1, yet some of the code (e.g. in tornado.auth) still relies on it. The goal here would be to clean-up the codebase, including doc strings, and remove the method altogether.", "issue_status": "Closed", "issue_reporting_time": "2011-06-16T14:43:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1163": {"issue_url": "https://github.com/tornadoweb/tornado/issues/281", "issue_id": "#281", "issue_summary": "WSGIContainer passes PATH_INFO to application without unquoting", "issue_description": "mortenlj commented on 15 Jun 2011\nAs mentioned on python-tornado mailinglist here and on the django-users mailinglist here, it seems Tornado isn't properly unquoting the PATH_INFO before building the environ passed to the application.\nThis breaks URLs like http://example.com/browse/new%20york/ when running Django as a WSGI application on Tornado.", "issue_status": "Closed", "issue_reporting_time": "2011-06-14T19:16:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1164": {"issue_url": "https://github.com/tornadoweb/tornado/issues/280", "issue_id": "#280", "issue_summary": "Problem with non latin xhtml_escape() under python2", "issue_description": "andy128k commented on 14 Jun 2011\nescape.py, function xhtml_escape\nnative_str causes problem in python 2. Unicode decode error is raised.\nremoving native_str solves my problem.\nreturn xml.sax.saxutils.escape(value, {'\"': \"\"\"})\nPlease fix.", "issue_status": "Closed", "issue_reporting_time": "2011-06-14T12:00:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1165": {"issue_url": "https://github.com/tornadoweb/tornado/issues/276", "issue_id": "#276", "issue_summary": "interprocess communication", "issue_description": "goldalworming commented on 6 Jun 2011\nfinally I a little understand about tornadoweb asynchronous\nthe key of asynchronous response is chat example is\n    for callback in cls.waiters:\n        try:\n            callback(messages)\n        except:\n            logging.error(\"Error in waiter callback\", exc_info=True)\nso Is there any solution to store the callback function in datastore or solution if using several computer or process??\ne.g :\nA request updates to node1, B post data that handled by node2 for A\nhow to node2 call node1 callback??", "issue_status": "Closed", "issue_reporting_time": "2011-06-06T18:04:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1166": {"issue_url": "https://github.com/tornadoweb/tornado/issues/274", "issue_id": "#274", "issue_summary": "RequestHandler._handle_request_exception throws TypeError", "issue_description": "repeatedly commented on 30 May 2011\nHi,\nI use HTTPError for exception handling, but following code raises TypeError.\nraise tornado.web.HTTPError(500, \"Unknown Error!\", True)\n# TypeError: not all arguments converted during string formatting\nThe reason for this is simple: _handle_request_exception does not consider args attribute for formatting.\nPatch is bellow,\ndiff --git a/tornado/web.py b/tornado/web.py\nindex ecc686f..ff19d2e 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -941,7 +941,7 @@ class RequestHandler(object):\n     def _handle_request_exception(self, e):\n         if isinstance(e, HTTPError):\n             if e.log_message:\n-                format = \"%d %s: \" + e.log_message\n+                format = \"%d %s\" + (\" %s\" * len(e.args)) + \": \" + e.log_message\n                 args = [e.status_code, self._request_summary()] + list(e.args)\n                 logging.warning(format, *args)\n             if e.status_code not in httplib.responses:", "issue_status": "Closed", "issue_reporting_time": "2011-05-30T17:11:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1167": {"issue_url": "https://github.com/tornadoweb/tornado/issues/271", "issue_id": "#271", "issue_summary": "Non-ascii characters cause UnicodeEncodeError", "issue_description": "peterbe commented on 25 May 2011\nI can quite easily re-produce this. I change my name on Google Accounts to something that has non-ascii characters in it (Peter B\u00e4ngtsson) and then authenticate on my app on a request handler that uses the tornado.auth.GoogleMixin and I get this error:\nTraceback (most recent call last):\n  File \"/Users/peterbe/virtualenvs/worklog/lib/python2.6/site-packages/tornado/web.py\", line 884, in _execute\n    getattr(self, self.request.method.lower())(*args, **kwargs)\n  File \"/Users/peterbe/virtualenvs/worklog/lib/python2.6/site-packages/tornado/web.py\", line 965, in wrapper\n    return method(self, *args, **kwargs)\n  File \"/Users/peterbe/dev/TORNADO/worklog/apps/main/handlers.py\", line 1713, in get\n    self.get_authenticated_user(self.async_callback(self._on_auth))\n  File \"/Users/peterbe/virtualenvs/worklog/lib/python2.6/site-packages/tornado/auth.py\", line 728, in get_authenticated_user\n    OpenIdMixin.get_authenticated_user(self, callback)\n  File \"/Users/peterbe/virtualenvs/worklog/lib/python2.6/site-packages/tornado/auth.py\", line 99, in get_authenticated_user\n    method=\"POST\", body=urllib.urlencode(args))\n  File \"/usr/local/Cellar/python2.6/2.6.6/lib/python2.6/urllib.py\", line 1269, in urlencode\n    v = quote_plus(str(v))\nUnicodeEncodeError: 'ascii' codec can't encode characters in position 1-2: ordinal not in range(128)\nThe offending method that gets it wrong is this:\ndef get_authenticated_user(self, callback):\n    \"\"\"Fetches the authenticated user data upon redirect.\n\n    This method should be called by the handler that receives the\n    redirect from the authenticate_redirect() or authorize_redirect()\n    methods.\n    \"\"\"\n    # Verify the OpenID response via direct request to the OP\n    args = dict((k, v[-1]) for k, v in self.request.arguments.iteritems())\n    args[\"openid.mode\"] = u\"check_authentication\"\n    url = self._OPENID_ENDPOINT\n    http = httpclient.AsyncHTTPClient()\n    http.fetch(url, self.async_callback(\n        self._on_authentication_verified, callback),\n        method=\"POST\", body=urllib.urlencode(args))\nI would suggest a patch that converts v[-1] to a byte string from utf-8 but the utility functions for to- and from unicode has changed so much lately that I don't know which is which.", "issue_status": "Closed", "issue_reporting_time": "2011-05-24T22:29:27Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1168": {"issue_url": "https://github.com/tornadoweb/tornado/issues/270", "issue_id": "#270", "issue_summary": "http_server doesn't complain if chosen port is already busy", "issue_description": "peterbe commented on 25 May 2011\nso my code looks something like this:\nif __name__ == '__main__':\n    ...\n    http_server.listen(8000)\n    tornado.ioloop.IOLoop.instance().start()\nSometimes I leave another django or tornado app running already on port 8000 which I soon discover when I try to actually access the site.\nIt would be nice if http_server or the instance().start() could raise an error if the port is already taken.", "issue_status": "Closed", "issue_reporting_time": "2011-05-24T21:55:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1169": {"issue_url": "https://github.com/tornadoweb/tornado/issues/266", "issue_id": "#266", "issue_summary": "JSON responses should have mimetype \"application/json\"", "issue_description": "lokkilok commented on 18 May 2011\nThe RequestHandler.write method in web.py automatically converts a dict to JSON, which is nice. But the Content-Type header is given a value of \"text/javscript\" whereas the standard dictates \"application/json\".\nSee http://www.ietf.org/rfc/rfc4627.txt and http://www.iana.org/assignments/media-types/application/index.html\nFor example jQuery (1.5) will evaluate/run the json rather than convert is into a Javascript object when the Content-Type is text/javascript. You have to explicitly inform jQuery that you expect JSON back.", "issue_status": "Closed", "issue_reporting_time": "2011-05-18T11:28:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1170": {"issue_url": "https://github.com/tornadoweb/tornado/issues/264", "issue_id": "#264", "issue_summary": "More str vs. byte vs. unicode problems with latest commits", "issue_description": "peterbe commented on 16 May 2011\n[E 110516 08:25:10 iostream:237] Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/iostream.py\", line 234, in wrapper\n        callback(*args)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/stack_context.py\", line 156, in wrapped\n        callback(*args, **kwargs)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/httpserver.py\", line 385, in _on_headers\n        self.request_callback(self._request)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/web.py\", line 1226, in __call__\n        handler._execute(transforms, *args, **kwargs)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornadio/router.py\", line 77, in _execute\n        handler._execute(transforms, *extra, **kwargs)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornadio/persistent.py\", line 52, in _execute\n        **kwargs)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/websocket.py\", line 101, in _execute\n        uri=self.request.uri)))\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/iostream.py\", line 166, in write\n        assert isinstance(data, bytes_type)\n    AssertionError\nEasily solved this with this:\ndiff --git a/tornado/iostream.py b/tornado/iostream.py\nindex 38c1a2b..ffd5fa1 100644\n--- a/tornado/iostream.py\n+++ b/tornado/iostream.py\n@@ -163,7 +163,7 @@ class IOStream(object):\n         previously buffered write data and an old write callback, that\n         callback is simply overwritten with this new callback.\n         \"\"\"\n-        assert isinstance(data, bytes_type)\n+        assert isinstance(data, (unicode, bytes_type)), type(data)\n         self._check_closed()\n         self._write_buffer.append(data)\n         self._add_io_state(self.io_loop.WRITE)\nNext is a problem with websocket.py parsing:\n[E 110516 08:28:55 iostream:237] Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/iostream.py\", line 234, in wrapper\n        callback(*args)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/stack_context.py\", line 156, in wrapped\n        callback(*args, **kwargs)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/websocket.py\", line 106, in _handle_challenge\n        challenge_response = self.ws_request.challenge_response(challenge)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/websocket.py\", line 238, in challenge_response\n        part_1 = self._calculate_part(key_1)\n      File \"/Users/peterbe/virtualenvs/tornado_gkc/lib/python2.6/site-packages/tornado/websocket.py\", line 262, in _calculate_part\n        number, spaces = filter(str.isdigit, key), filter(str.isspace, key)\n    TypeError: descriptor 'isdigit' requires a 'str' object but received a 'unicode'\nI solved it like this:\ndiff --git a/tornado/websocket.py b/tornado/websocket.py\nindex 696a178..cefcbf5 100644\n--- a/tornado/websocket.py\n+++ b/tornado/websocket.py\n@@ -259,7 +259,9 @@ class WebSocketRequest(object):\n         \"\"\"Processes the key headers and calculates their key value.\n\n         Raises ValueError when feed invalid key.\"\"\"\n-        number, spaces = filter(str.isdigit, key), filter(str.isspace, key)\n+        type_ = isinstance(key, str) and str or unicode\n+        number, spaces = filter(type_.isdigit, key), filter(type_.isspace, key)\n+\n         try:\n             key_number = int(number) / len(spaces)\n         except (ValueError, ZeroDivisionError):\nI couldn't see any unit tests for websockets but perhaps that's a hint that I should contribute some.", "issue_status": "Closed", "issue_reporting_time": "2011-05-16T07:39:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1171": {"issue_url": "https://github.com/tornadoweb/tornado/issues/263", "issue_id": "#263", "issue_summary": "Unicode Cookie header breaks self.cookies.load()", "issue_description": "peterbe commented on 16 May 2011\nAs of the latest commit, it breaks cookies. This naive patch fixes it:\ndiff --git a/tornado/web.py b/tornado/web.py\nindex 0702131..9533fcc 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -264,8 +264,11 @@ class RequestHandler(object):\n         if not hasattr(self, \"_cookies\"):\n             self._cookies = Cookie.BaseCookie()\n             if \"Cookie\" in self.request.headers:\n+                cookie = self.request.headers[\"Cookie\"]\n+                if isinstance(cookie, unicode):\n+                    cookie = cookie.encode('utf-8')\n                 try:\n-                    self._cookies.load(self.request.headers[\"Cookie\"])\n+                    self._cookies.load(cookie)\n                 except:\n                     self.clear_all_cookies()\n         return self._cookies\nClearly, it's somehow related to the python3 merge but I can't pinpoint what exactly.", "issue_status": "Closed", "issue_reporting_time": "2011-05-15T20:21:43Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1172": {"issue_url": "https://github.com/tornadoweb/tornado/issues/261", "issue_id": "#261", "issue_summary": "Including POP3 and IMAP clients", "issue_description": "mmalecki commented on 14 May 2011\nAre there any plans on including POP3 and IMAP (and possibly different protocols) clients in tornado?\nI'm currently working on asynchronous implementations of both (with former almost finished).\nNow I'm wondering if should I add them into my repository and issue a pull request or just start a new project all by myself?\nCurrently, they don't match HTTP asynchronous client convention (they're not divided into simple and full-blown one, there's no connection \"caching\").\nThey're almost compatible with Python's built-in poplib and imaplib.\nThis is an overview of POP3 client: https://gist.github.com/971309", "issue_status": "Closed", "issue_reporting_time": "2011-05-13T20:57:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1173": {"issue_url": "https://github.com/tornadoweb/tornado/issues/259", "issue_id": "#259", "issue_summary": "on_connection_close() does not get called in tornado 1.2.1", "issue_description": "Contributor\njehiah commented on 5 May 2011\nI don't have any more specific details (at the moment) but i recently found that after upgrading to torando 1.2.1 (from a really old version) that RequestHandler.on_connection_close() was no longer being called at the end of a request.\nI've temporarily moved to chaining my code from self.finish() as a workaround.", "issue_status": "Closed", "issue_reporting_time": "2011-05-05T11:39:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1174": {"issue_url": "https://github.com/tornadoweb/tornado/issues/257", "issue_id": "#257", "issue_summary": "Improved error handling for exceptions inside websocket on_message callbacks", "issue_description": "Contributor\nkmike commented on 4 May 2011\nWebSocketHandler._on_end_delimiter calls on_message callback and then calls self._receive_message().\nIf an exception occurs in on_messsage callback then the stream gets closed (https://github.com/facebook/tornado/blob/master/tornado/websocket.py#L170).\nThis leads to IOError(\"Stream is closed\") erorrs in self._receive_message() because 'if not self.client_terminated:' is not checked again.\nI think this can be one of the causes for #252", "issue_status": "Closed", "issue_reporting_time": "2011-05-04T15:13:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1175": {"issue_url": "https://github.com/tornadoweb/tornado/issues/254", "issue_id": "#254", "issue_summary": "Add support for per-request CSRF protection", "issue_description": "Contributor\nchristarnowski commented on 28 Apr 2011\nIt would be nice if Tornado allowed to disable CSRF protection for the duration of a single request. Currently it can only be achieved by overriding the RequestHandler._execute().\nIt can be achieved by allowing subclasses of the RequestHandler to override xsrf_protection(), which in turn, by default, would return the value of xsrf_cookies setting.\nclass RequestHandler(object):\n    def xsrf_protection(self):\n        return self.application.settings.get(\"xsrf_cookies\")\n...\nAnd in the _execute method:\nif self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and self.xsrf_protection():\n    self.check_xsrf_cookie()\nWhat do you think?", "issue_status": "Closed", "issue_reporting_time": "2011-04-28T18:18:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1176": {"issue_url": "https://github.com/tornadoweb/tornado/issues/252", "issue_id": "#252", "issue_summary": "Recursion loop between websocket and iostream", "issue_description": "justinfx commented on 27 Apr 2011\nThis is my first project using Tornado... building a message service\nwith TornadIO + ZMQ. I'm using pyzmq's ioloop.\nI have been running into this issue of a recursive loop between the\niostream and the websocket, and can't yet pinpoint why. Seems a client\nconnects fine and sends plenty of messages and receives fine. Someone\nelse connects and is fine for a bit then crash. I dont know if I'm not\nhandling a disconnect properly, or if something in a message is\ncausing a read error in the tornado code. Maybe someone can tell me\nwhats really happening here and if its something I'm not handling\nproperly...\n// Start of the traceback...\n\n[E 110426 01:45:28 ioloop:295] Exception in I/O handler for fd 22\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.6/dist-packages/pyzmq-2.1.4-py2.6-\nlinux-x86_64.egg/zmq/eventloop/ioloop.py\", line 282, in start\nself._handlers[fd](fd, events)\nFile \"/usr/local/lib/python2.6/dist-packages/pyzmq-2.1.4-py2.6-\nlinux-x86_64.egg/zmq/eventloop/stack_context.py\", line 133, in wrapped\ncallback(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 199, in _handle_events\nself._handle_read()\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 258, in _handle_read\nif self._read_from_buffer():\n\n// START: here is the start of the block that loops recursively\n\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 325, in _read_from_buffer\nself._consume(loc + delimiter_len))\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 230, in _run_callback\ncallback(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/stack_context.py\", line 173, in wrapped\ncallback(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/websocket.py\", line 193, in _on_end_delimiter\nself._receive_message()\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/websocket.py\", line 178, in _receive_message\nself.stream.read_bytes(1, self._on_frame_type)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 149, in read_bytes\nif self._read_from_buffer():\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 314, in _read_from_buffer\nself._run_callback(callback, self._consume(num_bytes))\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 230, in _run_callback\ncallback(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/stack_context.py\", line 173, in wrapped\ncallback(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/websocket.py\", line 183, in _on_frame_type\nself.stream.read_until(\"\\xff\", self._on_end_delimiter)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-\npy2.6.egg/tornado/iostream.py\", line 133, in read_until\nif self._read_from_buffer():\n\n// Loop back to start (line 325 in iostream\nAny help??????\nIm using the pypi tornado\n1.2.1, tornadIO 0.0.4, zeromq 2.1.4, and pypi pyzmq, on ubuntu linux", "issue_status": "Closed", "issue_reporting_time": "2011-04-26T18:45:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1177": {"issue_url": "https://github.com/tornadoweb/tornado/issues/251", "issue_id": "#251", "issue_summary": "Facebook Demo KeyError: 'actions'", "issue_description": "jamesthornton commented on 25 Apr 2011\nAdd a conditional to display actions because sometime post[\"actions\"] isn't set.", "issue_status": "Closed", "issue_reporting_time": "2011-04-24T19:43:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1178": {"issue_url": "https://github.com/tornadoweb/tornado/issues/249", "issue_id": "#249", "issue_summary": "simple_httpclient doesn't handle comma-separated Content-Length", "issue_description": "davidrecordon commented on 22 Apr 2011\nApparently the HTTP spec allows proxies to combine multiple duplicate headers into a single one with the value being separated by a comma and a space.\nWe're thus seeing some photos with a header like Content-Length: 12345, 12345\nThis results in an uncaught exception:\n[W 110421 17:42:59 simple_httpclient:227] uncaught exception\nTraceback (most recent call last):\nFile \"tornado/simple_httpclient.py\", line 225, in cleanup\nFile \"tornado/stack_context.py\", line 171, in wrapped\nFile \"tornado/simple_httpclient.py\", line 258, in _on_headers\nValueError: invalid literal for int() with base 10: '28760,28760'", "issue_status": "Closed", "issue_reporting_time": "2011-04-22T00:46:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1179": {"issue_url": "https://github.com/tornadoweb/tornado/issues/247", "issue_id": "#247", "issue_summary": "load_gettext_translations should not parse SVC tools meta dir", "issue_description": "sshwsfc commented on 20 Apr 2011\nshould ignore .svn dir.", "issue_status": "Closed", "issue_reporting_time": "2011-04-20T02:01:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1180": {"issue_url": "https://github.com/tornadoweb/tornado/issues/245", "issue_id": "#245", "issue_summary": "wsgi request fails if the request contains HTTP_CONTENT_LENGTH", "issue_description": "raptium commented on 15 Apr 2011\nwsgi.py reads content_length string from environ['HTTP_CONTENT_LENGTH'] and never converts it into int.\nTraceback (most recent call last):\n  File \"/home/hguan/Desktop/raad/www/wsgi.py\", line 34, in application\n    return tornado_application(environ, start_response)\n  File \"/home/hguan/Desktop/raad/www/tornado/wsgi.py\", line 77, in __call__\n    handler = web.Application.__call__(self, HTTPRequest(environ))\n  File \"/home/hguan/Desktop/raad/www/tornado/wsgi.py\", line 116, in __init__\n    self.headers[\"Content-Length\"])\nTypeError: an integer is required\nActually Content-Length is first read from environ['CONTENT_LENGTH'] and it gets converted into int. However, if HTTP_CONTENT_LENGTH also presents, it will overwrite self.header['Content-Length'] with a str.\nif environ.get(\"CONTENT_LENGTH\"):\n    self.headers[\"Content-Length\"] = int(environ[\"CONTENT_LENGTH\"])\nfor key in environ:\n    if key.startswith(\"HTTP_\"):\n        self.headers[key[5:].replace(\"_\", \"-\")] = environ[key]\nif self.headers.get(\"Content-Length\"):\n    self.body = environ[\"wsgi.input\"].read(\n        self.headers[\"Content-Length\"])", "issue_status": "Closed", "issue_reporting_time": "2011-04-15T14:22:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1181": {"issue_url": "https://github.com/tornadoweb/tornado/issues/244", "issue_id": "#244", "issue_summary": "u\" \" triggers UnicodeDecodeError in Template", "issue_description": "chadwhitacre commented on 15 Apr 2011\nIf I pass a bytestring to a Template, or a unicode object with no whitespace, then I can successfully generate the template using unicode data:\n>>> Template(\"{{ text }}\").generate(text=unichr(1758))\n'\\xdb\\x9e'\n>>> Template(u\"{{ text }}\").generate(text=unichr(1758))\n'\\xdb\\x9e'\n>>> Template(\" {{ text }}\").generate(text=unichr(1758))\n' \\xdb\\x9e'\nIf I pass a bytestring to a Template, or a unicode object with (or without) whitespace, then I can successfully generate the template with ASCII data:\n>>> Template(\" {{ text }}\").generate(text=u\"a\")\n' a'\n>>> Template(u\" {{ text }}\").generate(text=\"a\")\nu' a'\nBut if I pass a unicode object to Template with whitespace, and try to generate the template with unicode data, I get a UnicodeDecodeError:\n>>> Template(u\" {{ text }}\").generate(text=unichr(1758))\nERROR:root:<string> code:\n1  def _execute():\n2      _buffer = []\n3      _buffer.append(u' ')\n4      _tmp = text\n5      if isinstance(_tmp, str): _buffer.append(_tmp)\n6      elif isinstance(_tmp, unicode): _buffer.append(_tmp.encode('utf-8'))\n7      else: _buffer.append(str(_tmp))\n8      return ''.join(_buffer)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/Users/whit537/personal/aspen/master/aspen/_tornado/template.py\",\n   line 129, in generate\n    return execute()\n  File \"<string>\", line 8, in _execute\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xdb in position 0:\n  ordinal not in range(128)\nThis is with 2afc7ba.", "issue_status": "Closed", "issue_reporting_time": "2011-04-15T02:52:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1182": {"issue_url": "https://github.com/tornadoweb/tornado/issues/243", "issue_id": "#243", "issue_summary": "simple_httpclient does not support HEAD requests", "issue_description": "Member\nbdarnell commented on 14 Apr 2011\nIt needs to stop after the headers instead of trying to read the body (even though e.g. Content-length is present)", "issue_status": "Closed", "issue_reporting_time": "2011-04-14T05:05:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1183": {"issue_url": "https://github.com/tornadoweb/tornado/issues/241", "issue_id": "#241", "issue_summary": "Need to configure the domain for Facebook Graph API", "issue_description": "dkellerman commented on 3 Apr 2011\nIt would be very nice if I could configure the URLs that are used to access the Facebook Graph API so that I could point to graph.beta.facebook.com - unfortunately it's not even as easy as monkey-patching the _OAUTH urls, since there's another url hardcoded in the \"facebook_request\" method.", "issue_status": "Closed", "issue_reporting_time": "2011-04-02T22:15:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1184": {"issue_url": "https://github.com/tornadoweb/tornado/issues/234", "issue_id": "#234", "issue_summary": "Could web.Application.get_arguments return all arguments if no name is passed?", "issue_description": "Contributor\nemehrkay commented on 22 Mar 2011\n   def get_arguments(self, name=None, strip=True):\n    ...\n    if name is not None:\n        values = self.request.arguments.get(name, [])\n    else:\n        values = self.request.arguments\nIs there a reason why I cannot have all the arguments at once (cleaned via web._unicode) as a dict or am I reading the source incorrectly?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2011-03-22T04:01:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1185": {"issue_url": "https://github.com/tornadoweb/tornado/issues/233", "issue_id": "#233", "issue_summary": "simple_httpclient has a problem passing expect header to Twitter", "issue_description": "Contributor\njoerussbowman commented on 15 Mar 2011\nThe HTTPRequest object will always set the Expect header to '' if the header isn't included. When using the curl implementation this is fine. However, trying to move to the simple_httpclient I have found that Twitter's Varnish servers will send error 417. I confirmed, switching back and forth between the two clients that only simple_httpclient get's the value returned. I also removed the if statement that adds the head in httpclient.py HTTPRequest\n    if \"Expect\" not in headers:\n        headers[\"Expect\"] = \"\"\nAnd then found that simple_httpclient would work, of course without that header not being sent in the request.\nIt's late for me, so I'm not going to be able to figure out how to set up something to do packet inspection on my laptop, sorry new to osx. Hopefully this error report carries enough information.\nThe Twitter API I was hitting is the search api which uses the url format of\n\"http://search.twitter.com/search.json?q=%s\" % query", "issue_status": "Closed", "issue_reporting_time": "2011-03-15T02:49:22Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1186": {"issue_url": "https://github.com/tornadoweb/tornado/issues/231", "issue_id": "#231", "issue_summary": "Need a way to handler large file uploading", "issue_description": "tsangpozheng commented on 14 Mar 2011\nI want to use tornado to save the large uploading files to disk, but I found that tornado will read all the bytes in memory before executing the handler method.\nHow should I do if I want the handler method to be executed first, and save the following data content to the disk streamly.\n1", "issue_status": "Closed", "issue_reporting_time": "2011-03-14T14:03:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1187": {"issue_url": "https://github.com/tornadoweb/tornado/issues/230", "issue_id": "#230", "issue_summary": "httpclient raises an error in recent commit", "issue_description": "tzuryby commented on 13 Mar 2011\nI have this line of code which I use within my tornado to fetch some local data as\n`httpclient.HTTPClient().fetch(\"http://admin:admin@localhost:2812\")`\nThis worked fine for me by far, yet, as I cloned tornado today, I get an error, which suggest something in went wrong in the url parser as first colon (of auth) split the url instead of the second (port number)\n>>> httpclient.HTTPClient().fetch(\"http://admin:admin@localhost:2812\")\nWARNING:root:uncaught exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 225, in cleanup\n    yield\n  File \"/usr/local/lib/python2.6/dist-packages/tornado/simple_httpclient.py\", line 132, in __init__\n    port = int(port)\nValueError: invalid literal for int() with base 10: 'admin@localhost:2812'\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/usr/local/lib/python2.6/dist-packages/tornado/httpclient.py\", line 46, in fetch\n    response.rethrow()\n  File \"/usr/local/lib/python2.6/dist-packages/tornado/httpclient.py\", line 264, in rethrow\n    raise self.error\nValueError: invalid literal for int() with base 10: 'admin@localhost:2812'\n>>> ", "issue_status": "Closed", "issue_reporting_time": "2011-03-13T04:51:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1188": {"issue_url": "https://github.com/tornadoweb/tornado/issues/229", "issue_id": "#229", "issue_summary": "Error on facebook examples KeyError: 'access_token'", "issue_description": "goldalworming commented on 9 Mar 2011\ni've got error using facebook-example on latest tornado using graph api\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-py2.6.egg/tornado/web.py\", line 869, in _execute\n    getattr(self, self.request.method.lower())(*args, **kwargs)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-py2.6.egg/tornado/web.py\", line 1505, in wrapper\n    return method(self, *args, **kwargs)\n  File \"/usr/local/lib/python2.6/dist-packages/tornado-1.2.1-py2.6.egg/tornado/web.py\", line 949, in wrapper\n    return method(self, *args, **kwargs)\n  File \"facebook.py\", line 69, in get\n    access_token=self.current_user[\"access_token\"])\nKeyError: 'access_token'\n[E 110309 04:00:44 web:1243] 500 GET / (127.0.0.1) 10.07ms\nwhat to do with access token??", "issue_status": "Closed", "issue_reporting_time": "2011-03-08T22:30:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1189": {"issue_url": "https://github.com/tornadoweb/tornado/issues/228", "issue_id": "#228", "issue_summary": "Support for full HTTP Redirect codes,Line 387", "issue_description": "thecapacity commented on 7 Mar 2011\nMy new redirect function is (Line 387 of web.py)\nI just changed the \"permanent\" to support my use cases which needs status code of 303.\ndef redirect(self, url, status=301):\n    \"\"\"Sends a redirect to the given (optionally relative) URL.\"\"\"\n    if self._headers_written:\n        raise Exception(\"Cannot redirect after headers have been written\")\n    self.set_status(status)\n    # Remove whitespace\n    url = re.sub(r\"[\\x00-\\x20]+\", \"\", _utf8(url))\n    self.set_header(\"Location\", urlparse.urljoin(self.request.uri, url))\n    self.finish()\nBased on: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\nIt looks like returning 302 (for a login post) isn't the right thing to do since;\n\"If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued. \"\nSorry for not having a proper pull request, but git is on my list to learn after tornado!! =)", "issue_status": "Closed", "issue_reporting_time": "2011-03-06T22:59:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1190": {"issue_url": "https://github.com/tornadoweb/tornado/issues/227", "issue_id": "#227", "issue_summary": "FacebookGraphMixin only returning picture field", "issue_description": "rwynn commented on 2 Mar 2011\nIn FacebookGraphMixin _on_access_token I need to change the code as follows in order to retrieve all fields. Otherwise, only the picture field is returned\n  fields = set(['id', 'name', 'first_name', 'last_name', 'locale', 'picture', 'link'])\n  if extra_fields: fields.update(extra_fields)\n\n  self.facebook_request(\n      path=\"/me\",\n      callback=self.async_callback(\n          self._on_get_user_info, callback, session, extra_fields),\n      access_token=session[\"access_token\"],\n      fields=\",\".join(fields)\n      )", "issue_status": "Closed", "issue_reporting_time": "2011-03-02T06:19:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1191": {"issue_url": "https://github.com/tornadoweb/tornado/issues/226", "issue_id": "#226", "issue_summary": "IOLoop.handle_callback_exception gone", "issue_description": "Contributor\nFlorianLudwig commented on 24 Feb 2011\nThe following comment from iostream [0] from the function _run_callback got two things wrong:\n# Re-raise the exception so that IOLoop.handle_callback_exception\n# can see it and log the error\nThe function _run_callback already logs the error\nthere is no IOLoop.handle_callback_exception\nPS I used handle_callback_exception to implement my own exception handler\n[0] https://github.com/facebook/tornado/blob/master/tornado/iostream.py#L239", "issue_status": "Closed", "issue_reporting_time": "2011-02-24T09:52:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1192": {"issue_url": "https://github.com/tornadoweb/tornado/issues/225", "issue_id": "#225", "issue_summary": "OPTIONS should not require an XSRF token", "issue_description": "danielgross commented on 23 Feb 2011\nThe change introduced in Tornado 1.1.1 lets GET and HEAD requests through without requiring a XSRF token.\nOPTIONS (and possibly TRACE, although it isn't considered a supported method) should be included as well.", "issue_status": "Closed", "issue_reporting_time": "2011-02-23T13:32:42Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1193": {"issue_url": "https://github.com/tornadoweb/tornado/issues/224", "issue_id": "#224", "issue_summary": "Make xhtml_escaping optional in tornado.escape.linkify", "issue_description": "Contributor\nghost commented on 23 Feb 2011\nThe function tornado.escape.linkify should have a parameter that prevent xhtml_escaping of the provided string to linkify.", "issue_status": "Closed", "issue_reporting_time": "2011-02-22T20:33:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1194": {"issue_url": "https://github.com/tornadoweb/tornado/issues/223", "issue_id": "#223", "issue_summary": "IOStream connect callback is called even when connection is refused (only kqueue)", "issue_description": "Contributor\nrickardb commented on 21 Feb 2011\nIn a kqueue based environment, iostream's connect callback is called even when the connection is refused. Some investigation shows that this is due to the fact that iostream's _hande_events gets a WRITE event for the given file descriptor.\nSimple example: https://gist.github.com/837089\nAdding some output to IOStream._handle_events shows the following log for kqueue:\n[I 110221 15:04:11 iostream:192] _handle_events, fd: 6  events: 0x4\n[I 110221 15:04:11 app:19] on_connect\n[I 110221 15:04:11 iostream:192] _handle_events, fd: 6  events: 0x1\n[W 110221 15:04:11 iostream:290] Read error on 6: [Errno 61] Connection refused\n[I 110221 15:04:11 app:22] on_closed\nSelect gives the following log:\n[I 110221 15:23:37 iostream:192] _handle_events, fd: 5  events: 0x5\n[W 110221 15:23:37 iostream:290] Read error on 5: [Errno 61] Connection refused\n[I 110221 15:23:37 app:22] on_closed\nAnd epoll gives the following:\n[I 110221 15:25:19 iostream:192] _handle_events, fd: 3  events: 0x2018\n[I 110221 15:25:19 app:22] on_closed", "issue_status": "Closed", "issue_reporting_time": "2011-02-21T14:28:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1195": {"issue_url": "https://github.com/tornadoweb/tornado/issues/221", "issue_id": "#221", "issue_summary": "Error to run authdemo.py when set env var USE_SIMPLE_HTTPCLIENT=1", "issue_description": "edersohe commented on 19 Feb 2011\n$> USE_SIMPLE_HTTPCLIENT=1 python authdemo.py\n[E 110218 12:06:37 iostream:221] Uncaught exception, closing connection.\nTraceback (most recent call last):\nFile \"/home/edersohe/Ambientes/tornado/lib/python2.6/site-packages/tornado/iostream.py\", line 204, in _handle_events\nself._handle_connect()\nFile \"/home/edersohe/Ambientes/tornado/lib/python2.6/site-packages/tornado/iostream.py\", line 451, in _handle_connect\n**self._ssl_options)\nFile \"/usr/lib/python2.6/ssl.py\", line 338, in wrap_socket\nsuppress_ragged_eofs=suppress_ragged_eofs)\nFile \"/usr/lib/python2.6/ssl.py\", line 118, in init\ncert_reqs, ssl_version, ca_certs)\nSSLError: [Errno 185090050] _ssl.c:328: error:0B084002:x509 certificate routines:X509_load_cert_crl_file:system lib", "issue_status": "Closed", "issue_reporting_time": "2011-02-18T18:36:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1196": {"issue_url": "https://github.com/tornadoweb/tornado/issues/220", "issue_id": "#220", "issue_summary": "AttributeError in Tornado ioloop", "issue_description": "l0k9j8 commented on 18 Feb 2011\nTornado crashes when I set concurrency count over 500 in \"ab\" or \"jmeter\".\nError log:\ntornado.ioloop.IOLoop.instance().start()\nFile \"C:\\Python26\\lib\\site-packages\\tornado\\ioloop.py\", line 234, in start\nif (getattr(e, 'errno') == errno.EINTR or\nAttributeError: 'exceptions.ValueError' object has no attribute 'errno'", "issue_status": "Closed", "issue_reporting_time": "2011-02-18T07:51:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1197": {"issue_url": "https://github.com/tornadoweb/tornado/issues/219", "issue_id": "#219", "issue_summary": "_cookie_signature ignores delimiters", "issue_description": "rickyz commented on 14 Feb 2011\nI see that there's a comment in the code indicating that this is known, but it seems that the secure cookie function still hmacs the contents of cookies with the delimiter character removed. As a result, a user can cause a 500 error by moving a cookie delimiter to the beginning, causing the int() call to throw a ValueError.\nI see that you want to maintain backwards compatibility with the cookie, but in this case, I think it'd really be better to break compatibility and hmac the entire contents of the cookie before processing any of it:\ndiff --git a/tornado/web.py b/tornado/web.py\nindex 904336e..0a2f30d 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -321,6 +321,9 @@ class RequestHandler(object):\n\n         To read a cookie set with this method, use get_secure_cookie().\n         \"\"\"\n+        if '|' in name:\n+            # Disallow delimiter characters in secure cookie names.\n+            raise ValueError(\"Invalid secure cookie %r: %r\" % (name, value))\n         self.set_cookie(name, self.create_signed_value(name, value),\n                         expires_days=expires_days, **kwargs)\n\n@@ -379,10 +382,10 @@ class RequestHandler(object):\n\n     def _cookie_signature(self, *parts):\n         self.require_setting(\"cookie_secret\", \"secure cookies\")\n-        hash = hmac.new(self.application.settings[\"cookie_secret\"],\n-                        digestmod=hashlib.sha1)\n-        for part in parts: hash.update(part)\n-        return hash.hexdigest()\n+        cookie_hmac = hmac.new(self.application.settings[\"cookie_secret\"],\n+                               digestmod=hashlib.sha1)\n+        cookie_hmac.update('|'.join(parts))\n+        return cookie_hmac.hexdigest()\n\n     def redirect(self, url, permanent=False):\n         \"\"\"Sends a redirect to the given (optionally relative) URL.\"\"\"", "issue_status": "Closed", "issue_reporting_time": "2011-02-14T07:41:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1198": {"issue_url": "https://github.com/tornadoweb/tornado/issues/217", "issue_id": "#217", "issue_summary": "Secure WebSockets (wss) fail due to location mismatch (fix patch included)", "issue_description": "riskable commented on 10 Feb 2011\nIn Tornado 1.1 and 1.1.1, secure WebSocket URLs (wss://) do not work correctly due to the fact that websocket.py has a hard-coded \"Sec-WebSocket-Location\" response header (ws://). In the development branch this is fixed (it has an entirely different websocket.py) but the dev branch has too many other issues at the moment (with SSL anyway) for it to be usable. Fortunately, there's a quick fix:\n--- websocket.py-orig   2011-02-10 12:19:45.000000000 -0500\n+++ websocket.py        2011-02-10 12:20:05.405287003 -0500\n@@ -93,16 +93,19 @@\n        self._write_response(challenge_response)\n\n    def _write_response(self, challenge):\n+       scheme = \"wss\" if self.request.headers['Origin'].startswith('https') \\\n+           else \"ws\"\n        self.stream.write(\n            \"HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n\"\n            \"Upgrade: WebSocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Server: TornadoServer/%(version)s\\r\\n\"\n            \"Sec-WebSocket-Origin: %(origin)s\\r\\n\"\n-            \"Sec-WebSocket-Location: ws://%(host)s%(path)s\\r\\n\"\n+            \"Sec-WebSocket-Location: %(scheme)s://%(host)s%(path)s\\r\\n\"\n            \"\\r\\n%(challenge)s\" % (dict(\n                    version=tornado.version,\n                    origin=self.request.headers[\"Origin\"],\n+                   scheme=scheme,\n                    host=self.request.host,\n                    path=self.request.path,\n                    challenge=challenge)))\nBy using the 'Origin' request header we can (reliably) determine the protocol being used to connect (Note: self.request.protocol is always \"http\" for some reason) and adjust the \"Sec-WebSocket-Location\" header accordingly. This should always work since all browsers that support WebSockets also support (and use) the 'Origin' header.", "issue_status": "Closed", "issue_reporting_time": "2011-02-10T17:31:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1199": {"issue_url": "https://github.com/tornadoweb/tornado/issues/216", "issue_id": "#216", "issue_summary": "1.1.1 from pypi borked", "issue_description": "sirpengi commented on 9 Feb 2011\nInstalling (via pip install tornado) from pypi installs a broken version of tornado.\nThe following is from the hello world example:\nTraceback (most recent call last):\n  File \"server.py\", line 13, in <module>\n    application.listen(8888)\nAttributeError: 'Application' object has no attribute 'listen'\nLooking in the virtualenv site-packages, I see the class Application in web.py does not contain the listen method.\nSource:\nhttp://pypi.python.org/pypi/tornado/1.1.1", "issue_status": "Closed", "issue_reporting_time": "2011-02-09T08:26:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1200": {"issue_url": "https://github.com/tornadoweb/tornado/issues/214", "issue_id": "#214", "issue_summary": "Tornado vulnerable to XSRF attack", "issue_description": "nealpoole commented on 9 Feb 2011\nhttps://github.com/facebook/tornado/blob/master/tornado/web.py#L736 checks for the presence of an X-Requested-With header as a way to mitigate XSRF attacks. Recently, Ruby on Rails and Django replaced similar checks, citing a vulnerability.that allows an attacker to cause a user to make cross-domain requests with custom headers.\nSources:\nhttp://www.djangoproject.com/weblog/2011/feb/08/security/\nhttp://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails", "issue_status": "Closed", "issue_reporting_time": "2011-02-09T04:34:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1201": {"issue_url": "https://github.com/tornadoweb/tornado/issues/211", "issue_id": "#211", "issue_summary": "SSLIOStream doesn't handle feckless http requests properly", "issue_description": "janssen commented on 4 Feb 2011\nYou can put tornado into an endless loop by connecting to an HTTPS server with a simple HTTP (or even socket) connection.\nHere's a fix (against the 1.1 release):\ndiff -r -u tornado-1.1/tornado/iostream.py tornado-1.1-patched/tornado/iostream.py\n--- tornado-1.1/tornado/iostream.py 2010-08-30 12:56:24.000000000 -0700\n+++ tornado-1.1-patched/tornado/iostream.py 2011-02-03 17:25:51.247581835 -0800\n@@ -269,7 +269,7 @@\n             elif err.args[0] in (ssl.SSL_ERROR_EOF,\n                                  ssl.SSL_ERROR_ZERO_RETURN):\n                 return self.close()\n-            raise\n+            return self.close()\n         except socket.error, err:\n             if err.args[0] == errno.ECONNABORTED:\n                 return self.close()", "issue_status": "Closed", "issue_reporting_time": "2011-02-04T01:34:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1202": {"issue_url": "https://github.com/tornadoweb/tornado/issues/210", "issue_id": "#210", "issue_summary": "tornado.httpserver.HTTPRequest.full_url() fails on HTTPS", "issue_description": "janssen commented on 4 Feb 2011\nThe HTTPRequest class can't accurately determine its protocol setting when used in an HTTPS server, so it forms urls that say \"http://...\" instead of \"https://...\".", "issue_status": "Closed", "issue_reporting_time": "2011-02-04T01:10:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1203": {"issue_url": "https://github.com/tornadoweb/tornado/issues/209", "issue_id": "#209", "issue_summary": "Minor error in template.py documentation", "issue_description": "metachris commented on 2 Feb 2011\nhttps://github.com/facebook/tornado/blob/master/tornado/template.py#L56\nSays\n{% block student %}\n  <li><span style=\"bold\">{{ escape(student.name) }}</span></li>\n{% block %}\nShould be\n{% block student %}\n  <li><span style=\"bold\">{{ escape(student.name) }}</span></li>\n{% end %}", "issue_status": "Closed", "issue_reporting_time": "2011-02-01T22:47:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1204": {"issue_url": "https://github.com/tornadoweb/tornado/issues/208", "issue_id": "#208", "issue_summary": "WebSocket Handshake URI", "issue_description": "sarva commented on 25 Jan 2011\nRequesting a WebSocket connection with url ws://localhost:8895?foo=bar results in error message (chromium):\nError during WebSocket handshake: location mismatch: ws://localhost:8895/?foo=bar != ws://localhost:8895/\nThe handshake URI seems to be using self.request.path which does not including the GET parameters.\nShould self.request.uri be used instead?", "issue_status": "Closed", "issue_reporting_time": "2011-01-25T03:18:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1205": {"issue_url": "https://github.com/tornadoweb/tornado/issues/207", "issue_id": "#207", "issue_summary": "httpclient fails on headers where value contains ': '", "issue_description": "rawler commented on 24 Jan 2011\nHttpClient generates a warning if the servers respond with a header containing the string ': '. AFAICT, such headers are allowed according to the HTTP-spec in the specification of field-content. (http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2)\nLuckily, the fix is simple, just add a limit to the split performed in _curl_header_callback:\nparts = header_line.split(\": \", 1)", "issue_status": "Closed", "issue_reporting_time": "2011-01-24T15:17:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1206": {"issue_url": "https://github.com/tornadoweb/tornado/issues/205", "issue_id": "#205", "issue_summary": "RedirectHandler called with wrong signature", "issue_description": "podados commented on 15 Jan 2011\ntornado/web.py line 1157\ncurrent - handler = RedirectHandler(\nself, request, \"http://\" + self.default_host + \"/\")\nought to be - handler = RedirectHandler(\nself, request, url=\"http://\" + self.default_host + \"/\")", "issue_status": "Closed", "issue_reporting_time": "2011-01-15T06:48:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1207": {"issue_url": "https://github.com/tornadoweb/tornado/issues/202", "issue_id": "#202", "issue_summary": "HTTPRequest.protocol not correctly set using HTTPServer", "issue_description": "johnboxall commented on 10 Jan 2011\nHey guys - thanks for the awesome project!\nHTTPRequest.protocol is not correctly set when using the HTTPServer with ssl_options. Connections made over SSL are reported to use HTTP.\nThe problem seems to be that HTTPRequest.__init__ isn't passed any protocol information from HTTPConnection (which should know that the connection was made over SSL).", "issue_status": "Closed", "issue_reporting_time": "2011-01-09T20:46:50Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1208": {"issue_url": "https://github.com/tornadoweb/tornado/issues/200", "issue_id": "#200", "issue_summary": "Untitled", "issue_description": "jonchu commented on 26 Dec 2010\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2010-12-26T06:37:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1209": {"issue_url": "https://github.com/tornadoweb/tornado/issues/198", "issue_id": "#198", "issue_summary": "Add UIModule.html_body before adding UIModule.embedded_javascript to rendered template", "issue_description": "kwellman commented on 17 Dec 2010\nEmbedded javascript should go at the very end of the , but will come before any html returned by the UIModule.html_body method because of the order they are added in the RequestHandler.render method.\nExample use-case where order matters...\nUsing the Facebook Javascript SDK, the html \"\n\" needs to come before the embedded javascript as follows:\n(source: http://developers.facebook.com/docs/reference/javascript/)\n<script src=\"http://connect.facebook.net/en_US/all.js\"\\>\\ <script> FB.init({ appId : 'YOUR APP ID', status : true, // check login status cookie : true, // enable cookies to allow the server to access the session xfbml : true // parse XFBML }); </script>", "issue_status": "Closed", "issue_reporting_time": "2010-12-17T06:00:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1210": {"issue_url": "https://github.com/tornadoweb/tornado/issues/195", "issue_id": "#195", "issue_summary": "Timeouts are using an inefficient data structure", "issue_description": "OleLaursen commented on 16 Dec 2010\nHi!\nI was trying to use the timeouts to time out clients that don't close the connection after a while. This means I get quite a bunch of timeouts (they're on the order of 5-10 minutes each), which in turn completely killed the server under load.\nA big part of this load appears to be because the timeouts are handled inefficiently. Long story below, in short I have a simple patch that helped me a lot. I don't think it's perfect, but it's at least much better.\nHere are the problems:\nWhen adding a timeout, bisect.insort is used on an array. If a timeout ends up in the middle of the array, Python has to move each element from that position and onwards one place to the right. With n insertions, this is O(n2) I believe - of course new timeouts are probably more likely to end up at the end, so it's not as bad as it could be but still.\nWhen removing a timeout, remove is called on the array. Same story, every element after it now has to be shifted one place to the left.\nWhen actually using a timeout, .pop(0) is used to remove it from the array. This removes the first element, so each and every element after it has to be shifted one place to the left.\nWhile the last item can be solved by sorting the array backwards (why this wasn't done in the first place is beyond me :), we can use a heap instead, the implementation is bundled with Python and it turns inserting and popping into O(log n) operations. Removing an arbitrary element is harder, in my patch I search the array with .index() (which is hopefully using a native implementation) and then just clear the callback. When popping elements, we can then skip those with empty callbacks.", "issue_status": "Closed", "issue_reporting_time": "2010-12-15T21:16:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1211": {"issue_url": "https://github.com/tornadoweb/tornado/issues/194", "issue_id": "#194", "issue_summary": "ErrorHandler exception on server autoreload", "issue_description": "parente commented on 15 Dec 2010\nAutoreload is a funny case, but this exception seems to be pointing at a place that is constructing a bad ErrorHandler object:\n[E 101214 13:57:48 iostream:218] Uncaught exception, closing connection.\n    Traceback (most recent call last):\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 196, in _handle_events\n        self._handle_read()\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 255, in _handle_read\n        if self._read_from_buffer():\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 321, in _read_from_buffer\n        self._consume(loc + delimiter_len))\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 227, in _run_callback\n        callback(*args, **kwargs)\n      File \"/Users/parente/projects/tornado/tornado/stack_context.py\", line 173, in wrapped\n        callback(*args, **kwargs)\n      File \"/Users/parente/projects/tornado/tornado/httpserver.py\", line 350, in _on_headers\n        self.stream.read_bytes(content_length, self._on_request_body)\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 146, in read_bytes\n        if self._read_from_buffer():\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 311, in _read_from_buffer\n        self._run_callback(callback, self._consume(num_bytes))\n      File \"/Users/parente/projects/tornado/tornado/iostream.py\", line 227, in _run_callback\n        callback(*args, **kwargs)\n      File \"/Users/parente/projects/tornado/tornado/stack_context.py\", line 173, in wrapped\n        callback(*args, **kwargs)\n      File \"/Users/parente/projects/tornado/tornado/httpserver.py\", line 380, in _on_request_body\n        self.request_callback(self._request)\n      File \"/Users/parente/projects/tornado/tornado/web.py\", line 1163, in __call__\n        handler = ErrorHandler(self, request, 404)\n    TypeError: __init__() takes exactly 3 arguments (4 given)", "issue_status": "Closed", "issue_reporting_time": "2010-12-14T19:01:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1212": {"issue_url": "https://github.com/tornadoweb/tornado/issues/192", "issue_id": "#192", "issue_summary": "chatdemo crashes Python on Windows", "issue_description": "ghazel commented on 12 Dec 2010\nAfter authorization with Google, python.exe stops working.\nVersion info:\nWindows 7 x64\nPython 2.7 (r27:82525, Jul  4 2010, 07:43:08) [MSC v.1500 64 bit (AMD64)] on win32\ntornado-1.1-py2.7\nlibcurl 7.21.2\npycurl_ssl-7.19.0-py2.7\nThe stack points a finger at pycurl, kinda:\n>   ntdll.dll!0000000076f71c30()    \n    [Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll] \n    kernel32.dll!0000000076822c7a()     \n    msvcr90.dll!000000006295c7bc()  \n    pycurl.pyd!00000000024a7001()   \n    pycurl.pyd!00000000024a8c20()   \n    pycurl.pyd!000000000249a6d7()   \n    pycurl.pyd!000000000249345a()   \n    python27.dll!000000001e0ca9e9()     \n    python27.dll!000000001e10ec24()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e0a3351()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e41b()     \n    python27.dll!000000001e10ecca()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e10d2d8()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e0a3351()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e0def6e()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e41b()     \n    python27.dll!000000001e10ecca()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e007449()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e10d349()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e71d()     \n    python27.dll!000000001e1124af()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e0bc553()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e007449()     \n    python27.dll!000000001e08a475()     \n    python27.dll!000000001e10e41b()     \n    python27.dll!000000001e10ecca()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e10d2d8()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e10d2d8()     \n    python27.dll!000000001e10ecb4()     \n    python27.dll!000000001e1123d4()     \n    python27.dll!000000001e113bd9()     \n    python27.dll!000000001e113c79()     \n    python27.dll!000000001e13fc0a()     \n    python27.dll!000000001e140eea()     \n    python27.dll!000000001e14152a()     \n    python27.dll!000000001e141f23()     \n    python27.dll!000000001e0443f9()     \n    python.exe!000000001d00119e()   \n    kernel32.dll!000000007681f56d()     \n    ntdll.dll!0000000076f53021()    ", "issue_status": "Closed", "issue_reporting_time": "2010-12-12T09:38:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1213": {"issue_url": "https://github.com/tornadoweb/tornado/issues/191", "issue_id": "#191", "issue_summary": "StaticFileHandler, RedirectHandler, etc. don't allow **kwargs", "issue_description": "parente commented on 12 Dec 2010\nThe various subclasses of RequestHandler in web.py do not define **kwargs in their constructors. This precludes creating further subclasses that want to receive additional options and handle them in initialize instead of overriding init.", "issue_status": "Closed", "issue_reporting_time": "2010-12-12T03:21:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1214": {"issue_url": "https://github.com/tornadoweb/tornado/issues/186", "issue_id": "#186", "issue_summary": "new lines when using {% set ... %}", "issue_description": "Contributor\newang commented on 2 Dec 2010\nIs it possible to get rid of the new lines that are inserted when using {% set .... %}? Right now, each {% set ... %} that I use results in a new line.", "issue_status": "Closed", "issue_reporting_time": "2010-12-02T07:41:28Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1215": {"issue_url": "https://github.com/tornadoweb/tornado/issues/185", "issue_id": "#185", "issue_summary": "HTTPRequest.__repr__() has two 'remote_ip'", "issue_description": "xueruini commented on 1 Dec 2010\nnot a bug, but should be fixed.", "issue_status": "Closed", "issue_reporting_time": "2010-12-01T05:08:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1216": {"issue_url": "https://github.com/tornadoweb/tornado/issues/184", "issue_id": "#184", "issue_summary": "HTTPConnection in httpserver.py cause memory leak?", "issue_description": "kommit commented on 30 Nov 2010\nI'm running a test server under Windows, the code is using the sample code in the source code:\nfrom tornado import httpserver\nfrom tornado import ioloop\n\ndef handle_request(request):\n    message = \"You requested %s\\n\" % request.uri\n    request.write(\"HTTP/1.1 200 OK\\r\\nContent-Length: %d\\r\\n\\r\\n%s\" % (\n    len(message), message))\n    request.finish()\n\nhttp_server = httpserver.HTTPServer(handle_request)\nhttp_server.listen(8888)\nioloop.IOLoop.instance().start()\nwhen i use the apache benchmark tool to make lots of requests, the memory usage keeps increasing.\nI read the source code of httpserver.py, and I think the instance of HTTPConnection will never deleted. Even the client connection has been closed.\nI also tried to added a del method to the HTTPConnection class to print a message, but it is never called.\nIs it a problem? Or did I misunderstand the server / python garbage collection?", "issue_status": "Closed", "issue_reporting_time": "2010-11-30T10:22:55Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1217": {"issue_url": "https://github.com/tornadoweb/tornado/issues/182", "issue_id": "#182", "issue_summary": "Send a message over websocket to all clients conneted", "issue_description": "mishudark commented on 29 Nov 2010\nHow can I do it?", "issue_status": "Closed", "issue_reporting_time": "2010-11-28T20:00:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1218": {"issue_url": "https://github.com/tornadoweb/tornado/issues/181", "issue_id": "#181", "issue_summary": "template expressions parsed incorrectly", "issue_description": "Contributor\newang commented on 27 Nov 2010\nI have the following template:\n{{ response_obj = {'error': message} }}\n{{ json_encode(response_obj) }}\nThat template is called using self.render('template', message='test msg')\nIf templates are compiled directly to python, shouldn't the output be:\n{\"error\": \"test msg\"}\nbut instead, the follow is generated:\n{'error': 'test msg'}\n{\"error\": \"test msg\"}\nAny fixes for this issue?", "issue_status": "Closed", "issue_reporting_time": "2010-11-27T01:28:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1219": {"issue_url": "https://github.com/tornadoweb/tornado/issues/180", "issue_id": "#180", "issue_summary": "\"Etag\" header not sent for HEAD requests", "issue_description": "dcowgill commented on 25 Nov 2010\nRequestHandler.flush conveniently has built-in support for HEAD requests, but RequestHandler.finish doesn't add the Etag header to the response unless the method is GET.\nThis conditional:\nif (self._status_code == 200 and self.request.method == \"GET\" and\n    \"Etag\" not in self._headers):\nshould probably be testing self.request.method in [\"GET\", \"HEAD\"] instead.", "issue_status": "Closed", "issue_reporting_time": "2010-11-24T21:41:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1220": {"issue_url": "https://github.com/tornadoweb/tornado/issues/178", "issue_id": "#178", "issue_summary": "cannot set compress_whitespace's value for Template", "issue_description": "jeffreyhsu commented on 23 Nov 2010\ntornado template will trim all spaces. but i want to use\n to format my code.\ni found there's a parameter to configure this 'compress_whitespace', but there's no way to set this param. #bug", "issue_status": "Closed", "issue_reporting_time": "2010-11-23T03:18:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1221": {"issue_url": "https://github.com/tornadoweb/tornado/issues/175", "issue_id": "#175", "issue_summary": "unable to access arguments on multipart/form-data requests", "issue_description": "Contributor\njoshstaiger commented on 23 Nov 2010\nAfter commit 9e96555, I'm unable to access any arguments from multipart/form-data POST requests.\nAdditionally I'm seeing this in the logs:\n[W 101122 19:05:13 httpserver:369] Invalid multipart/form-data", "issue_status": "Closed", "issue_reporting_time": "2010-11-23T00:40:03Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1222": {"issue_url": "https://github.com/tornadoweb/tornado/issues/174", "issue_id": "#174", "issue_summary": "Disable _xsrf checking on a per-handler basis", "issue_description": "sgraham commented on 22 Nov 2010\nI'm using xsrf_cookies=True. PayPal IPN (and other similar things) post notifications, but they won't have the _xsrf cookie of course, so they're rejected.\nIt would be useful to be able to tag individual handlers as not needing _xsrf checks.", "issue_status": "Closed", "issue_reporting_time": "2010-11-22T01:16:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1223": {"issue_url": "https://github.com/tornadoweb/tornado/issues/171", "issue_id": "#171", "issue_summary": "format_date returns current date when working in the future", "issue_description": "davidrecordon commented on 17 Nov 2010\nSaw a comment in locale.py about forcing the full format for future dates, but in this case we're asking for full format from the start.\nt = datetime.datetime.strptime(\"2011-06-04T18:00:00+0000\", \"%Y-%m-%dT%H:%M:%S+0000\")\nt\ndatetime.datetime(2011, 6, 4, 18, 0)\nt = locale.format_date(t, relative=False, full_format=True, gmt_offset=0)\nt\n'November 16, 2010 at 11:51 pm'", "issue_status": "Closed", "issue_reporting_time": "2010-11-16T23:54:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1224": {"issue_url": "https://github.com/tornadoweb/tornado/issues/170", "issue_id": "#170", "issue_summary": "remove import IOLoop in auth.py", "issue_description": "yinhm commented on 13 Nov 2010\nSince there is no directly using IOLoop in auth.py, it should be safe to remove it.\nThen we don't not need to remove this line to make auth work with app engine.\ntnx.", "issue_status": "Closed", "issue_reporting_time": "2010-11-13T17:44:06Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1225": {"issue_url": "https://github.com/tornadoweb/tornado/issues/169", "issue_id": "#169", "issue_summary": "mistype in iostream.IOStream._add_io_state", "issue_description": "menghan commented on 6 Nov 2010\ncommit 2b44fac doesnot fix that bug correctly, 'if socket is None' should be 'if self.socket is None', I think it is a mistype.", "issue_status": "Closed", "issue_reporting_time": "2010-11-06T10:00:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1226": {"issue_url": "https://github.com/tornadoweb/tornado/issues/168", "issue_id": "#168", "issue_summary": "invalid translated language strings in locale.py", "issue_description": "Contributor\njehiah commented on 6 Nov 2010\nsome of the translated language strings in locale.py seem to be corrupt.\nfor example Japanese is listed as \"name\": u\"\\xe6\\xe6\\xe8\" when it should be \"name\": u\"\\u65e5\\u672c\\u8a9e\" or '\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e' in utf-8\nI think this problem is limited to the translated strings for Japanese, Korean, and Chinese (all 3), but I'm not qualified enough to verify all the others.\nhttps://github.com/facebook/tornado/blob/master/tornado/locale.py#L430", "issue_status": "Closed", "issue_reporting_time": "2010-11-05T20:36:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1227": {"issue_url": "https://github.com/tornadoweb/tornado/issues/164", "issue_id": "#164", "issue_summary": "Using websocket with SSL doesn't work.", "issue_description": "Contributor\nrickardb commented on 2 Nov 2010\nUsing the websocket module over SSL doesn't work because it doesn't honor the scheme in the WebSocket-Location header, and thus generating an exception in the browser:\nError during WebSocket handshake: location mismatch: wss://example.com/ws != ws://example.com/ws", "issue_status": "Closed", "issue_reporting_time": "2010-11-02T12:38:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1228": {"issue_url": "https://github.com/tornadoweb/tornado/issues/163", "issue_id": "#163", "issue_summary": "'socket' is sometimes None in IOStream::_add_io_state", "issue_description": "ithayer commented on 1 Nov 2010\nThis is during a _finish_request call. The stack trace is below. read_until calls read_to_buffer, which calls read_from_socket. It seems that in most cases, socket.recv inside read_from_socket raises an exception (errno.EWOULDBLOCK, also displayed below). However in the minority of cases, socket.recv returns \"\", which causes the socket to be closed. This causes the call to\n    self._add_io_state(self.io_loop.READ)\ninside IOStream::read_until to operate on a null socket. Is that expected?\nThe abnormal, exception case:\nTraceback (most recent call last):\nFile \"/root/debtapp/web/django_tornado/tornado/web.py\", line 814, in _stack_context\nyield\nFile \"/root/debtapp/web/django_tornado/tornado/stack_context.py\", line 77, in StackContext\nyield\nFile \"/usr/lib/python2.6/contextlib.py\", line 113, in nested\nyield vars\nFile \"/root/debtapp/web/django_tornado/tornado/stack_context.py\", line 126, in wrapped\ncallback(_args, *_kwargs)\nFile \"/root/debtapp/web/django_tornado/tornado/httpserver.py\", line 300, in _on_write_complete\nself._finish_request()\nFile \"/root/debtapp/web/django_tornado/tornado/httpserver.py\", line 322, in _finish_request\nself.stream.read_until(\"\\r\\n\\r\\n\", self._on_headers)\nFile \"/root/debtapp/web/django_tornado/tornado/iostream.py\", line 137, in read_until\nself._add_io_state(self.io_loop.READ)\nFile \"/root/debtapp/web/django_tornado/tornado/iostream.py\", line 371, in _add_io_state\nself.io_loop.update_handler(self.socket.fileno(), self._state)\nAttributeError: 'NoneType' object has no attribute 'fileno'\nThe 'normal' case:\nERROR:root:[Errno 11] Resource temporarily unavailable\nTraceback (most recent call last):\nFile \"/root/debtapp/web/django_tornado/tornado/iostream.py\", line 266, in _read_from_socket\nchunk = self.socket.recv(self.read_chunk_size)", "issue_status": "Closed", "issue_reporting_time": "2010-10-31T22:29:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1229": {"issue_url": "https://github.com/tornadoweb/tornado/issues/162", "issue_id": "#162", "issue_summary": "'socket' is sometimes None in IOStream::_add_io_state (duplicate)", "issue_description": "ithayer commented on 1 Nov 2010\nTraceback (most recent call last):\nFile \"/root/debtapp/web/django_tornado/tornado/web.py\", line 814, in _stack_context\nyield\nFile \"/root/debtapp/web/django_tornado/tornado/stack_context.py\", line 77, in StackContext\nyield\nFile \"/usr/lib/python2.6/contextlib.py\", line 113, in nested\nyield vars\nFile \"/root/debtapp/web/django_tornado/tornado/stack_context.py\", line 126, in wrapped\ncallback(_args, *_kwargs)\nFile \"/root/debtapp/web/django_tornado/tornado/httpserver.py\", line 300, in _on_write_complete\nself._finish_request()\nFile \"/root/debtapp/web/django_tornado/tornado/httpserver.py\", line 322, in _finish_request\nself.stream.read_until(\"\\r\\n\\r\\n\", self._on_headers)\nFile \"/root/debtapp/web/django_tornado/tornado/iostream.py\", line 137, in read_until\nself._add_io_state(self.io_loop.READ)\nFile \"/root/debtapp/web/django_tornado/tornado/iostream.py\", line 371, in _add_io_state\nself.io_loop.update_handler(self.socket.fileno(), self._state)\nAttributeError: 'NoneType' object has no attribute 'fileno'", "issue_status": "Closed", "issue_reporting_time": "2010-10-31T22:29:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1230": {"issue_url": "https://github.com/tornadoweb/tornado/issues/160", "issue_id": "#160", "issue_summary": "304 Responses sometimes include non zero Content-Length", "issue_description": "Contributor\namorton commented on 28 Oct 2010\nI think there is a small bug in the RequestHandler.\nI'm running Varnish > Nginx > Tornado and was getting occasional 503 errors from varnish. Which I tracked down to Tornado returning HTTP 304 with an empty response body but with Content-Length set to a non zero value.\nIt happens when the client makes a request for a static file with both If-Modified-Since and If-None-Match where the static file has a new modified date, but has not changed. The StaticFileHandler will notice the file has changed and stream it into the response, together with the Content-Length.\nRequestHandler.finish() will then look at the etag for the response, notice it's the same and clear the response without reseting the Content-Length. The following code in finish() only sets the Content-Length if it is not present.\nI was able to fix it by setting the Content-Length to 0 when finish() clears the response.\nCheers", "issue_status": "Closed", "issue_reporting_time": "2010-10-28T03:00:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1231": {"issue_url": "https://github.com/tornadoweb/tornado/issues/150", "issue_id": "#150", "issue_summary": "locale's format_date() does not with future dates", "issue_description": "csytan commented on 12 Oct 2010\nfrom tornado import locale\nimport datetime\na_week_from_now = datetime.datetime.now() + datetime.timedelta(days=7)\nprint a_week_from_now\n2010-10-18 23:41:09.561467\nl = locale.Locale.get_closest()\nprint l.format_date(a_week_from_now, relative=False, full_format=True)\nOctober 11, 2010 at 11:41 pm", "issue_status": "Closed", "issue_reporting_time": "2010-10-11T23:44:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1232": {"issue_url": "https://github.com/tornadoweb/tornado/issues/146", "issue_id": "#146", "issue_summary": "asynchronous connect", "issue_description": "ghazel commented on 8 Oct 2010\nI noticed in the demonstrations of IOStream a blocking sock.connect() call is used before the socket is made non-blocking and added to the IOLoop: http://github.com/facebook/tornado/blob/master/tornado/iostream.py#L46\nIt would be fairly simply to add non-blocking connect_ex support, and _handle_connect to the IOStream. I've done this in my own code. Is this a planned feature?", "issue_status": "Closed", "issue_reporting_time": "2010-10-07T22:06:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1233": {"issue_url": "https://github.com/tornadoweb/tornado/issues/145", "issue_id": "#145", "issue_summary": "Fix content_length test in httpserver.py", "issue_description": "ghost commented on 4 Oct 2010\nWithout that, if the client add header \"Content-Length: 0\", the stream wait for nothing.\nhttp://gist.github.com/610103", "issue_status": "Closed", "issue_reporting_time": "2010-10-04T17:18:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1234": {"issue_url": "https://github.com/tornadoweb/tornado/issues/143", "issue_id": "#143", "issue_summary": "New IOStream implementation doesn't detect closed socket in select and kqueue.", "issue_description": "Contributor\nrickardb commented on 27 Sep 2010\nThe commit f6f7f83 introduced a new implementation of IOStream.\nIn select (possibly kqueue as well?) a read event is generated when a socket is closed with zero bytes on the socket. In the old implementation of IOStream this was caught by the following code:\nLines 193-195 of iostream.py:\n    if not chunk:\n        self.close()\n        return\nIn the new implementation the socket is never closed under these conditions thus the read event will keep firing off on the socket.", "issue_status": "Closed", "issue_reporting_time": "2010-09-27T08:23:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1235": {"issue_url": "https://github.com/tornadoweb/tornado/issues/142", "issue_id": "#142", "issue_summary": "Incorrect for readme directions in tornado 1.1 tarball", "issue_description": "gtzilla commented on 23 Sep 2010\nThe website says:\nyou need to have PycURL (version 7.18.2 or higher)\nhowever, the README file says:\nsudo easy_install setuptools pycurl==7.16.2.1 simplejson\nrunning 7.16.2 with tornado 1.1 causes an endless loop error b/c pycurl.SOCKET_TIMEOUT does not exist. tornado falls into an endless loop.\nUsing the package on the site, and not in the readme resolves this\nsudo easy_install -U setuptools pycurl==7.18.2", "issue_status": "Closed", "issue_reporting_time": "2010-09-23T07:47:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1236": {"issue_url": "https://github.com/tornadoweb/tornado/issues/141", "issue_id": "#141", "issue_summary": "A defect in tornado/web.py", "issue_description": "ghost commented on 21 Sep 2010\nLine 1127-1129 (in Application.call)\nif not handlers:\nhandler = RedirectHandler(\nrequest, \"http://\" + self.default_host + \"/\")\nShould it be following?\nif not handlers:\nhandler = RedirectHandler(\nself, request, \"http://\" + self.default_host + \"/\")", "issue_status": "Closed", "issue_reporting_time": "2010-09-21T07:53:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1237": {"issue_url": "https://github.com/tornadoweb/tornado/issues/140", "issue_id": "#140", "issue_summary": "Authentication with FacebookGraph API sometimes fails.", "issue_description": "Contributor\nrickardb commented on 20 Sep 2010\nAuthentication with the Facebook Graph API somtimes generates an expection. This seems to be due to the fact that facebook doesn't return the 'expires' keyword in the response to _OAUTH_ACCESS_TOKEN_URL. Stacktrace:\nTraceback (most recent call last):\n  File \"vendor/tornado/tornado/web.py\", line 789, in wrapper\n    return callback(*args, **kwargs)\n  File \"vendor/tornado/tornado/auth.py\", line 967, in _on_access_token\n    \"expires\": cgi.parse_qs(response.body)[\"expires\"]\nKeyError: 'expires'\nLooking at response.body does indeed show that the expires keyword is not returned:\naccess_token=xxx", "issue_status": "Closed", "issue_reporting_time": "2010-09-20T15:10:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1238": {"issue_url": "https://github.com/tornadoweb/tornado/issues/137", "issue_id": "#137", "issue_summary": "Tornado main loop quits unexpectedly", "issue_description": "parente commented on 13 Sep 2010\nAn app I'm developing with tornado occasionally quits its main loop unexpectedly:\nTraceback (most recent call last):\n  File \"pbs3.py\", line 129, in \n    run_server(opts.port, opts.configPath, opts.debug)\n  File \"pbs3.py\", line 115, in run_server\n    ioloop.start()\n  File \"/Library/Python/2.6/site-packages/tornado-1.1-py2.6.egg/tornado/ioloop.py\", line 234, in start\n    if (getattr(e, 'errno') == errno.EINTR or\nAttributeError: 'exceptions.KeyError' object has no attribute 'errno'\nI know this traceback is pretty useless. It seems the try/except in start() should be catching all possible exceptions to prevent the main loop from quitting, but is missing something.", "issue_status": "Closed", "issue_reporting_time": "2010-09-13T15:33:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1239": {"issue_url": "https://github.com/tornadoweb/tornado/issues/135", "issue_id": "#135", "issue_summary": "PeriodicCallback can impede GC", "issue_description": "parente commented on 9 Sep 2010\nhttp://github.com/facebook/tornado/blob/master/tornado/ioloop.py#L380\nThe stop() method of PeriodicCallback (PC) should set this.callback to some sentinel (None) to avoid a cycle that might impede garbage collection (obj to which callback is bound <-> PC object).", "issue_status": "Closed", "issue_reporting_time": "2010-09-08T20:32:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1240": {"issue_url": "https://github.com/tornadoweb/tornado/issues/134", "issue_id": "#134", "issue_summary": "PeriodicCallback stop broken within callback", "issue_description": "parente commented on 9 Sep 2010\nhttp://github.com/facebook/tornado/blob/master/tornado/ioloop.py#L391\nIf the callback registered with PeriodicCallback (PC) invokes stop() on the PC instance within the callback, this information is lost when the PC reaches line 391 and blindly calls start() again on itself.\nThe start() on 391 should be guarded with an if self._running:", "issue_status": "Closed", "issue_reporting_time": "2010-09-08T20:29:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1241": {"issue_url": "https://github.com/tornadoweb/tornado/issues/133", "issue_id": "#133", "issue_summary": "websocket.py typo line 106", "issue_description": "pleasuredroids commented on 6 Sep 2010\nchalleng=challenge should read challenge=challenge", "issue_status": "Closed", "issue_reporting_time": "2010-09-06T18:21:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1242": {"issue_url": "https://github.com/tornadoweb/tornado/issues/132", "issue_id": "#132", "issue_summary": "tornado.escape has superfluous lambdas", "issue_description": "cwells commented on 6 Sep 2010\nlambda causes extra function call for no apparent reason:\n_json_decode = lambda s: json.loads(s)\n_json_encode = lambda v: json.dumps(v)\nShould just be:\n_json_decode = json.loads\n_json_encode = json.dumps\nGiven how often these functions are called, it's probably a measurable performance hit.", "issue_status": "Closed", "issue_reporting_time": "2010-09-06T05:29:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1243": {"issue_url": "https://github.com/tornadoweb/tornado/issues/131", "issue_id": "#131", "issue_summary": "Need Model", "issue_description": "cuimuxi commented on 5 Sep 2010\nNow, database wraper is too simple, need code so many SQL in action, and only support MySQL", "issue_status": "Closed", "issue_reporting_time": "2010-09-05T09:06:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1244": {"issue_url": "https://github.com/tornadoweb/tornado/issues/125", "issue_id": "#125", "issue_summary": "HTTPResponse.__init__ starts cyclical reference", "issue_description": "sagelywizard commented on 31 Aug 2010\nIn httpclient.py, the init method of the HTTPResponse class causes a memory leak when the response code is greater than 300 and less than 200. In the HTTPResponse init method, an HTTPError instance is created (when self.code < 200 or >= 300), which contains a reference to the original HTTPResponse.\nSo, HTTPResponse.init references HTTPError, HTTPError.init references HTTPResponse, which references HTTPResponse, which references HTTPError, rinse, repeat.\nThis causes a rather nasty memory leak. It'd probably be best for HTTPError to have a weak reference to HTTPResponse.\nIf you have any questions, feel free to contact me.", "issue_status": "Closed", "issue_reporting_time": "2010-08-31T17:28:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1245": {"issue_url": "https://github.com/tornadoweb/tornado/issues/124", "issue_id": "#124", "issue_summary": "Request handler mapping by string", "issue_description": "exavolt commented on 31 Aug 2010\nInstead of the class, use the class path (module + class name).\nhandlers = [(r'/account/login', 'account.LoginHandler')]\nthe reasons:\nno need to import the class explicitly (sometimes forgot to import to class)\nlazy load the module / class", "issue_status": "Closed", "issue_reporting_time": "2010-08-31T03:56:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1246": {"issue_url": "https://github.com/tornadoweb/tornado/issues/123", "issue_id": "#123", "issue_summary": "HTTPServer docstring does not match with the code.", "issue_description": "Contributor\nfelinx commented on 28 Aug 2010\nSome guys are confused about http_server.start() when they reading the docstring of HTTPServer,\nThe docstring say (httpserver.py Line: 119):\nhttp_server.start() # Forks multiple sub-processes\nAcutally, start() without args will not fork sub-processes because\nthe default num_processes has been modified to one rather than None as before.\nThe docstring description does not match with the code now, maybe you need update this paragraph.\nBy default, listen() runs in a single thread in a single process. You\ncan utilize all available CPUs on this machine by calling bind() and\nstart() instead of listen():\n\n    http_server = httpserver.HTTPServer(handle_request)\n    http_server.bind(8888)\n    http_server.start() # Forks multiple sub-processes\n    ioloop.IOLoop.instance().start()\n\nstart() detects the number of CPUs on this machine and \"pre-forks\" that\nnumber of child processes so that we have one Tornado process per CPU,\nall with their own IOLoop. You can also pass in the specific number of\nchild processes you want to run with if you want to override this\nauto-detection.", "issue_status": "Closed", "issue_reporting_time": "2010-08-28T04:59:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1247": {"issue_url": "https://github.com/tornadoweb/tornado/issues/122", "issue_id": "#122", "issue_summary": "RequestHandler.write doesn't convert list as json", "issue_description": "paparent commented on 28 Aug 2010\nCurrently only dict are converted to JSON and set the header, and not lists.", "issue_status": "Closed", "issue_reporting_time": "2010-08-27T20:48:53Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1248": {"issue_url": "https://github.com/tornadoweb/tornado/issues/121", "issue_id": "#121", "issue_summary": "pycurl's lack of thread safety affects Tornado, causing segfaults", "issue_description": "slingamn commented on 26 Aug 2010\nWe were using the blocking HTTPClient in some multithreaded code and we started getting segmentation faults. We think they were caused by libcurl/pycurl's use of signals to implement timeouts, as discussed here:\nhttp://www.python-forum.org/pythonforum/viewtopic.php?f=5&t=9395\nWe monkeypatched tornado.httpclient._curl_create to do:\ncurl.setopt(pycurl.NOSIGNAL, 1)\nwhich fixed the segmentation fault issues. The libcurl documentation indicates that this breaks DNS lookup timeouts on some builds:\nhttp://curl.haxx.se/libcurl/c/curl_easy_setopt.html\nso it may not be a desirable solution. Thoughts? Thanks for your time.", "issue_status": "Closed", "issue_reporting_time": "2010-08-26T05:47:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1249": {"issue_url": "https://github.com/tornadoweb/tornado/issues/120", "issue_id": "#120", "issue_summary": "locale.list method returns \"and\" in English only", "issue_description": "tetsuo commented on 21 Aug 2010\nhere's a fix to depend it on translations:\nhttp://pastebin.org/643787", "issue_status": "Closed", "issue_reporting_time": "2010-08-21T12:05:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1250": {"issue_url": "https://github.com/tornadoweb/tornado/issues/119", "issue_id": "#119", "issue_summary": "tornado.web.authenticated does not redirect correct if we use subdomain", "issue_description": "Contributor\nfelinx commented on 6 Aug 2010\nFor example:\nlogin_url:\nhttp://poweredsites.org/login\nurl which need authenticated:\nhttp://blog.poweredsites.org/compose\nIt will redirect to http://poweredsites.org/compose after authenticated success because authenticated use uri rather than full_url(), that's not correct for next url.\ntornado.web.authenticated:\nurl += \"?\" + urllib.urlencode(dict(next=self.request.uri))\nfix this line to below, then it will work well:\nurl += \"?\" + urllib.urlencode(dict(next=self.request.full_url()))", "issue_status": "Closed", "issue_reporting_time": "2010-08-06T09:18:12Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1251": {"issue_url": "https://github.com/tornadoweb/tornado/issues/118", "issue_id": "#118", "issue_summary": "Untitled", "issue_description": "Sh4rK commented on 5 Aug 2010\nHi Everybody!\nI forked Tornado, and modified it, so if you run 2to3 on it, it produces correct Python 3 code (sometimes a bit ugly though).\nThe problem is, while it doesn't give any exceptions, it doesn't actually do anything (browser hangs).\nIf you know why is this, please help me!", "issue_status": "Closed", "issue_reporting_time": "2010-08-04T20:35:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1252": {"issue_url": "https://github.com/tornadoweb/tornado/issues/117", "issue_id": "#117", "issue_summary": "websocket support", "issue_description": "GvS666 commented on 24 Jul 2010\nI'm working on web app using tornado with websockets and now suddenly they are not supported anymore. Any ETA on new version of websockets?", "issue_status": "Closed", "issue_reporting_time": "2010-07-24T11:34:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1253": {"issue_url": "https://github.com/tornadoweb/tornado/issues/116", "issue_id": "#116", "issue_summary": "tornado.escape should use simplejson by default (instead of built-in json)", "issue_description": "benweatherman commented on 22 Jul 2010\nIn my testing, simplejson is several orders of magnitude faster than the built-in json module. I think tornado.escape should try to load simplejson first and only fallback to json if simplejson isn't installed.", "issue_status": "Closed", "issue_reporting_time": "2010-07-21T18:48:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1254": {"issue_url": "https://github.com/tornadoweb/tornado/issues/115", "issue_id": "#115", "issue_summary": "URI parsing breaks with optional captured groups", "issue_description": "pmccurdy commented on 20 Jul 2010\nIf you have an URI regex like /foo/(bar)? (that is, an optional captured group), the regex match will return a None element if you match against plain /foo/, since the string matches but the group doesn't exist. But you can't unquote None, so the recent change to unquote URI matches in commit 557da3d breaks.\nThe following patch fixes it, at least for me (though I'll confess that I took the opportunity to clean up my URI matching to no longer have any optional captured groups, for sanity, so it's no longer much of a pressing concern for me).\ndiff --git a/tornado/web.py b/tornado/web.py\nindex 3beac23..d75ccd0 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -1069,7 +1069,7 @@ class Application(object):\n                     if kwargs:\n                         args = []\n                     else:\n-                        args = [urllib.unquote(s) for s in match.groups()]\n+                        args = [s and urllib.unquote(s) for s in match.groups()]\n                     break\n             if not handler:\n                 handler = ErrorHandler(self, request, 404)", "issue_status": "Closed", "issue_reporting_time": "2010-07-20T04:49:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1255": {"issue_url": "https://github.com/tornadoweb/tornado/issues/114", "issue_id": "#114", "issue_summary": "Remove dependency on json module when json_{encode,decode} not used", "issue_description": "lelutin commented on 20 Jul 2010\nThe escape.py file currently forces users to install one of python-json or python-simplejson. For content that isn't planning on using json functionality at all, it adds a useless dependency. JSON modules should only be forcefully required when json_{encode,decode} are used.", "issue_status": "Closed", "issue_reporting_time": "2010-07-19T20:28:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1256": {"issue_url": "https://github.com/tornadoweb/tornado/issues/112", "issue_id": "#112", "issue_summary": "Facebook Mixin should be ported to use OAuth 2.0", "issue_description": "douglasgraves commented on 16 Jul 2010\nAny plans to switch the Facebook Mixin in auth.py over to their new way of authenticating users? Looks like the mixin currently uses the deprecated Facebook Connect method. While we're at it, it would be awesome if the facebook login url could be easily overridden for Facebook's \"m\" and \"touch\" subdomains for mobile devices\u2014subclassing a few dozen lines of code to simply change a few characters in the login url seems a bit silly.", "issue_status": "Closed", "issue_reporting_time": "2010-07-15T20:58:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1257": {"issue_url": "https://github.com/tornadoweb/tornado/issues/111", "issue_id": "#111", "issue_summary": "last update CONVERSIONS problem", "issue_description": "klen commented on 14 Jul 2010\nTraceback (most recent call last):\nFile \"./auth.py\", line 14, in\nimport tornado.database\nFile \"/home/klen/Projects/vsyako/project/apps/tornado/database.py\", line 175, in\nCONVERSIONS[field_type].insert(0, (FLAG.BINARY, str))\nTypeError: unhashable type: 'list'", "issue_status": "Closed", "issue_reporting_time": "2010-07-14T13:42:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1258": {"issue_url": "https://github.com/tornadoweb/tornado/issues/110", "issue_id": "#110", "issue_summary": "HTTPClient & AsyncHTTPClient Lag/Overhead", "issue_description": "vishnevskiy commented on 13 Jul 2010\nI am using HTTPClient and AsyncHTTPClient to talk to a local\nHTTPServer for RPC calls (POST with body)\nOn the first request its really fast, but every request after its\nalways 30ms overhead. I tested all around the code.\nPut this an output into HTTPConnection\ndef _on_request_body(self, data):\nlogging.warning(\"TEST %.2fms\", 1000.0 * (time.time() -\nself._request._start_time))\n// other code goes here\nAt this point there is 30ms overhead.\nIt is also not the server's fault it seems, but the client's.\nBecause if I restart the process that is using the client and make\nanother request, its fast for the first one, and then 30ms for the\nrest. (Works anytime I restart the process with HTTPClient)\nIf I do not have a request body, then this is not an issue. Is CURL\nhaving a delay before sending the body or something?\nAny ideas?", "issue_status": "Closed", "issue_reporting_time": "2010-07-13T00:25:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1259": {"issue_url": "https://github.com/tornadoweb/tornado/issues/109", "issue_id": "#109", "issue_summary": "RequestHandler.write should also auto-convert lists to JS", "issue_description": "benweatherman commented on 12 Jul 2010\nCurrently, RequestHandler.write will automatically detect writing dict and chunk it as JS. Shouldn't list be the same way?", "issue_status": "Closed", "issue_reporting_time": "2010-07-12T16:49:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1260": {"issue_url": "https://github.com/tornadoweb/tornado/issues/108", "issue_id": "#108", "issue_summary": "can i have a testcase in tornado like django test ?", "issue_description": "kulasama commented on 12 Jul 2010\nhi all\ni want to write testcase like django test on tornado. any idea?", "issue_status": "Closed", "issue_reporting_time": "2010-07-12T01:52:38Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1261": {"issue_url": "https://github.com/tornadoweb/tornado/issues/107", "issue_id": "#107", "issue_summary": "WSGIContainer doesn't properly call close", "issue_description": "jokey2k commented on 11 Jul 2010\nAfter wondering why my DB Connections explode, I found that the close handling after a request is not done properly, the close is called on a list.\nHere's a patch to fix that:\n--- a/tornado/wsgi.py\n+++ b/tornado/wsgi.py\n@@ -219,11 +219,15 @@ class WSGIContainer(object):\ndata[\"status\"] = status\ndata[\"headers\"] = response_headers\nreturn response.append\n   response.extend(self.wsgi_application(\n           WSGIContainer.environ(request), start_response))\n   body = \"\".join(response)\n   if hasattr(response, \"close\"):\n       response.close()\n   app_iter = self.wsgi_application(\n       WSGIContainer.environ(request), start_response)\n   try:\n       for resp in app_iter:\n           response.extend(resp)\n   finally:\n       body = \"\".join(response)\n       if hasattr(app_iter, \"close\"):\n           app_iter.close()\n if not data: raise Exception(\"WSGI app did not call start_response\")\n\n status_code = int(data[\"status\"].split()[0])", "issue_status": "Closed", "issue_reporting_time": "2010-07-11T09:09:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1262": {"issue_url": "https://github.com/tornadoweb/tornado/issues/106", "issue_id": "#106", "issue_summary": "FacebookMixin still using REST", "issue_description": "swasheck commented on 29 Jun 2010\nIt's not really an \"issue\" per se but it seems that Facebook is moving away from the REST API and wanting developers to pick up on the Graph API. How much of an overhaul would that cause in auth.py?", "issue_status": "Closed", "issue_reporting_time": "2010-06-29T04:05:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1263": {"issue_url": "https://github.com/tornadoweb/tornado/issues/105", "issue_id": "#105", "issue_summary": "options.parse_config_file's argument 'overwrite' doesn't do anything", "issue_description": "mikelikespie commented on 24 Jun 2010\nNot sure what this argument should do. Its not reference anywhere in the function.", "issue_status": "Closed", "issue_reporting_time": "2010-06-23T22:30:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1264": {"issue_url": "https://github.com/tornadoweb/tornado/issues/104", "issue_id": "#104", "issue_summary": "ioloop.add_handler raises IOError only if ioloop._poll is select.epoll", "issue_description": "yangofzeal commented on 23 Jun 2010\nI'm trying to serve a large file during a GET request asynchronously. The following code works with os.popen(\"cat myfile\"), but doesn't work with open(\"myfile\") unless select.poll or ioloop._Select is used. If tornado.ioloop._poll == select.epoll, then I get an IOError (see below)\nI'm using the latest git version of the source with python 2.6.4 on Linux\nclass FileServer(tornado.web.RequestHandler):\n@tornado.web.asynchronous\ndef get(self):\nself.set_header(\"Content-Type\", \"applet/octet-stream\")\nself.ioloop = tornado.ioloop.IOLoop.instance()\nif 1:\n# works\ncmd = \"cat sample.dat\"\nself.pipe = os.popen(cmd)\nelif 0:\n# only works if tornado.ioloop._poll = select.poll or tornado.ioloop._Select\n# IOError if tornado.ioloop._poll = select.epoll\nself.pipe = open(\"sample.dat\",'r')\nself.ioloop.add_handler( self.pipe.fileno(), self.async_callback(self.on_read), self.ioloop.READ )\ndef on_read(self, fd, events):\nbuffer = self.pipe.read(1024)\ntry:\nassert buffer\nself.write(buffer)\nself.flush()\nexcept:\nself.pipe.close()\nself.ioloop.remove_handler(fd)\nself.finish()\nhere's the traceback from the server console output:\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/web.py\", line 770, in _execute\ngetattr(self, self.request.method.lower())(_args, *_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/web.py\", line 854, in wrapper\nreturn method(self, _args, *_kwargs)\nFile \"./fileserve.py\", line 25, in get\nself.ioloop.add_handler( self.pipe.fileno(), self.async_callback(self.on_read), self.ioloop.READ )\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/ioloop.py\", line 149, in add_handler\nself._impl.register(fd, events | self.ERROR)\nIOError: [Errno 1] Operation not permitted", "issue_status": "Closed", "issue_reporting_time": "2010-06-22T18:54:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1265": {"issue_url": "https://github.com/tornadoweb/tornado/issues/103", "issue_id": "#103", "issue_summary": "Google Mixin OpenID endpoint typo", "issue_description": "brimcfadden commented on 22 Jun 2010\nhttp://github.com/facebook/tornado/blob/master/tornado/auth.py#L613\n_OPENID_ENDPOINT = \"https://www.google.com/accounts/o8/ud\"\nshould be\n_OPENID_ENDPOINT = \"https://www.google.com/accounts/o8/id\"", "issue_status": "Closed", "issue_reporting_time": "2010-06-22T18:24:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1266": {"issue_url": "https://github.com/tornadoweb/tornado/issues/102", "issue_id": "#102", "issue_summary": "New version of WebSocket", "issue_description": "ghost commented on 21 Jun 2010\ndraft-ietf-hybi-thewebsocketprotocol-00 is new version of WebSocket. It's implamented in WebKit night build. draft-hixie-thewebsocketprotocol-75 version of the websocket's protocol is obsoleted and no longer supported in future version of browsers.", "issue_status": "Closed", "issue_reporting_time": "2010-06-21T15:34:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1267": {"issue_url": "https://github.com/tornadoweb/tornado/issues/101", "issue_id": "#101", "issue_summary": "Patch: workaround for libcurl CURL_MAX_WRITE_SIZE", "issue_description": "elephantum commented on 19 Jun 2010\nThe problem is the following: even the libcurl's documentation says that there is no need to run .perform() again after the E_OK is returned, the truth is more subtle. E_OK is returned in two different cases: 1) there is really nothing to do, 2) CURL_MAX_WRITE_SIZE of data was passed to write_function. There is no way to check whether there is any data available right now. Even epoll'ing wouldn't help in some cases, when data is read into internal libcurl's buffers. This behavior significantly degrades performance of fetching http-resources which are bigger than 16Kb. It is especially well seen when some synchronous work should be done (50-100ms XSL transformations in my case).\nThe problem can be illustrated with this snippet of code: http://gist.github.com/444860/ run it before and after the patch to feel the difference in downloading speed.\nI've developed a workaround for the given problem which I propose for merge into tornado: http://github.com/elephantum/tornado/commit/384ce35b9c4b5de9cb247ac4bd5c810ca632daa0", "issue_status": "Closed", "issue_reporting_time": "2010-06-19T13:36:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1268": {"issue_url": "https://github.com/tornadoweb/tornado/issues/100", "issue_id": "#100", "issue_summary": "Secure websocket with ssl_options fails", "issue_description": "parente commented on 9 Jun 2010\nTested in Safari 5.\nEnable ssl_options on the Application object with a valid cert and key.\nVisit a static index.html page secured with https. Works fine.\nIn that index.html page, connect to a tornado.websocet.WebSocketHandler using wss://\nGet an exception server side about invalid EOF. Client\nERROR:root:Exception in I/O handler for fd 3\nTraceback (most recent call last):\nFile \"/Library/Python/2.6/site-packages/tornado-0.2-py2.6.egg/tornado/ioloop.py\", line 245, in start\nself._handlers[fd](fd, events)\nFile \"/Library/Python/2.6/site-packages/tornado-0.2-py2.6.egg/tornado/httpserver.py\", line 213, in _handle_events\nconnection, server_side=True, **self.ssl_options)\nFile \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/ssl.py\", line 350, in wrap_socket\nsuppress_ragged_eofs=suppress_ragged_eofs)\nFile \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/ssl.py\", line 118, in init\nself.do_handshake()\nFile \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/ssl.py\", line 293, in do_handshake\nself._sslobj.do_handshake()\nSSLError: [Errno 8] _ssl.c:480: EOF occurred in violation of protocol", "issue_status": "Closed", "issue_reporting_time": "2010-06-09T16:38:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1269": {"issue_url": "https://github.com/tornadoweb/tornado/issues/99", "issue_id": "#99", "issue_summary": "Template error on GAE", "issue_description": "paulosuzart commented on 9 Jun 2010\nHi guys, I'm getting the error:\n    if isinstance(_tmp, str): _buffer.append(_tmp)\nSyntaxError: invalid syntax^ (error points to ':')\nWhile rendering a template (small and simple, extends, fir block and if)\nAny way to solve the problem?\nThanks", "issue_status": "Closed", "issue_reporting_time": "2010-06-09T01:49:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1270": {"issue_url": "https://github.com/tornadoweb/tornado/issues/98", "issue_id": "#98", "issue_summary": "Missing import sys module in httpclient module", "issue_description": "Contributor\nfelinx commented on 7 Jun 2010\nMissing import sys module in httpclient module, it has been used at line245 and 246.", "issue_status": "Closed", "issue_reporting_time": "2010-06-07T07:39:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1271": {"issue_url": "https://github.com/tornadoweb/tornado/issues/97", "issue_id": "#97", "issue_summary": "when we write much more data, iostream will raise 'message too long' exception.", "issue_description": "kulasama commented on 7 Jun 2010\nwhen i use iostream.py to write big data.\nthere will raise a exception.\nfixed code bellow:\niostream.py 215 num_bytes = self.socket.send(self._write_buffer)\nchanged to this code num_bytes = self.socket.send(self._write_buffer[:8192])\nthen fixed this bug.", "issue_status": "Closed", "issue_reporting_time": "2010-06-07T03:58:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1272": {"issue_url": "https://github.com/tornadoweb/tornado/issues/96", "issue_id": "#96", "issue_summary": "urllib.unquote() for static file handler", "issue_description": "davidk commented on 31 May 2010\nI ran into an issue where static files with spaces (%20) were not being served properly since they were being fed directly into os.path.* in web.py's StaticFileHandler class for processing and 404ed.\nHacked a one-line fix for this using urllib.unquote() which seems to have cured things:\nhttp://github.com/davidk/tornado/commit/9ee458067b3137daa4809fc43dbe6c5b6f32dfd7", "issue_status": "Closed", "issue_reporting_time": "2010-05-31T11:40:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1273": {"issue_url": "https://github.com/tornadoweb/tornado/issues/95", "issue_id": "#95", "issue_summary": "Circular reference with RequestHandler.on_connection_close", "issue_description": "elephantum commented on 25 May 2010\nThe following circular reference can be observed in runtime:\nRequestHandler -> .request -> HTTPRequest -> .connection -> HTTPConnection -> .stream -> IOStream -> ._close_callback -> RequestHandler.on_connection_close -> RequestHandler\nThis prevents gc to collect RequestHandler and all the associated objects, which leads to evergrowing memory consumption.\nThere is very simple fix for this problem: http://github.com/elephantum/tornado/commit/8ffbe0e64df2c36b93e8ca66abfe483b211efd52", "issue_status": "Closed", "issue_reporting_time": "2010-05-25T12:17:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1274": {"issue_url": "https://github.com/tornadoweb/tornado/issues/94", "issue_id": "#94", "issue_summary": "circular reference with RequestHandler.on_connection_close", "issue_description": "elephantum commented on 25 May 2010\nThe following circular reference appears in runtime:\nRequestHandler -> .request -> HTTRequest -> .connection -> HTTPConnection -> .stream -> IOStream -> ._close_callback -> RequestHandler.on_connection_close -> RequestHandler\nThis prevents gc to collect RequestHandler and it hangs in memory (forever?) resulting in huge memory consumption.\nThere is an easy fix for this problem: http://github.com/elephantum/tornado/commit/8ffbe0e64df2c36b93e8ca66abfe483b211efd52", "issue_status": "Closed", "issue_reporting_time": "2010-05-25T11:08:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1275": {"issue_url": "https://github.com/tornadoweb/tornado/issues/93", "issue_id": "#93", "issue_summary": "HTTPConnection::_on_headers seems to leak connection", "issue_description": "jefimm commented on 24 May 2010\nThe function HTTPConnection::_on_headers seems to leak connection if\nexception is thrown.\nThis can lead to denial of service on the server.", "issue_status": "Closed", "issue_reporting_time": "2010-05-24T10:22:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1276": {"issue_url": "https://github.com/tornadoweb/tornado/issues/92", "issue_id": "#92", "issue_summary": "Security vulnerability", "issue_description": "kellym commented on 21 May 2010\nI was attempting to write my own authentication with tornado, but I have noticed that both POST and GET arguments come through with the same call, self.get_argument(). Maybe I'm a little overly paranoid, but I like my arguments to come in separately... in fact, it's highly recommended to never use a GET request to store information, yet someone could easily throw in a query string with whatever data they wanted.\nI'm all fine for leaving self.get_argument(), but maybe there should be a built-in self.GET.get() and self.POST.get(), something like Django.", "issue_status": "Closed", "issue_reporting_time": "2010-05-21T13:37:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1277": {"issue_url": "https://github.com/tornadoweb/tornado/issues/90", "issue_id": "#90", "issue_summary": "Support custom, non-standard, HTTP methods", "issue_description": "nailor commented on 18 May 2010\nThis is more of a proposal than a bug report. Feel free to close this issue, if this is not desired behavior for Tornado.\nInstead of limiting the AsyncHTTPClient's methods to standard PUT, POST, GET, HEAD and DELETE, Tornado could allow any custom HTTP method to be used. This has some benefits when working with certain applications, like CouchDB, where a non-standard method COPY is used to do an atomic copy of a document.\nThis behavior could easily be achieved with following patch\ndiff --git a/tornado/httpclient.py b/tornado/httpclient.py\nindex e45bfd6..fa152dc 100644\n--- a/tornado/httpclient.py\n+++ b/tornado/httpclient.py\n@@ -390,16 +390,13 @@ def _curl_setup_request(curl, request, buffer, headers):\n         \"PUT\": pycurl.UPLOAD,\n         \"HEAD\": pycurl.NOBODY,\n     }\n-    custom_methods = set([\"DELETE\"])\n     for o in curl_options.values():\n         curl.setopt(o, False)\n     if request.method in curl_options:\n         curl.unsetopt(pycurl.CUSTOMREQUEST)\n         curl.setopt(curl_options[request.method], True)\n-    elif request.method in custom_methods:\n-        curl.setopt(pycurl.CUSTOMREQUEST, request.method)\n     else:\n-        raise KeyError('unknown method ' + request.method)\n+        curl.setopt(pycurl.CUSTOMREQUEST, request.method)\n \n     # Handle curl's cryptic options for every individual HTTP method\n     if request.method in (\"POST\", \"PUT\"):", "issue_status": "Closed", "issue_reporting_time": "2010-05-18T09:56:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1278": {"issue_url": "https://github.com/tornadoweb/tornado/issues/88", "issue_id": "#88", "issue_summary": "when you reverse_url a handler with addslash, you are likely to get a ? in the result", "issue_description": "cactus commented on 13 May 2010\nassume routing of:\nurl(r\"/login/?\", handler.LoginHandler, name=\"login\"),\nhandler of:\nclass LoginHandler(BaseHandler):\n    @cyclone.web.addslash\n     def get(self):\n         self.render(\"login.html\")\nIn login.html, if you have {{ reverse_url(\"login\") }} you end up with /login/? as the result. I think the ? should be dropped, if it is the last character in the path result -- such as in the case of addslash and removeslash.", "issue_status": "Closed", "issue_reporting_time": "2010-05-13T05:08:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1279": {"issue_url": "https://github.com/tornadoweb/tornado/issues/87", "issue_id": "#87", "issue_summary": "tornado.websocket will not work past one message", "issue_description": "Contributor\ndlo commented on 5 May 2010\nCode to test this behavior is at http://gist.github.com/390142.\nBasically, tornado.websocket will not parse messages past the first one. This is a major bug. I looked through the source and couldn't isolate the issue, so I'm hoping someone else can.\nTested in Webkit, version 4.0.5 (6531.22.7, r58691) and Chrome 5.0.375.29 beta.\nI forked Tornado and verified a fix. Here's the commit that brings websocket.py back to life: dlo/tornado@9ea5f8a277db96557ae7867375c7db4d8c5f633a", "issue_status": "Closed", "issue_reporting_time": "2010-05-04T22:46:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1280": {"issue_url": "https://github.com/tornadoweb/tornado/issues/86", "issue_id": "#86", "issue_summary": "Add .DS_Store to .gitignore", "issue_description": "thepian commented on 1 May 2010\nNo description provided.", "issue_status": "Closed", "issue_reporting_time": "2010-05-01T14:28:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1281": {"issue_url": "https://github.com/tornadoweb/tornado/issues/85", "issue_id": "#85", "issue_summary": "httponly cookies", "issue_description": "rwynn commented on 30 Apr 2010\nit seems there is no way to mark a cookie or secure cookie as httponly when it is created. python 2.6 adds support for this. would be a nice security enhancement.", "issue_status": "Closed", "issue_reporting_time": "2010-04-30T17:14:13Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1282": {"issue_url": "https://github.com/tornadoweb/tornado/issues/84", "issue_id": "#84", "issue_summary": "No handlers could be found for logger \"tornado.ioloop\"", "issue_description": "ssadler commented on 18 Apr 2010\nTo reproduce, start a server with this handler:\npong = 'http://localhost:8888/pong'\n\nclass MainHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        http = tornado.httpclient.AsyncHTTPClient()\n        http.fetch(pong, self.async_callback(self.on_response))\n\n    def on_response(self, response):\n        self.write(\"Hello, world\")\n        self.finish()\n\nclass PongHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Pong\")\n\napplication = tornado.web.Application([\n    (r\"/a\", MainHandler),\n    (r\"/pong\", PongHandler),\n])\nAnd benchmark it with ab at huge concurrency (10000 or so). The idea is to have it encounter a \"too many open files\" or \"IOError: [Errno 9] Bad file descriptor\" exception.\nAdding _log.addHandler(logging.StreamHandler()) to ioloop.py results in the exceptions being printed as expected.\nI also encountered this error when I got Swirl (http://github.com/enaeseth/swirl) to produce an error, except it was trying to use logger \"tornado.web\".", "issue_status": "Closed", "issue_reporting_time": "2010-04-17T20:35:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1283": {"issue_url": "https://github.com/tornadoweb/tornado/issues/83", "issue_id": "#83", "issue_summary": "AsyncHTTPClient is not properly closed when using close-method", "issue_description": "nailor commented on 13 Apr 2010\nIf AsyncHTTPClient has queued _perform calls when the close is called the AsyncHTTPClient eventually raises following error:\nerror: cannot invoke perform() - no multi handle\nThis happens because the callbacks to _perform have been added to underlying IOLoop while close closes all the curl handles. Following patch adds a simple variable to detect whether the client is closed or not and properly avoids executing the _perform if the client is closed\ndiff --git a/tornado/httpclient.py b/tornado/httpclient.py\nindex 2c9155e..47acb29 100644\n--- a/tornado/httpclient.py\n+++ b/tornado/httpclient.py\n@@ -122,6 +122,7 @@ class AsyncHTTPClient(object):\n             instance._events = {}\n             instance._added_perform_callback = False\n             instance._timeout = None\n+            instance._closed = False\n             cls._ASYNC_CLIENTS[io_loop] = instance\n             return instance\n \n@@ -131,6 +132,7 @@ class AsyncHTTPClient(object):\n         create and destroy http clients.  No other methods may be called\n         on the AsyncHTTPClient after close().\n         \"\"\"\n+        self._closed = True\n         del AsyncHTTPClient._ASYNC_CLIENTS[self.io_loop]\n         for curl in self._curls:\n             curl.close()\n@@ -165,6 +167,9 @@ class AsyncHTTPClient(object):\n     def _perform(self):\n         self._added_perform_callback = False\n \n+        if self._closed:\n+            return\n+\n         while True:\n             while True:\n                 ret, num_handles = self._multi.perform()", "issue_status": "Closed", "issue_reporting_time": "2010-04-13T11:38:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1284": {"issue_url": "https://github.com/tornadoweb/tornado/issues/82", "issue_id": "#82", "issue_summary": "OpenID default realm not SSL-compatible", "issue_description": "ghost commented on 13 Apr 2010\nCurrently, the OpenID realm is hard-coded to begin with \"http://\" which does not work for SSL-based sites. I have created a patch (which now should be devoid of my other junk) to fix this:\nhttp://github.com/funtoo/tornado/commit/94c25d5f617822c5d953940840b751c2cdba34ef\nThis allows SSL-enabled sites to work correctly, so that the OpenID spec is followed, which specified that the return_to path must consist of the realm plus additional subpaths.", "issue_status": "Closed", "issue_reporting_time": "2010-04-12T21:36:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1285": {"issue_url": "https://github.com/tornadoweb/tornado/issues/81", "issue_id": "#81", "issue_summary": "IOError \"Stream is closed\" not caught in finish()", "issue_description": "parente commented on 1 Apr 2010\nIs it expected that my handler should catch this exception? When it happens, the server goes into limbo and no longer handles requests.\n...\nself.finish()\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/web.py\", line 459, in finish\nself.flush(include_footers=True)\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/web.py\", line 433, in flush\nself.request.write(headers + chunk)\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/httpserver.py\", line 286, in write\nself.connection.write(chunk)\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/httpserver.py\", line 126, in write\nself.stream.write(chunk, self._on_write_complete)\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/iostream.py\", line 111, in write\nself._check_closed()\nFile \"/home/parente/envs/jsonic/lib/python2.6/site-packages/tornado-0.2-py2.6.egg/tornado/iostream.py\", line 223, in _check_closed\nraise IOError(\"Stream is closed\")\nIOError: Stream is closed", "issue_status": "Closed", "issue_reporting_time": "2010-04-01T00:51:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1286": {"issue_url": "https://github.com/tornadoweb/tornado/issues/80", "issue_id": "#80", "issue_summary": "According to PEP 333 start_response(status, headers) function must return a write(body_data) callable.", "issue_description": "rkintzi commented on 28 Mar 2010\nI have found two issues since I last cloned Tornado repository on Monday:\nAccording to PEP 333 start_response(status, headers) function must return\na write(body_data) callable.\nWhen WSGI app pass to start_response two Set-Cookie headers only last one\nis send in response.\nFirst issue is still there. Second one was already fixed.\nTo fix both of this issues I wrote HTTPWSGIServer class which might be used\ninstead of original HTTPServer. My code relies on webob.Request/Response objects.\nIf you are interested in it let me know.\nRados\u0142aw Kintzi\nPS. Is it possible to attach file to issue in Github?", "issue_status": "Closed", "issue_reporting_time": "2010-03-28T14:39:07Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1287": {"issue_url": "https://github.com/tornadoweb/tornado/issues/79", "issue_id": "#79", "issue_summary": "Can't set not ascii string cookie value", "issue_description": "joo commented on 26 Mar 2010\nself.set_cookie(\"message\", u\"\u6d4b\u8bd5\")\nself.get_cookie(\"message\") is null value", "issue_status": "Closed", "issue_reporting_time": "2010-03-26T10:00:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1288": {"issue_url": "https://github.com/tornadoweb/tornado/issues/78", "issue_id": "#78", "issue_summary": "File name win32_support.py", "issue_description": "joo commented on 26 Mar 2010\nFile name win32_support.py with other inconsistencies, such as: s3server.py, proposal to change the win32support.py", "issue_status": "Closed", "issue_reporting_time": "2010-03-26T02:14:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1289": {"issue_url": "https://github.com/tornadoweb/tornado/issues/77", "issue_id": "#77", "issue_summary": "a bug in tornado.web.add_handlers", "issue_description": "wangchyz commented on 25 Mar 2010\nthis bug can maybe cause add_handlers invalid\ndiff --git a/tornado/web.py b/tornado/web.py\nindex 8cba99a..5126fb8 100644\n--- a/tornado/web.py\n+++ b/tornado/web.py\n@@ -934,7 +934,13 @@ class Application(object):\nif not host_pattern.endswith(\"$\"):\nhost_pattern += \"$\"\nhandlers = []\n   self.handlers.append((re.compile(host_pattern), handlers))\n   for h_pattern, h_handlers in self.handlers:\n       if h_pattern.pattern == host_pattern:\n           handlers = h_handlers\n   if handlers == []:\n       self.handlers.append((re.compile(host_pattern), handlers))\n\n for spec in host_handlers:\n     if type(spec) is type(()):", "issue_status": "Closed", "issue_reporting_time": "2010-03-25T08:23:00Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1290": {"issue_url": "https://github.com/tornadoweb/tornado/issues/76", "issue_id": "#76", "issue_summary": "a bug in tornado.web.add_handlers", "issue_description": "wangchyz commented on 25 Mar 2010\nthis bug can make user call add_handlers invalid\nI don't kown how to push in github, Sorry.\ndiff --git a/tornado/web.py b/tornado/web.py\n   self.handlers.append((re.compile(host_pattern), handlers))\n   for h_pattern, h_handlers in self.handlers:\n       if h_pattern.pattern == host_pattern:\n           handlers = h_handlers\n   if handlers == []:\n       self.handlers.append((re.compile(host_pattern), handlers))", "issue_status": "Closed", "issue_reporting_time": "2010-03-25T08:03:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1291": {"issue_url": "https://github.com/tornadoweb/tornado/issues/75", "issue_id": "#75", "issue_summary": "httpclient get method can't send body data", "issue_description": "joo commented on 22 Mar 2010\nurl = 'http://' + self.request.host + '/exchange/login'\nheaders = {'Accept': 'text/xml'}\nbody = 'xml data ...'\nrequest = httpclient.HTTPRequest(url=url, method='GET',\nheaders=headers, body=body)\nprint request.body\nhttp = httpclient.AsyncHTTPClient()\nhttp.fetch(request, callback=self.async_callback(self.on_get_response))", "issue_status": "Closed", "issue_reporting_time": "2010-03-22T17:45:32Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1292": {"issue_url": "https://github.com/tornadoweb/tornado/issues/74", "issue_id": "#74", "issue_summary": "Wrong docstring in tornado/web.py", "issue_description": "hanwentao commented on 19 Mar 2010\nDocstring on line 1315 should be \"CSS files\".", "issue_status": "Closed", "issue_reporting_time": "2010-03-19T02:58:23Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1293": {"issue_url": "https://github.com/tornadoweb/tornado/issues/73", "issue_id": "#73", "issue_summary": "is there a httpclient wihout pycurl ?", "issue_description": "conferno commented on 15 Mar 2010\npycurl seems to be a performance bottleneck.", "issue_status": "Closed", "issue_reporting_time": "2010-03-15T17:35:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1294": {"issue_url": "https://github.com/tornadoweb/tornado/issues/72", "issue_id": "#72", "issue_summary": "Simple bug with _running in ioloop.py PeriodicCallback", "issue_description": "OleLaursen commented on 11 Mar 2010\nHi!\nThe problem is that self._running is set to true in the constructor instead of in start(). So _running says it's running even if it's not (yet) and furthermore you can't stop() then start() again. Just copy the line self._running = True into start() and change the one in __init__ to False instead of True.\nAnother thing is that I think _running makes sense as running because it's useful from outside - e.g. I have a use case where if I get a certain kind of request, I need to start a periodic clean up function, the easiest way to model it is as a global PeriodicCallback, then if it's not running, I start it in the request.\nOle", "issue_status": "Closed", "issue_reporting_time": "2010-03-11T12:18:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1295": {"issue_url": "https://github.com/tornadoweb/tornado/issues/71", "issue_id": "#71", "issue_summary": "custom 404 page for tornado", "issue_description": "yashh commented on 10 Mar 2010\nhey is there a way to create a custom 404 / 500 page for tornado. Right now\nraise tornado.web.HTTPError(404)\nrenders the text \"404: Not Found\". Just wanted to know if there is any way to have a template for it?", "issue_status": "Closed", "issue_reporting_time": "2010-03-10T06:43:19Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1296": {"issue_url": "https://github.com/tornadoweb/tornado/issues/70", "issue_id": "#70", "issue_summary": "CPU usage using _Select IOLoop", "issue_description": "leepa commented on 3 Mar 2010\nOn Solaris, the only option is use select() as the IOLoop. Even on a basic app doing tornado.ioloop.IOLoop.instance().start() it ends up using 10-15% CPU. Not sure what's causing this - but wanted to raise it as a problem.", "issue_status": "Closed", "issue_reporting_time": "2010-03-02T20:53:29Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1297": {"issue_url": "https://github.com/tornadoweb/tornado/issues/69", "issue_id": "#69", "issue_summary": "WebSockets receive_message problem.", "issue_description": "giolekva commented on 2 Mar 2010\nEvery time server receives message from browser using WebSockets, I have to rebind on_message method again to receive future messages, like this:\nclass MessageHandler(websocket.WebSocketHandler):\ndef open(self):\nself.receive_message(self.on_message)\ndef on_message(self, message):\n    # process message \n    self.receive_message(self.on_message)", "issue_status": "Closed", "issue_reporting_time": "2010-03-02T06:53:54Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1298": {"issue_url": "https://github.com/tornadoweb/tornado/issues/68", "issue_id": "#68", "issue_summary": "host broken when reverse proxied", "issue_description": "sgala commented on 26 Feb 2010\nThis commit http://github.com/sgala/tornado/commit/219c334548a94c61dabd39f626dfa644395d6788\nfixes the fact that the host variable will be wrong when reverse proxied (even if using xheaders), and so auth in all demos will fail because the realms will be broken.", "issue_status": "Closed", "issue_reporting_time": "2010-02-26T10:55:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1299": {"issue_url": "https://github.com/tornadoweb/tornado/issues/67", "issue_id": "#67", "issue_summary": "StaticFileHandler assumes text-mode files", "issue_description": "parente commented on 25 Feb 2010\nAs of this writing,\nhttp://github.com/facebook/tornado/blob/master/tornado/web.py#L1136\nshows StaticFileHandler opening the files to write back to the user using text mode. According to the Python doc, text mode performs conversion on new lines that is specific to the platform. To avoid this behavior, the file should be opened with mode \"rb\" to make it safe for binary files.", "issue_status": "Closed", "issue_reporting_time": "2010-02-25T03:13:33Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1300": {"issue_url": "https://github.com/tornadoweb/tornado/issues/66", "issue_id": "#66", "issue_summary": "some bugs in web.Application", "issue_description": "ghost commented on 23 Feb 2010\nweb.py line: 983\n- for m in list: self._load_ui_modules(m)\n+ for m in modules: self._load_ui_modules(m)\n\nweb.py line: 971\n- for m in list: self._load_ui_methods(m)\n+ for m in methods: self._load_ui_methods(m)", "issue_status": "Closed", "issue_reporting_time": "2010-02-22T22:18:41Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1301": {"issue_url": "https://github.com/tornadoweb/tornado/issues/65", "issue_id": "#65", "issue_summary": "[bug] can't run multi-processor prefork with debug=True", "issue_description": "fabware commented on 22 Feb 2010\nReplace the main in demos/helloworld/helloworld.py with the following:\ndef main():\ntornado.options.parse_command_line()\nsettings = {'debug': True}\napplication = tornado.web.Application([\n(r\"/\", MainHandler),\n], **settings)\nhttp_server = tornado.httpserver.HTTPServer(application)\nhttp_server.bind(options.port)\nhttp_server.start()\ntornado.ioloop.IOLoop.instance().start()\nWILL CAUSE:\n[E 100222 11:24:11 httpserver:171] Cannot run in multiple processes: IOLoop instance has already been initialized. You cannot call IOLoop.instance() before calling start()\nWell, this behaviour maybe intentional, but a new user would get mad without a notice in documentation or in code.", "issue_status": "Closed", "issue_reporting_time": "2010-02-22T03:33:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1302": {"issue_url": "https://github.com/tornadoweb/tornado/issues/64", "issue_id": "#64", "issue_summary": "Fix for web._get_host_handlers()", "issue_description": "ghost commented on 15 Feb 2010\nWithout this fix, _get_host_handlers only return the first host_pattern match. It's a real problem because if for example you do many add_handlers with same host, only the first will get return.\nFix :\ndef _get_host_handlers(self, request):\n    host = request.host.lower().split(':')[0]\n    result = []\n    for pattern, handlers in self.handlers:\n        if pattern.match(host):\n            result += handlers\n    # Look for default host if not behind load balancer (for debugging)\n    if \"X-Real-Ip\" not in request.headers:\n        for pattern, handlers in self.handlers:\n            if pattern.match(self.default_host):\n                result += handlers\n\n    if result:\n        return result\n    return None", "issue_status": "Closed", "issue_reporting_time": "2010-02-15T12:14:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1303": {"issue_url": "https://github.com/tornadoweb/tornado/issues/63", "issue_id": "#63", "issue_summary": "fix for iostream._handle_write()", "issue_description": "mdagosta commented on 15 Feb 2010\nSometimes when streaming a write_buffer larger than the default socket.send buffer size, iostream will break partway through the buffer, leaving the connection open. Changing 'break' to 'continue' on errno 11 in iostream._handle_write() works for me.", "issue_status": "Closed", "issue_reporting_time": "2010-02-15T08:20:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1304": {"issue_url": "https://github.com/tornadoweb/tornado/issues/62", "issue_id": "#62", "issue_summary": "A little patch for supporting helloworld demo under windows", "issue_description": "fangpenlin commented on 11 Feb 2010\nHi,\nI tried to run the helloworld demo under windows, but I got some errors. Tornado uses fcntl for controlling file. For running the demo, I modified some parts of original tornado. Actually, I don't really understand all of those fcntl operations for, especially the waker in IOLoop, however, without that the helloworld demo works find under windows. I don't have time to test other demos. Tornado really looks good, compare to twisted, it is simple and powerful. This is just a good begining, as a windows user, I hope it would be possible to develop tornado application under Windows in future. :D\nRegards\nVictor Lin.\nHere is the patch:\ndiff --git a/tornado/httpserver.py b/tornado/httpserver.py\nindex 4e5ae76..ded4623 100644\n--- a/tornado/httpserver.py\n+++ b/tornado/httpserver.py\n@@ -18,7 +18,6 @@\nimport cgi\nimport errno\n-import fcntl\nimport functools\nimport ioloop\nimport iostream\n@@ -136,9 +135,11 @@ class HTTPServer(object):\n\"\"\"\nassert not self._socket\nself._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n   flags = fcntl.fcntl(self._socket.fileno(), fcntl.F_GETFD)\n   flags |= fcntl.FD_CLOEXEC\n   fcntl.fcntl(self._socket.fileno(), fcntl.F_SETFD, flags)\n   if os.name != 'nt':\n       import fcntl\n       flags = fcntl.fcntl(self._socket.fileno(), fcntl.F_GETFD)\n       flags |= fcntl.FD_CLOEXEC\n       fcntl.fcntl(self._socket.fileno(), fcntl.F_SETFD, flags)\n self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n self._socket.setblocking(0)\n self._socket.bind((address, port))\ndiff --git a/tornado/ioloop.py b/tornado/ioloop.py\nindex 35d90cd..20f2863 100644\n--- a/tornado/ioloop.py\n+++ b/tornado/ioloop.py\n@@ -18,7 +18,6 @@\nimport bisect\nimport errno\n-import fcntl\nimport logging\nimport os\nimport select\n@@ -90,12 +89,13 @@ class IOLoop(object):\n # Create a pipe that we send bogus data to when we want to wake\n # the I/O loop when it is idle\n   r, w = os.pipe()\n   self._set_nonblocking(r)\n   self._set_nonblocking(w)\n   self._waker_reader = os.fdopen(r, \"r\", 0)\n   self._waker_writer = os.fdopen(w, \"w\", 0)\n   self.add_handler(r, self._read_waker, self.WRITE)\n   if os.name != 'nt':\n       r, w = os.pipe()\n       self._set_nonblocking(r)\n       self._set_nonblocking(w)\n       self._waker_reader = os.fdopen(r, \"r\", 0)\n       self._waker_writer = os.fdopen(w, \"w\", 0)\n       self.add_handler(r, self._read_waker, self.WRITE)\n@classmethod\ndef instance(cls):\n@@ -271,10 +271,10 @@ class IOLoop(object):\npass\ndef _set_nonblocking(self, fd):\n   import fcntl\n flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n fcntl.fcntl(fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)\nclass _Timeout(object):\n\"\"\"An IOLoop timeout, a UNIX timestamp and a callback\"\"\"\ndef init(self, deadline, callback):", "issue_status": "Closed", "issue_reporting_time": "2010-02-11T07:43:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1305": {"issue_url": "https://github.com/tornadoweb/tornado/issues/61", "issue_id": "#61", "issue_summary": "HTTP Headers not parsed correctly.", "issue_description": "thecleanmachine commented on 7 Feb 2010\nSometimes HTTP headers contain a space after the colon - this causes Tornado to exception. This especially shows up when you do a POST from AppEngine to Torndado Web Server.", "issue_status": "Closed", "issue_reporting_time": "2010-02-06T23:00:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1306": {"issue_url": "https://github.com/tornadoweb/tornado/issues/60", "issue_id": "#60", "issue_summary": "parse_command_line must add logging handler only once", "issue_description": "redbaron commented on 4 Feb 2010\nI use options module in this way:\n#settings loading\nparse_command_line() #get settings file option\u22c5\nparse_config_file(options.settings)\nparse_command_line() #override settings from file\nBut second call to parse_command_line adds additional logging handler, which duplicates intries in output log.", "issue_status": "Closed", "issue_reporting_time": "2010-02-04T13:02:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1307": {"issue_url": "https://github.com/tornadoweb/tornado/issues/59", "issue_id": "#59", "issue_summary": "ioloop._KQueue does not always fire WRITE events when necessary", "issue_description": "Contributor\nweaver commented on 4 Feb 2010\nPatch: http://github.com/weaver/tornado/commit/1fea8629440fb4145c1252442b4c6b76f2752cf2\nDescription\nWhile working on STARTTLS support for a project (see http://gist.github.com/293449) I found that TCP clients would sometimes appear to \"hang\" after a connection was initially established and they'd called write(). After some digging I saw that under certain conditions, kqueue would only signal a WRITE event when the socket was initially writable, but not always every time IOStream needed a WRITE to send its buffer.\nTo Reproduce\nRun the starttls.py http://gist.github.com/293449 script in OS X or a *BSD. Then, run it again without using the _KQueue implementation included in the example (change line 472 to `io = IOLoop()'). The client never sends its \"hello\" message.\nSolutions\nI played around with various options, such as adding a flush() method to IOStream or calling _handle_write() from write(), but these all seemed hacky or required wide-ranging changes in my application code. Refactoring _KQueue seemed best.", "issue_status": "Closed", "issue_reporting_time": "2010-02-03T21:53:11Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1308": {"issue_url": "https://github.com/tornadoweb/tornado/issues/58", "issue_id": "#58", "issue_summary": "Typo in web.py", "issue_description": "adrianstanescu commented on 1 Feb 2010\nThere are two typos in web.py at line 960 and 973:\ndef _load_ui_methods(self, methods):\n    if type(methods) is types.ModuleType:\n        self._load_ui_methods(dict((n, getattr(methods, n))\n                                   for n in dir(methods)))\n    elif isinstance(methods, list):\n->      for m in list: self._load_ui_methods(m)\nand\ndef _load_ui_modules(self, modules):\n    if type(modules) is types.ModuleType:\n        self._load_ui_modules(dict((n, getattr(modules, n))\n                                   for n in dir(modules)))\n    elif isinstance(modules, list):\n->      for m in list: self._load_ui_modules(m)\nI think the last lists should be methods and modules respectively, i.e.,\nfor m in methods: self._load_ui_methods(m)\nand\nfor m in modules: self._load_ui_modules(m)", "issue_status": "Closed", "issue_reporting_time": "2010-02-01T17:27:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1309": {"issue_url": "https://github.com/tornadoweb/tornado/issues/57", "issue_id": "#57", "issue_summary": "Exception in ioloop.py remove_handler (when usging tornado-0.2.tar.gz)", "issue_description": "griggheo commented on 29 Jan 2010\nNOTE: this works with the latest tornado source code as of 01/28/10\ntornado installed from http://www.tornadoweb.org/static/tornado-0.2.tar.gz\nusing AsyncHTTPClient() in load testing script\nwhen approximately 100 requests are made at the same time, I start getting these:\nERROR:root:Exception in callback <bound method AsyncHTTPClient._handle_timeout of <tornado.httpclient.AsyncHTTPClient object at 0x7f3e394021d0>>\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/ioloop.py\", line 238, in _run_callback\ncallback()\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/httpclient.py\", line 150, in _handle_timeout\nself._perform()\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/httpclient.py\", line 214, in _perform\nself.io_loop.remove_handler(fd)\nFile \"/usr/local/lib/python2.6/dist-packages/tornado/ioloop.py\", line 133, in remove_handler\nself._impl.unregister(fd)\nIOError: [Errno 2] No such file or directory", "issue_status": "Closed", "issue_reporting_time": "2010-01-28T21:05:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1310": {"issue_url": "https://github.com/tornadoweb/tornado/issues/56", "issue_id": "#56", "issue_summary": "Space in url causes hang", "issue_description": "stevvooe commented on 26 Jan 2010\nWhen I fetch a url with a space, tornado crashes or hangs:\ncurl -vv -i  -D - -s 'http://localhost:8080/url with space'\n* About to connect() to localhost port 8080 (#0)\n*   Trying ::1... Unknown error 111\n*   Trying 127.0.0.1... connected\n* Connected to localhost (127.0.0.1) port 8080 (#0)\n> GET /url with space HTTP/1.1\n> User-Agent: curl/7.18.2 (i486-pc-linux-gnu) libcurl/7.18.2 OpenSSL/0.9.8g zlib/1.2.3.3 libidn/1.10\n> Host: localhost:8080\n> Accept: */*\n> \nAfter this, the curl call will hang. The following error is printed to the console:\nException in I/O handler for fd 7\nTraceback (most recent call last):\n  File \"<>tornado/ioloop.py\", line 197, in start\n    self._handlers[fd](fd, events)\n  File \"<>tornado/iostream.py\", line 144, in _handle_events\n    self._handle_read()\n  File \"<>tornado/iostream.py\", line 196, in _handle_read\n    callback(self._consume(loc + delimiter_len))\n  File \"<>tornado/httpserver.py\", line 263, in _on_headers\n    method, uri, version = start_line.split(\" \")\nValueError: too many values to unpack\nThis happens whether they are defined by the application handlers or not. I\nattempted the following patch:\n$ git diff\ndiff --git a/tornado/httpserver.py b/tornado/httpserver.py\nindex 894f059..933d910 100644\n--- a/tornado/httpserver.py\n+++ b/tornado/httpserver.py\n@@ -260,7 +260,10 @@ class HTTPConnection(object):\n     def _on_headers(self, data):\n         eol = data.find(\"\\r\\n\")\n         start_line = data[:eol]\n-        method, uri, version = start_line.split(\" \")\n+        try:\n+            method, uri, version = start_line.split(\" \")\n+        except ValueError, e:\n+            raise Exception(\"Error parsing request: %s\", e)\n         if not version.startswith(\"HTTP/\"):\n             raise Exception(\"Malformed HTTP version in HTTP Request-Line\")\n         headers = HTTPHeaders.parse(data[eol:])\nHowever, it seems that any exception in this particular context will hang the\nclient. It should finish the request and throw a \"400 Bad Request\" error so\nthe client can detect that the request is malformed.\nI am testing against the current trunk.", "issue_status": "Closed", "issue_reporting_time": "2010-01-25T19:30:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1311": {"issue_url": "https://github.com/tornadoweb/tornado/issues/55", "issue_id": "#55", "issue_summary": "httpclient: connect_timeout and request_timeout cannot be set to zero (unlimited)", "issue_description": "akheron commented on 14 Jan 2010\nThere are hard-coded defaults of 20 seconds for both values, and the user cannot set e.g. connect_timeout=0 as 0 evaluates to false and the default value is used.\nclass HTTPRequest(object):\n    def __init__(self, url, method=\"GET\", headers={}, body=None,\n                 ...\n                 connect_timeout=None, request_timeout=None,\n                 ...):\n        ...\n        self.connect_timeout = connect_timeout or 20.0\n        self.request_timeout = request_timeout or 20.0\n        ...\nWith the current code I can emulate it this way:\nHTTPRequest(..., request_timeout=0.1)\n0.1 evaluates to true, so the default is not set, and when request_timeout is later cast to int, the result is 0. But this is quite ugly :)", "issue_status": "Closed", "issue_reporting_time": "2010-01-14T08:28:48Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1312": {"issue_url": "https://github.com/tornadoweb/tornado/issues/54", "issue_id": "#54", "issue_summary": "json_encode & json_decode do not support 'object_hook' and 'default' args", "issue_description": "PavloKapyshin commented on 8 Jan 2010\nAs described in http://docs.python.org/library/json.html", "issue_status": "Closed", "issue_reporting_time": "2010-01-07T22:14:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1313": {"issue_url": "https://github.com/tornadoweb/tornado/issues/53", "issue_id": "#53", "issue_summary": "Should not log to the root logger", "issue_description": "mackstann commented on 5 Jan 2010\nTornado should log to its own logger, so that the output can be properly separated, filtered, etc., from the output of the program using tornado. I'm seeing this in httpclient.py specifically.", "issue_status": "Closed", "issue_reporting_time": "2010-01-05T08:07:51Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1314": {"issue_url": "https://github.com/tornadoweb/tornado/issues/52", "issue_id": "#52", "issue_summary": "Option to reload modified templates without server restart", "issue_description": "gsf commented on 4 Jan 2010\nAs noted in a recent thread on the tornado list [0], the reloading of templates without a server restart is sometimes a requirement. While the \"debug\" setting provides reloading, it doesn't suit the needs of clients who request the ability to modify templates in the long term. The \"reload_modified_templates\" setting, seen in my branch [1], allows for this at a slight loss of speed. As I noted in the thread, \"Running \"ab -n 100000 -c 25 http://10.0.1.x/\" from a separate machine resulted in 2465.15 rps without my patch and 2343.14 rps with.\"\n[0] http://groups.google.com/group/python-tornado/browse_thread/thread/2005e97722ba29a3\n[1] http://github.com/gsf/tornado/commits/modtpl", "issue_status": "Closed", "issue_reporting_time": "2010-01-04T18:02:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1315": {"issue_url": "https://github.com/tornadoweb/tornado/issues/51", "issue_id": "#51", "issue_summary": "twitter login should use /account/verify_credentials", "issue_description": "Contributor\njoerussbowman commented on 3 Jan 2010\n_oauth_get_user currently uses \"/users/show/\" + access_token[\"screen_name\"] for logging in a user.\nThe access_token shouldn't rely on the screen_name, as the screen_name can be changed.\nYou can make a signed request to /account/verify_credentials to get the user information.\nhttp://apiwiki.twitter.com/Twitter-REST-API-Method%3A-account%C2%A0verify_credentials", "issue_status": "Closed", "issue_reporting_time": "2010-01-03T03:38:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1316": {"issue_url": "https://github.com/tornadoweb/tornado/issues/50", "issue_id": "#50", "issue_summary": "Need variable assignment in template", "issue_description": "yashh commented on 1 Jan 2010\nI have a huge json string in my template and I am using\n{{ json_decode(json_string)[\"name\"] }}\nsimilarly to render other attributes I am calling json_decode everytime. Is there a way I can assign the output of the json_decode operation to a variable?\n{% data_dict = json_decode(json_string) %}\nI get ParseError: unknown operator: 'data_dict'.\nAny work arounds?", "issue_status": "Closed", "issue_reporting_time": "2010-01-01T08:40:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1317": {"issue_url": "https://github.com/tornadoweb/tornado/issues/49", "issue_id": "#49", "issue_summary": "Middleware for tornado?", "issue_description": "yashh commented on 31 Dec 2009\nIs there a way to hook up middleware into tornado. Process every incoming request and then route it to the handler.\nI am trying to handle urls with trailing slashes -> ex: /login/ & /login\n(r\"/login/?\", LoginHandler),\nUsing a regex solves the problem but have a slight doubt that it kills some performance. With middleware we can do something like url.rstrip('/')", "issue_status": "Closed", "issue_reporting_time": "2009-12-31T09:10:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1318": {"issue_url": "https://github.com/tornadoweb/tornado/issues/48", "issue_id": "#48", "issue_summary": "PUT should support request arguments in body as well as POST", "issue_description": "araddon commented on 31 Dec 2009\nAdded support to parse the body into the arguments of Request object on PUT as well as POST\nhttp://github.com/araddon/tornado/commit/f9b62ff57d698cb935be318e776ce509243dc06c", "issue_status": "Closed", "issue_reporting_time": "2009-12-31T02:14:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1319": {"issue_url": "https://github.com/tornadoweb/tornado/issues/47", "issue_id": "#47", "issue_summary": "CPU 100%, High load averages", "issue_description": "leeight commented on 30 Dec 2009\nLSB Version: :core-3.0-amd64:core-3.0-noarch:graphics-3.0-amd64:graphics-3.0-noarch\nDistributor ID: RedHatEnterpriseAS\nDescription: Red Hat Enterprise Linux AS release 4 (Nahant Update 3)\nRelease: 4\nCodename: NahantUpdate3\nchange ioloop.py, change 145 line, add\ntime.sleep(0.0001)\nit works.", "issue_status": "Closed", "issue_reporting_time": "2009-12-30T16:03:58Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1320": {"issue_url": "https://github.com/tornadoweb/tornado/issues/46", "issue_id": "#46", "issue_summary": "Support http OPTIONS method used by Firefox/Safari on Cross Domain requests", "issue_description": "araddon commented on 23 Dec 2009\nI was running into issues with a JSON Api I was building for cross domain requests coming from Firefox/Safari that were sending an HTTP OPTIONS pre-flight request before sending the http get. See https://developer.mozilla.org/en/HTTP_access_control\nMy Fix http://github.com/araddon/tornado/commit/d91deae5f22e6d0cd3b86d5b960729ae004bd394\nI was able to get Firefox/Safari to work correctly by implementing an \"options\" method on my handler similar to get/post but actually just returning nothing.", "issue_status": "Closed", "issue_reporting_time": "2009-12-22T18:49:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1321": {"issue_url": "https://github.com/tornadoweb/tornado/issues/45", "issue_id": "#45", "issue_summary": "Escaping doesn't convert ' and \"", "issue_description": "apg commented on 16 Dec 2009\nReported by Stefan Scholl on the mailing list:\nI've just seen that tornado.escape.xhtml_escape (used as \"escape\" in\nthe templates) only escapes \"&\", \"<\", and \">\". It uses escape from\nxml.sax.saxutils.\nUsed in an attribute, ' and \" should be escaped, too.\nBut don't convert ' to ', because this is XML only and can be a\nproblem with HTML and visitors using Internet Explorer. ' should be\nconverted to '.", "issue_status": "Closed", "issue_reporting_time": "2009-12-16T12:25:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1322": {"issue_url": "https://github.com/tornadoweb/tornado/issues/44", "issue_id": "#44", "issue_summary": "worth flagging up that pycurl needs to be >=7.16.4 if you want response headers?", "issue_description": "thruflo commented on 13 Dec 2009\nI just spent a bit of time digging around to find out that in tornado.httpclient._curl_setup_request there's this code::\ntry:\n    curl.setopt(pycurl.HEADERFUNCTION,\n                functools.partial(_curl_header_callback, headers))\nexcept:\n    # Old version of curl; response will not include headers\n    pass\nThe \"old version of curl\" refers to any version before 7.16.4 (see the ChangeLog here: http://pycurl.sourceforge.net/ChangeLog ).\nIn the tornado README, there's a suggested Mac OSX command of::\n$ sudo easy_install setuptools pycurl==7.16.2.1 simplejson\nTo resolve Tornado's dependencies. Perhaps it's worth either updating that to 7.16.4 (looking at the change log I can't see any compatibility / libcurl version issues) or perhaps at least flagging up the choice?\nIf not worth tweaking the README at least perhaps this post might help if you're scratching your head...\nThanks,\nJames.", "issue_status": "Closed", "issue_reporting_time": "2009-12-13T11:56:47Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1323": {"issue_url": "https://github.com/tornadoweb/tornado/issues/43", "issue_id": "#43", "issue_summary": "tornado.auth.FacebookMixin should use session secret instead of the application secret", "issue_description": "tsharju commented on 12 Dec 2009\nThe _signature method of tornado.auth.FacebookMixin uses the application secret when signing the requests. This causes all the authenticated requests to the Facebook API fail since the requests should be signed using the session secret. I guess Facebook has changed their API at some point. http://wiki.developers.facebook.com/index.php/Authorization_and_Authentication_for_Desktop_Applications", "issue_status": "Closed", "issue_reporting_time": "2009-12-12T07:41:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1324": {"issue_url": "https://github.com/tornadoweb/tornado/issues/42", "issue_id": "#42", "issue_summary": "tornado.database with DBUtils", "issue_description": "smallfish commented on 10 Dec 2009\nI change it, you can look my blog: http://chenxiaoyu.org/blog/archives/82\nbut code is not check DBUtils version.\ncode:\ndef reconnect(self):\n    \"\"\"Closes the existing database connection and re-opens it.\"\"\"\n    self.close()\n    try:\n        from DBUtils import PooledDB\n        pool_con = PooledDB.PooledDB(creator=MySQLdb, **self._db_args)\n        self._db = pool_con.connection()\n    except:\n        self._db = MySQLdb.connect(**self._db_args)\n        self._db.autocommit(True)", "issue_status": "Closed", "issue_reporting_time": "2009-12-10T06:17:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1325": {"issue_url": "https://github.com/tornadoweb/tornado/issues/41", "issue_id": "#41", "issue_summary": "Request body is ignored on HTTP PUT requests to HTTPServer", "issue_description": "Contributor\njoerussbowman commented on 10 Dec 2009\nThe user marc in the group encountered this, and the patch was supplied in their post here: http://groups.google.com/group/python-tornado/browse_thread/thread/29ec5a1300c10e2/1c7c8239cad08def?lnk=gst&q=put+method#1c7c8239cad08def\ndiff --git a/tornado/httpserver.py b/tornado/httpserver.py\nindex 460f5c8..60957c7 100644\n--- a/tornado/httpserver.py\n+++ b/tornado/httpserver.py\n@@ -201,7 +201,7 @@ class HTTPConnection(object):\ndef _on_request_body(self, data):\nself._request.body = data\ncontent_type = self._request.headers.get(\"Content-Type\", \"\")\n   if self._request.method == \"POST\":\n   if self._request.method in (\"POST\", \"PUT\"):\n     if content_type.startswith(\"application/x-www-form-\nurlencoded\"):\narguments = cgi.parse_qs(self._request.body)\nfor name, values in arguments.iteritems():", "issue_status": "Closed", "issue_reporting_time": "2009-12-10T00:51:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1326": {"issue_url": "https://github.com/tornadoweb/tornado/issues/40", "issue_id": "#40", "issue_summary": "DELETE method not supported by HTTPClient", "issue_description": "ketralnis commented on 10 Dec 2009\nhttp://groups.google.com/group/python-tornado/browse_thread/thread/593d41a6c2fb9246\nWhen I try to use the DELETE method with the HTTP client, I get:\nTraceback (most recent call last):\nFile \"/Users/dking/src/reddit/rdb/rdbclient.py\", line 154, in delete\nresp = self.http.fetch(req)\nFile \"/usr/local/lib/python2.6/site-packages/tornado/httpclient.py\", line 63, in fetch\nFile \"/usr/local/lib/python2.6/site-packages/tornado/httpclient.py\", line 372, in _curl_setup_request\nKeyError: 'DELETE'\nIt looks like this is happening here (http://github.com/facebook/tornado/blob/master/tornado/httpclient.py#...\ncurl_options = {\n\"GET\": pycurl.HTTPGET,\n\"POST\": pycurl.POST,\n\"PUT\": pycurl.UPLOAD,\n\"HEAD\": pycurl.NOBODY,\n}\nfor o in curl_options.values():\ncurl.setopt(o, False)\ncurl.setopt(curl_options[request.method], True)\nIs this a quick-fix, or does pycurl just not support the method?", "issue_status": "Closed", "issue_reporting_time": "2009-12-09T23:02:46Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1327": {"issue_url": "https://github.com/tornadoweb/tornado/issues/39", "issue_id": "#39", "issue_summary": "WSGIContainer's start_response method is incorrect", "issue_description": "jkp commented on 6 Dec 2009\nThe prototype for a start_response method is as follows:\ndef start_response(status,response_headers,exc_info=None):\nSee here: http://www.python.org/dev/peps/pep-0333/#the-start-response-callable.\nThe version in Tornado does not take the exc_info parameter meaning it is not possible to run a number of middlewares under it. It's an easy one to fix though :)", "issue_status": "Closed", "issue_reporting_time": "2009-12-06T12:01:24Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1328": {"issue_url": "https://github.com/tornadoweb/tornado/issues/38", "issue_id": "#38", "issue_summary": "PyPI package", "issue_description": "ask commented on 26 Nov 2009\nYou should publish tornado on PyPI, so it's possible to use it as a dependency.\nEven if you consider this beta software, it's considered a best practice. People have already started using Tornado, so there's no reason not to make it easier for people to deploy it.", "issue_status": "Closed", "issue_reporting_time": "2009-11-26T13:25:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1329": {"issue_url": "https://github.com/tornadoweb/tornado/issues/37", "issue_id": "#37", "issue_summary": "IOStream doesn't detect remote hang up when _Select is used", "issue_description": "sris commented on 13 Nov 2009\niostream.py provides a way to set a callback that should be invoked when a connection is closed. When using _Select this callback won't be invoked until a read or write is performed on the socket.\nSelect signals remote hang-ups by creating a read event with 0 byte length. This won't be noticed by iostream's _handle_event when a connection is idle since it only subscribes to io_loop.ERROR events.\nThis works fine with epoll since epoll with emit a HUP event that will get noticed.", "issue_status": "Closed", "issue_reporting_time": "2009-11-12T23:08:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1330": {"issue_url": "https://github.com/tornadoweb/tornado/issues/36", "issue_id": "#36", "issue_summary": "cookie value must quote", "issue_description": "nwind commented on 12 Nov 2009\n'set_cookie' and 'get_cookie' in web.py must quote and unquote\nfor example\nnew_cookie[name] = value\nmust be\nnew_cookie[name] = urllib.quote(value)\nbecause if '=' in set-cookie, ie and webkit will ignore it\nbase64.b64encode('yaki')\n'eWFraQ=='\nhttp://www.ietf.org/rfc/rfc2109.txt\nThe two state management headers, Set-Cookie and Cookie, have common\nsyntactic properties involving attribute-value pairs. The following\ngrammar uses the notation, and tokens DIGIT (decimal digits) and\ntoken (informally, a sequence of non-special, non-white space\ncharacters) from the HTTP/1.1 specification [RFC 2068] to describe\ntheir syntax.\nav-pairs = av-pair *(\";\" av-pair)\nav-pair = attr [\"=\" value] ; optional value\nattr = token\nvalue = word\nword = token | quoted-string", "issue_status": "Closed", "issue_reporting_time": "2009-11-12T07:12:35Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1331": {"issue_url": "https://github.com/tornadoweb/tornado/issues/35", "issue_id": "#35", "issue_summary": "Not good news", "issue_description": "joo commented on 9 Nov 2009\nHttpserver HTTPHeaders uses C-extension instead of native python.\nI strongly disagree with, unless there is a huge performance improvements.\nI do not understand why the use of non-core functions to the expansion of c?", "issue_status": "Closed", "issue_reporting_time": "2009-11-09T10:56:30Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1332": {"issue_url": "https://github.com/tornadoweb/tornado/issues/34", "issue_id": "#34", "issue_summary": "Some code snippet need to refactoring?", "issue_description": "joo commented on 8 Nov 2009\nI found some function _utf8 and _unicode repeatedly appear in different modules, that's not convenient maintain.\nThe following function appear in web.py module is right?\ndef _utf8(s):\nif isinstance(s, unicode):\nreturn s.encode(\"utf-8\")\nassert isinstance(s, str)\nreturn s\nor the following function appear in httpclient.py module is right.\ndef _utf8(value):\nif value is None:\nreturn value\nif isinstance(value, unicode):\nreturn value.encode(\"utf-8\")\nassert isinstance(value, str)\nreturn value\nI used to use last code. Thanks!", "issue_status": "Closed", "issue_reporting_time": "2009-11-08T17:24:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1333": {"issue_url": "https://github.com/tornadoweb/tornado/issues/33", "issue_id": "#33", "issue_summary": "blog/templates/compose.html escape is not enough", "issue_description": "ldenoue commented on 6 Nov 2009\nIf the title of the blog contains \", then escape in the template it not enough.", "issue_status": "Closed", "issue_reporting_time": "2009-11-06T02:46:14Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1334": {"issue_url": "https://github.com/tornadoweb/tornado/issues/32", "issue_id": "#32", "issue_summary": "IOError in AsyncHTTPClient", "issue_description": "stevvooe commented on 31 Oct 2009\nI was doing some evaluation on the httpclient with async calls on Python 2.6.2 and received the following IOError:\nERROR:root:Exception in callback <bound method AsyncHTTPClient._perform of <tornado.httpclient.AsyncHTTPClient object at 0xa17e18c>>\nTraceback (most recent call last):\n    File \"/home/steve/sandbox/tornado/tornado/ioloop.py\", line 241, in _run_callback\n          callback()\n    File \"/home/steve/sandbox/tornado/tornado/httpclient.py\", line 222, in _perform\n        self.io_loop.update_handler(fd, events)\n    File \"/home/steve/sandbox/tornado/tornado/ioloop.py\", line 127, in update_handler\n        self._impl.modify(fd, events | self.ERROR)\nIOError: [Errno 2] No such file or directory\nI added a catch for this in the httpclient where calls the epoll modify function, so that it registers the fd if the modify fails. The change set is here:\nhttp://github.com/stevvooe/tornado/commit/d85baebc02791ac4ddc3ce4a3d70ac5361fae3ba", "issue_status": "Closed", "issue_reporting_time": "2009-10-31T03:33:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1335": {"issue_url": "https://github.com/tornadoweb/tornado/issues/31", "issue_id": "#31", "issue_summary": "web.py L127 ignores no_keep_alive", "issue_description": "Contributor\ngmr commented on 30 Oct 2009\nI believe L127->L129 should read:\n    if not self.request.supports_http_1_1() and not self.settings.no_keep_alive:\n        if self.request.headers.get(\"Connection\") == \"Keep-Alive\":\n            self.set_header(\"Connection\", \"Keep-Alive\")\nand not:\n    if not self.request.supports_http_1_1():\n        if self.request.headers.get(\"Connection\") == \"Keep-Alive\":\n            self.set_header(\"Connection\", \"Keep-Alive\")", "issue_status": "Closed", "issue_reporting_time": "2009-10-30T00:51:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1336": {"issue_url": "https://github.com/tornadoweb/tornado/issues/30", "issue_id": "#30", "issue_summary": "add a \"nice\" self.arguments (in tornado.web)", "issue_description": "sylvainvivien commented on 26 Oct 2009\nRelated to this (allow_multiple) in get_arguments : http://github.com/facebook/tornado/issues#issue/26\nIt could be nice to have a \"nice\" self.arguments : same than self.request.arguments but with all unicode jobs done in get_argument + single value not in a list.\ni.e :\n@Property\ndef arguments(self)\nreturn dict((k, get_argument(k, allow_multiple=True)) for k in\nself.request.arguments)\nSo if self.request.arguments = {'k1': ['unicode_val1'], 'k2':\n['unicode_val21', 'unicode_val22']}\nthen\nself.arguments should returns :\n{'k1': u'unicode_val1', 'k2': [u'unicode_val21', u'unicode_val22']}", "issue_status": "Closed", "issue_reporting_time": "2009-10-25T19:10:52Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1337": {"issue_url": "https://github.com/tornadoweb/tornado/issues/29", "issue_id": "#29", "issue_summary": "Minor fix for \"/\" in web.py", "issue_description": "aldenml commented on 24 Oct 2009\nReplace \"/\" by os.sep int the line 1040:\nself.root = os.path.abspath(path) + \"/\"", "issue_status": "Closed", "issue_reporting_time": "2009-10-23T19:46:31Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1338": {"issue_url": "https://github.com/tornadoweb/tornado/issues/28", "issue_id": "#28", "issue_summary": "[solved] String formatting for dynamic query exhibiting failure", "issue_description": "Kuze commented on 22 Oct 2009\nNevermind, got it to work by doing the following:\ntable = 'logs'\ncolumn_id = 'col_id'\ncolumn_data = 'col_data'\nlog_data = 'some data here'\nself.db.execute(\n\"INSERT INTO %s (%s, %s)\" % (table, column_id, column_data) +\n\"VALUES (%s, %s)\", 'NULL', log_data\n)", "issue_status": "Closed", "issue_reporting_time": "2009-10-22T14:39:40Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1339": {"issue_url": "https://github.com/tornadoweb/tornado/issues/27", "issue_id": "#27", "issue_summary": "Expiration of secure cookies hardcoded to 31 days, inconsistent with expires_days arg to set_secure_cookie", "issue_description": "kjk commented on 21 Oct 2009\nNot sure if it's by design, but in get_secure_cookie(), a cookie over 31 days is always considered expired. It has no relation to expires_days argument in set_secure_cookie. Effectively it means that providing expires_days > 31 in set_secure_cookie() will have no effect and cookie will last for 31 days.", "issue_status": "Closed", "issue_reporting_time": "2009-10-21T01:25:18Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1340": {"issue_url": "https://github.com/tornadoweb/tornado/issues/26", "issue_id": "#26", "issue_summary": "Argument with multiple occurrences", "issue_description": "sylvainvivien commented on 18 Oct 2009\nLike Google webapp : http://code.google.com/intl/fr/appengine/docs/python/tools/webapp/req...\nit could be nice to have an \"allow_multiple=True\" in the get_argument\nfunction. (or a get_all_argument)\nExample : currently, if self.request.arguments returns {'key1':\n['val3'], 'key2': ['val1', 'val2']}\nself.get_argument(key2) will return 'val2'\nand with an allow_multiple=True :\nself.get_argument(key2, allow_multiple=True) it should return ['val1',\n'val2']\nI know it's possible to do : self.request.arguments['key2'], but here\nwe missed all unicode/utf-8 functions.\nAnother thing, in my example : {'key1': ['val3'], 'key2': ['val1',\n'val2']}\nFor key1, that is not \"multiple\", self.request.arguments should return\n{'key1': 'val3', 'key2': ['val1', 'val2']}.\ni.e. : key1 should not be a list but a value.\nI think it is the same issue with self.request.files, that always\nreturns a list even if there is only one file.\nmore info here : http://groups.google.com/group/python-tornado/browse_frm/thread/33325d1c500dccef/7af8756c4547b6bc", "issue_status": "Closed", "issue_reporting_time": "2009-10-18T16:14:56Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1341": {"issue_url": "https://github.com/tornadoweb/tornado/issues/25", "issue_id": "#25", "issue_summary": "url_escape with a \"quote\" option (not quote_plus)", "issue_description": "sylvainvivien commented on 18 Oct 2009\nCould you add an option for the url_escape method that don't use\nquote_plus but only quote.\nSomething like this :\ndef url_escape(value, quote_plus=True):\n\"\"\"Returns a valid URL-encoded version of the given value.\"\"\"\nif quote_plus:\nreturn urllib.quote_plus(utf8(value))\nreturn urllib.quote(utf8(value))", "issue_status": "Closed", "issue_reporting_time": "2009-10-18T16:13:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1342": {"issue_url": "https://github.com/tornadoweb/tornado/issues/24", "issue_id": "#24", "issue_summary": "Crash with semicolon in filename", "issue_description": "sylvainvivien commented on 18 Oct 2009\nIf I upload a file with a semicolon (;) [\"my;file.pdf\"], Tornado\ncrashes\nFile \"tornado\\wsgi.py\", line 172, in _parse_mime_body\nname, name_value = name_part.strip().split(\"=\", 1)\nValueError: need more than 1 value to unpack\nSemicolon in filename is most of the time nerver well handled in\npython (don't know why it is not fixed... or maybe I don't know how it\nworks) and we \"often' get : \"my\" instead of \"my;file.pdf\".\nmore info here : http://groups.google.com/group/python-tornado/browse_frm/thread/6e6ade3b63667fd0/e9aab86519647dd8", "issue_status": "Closed", "issue_reporting_time": "2009-10-18T16:13:04Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1343": {"issue_url": "https://github.com/tornadoweb/tornado/issues/23", "issue_id": "#23", "issue_summary": "Use self.headers instead of headers?", "issue_description": "victorhsieh commented on 3 Oct 2009\nHi,\nI believe that I encounter a bug when try to create an instanace of httpserver.HTTPRequest.\nIn the constructor of httpserver.HTTPRequest, I think this line\nself.host = host or headers.get(\"Host\") or \"127.0.0.1\"\nshould probably mean\nself.host = host or self.headers.get(\"Host\") or \"127.0.0.1\"\nOtherwise, creating an HTTPReqeust instance without giving headers will die here.\nThanks,\nVictor", "issue_status": "Closed", "issue_reporting_time": "2009-10-03T07:00:02Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1344": {"issue_url": "https://github.com/tornadoweb/tornado/issues/22", "issue_id": "#22", "issue_summary": "How about a version indicator?", "issue_description": "chadwhitacre commented on 3 Oct 2009\nSimple request. Just looking for tornado.version = (0, 2) or '0.2' or something.", "issue_status": "Closed", "issue_reporting_time": "2009-10-03T02:49:16Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1345": {"issue_url": "https://github.com/tornadoweb/tornado/issues/21", "issue_id": "#21", "issue_summary": "CSS embedding mistake", "issue_description": "sashka commented on 30 Sep 2009\nSince this commit http://github.com/facebook/tornado/commit/aa836cdf3952d52efc68201872b3a0053aca33ad\nthere is always mistaken css style constructions appears if I've defined css_files(), but haven't defined embedded_css():\n\n<style type=\"text/css\">\n.......\n</style>\nThat's because you're filling css_embed with inclusion path.\n   if css_files:\n        ...\n        css_embed = ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                            'type=\"text/css\" rel=\"stylesheet\"/>'\n                            for p in paths)\n        ...\n    if css_embed:\n        css_embed = '<style type=\"text/css\">\\n' + '\\n'.join(css_embed) + \\\n            '\\n</style>'\nI think you'll find the same problem with embedded_javascript() and javascript_files()", "issue_status": "Closed", "issue_reporting_time": "2009-09-30T15:15:59Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1346": {"issue_url": "https://github.com/tornadoweb/tornado/issues/20", "issue_id": "#20", "issue_summary": "Can Server Tag be changed Globally?", "issue_description": "calidion commented on 27 Sep 2009\nwith out subclassing RequestHandler.", "issue_status": "Closed", "issue_reporting_time": "2009-09-27T05:03:36Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1347": {"issue_url": "https://github.com/tornadoweb/tornado/issues/19", "issue_id": "#19", "issue_summary": "Server does not listen on IPv6 socket", "issue_description": "Chaz6 commented on 27 Sep 2009\nOn Linux 2.6 with Python 2.6.2, when I run demos/chat/chatdemo.py the server listens on an IPv4 socket and not an IPv6 socket. lsof shows:-\npython 4755 chaz 6u IPv4 11426409 TCP *:8888 (LISTEN)", "issue_status": "Closed", "issue_reporting_time": "2009-09-26T20:26:57Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1348": {"issue_url": "https://github.com/tornadoweb/tornado/issues/18", "issue_id": "#18", "issue_summary": "static url is hard code", "issue_description": "nwind commented on 22 Sep 2009\nI think it should move to settings\nhandlers.extend([\n(r\"/static/(.*)\", StaticFileHandler, dict(path=path)),", "issue_status": "Closed", "issue_reporting_time": "2009-09-22T10:01:49Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1349": {"issue_url": "https://github.com/tornadoweb/tornado/issues/17", "issue_id": "#17", "issue_summary": "ioloop.py IOLoop remove_callback", "issue_description": "sri commented on 22 Sep 2009\nIf I am reading this correctly:\nThe body of the remove_callback method should be\nself._callbacks.remove(callback)\nnot\nself._callbacks.pop(callback)", "issue_status": "Closed", "issue_reporting_time": "2009-09-22T06:59:15Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1350": {"issue_url": "https://github.com/tornadoweb/tornado/issues/16", "issue_id": "#16", "issue_summary": "tornado.escape.json_encode should have the same signature as simplejson.dumps", "issue_description": "jed commented on 22 Sep 2009\nRight now, tornado.escape.json_encode will throw an error if any arguments other than the object to be encoded (such as the ensure_ascii option to prevent Unicode escaping) are passed.\nIs it possible to pass these options through as well?", "issue_status": "Closed", "issue_reporting_time": "2009-09-22T01:01:05Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1351": {"issue_url": "https://github.com/tornadoweb/tornado/issues/15", "issue_id": "#15", "issue_summary": "PeriodicCallback bug", "issue_description": "limscoder commented on 21 Sep 2009\nBug in line 275 of ioloop.py causes NameError:\nself.io_loop = io_loop or ioloop.IOLoop.instance()\nThe line should be:\nself.io_loop = io_loop or IOLoop.instance()", "issue_status": "Closed", "issue_reporting_time": "2009-09-21T05:06:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1352": {"issue_url": "https://github.com/tornadoweb/tornado/issues/14", "issue_id": "#14", "issue_summary": "libevent support", "issue_description": "dyuri commented on 18 Sep 2009\nI have a some machines with Solaris 10 and I wanted to try/use tornado on them also - but select() is very limited -, so I created a new little class (based on your _Select class) that uses libevent, so you can have better polling methods on non-linux systems.\nIt depends on python-libevent.\nHere you can find my modification, Solaris/FreeBSD users may find it useful:\nhttp://github.com/dyuri/tornado/blob/master/tornado/ioloop.py", "issue_status": "Closed", "issue_reporting_time": "2009-09-18T12:03:39Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1353": {"issue_url": "https://github.com/tornadoweb/tornado/issues/13", "issue_id": "#13", "issue_summary": "_TemplateReader slice", "issue_description": "severb commented on 18 Sep 2009\nOn line 424: slice.indices(size) call is missing the first arg (i.e. key).", "issue_status": "Closed", "issue_reporting_time": "2009-09-18T00:16:37Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1354": {"issue_url": "https://github.com/tornadoweb/tornado/issues/12", "issue_id": "#12", "issue_summary": "locale weekdays", "issue_description": "severb commented on 17 Sep 2009\n296 s/WEEKDAYS/_weekdays/", "issue_status": "Closed", "issue_reporting_time": "2009-09-17T09:07:20Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1355": {"issue_url": "https://github.com/tornadoweb/tornado/issues/11", "issue_id": "#11", "issue_summary": "GoogleAuth fails due to pycurl not handeling SSL connections", "issue_description": "eisokant commented on 16 Sep 2009\nIssue: http://groups.google.com/group/python-tornado/browse_thread/thread/4da447e9a79344c2\nSolution: http://groups.google.com/group/python-tornado/msg/2c74716c5cedb119", "issue_status": "Closed", "issue_reporting_time": "2009-09-16T14:56:10Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1356": {"issue_url": "https://github.com/tornadoweb/tornado/issues/10", "issue_id": "#10", "issue_summary": "XSRF token not needed for Ajax requests", "issue_description": "csytan commented on 16 Sep 2009\nThis is because of the same origin policy. See django's patch for more info:\nhttp://code.djangoproject.com/changeset/9554\nP.S. Thanks for releasing Tornado!", "issue_status": "Closed", "issue_reporting_time": "2009-09-16T01:30:34Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1357": {"issue_url": "https://github.com/tornadoweb/tornado/issues/9", "issue_id": "#9", "issue_summary": "server fails to parse folded headers", "issue_description": "dsporter commented on 15 Sep 2009\nThe server does not parse folded HTTP headers. Please see IETF RFC 2616 section 2.2 for the details.", "issue_status": "Closed", "issue_reporting_time": "2009-09-14T22:01:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1358": {"issue_url": "https://github.com/tornadoweb/tornado/issues/8", "issue_id": "#8", "issue_summary": "OpenIdMixin is likely broken for some providers due to POST/GET issue", "issue_description": "Contributor\nfiniteloop commented on 14 Sep 2009\nSee http://groups.google.com/group/python-tornado/browse_thread/thread/7331cc79de2f09f7", "issue_status": "Closed", "issue_reporting_time": "2009-09-13T19:28:21Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1359": {"issue_url": "https://github.com/tornadoweb/tornado/issues/7", "issue_id": "#7", "issue_summary": "HTTPClient may ignore method POST in some cases", "issue_description": "Contributor\nfiniteloop commented on 14 Sep 2009\nSee http://groups.google.com/group/python-tornado/browse_thread/thread/7331cc79de2f09f7", "issue_status": "Closed", "issue_reporting_time": "2009-09-13T19:28:01Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1360": {"issue_url": "https://github.com/tornadoweb/tornado/issues/6", "issue_id": "#6", "issue_summary": "iostream log message", "issue_description": "severb commented on 12 Sep 2009\n:207 s/Read/Write/", "issue_status": "Closed", "issue_reporting_time": "2009-09-11T19:45:08Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1361": {"issue_url": "https://github.com/tornadoweb/tornado/issues/5", "issue_id": "#5", "issue_summary": "Documentation Typo :: XSRF Form Example", "issue_description": "pkriete commented on 11 Sep 2009\nwebsite/templates/documentation.txt - Line 376\nShould have an action attribute instead of two method attributes.", "issue_status": "Closed", "issue_reporting_time": "2009-09-11T15:14:09Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1362": {"issue_url": "https://github.com/tornadoweb/tornado/issues/4", "issue_id": "#4", "issue_summary": "Documentation typo: javascript_file and css_file method names should be in plural", "issue_description": "tmu commented on 11 Sep 2009\nwebsite/templates/documentation.txt\nPassage:\nModules can include custom CSS and JavaScript functions by overriding\nthe embedded_css, embedded_javascript, javascript_file, or\ncss_file methods:\nChange\njavascript_file -> javascript_files\ncss_file -> css_files", "issue_status": "Closed", "issue_reporting_time": "2009-09-11T08:16:44Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1363": {"issue_url": "https://github.com/tornadoweb/tornado/issues/3", "issue_id": "#3", "issue_summary": "Automatically append / to urls, like django", "issue_description": "Contributor\njoerussbowman commented on 11 Sep 2009\nA nice to have would be for the request handler to automatically append a / to urls that don't have one, similar to how Django does it.\nCurrently I'm configuring urls like this\napplication = tornado.web.Application([\n(r\"/\", MainHandler),\n(r\"/test/*\", views.TestHandler),\n])\nBut being able to drop the regex * would make for simpler code and reduce a chance of a typo by forgetting to include it.", "issue_status": "Closed", "issue_reporting_time": "2009-09-11T03:32:45Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1364": {"issue_url": "https://github.com/tornadoweb/tornado/issues/2", "issue_id": "#2", "issue_summary": "Is there a way to run a system process asynchronously?", "issue_description": "hoisie commented on 11 Sep 2009\nIs there a way to run system commands asynchronously? For instance, let's say you're given an image as input, and you'd like to run some image conversion or optimization program in the background. Can you do this without blocking?", "issue_status": "Closed", "issue_reporting_time": "2009-09-10T22:33:25Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}, "1365": {"issue_url": "https://github.com/tornadoweb/tornado/issues/1", "issue_id": "#1", "issue_summary": "Can you test the speed vs. Pylons standalone and Django Standalone", "issue_description": "pykler commented on 11 Sep 2009\nTesting against things behind mod_wsgi is not a real test. There are too many variables in your performance test, this is not a good scientific experiment.", "issue_status": "Closed", "issue_reporting_time": "2009-09-10T19:53:26Z", "fixed_by": "", "pull_request_summary": "", "pull_request_description": "", "pull_request_status": "", "issue_fixed_time": "", "files_changed": []}}}
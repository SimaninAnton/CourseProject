EtienneBruines commented on 3 Dec 2015
I want to automate the certificate renewal using cron. In order to do so, I want to test the renew command, before putting it in my crontab.
Using this command:
./letsencrypt-auto certonly -c /etc/letsencrypt/pes_huperwebs_nl.cli --renew-by-default 
I'm getting the following error:
Failed authorization procedure. pes.huperwebs.nl (http-01): urn:acme:error:unauthorized 
:: The client lacks sufficient authorization 
:: Error parsing key authorization file: Invalid key authorization: malformed token
This is the pes_huperwebs_nl.ini file:
# This is an example of the kind of things you can do in a configuration file.
# All flags used by the client can be configured here. Run Let's Encrypt with
# "--help" to learn more about the available options.

# Use a 4096 bit RSA key instead of 2048
rsa-key-size = 4096

# Always use the production v01 server
server = https://acme-v01.api.letsencrypt.org/directory

# Uncomment and update to register with the specified e-mail address
email = etienne@bruines.com

# Specify the domains
domains = pes.huperwebs.nl

# Uncomment to use a text interface instead of ncurses
# text = True

# Uncomment to use the standalone authenticator on port 443
# authenticator = standalone
# standalone-supported-challenges = tls-sni-01

# Uncomment to use the webroot authenticator. Replace webroot-path with the
# path to the public_html / webroot folder being served by your web server.
authenticator = webroot
webroot-path = /var/www/pes_huperwebs_nl
It doesn't specify any file that is malformed, nor does it tell me how to fix it. I'm clueless here.
Debug process
I'm sending some kind of token to the server, which is of the format token.format. The dot is there, therefore it parses the 'parts' successfully, but the token part is apparently not well formed (i.e.: doesn't match regex ^[\\w-]{43}$.
Finally
After modifying the source a bit, and looking at the letsencrypt/boulder source, I found out this was caused by malformed response by nginx (bad configuration). I had to manually create a location entry in the nginx config file, because all other requests are being forwarded (reverse proxy) to a Go webserver (which isn't suited for this challenge-response).
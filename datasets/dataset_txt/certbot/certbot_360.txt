ishankhare07 commented on 27 Oct 2018
If you're having trouble using Certbot and aren't sure you've found a bug or
request for a new feature, please first try asking for help at
https://community.letsencrypt.org/. There is a much larger community there of
people familiar with the project who will be able to more quickly answer your
questions.
My operating system is (include version): kubernetes (possibly container optimized os)
I installed Certbot with (certbot-auto, OS package manager, pip, etc): certbot docker
I ran this command and it produced this output:
certbot certonly --noninteractive --agree-tos --staging --standalone -d staging.ishankhare.com -m me@ishankhare.com

Saving debug log to /var/log/letsencrypt/letsencrypt.log
Plugins selected: Authenticator standalone, Installer None
Obtaining a new certificate
Performing the following challenges:
http-01 challenge for staging.ishankhare.com
Waiting for verification...
Cleaning up challenges
Failed authorization procedure. staging.ishankhare.com (http-01): urn:ietf:params:acme:error:connection :: The server could not connect to the client to verify the domain :: Fetching http://staging.ishankhare.com/.well-known/acme-challenge/tpumqbcDWudT7EBsgC7IvtSzZvMAuooQ3PmSPh9yng8: Timeout during connect (likely firewall problem)
IMPORTANT NOTES:
 - The following errors were reported by the server:

   Domain: staging.ishankhare.com
   Type:   connection
   Detail: Fetching
   http://staging.ishankhare.com/.well-known/acme-challenge/tpumqbcDWudT7EBsgC7IvtSzZvMAuooQ3PmSPh9yng8:
   Timeout during connect (likely firewall problem)

   To fix these errors, please make sure that your domain name was
   entered correctly and the DNS A/AAAA record(s) for that domain
   contain(s) the right IP address. Additionally, please check that
   your computer has a publicly routable IP address and that no
   firewalls are preventing the server from communicating with the
   client. If you're using the webroot plugin, you should also verify
   that you are serving files from the webroot path you provided.
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.
Certbot's behavior differed from what I expected because:
When I run the above command using the same docker container on a GCP Compute machine instead of a kubernetes cluster, it works perfectly.
Here is a Certbot log showing the issue (if available):
Logs are stored in /var/log/letsencrypt by default. Feel free to redact domains, e-mail and IP addresses as you see fit.
Here is the relevant nginx server block or Apache virtualhost for the domain I am configuring: -
As a side note I'm attaching my kube pods and services yaml just in case someone wants to dig further.
service.yml
apiVersion: v1
kind: Service
metadata:
  name: certbot-lb
  labels:
    app: certbot-lb
spec:
  type: LoadBalancer
  loadBalancerIP: 35.189.170.149
  ports:
    - port: 80
      name: "http"
      protocol: TCP
    - port: 443
      name: "tls"
      protocol: TCP
  selector:
    app: certbot-generator
jobs.yml
apiVersion: batch/v1
kind: Job
metadata:
  #labels:
  #  app: certbot-generator
  name: certbot
spec:
  template:
    metadata:
      labels:
        app: certbot-generate
    spec:
      volumes:
        - name: certs
      containers:
        - name: certbot
          image: certbot/certbot
          command: ["certbot"]
          #command: ["yes"]
          args: ["certonly", "--noninteractive", "--agree-tos", "--staging", "--standalone", "-d", "staging.ishankhare.com", "-m", "me@ishankhare.com"]

          volumeMounts:
            - name: certs
              mountPath: "/etc/letsencrypt/"
              #- name: certs
              #mountPath: "/opt/"
          ports:
            - containerPort: 80
            - containerPort: 443
      restartPolicy: "OnFailure"
What I suspect: (I might be wrong!)
When running as a Docker container on a Compute instance, a default docker volume is created for the container, if not explicitly specified with a mount point. This allows the standalone server to use that volume and serve the .well-known directory.
When using the same in kubernetes, I create a Persistent Volume (PV) and mount it at the mount point /etc/letsencrypt - this allows me to store the generated certs on a persistent storage and use it later by mounting it on my nginx container. However, I have not mounted that PV at any mount point for the .well-known folder, which might be the reason why the certbot client is not able to find the challenge when resolving via DNS.
Also on inspecting further, I wasn't able to find a particular directory path that I should mount so that the .well-know dir should resolve (refer certbot/certbot/acme/acme/standalone.py)
If this gets working, we can have a simple and very automated way of generating a letsencrypt cert for and kubernetes cluster. I am using Job Controllers for this which seems to suit this particular case perfectly.
Once done with this, we can look into automated renewals for kubernetes clusters using CronJob kubernetes controller.
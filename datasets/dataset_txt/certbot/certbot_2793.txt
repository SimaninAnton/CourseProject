RalfJung commented on 6 Dec 2015
I am quite confused by how letsencrypt decides to name certificates when a certificate covers multiple domains, and confused about the relative scope of the global cli.conf and the files in renew.
By the "name" of a certificate, I mean the folder below /etc/letsencrypt/{live,archive} that the certificate is stored in. It seems to be the case that letsencrypt picks the first or the last domain name specified for this purpose. However, I couldn't see this properly documented (definitely not in --help). Since this name will probably be used throughout the lifetime of the server (or is there a way to rename?), this is rather annoying - I ended up with randomsubdomain.mydomain.de as the name. It is also entirely unclear what happens when I add more domains to the beginning / end of the list of current domains. Will it again pick the first domain, which is now a different one, and hence create a new cert that is entirely unrelated to the old one? Or will it somehow notice that some of the domains are already in an existing cert, and extend that? There could easily be multiple candidates though.
I thought that the files in /etc/letsencrypt/renew/*.conf would help me understand what is happening, but these files do not seem to change even when a certificate is successfully updated (e.g., when new domains are added). So now I don't even know whether changes in the cli.conf will affect any particular action I perform, since old copies of that configuration are stored in renew and may or may not be used whenever I do anything. The folder name seems to indictae that it is only used for automatic renewal, but then why should "get me a new cert and add this domain" be fundamentally different from "get me a new cert and keep the existing set of domains"? Really, renewal and changes in configuration are almost the same process, so I would think they also behave almost the same. or, put differently, changes in configuration can be decomposed into "change the target-state of the certificate", and "make a new certificate with the current target state", whereas renewal is just the second part.
All this ended up being so confusing and unpredictable, that I ended up running into the per-domain rate-limiting for one of my domains before I even understood what the client is doing. For my next domain, I ended up using a different client, that is way less convenient - but has predictable behavior, even without reading any docs.
Problem analysis
One of the core problems here is that "one of the domains the cert is valid for" is just the wrong kind of ID to name a sequence of cert-key-pairs that are considered successors of each other: The set of domains that are covered by the cert may change at any time. As time goes on, the domains that were originally in the cert could all be gone, and new domains be added, but the entire chain of cert-key-pairs can still be considered as belonging together. At any given point in time, no single domain may be the "main" domain, and even if there is a "main" one, it may change.
From what I understand, letsencrypt is managing a set of such "cert-key-sequences". I can modify existing such sequences, extend them with a new cert-key pair, keep the latest private key but get a new cert, change their configuration (set of domains, key size, whatever). I think this is a reasonable simple mental model, and everything letsencrypt does could be explained in terms of it. But the UI reflects this very poorly, IMHO, making it hard to map calls to letsencrypt, and changes in the global cli.conf, to this model.
Proposed solution
I suggest that letsencrypt makes a consistent distinction between a certificate sequence (there may be a better name for this) with some arbitrarily user-picked name for it, and the (set of) _domain_s the latest certificate of a sequence is valid for. It should always be clear whether an action creates an entirely new cert-seq or whether an existing cert-seq is extended. When a cert-seq already exists, it should always be clear whether a new private key is generated, or whether the previously existing private key is re-used.
I thought of something like this: All letsencrypt invocations can take a -n/--name parameter, which means they affect only the cert-seq stored in /etc/letsencrypt/{live,archive}/<name>. Some place is used to store interesting configuration for this sequence, e.g. renew/<name>.conf. When working on an existing sequence, one can use -d to add a new domain to the next certificate that wasn't present in the previous one, and some other flag to remove a domain. The file in renew/ always stores the current configuration of a sequence (the folder name doesn't really work then Any more, though). This includes exact current set of domains (matching the SANs in the certificate), and potentially more if the per-cert configuration differs from the global one (which can happen if the user sets flags on the CLI). That information is enough to do automatic renewal, but it is also used when e.g. adding a new domain to a sequence - all the other configuration stays the same. All the remaining configuration should either fall back to the global cli.conf, or it must be entirely clear how changes in the global configuration affect existing certificate sequences, and how to change the per-sequence config.
Or maybe this is entirely overkill, and there already is an easy mental model for what letsencrypt does right now, matching its UI. But then I would argue that model is not intuitively understood from the --help output, the name of the parameters, and the file structure stored in /etc/letsencrypt.
You probably don't want to change how everything works just for the fun of it, and I'm just talking here while you are doing all the work. That said, I'm very willing to work on improving this myself - hopefully I can find some of you guys at 32C3 :)
1
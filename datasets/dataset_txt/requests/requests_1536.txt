sinank commented on Jan 6, 2015
I am using a requests session pool in my code since we make a large number of HTTP requests.
We recently ran into an issue where temporary name resolution errors blocked the process from making any more HTTP requests since the pool was full.
I have pasted a quick script to reproduce the issue below.
from requests import Request, Session                                            
import requests                                                                  
import gevent                                                                    
from gevent import monkey                                                        

monkey.patch_all()                                                               

urltotest = 'http://thisisanunresolvablesite.com/foo'                            
MAX_CONC_REQUESTS_PER_CONNECTION = 21                                            
MAX_POOLS = 1                                                                    
MAX_CONC_REQUESTS = 5                                                            
# Requests session pool                                                          
http_pool = None                                                                 


def get_requests_session():                                                      
    global http_pool                                                             
    if not http_pool:                                                            
        http_pool = Session()                                                    
        adapter = requests.adapters.HTTPAdapter(                                 
            pool_connections=MAX_POOLS,                                          
            pool_maxsize=MAX_CONC_REQUESTS,                                      
            pool_block=True)                                                     
        http_pool.mount('http://', adapter)                                      
        http_pool.mount('https://', adapter)                                     
    return http_pool                                                             


def send_request_in_greenlet(i):                                                 
    try:                                                                         
        prepped = Request('GET', urltotest).prepare()                            
        session = get_requests_session()                                         

        print 'Sending request #', i                                             
        resp = session.send(prepped)                                             
        body = str(resp.content)                                                 
        status = str(resp.status_code)                                           
        print 'Reponse for request # %d - Status: %s' % (i, status)              
    except Exception as ex:                                                      
        print ex                                                                 

i = 0                                                                            
while i < 20:                                                                    
    i += 1                                                                       
    gevent.spawn(send_request_in_greenlet, i)                                    

try:                                                                             
    gevent.sleep(100)                                                            
except KeyboardInterrupt:                                                        
    pass  
The error seems to stem from the urlopen method in packages/urllib3/connectionpool.py:
       ...
       except (TimeoutError, HTTPException, SocketError) as e:                  
            if conn:                                                             
                # Discard the connection for these exceptions. It will be        
                # be replaced during the next _get_conn() call.                  
                conn.close()                                                     
                conn = None                                                      
             ...                                                                                 
        finally:                                                                 
            if release_conn:                                                     
                # Put the connection back to be reused. If the connection is        
                # expired then it will be None, which will get replaced with a   
                # fresh connection during _get_conn.                             
                self._put_conn(conn) 
I am not sure that this issue should be filed under urllib3 or requests. Apologizing in advance if I posted this at the wrong place.
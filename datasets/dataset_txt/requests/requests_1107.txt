Contributor
bodgit commented on Apr 13, 2016
I have an upstream server that supports both basic authentication and SSL client certificates for authenticating a client.
I have the following contrived requests client (with a session object) that hits the upstream server using basic auth and then switches to using SSL client certificates and repeats the request:
#!/usr/bin/env python

import requests

session = requests.Session()
session.verify = './cacert.pem'
session.auth = ('bob', 'password')

response = session.get('https://1.2.3.4/')

session.auth = None
session.cert = ('./cert.pem', './key.pem')
session.close()

response = session.get('https://1.2.3.4/')
Because the client certificates need to be presented at the beginning of the connection I use session.close() to tear down any active connections before attempting the second request. If I don't do this, the session connection pooling kicks in and reuses the existing connection from the first request which won't have presented any certificates and so the second request is unauthorised.
This is all understood however I then had a need for the client to access the server through a proxy so the code is updated to just add the proxy configuration:
#!/usr/bin/env python

import requests

session = requests.Session()
session.verify = False
session.auth = ('bob', 'password')

session.proxies = {
  'https': 'http://alice:secret@5.6.7.8:3128/',
}

response = session.get('https://1.2.3.4/')

session.auth = None
session.cert = ('./cert.pem', './key.pem')
session.close()

response = session.get('https://1.2.3.4/')
Now the second request is unauthorised; session.close() seems to have no effect and doesn't tear down the connections through the proxy; there are no TCP FIN packets initiated from the client which I do see when no proxy is used.
The upstream server has keepalives enabled so if I add a sleep for longer than the idle timeout then the server terminates the connection between itself and the proxy, then the proxy terminates the connection to the client and then the second request is successful.
I appreciate this is probably a corner case but any ideas here? I would expect session.close() to correctly tear down the connections to the proxy. I've reproduced this against version 2.9.1.
jaloren commented on May 24, 2016
I am on python2.7 installed on CentOS 6. I have OpenSSL 1.0.1e. I have requests version 2.9.1. The HTTP server is performing SSL client authentication. The client's chain has a verification depth of 2, which means there's a single intermediate CA certificate in the client chain. I am not sure if this is a bug or a feature request.
Based on the public api, I sent a request in like so. note i have explicitly chosen not to verify the server's chain of trust (i know that's not secure but this isn't being used in production). The cert.pem contains the client's PEM-encoded certificate, the intermediate CA cert, and the root cert. The final entity in the cert.pem is the client's private key (which is NOT encrypted).
resp = requests.get(url,verify=False,cert='cert.pem')
The following exception is thrown.
requests.exceptions.SSLError: Errno bad handshake
Looking at the server's ssl logs, I can see that the reason the server terminated the SSL connection was caused by the server's inability to construct the client's chain-of-trust. The server could not do this because the request's library only sent its client cert in it. I used openssl s_server to verify this as well.
I could not find anything in the official documentation that would allow me to specify a set of certs to be included in the client's chain-of-trust.
Looking at the pyopenssl wrapper used by requests, I can see the Context.use_certificate method, which sets the leaf cert. I am suspecting that only sets a single certificate. I suspect that for this to work, the requests external api would need to provide an interface for passing in a list of PEM-encoded certs, which is then set via the Context.add_extra_chain_cert method.
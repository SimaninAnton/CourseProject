gruns commented on Oct 26, 2016 â€¢
edited
Example:
import requests
from collections import MutableMapping

class mydict(MutableMapping):
  def __init__(self, *args, **kwargs):
    self.d = dict(*args, **kwargs)
  def __iter__(self):
    return iter(self.d)
  def __getitem__(self, key):
    return self.d.get(key)
  def __setitem__(self, key, value):
    self.d[key] = value
  def __delitem__(self, key):
    del self.d[key]
  def __len__(self):
    return len(self.d)

d = {'key':'value'}
myd = mydict(d)

# Works.
print requests.post('http://httpbin.org/post', data=d).json().get('form')

# Should also work but doesn't.
print requests.post('http://httpbin.org/post', data=myd).json().get('form')
In models.py, the is_stream check
is_stream = all([
    hasattr(data, '__iter__'),
    not isinstance(data, (basestring, list, tuple, dict))
])
explicitly checks if the data parameter is an instance of dict, so only
instances of dict can be passed through data=. All other dictionary-like
objects later bomb with
TypeError: must be convertible to a buffer, not mydict
Is it intentional that all dictionary-like objects not explicitly dict
subclasses are rejected? I can't fathom why.
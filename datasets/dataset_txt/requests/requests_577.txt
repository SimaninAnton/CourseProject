MatthewDaize commented on Jul 5, 2017
Summary.
I am trying to make a certificate-based request to an external URL using requests.get. I am trying to feed it the output of a call from the crypto library but it only allows paths.
What you expected.
I should be able to feed cert=(certificate, private_key) as part of a request with byte strings instead of file paths (of course in addition to)
This allows one to possibly avoid storing private keys at the path level and instead import a secured container (JKS for example) containing the key
What happened instead.
The request call seems to only take a file path and results in an error unable to find the file:
OSError: Could not find the TLS certificate file, invalid path: b'-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----\n
Reproduction Steps
import requests
import crypto

# Omitting argparse, file.read() commands for brevity in this example
p12 = crypto.load_pkcs12(keystoreFile, keystorePassphrase)

# These following commands output the contents of the loaded keystore
# In order to work around the error, they need to be redirected to new files (certificate.file, private_key.file
# These new file paths needs to be provided to the `requests.get` call
cert = crypto.dump_certificate(crypto.FILETYPE_PEM, p12.get_certificate())
caPem = crypto.dump_privatekey(crypto.FILETYPE_PEM, p12.get_privatekey())

resp = requests.get(APIURL, cert=(cert, caPem), verify=False)
System Information
{
  "chardet": {
    "version": "3.0.4"
  },
  "cryptography": {
    "version": "1.9"
  },
  "implementation": {
    "name": "CPython",
    "version": "3.6.1"
  },
  "platform": {
    "release": "16.6.0",
    "system": "Darwin"
  },
  "pyOpenSSL": {
    "openssl_version": "1010006f",
    "version": "17.1.0"
  },
  "requests": {
    "version": "2.18.1"
  },
  "system_ssl": {
    "version": "100020cf"
  },
  "urllib3": {
    "version": "1.21.1"
  },
  "using_pyopenssl": true
}
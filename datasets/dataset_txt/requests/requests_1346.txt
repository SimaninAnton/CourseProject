offbyone commented on Jul 31, 2015
I'm receiving a strange connection error using Requests 2.7.0
connecting to an HTTP service as part of an integration test. Below is
the call stack when I call into session.request in the API (for
reasons of NDA I can't provide the rest of the callstack).
The error is below in full detail, but in short, send() in requests is emitting ConnectionError: ('Connection aborted.', error(115, 'Operation now in progress'))
Python=2.7
Requests=2.7.0
The parameters being passed in to this are:
verb=POST
url=(an HTTP url for an internal service)
data=(a dict)
verify=False
cert=None
headers={'Content-Encoding': 'amz-1.0', 'Connection': 'keep-alive', 'Accept': 'application/json, text/javascript, /', 'User-Agent': 'A thing', 'Host': 'hostname', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', 'Content-Type': 'application/json'} # plus some service headers used by our service
timeout=False
proxies=NoneÔ¨Å
package-cache/packages/Requests/lib/python2.7/site-packages/requests/api.py:50: in request
response = session.request(method=method, url=url, *_kwargs)
package-cache/packages/Requests/lib/python2.7/site-packages/requests/sessions.py:465: in request
resp = self.send(prep, *_send_kwargs)
package-cache/packages/Requests/lib/python2.7/site-packages/requests/sessions.py:573: in send
r = adapter.send(request, **kwargs)
self = <requests.adapters.HTTPAdapter object at 0x7ff845dccd50>, request = <PreparedRequest [POST]>, stream = False, timeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7ff845dd0cd0>, verify = False, cert = None
proxies = {}
def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
    """Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a (`connect timeout, read
            timeout <user/advanced.html#timeouts>`_) tuple.
        :type timeout: float or tuple
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        """

    conn = self.get_connection(request.url, proxies)

    self.cert_verify(conn, request.url, verify, cert)
    url = self.request_url(request, proxies)
    self.add_headers(request)

    chunked = not (request.body is None or 'Content-Length' in request.headers)

    if isinstance(timeout, tuple):
        try:
            connect, read = timeout
            timeout = TimeoutSauce(connect=connect, read=read)
        except ValueError as e:
            # this may raise a string formatting error.
            err = ("Invalid timeout {0}. Pass a (connect, read) "
                   "timeout tuple, or a single float to set "
                   "both timeouts to the same value".format(timeout))
            raise ValueError(err)
    else:
        timeout = TimeoutSauce(connect=timeout, read=timeout)

    try:
        if not chunked:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout
            )
        # Send the request.
        else:
            if hasattr(conn, 'proxy_pool'):
                conn = conn.proxy_pool

            low_conn = conn._get_conn(timeout=timeout)

            try:
                low_conn.putrequest(request.method,
                                    url,
                                    skip_accept_encoding=True)

                for header, value in request.headers.items():
                    low_conn.putheader(header, value)

                low_conn.endheaders()

                for i in request.body:
                    low_conn.send(hex(len(i))[2:].encode('utf-8'))
                    low_conn.send(b'\r\n')
                    low_conn.send(i)
                    low_conn.send(b'\r\n')
                low_conn.send(b'0\r\n\r\n')

                r = low_conn.getresponse()
                resp = HTTPResponse.from_httplib(
                    r,
                    pool=conn,
                    connection=low_conn,
                    preload_content=False,
                    decode_content=False
                )
            except:
                # If we hit any problems here, clean up the connection.
                # Then, reraise so that we can handle the actual exception.
                low_conn.close()
                raise
            else:
                # All is well, return the connection to the pool.
                conn._put_conn(low_conn)

    except (ProtocolError, socket.error) as err:
      raise ConnectionError(err, request=request)
E ConnectionError: ('Connection aborted.', error(115, 'Operation now in progress'))
cert = None
chunked = False
conn = <requests.packages.urllib3.connectionpool.HTTPConnectionPool object at 0x7ff844c68c10>
err = ProtocolError('Connection aborted.', error(115, 'Operation now in progress'))
proxies = {}
request = <PreparedRequest [POST]>
self = <requests.adapters.HTTPAdapter object at 0x7ff845dccd50>
stream = False
timeout = <requests.packages.urllib3.util.timeout.Timeout object at 0x7ff845dd0cd0>
url = '/'
verify = False
package-cache/packages/Requests/lib/python2.7/site-packages/requests/adapters.py:415: ConnectionError
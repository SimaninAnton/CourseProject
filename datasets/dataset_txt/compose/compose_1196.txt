pharring commented on 19 Sep 2017
TL;DR
Looking for ideas to speed up back-to-back calls to docker-compose.
Long version
I’m working with the Docker Tools team in Visual Studio to help improve the developer experience for Visual Studio customers working with Docker projects. One of the scenarios we want to improve is the F5 time. i.e. the time it takes to build, deploy and debug an application using the Visual Studio IDE. In the case of a Docker-enabled application, that includes the time to rebuild any Docker containers. A Docker-enabled application consists of a docker-compose YML file referencing one or more projects with dockerfiles. During a build and deploy we call docker-compose several times. The exact sequence and number of calls varies depending on the topology of the application, but in a recent test for a simple MVC web application, I recorded seven docker-compose calls:
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.debug.g.yml" -p dockercompose15800850525253410089 config
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.release.g.yml" -p dockercompose15800850525253410089 kill
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.release.g.yml" -p dockercompose15800850525253410089 down --rmi local --remove-orphans
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.debug.g.yml" -p dockercompose15800850525253410089 kill
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.debug.g.yml" -p dockercompose15800850525253410089 down --rmi local --remove-orphans
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.debug.g.yml" -p dockercompose15800850525253410089 up -d --build
docker-compose -f "C:\app\docker-compose.yml" -f "C:\app\docker-compose.override.yml" -f "C:\app\obj\Docker\docker-compose.vs.debug.g.yml" -p dockercompose15800850525253410089 up -d
Aside: We think we can eliminate some of those calls, but I think we're still going to end up with at least 5 calls to docker-compose.
Now, docker-compose is really a self-extracting executable built using PyInstaller in “one file” mode. Each invocation will extract the payload to a temporary folder and launch a child process. The child process does the actual work and, when it exits, the original process cleans up the temporary folder and exits. Calling docker-compose several times back-to-back, therefore, results in a lot of repeated work. Specifically, there is the CPU cost of decompressing the payload and the file I/O cost of writing to the temp folder. Additionally, the I/O writes may trigger a scan from a virus scanner, further adding to the cost. In testing, on a fairly fast machine with an SSD, each invocation took between 200 and 250ms and wrote 9MB to temp before starting the child process (docker-compose.exe for Windows, version 1.14.0, build c7bdf9e).
So, I’m looking at ways of reducing or eliminating that repeated cost. I wanted to check with the community to avoid implementing something that might be already covered, has already been rejected or would be against the spirit of docker-compose.
Some ideas:
Preserve the contents of the temp folder so that they can be re-used each time. Reading the PyInstaller source code, the _MEIPASS2 environment variable can be set to point to an already-extracted folder location. We would need a PyInstaller modification to trigger an extraction the first time.
Supply docker-compose as a “one folder” application instead of, or in addition to the “one file” version. In that mode, there is no extraction and docker-compose runs directly from the installed location.
Add some sort of “batch mode” to docker-compose so that multiple commands (config, kill, down, up, etc.) can be executed in one go. This isn’t ideal, because the way Visual Studio calls docker-compose doesn’t lend itself to batching, but it may help a little.
Any other ideas here? Is anyone else working in this space? Has this sort of thing come up before?
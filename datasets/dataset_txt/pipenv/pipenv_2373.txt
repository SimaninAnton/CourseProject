justinmayer commented on 24 Mar 2017
As recently as Pipenv v3.3.6, I manually created my own virtual environment, installed Pipenv into it, and used Pipenv to manage project packages within that already-active virtual environment.
But since then there seems to have been a change that disrupts that workflow, and now Pipenv appears to ignore the active virtual environment and insists on creating its own virtual environment with an appended hash.
Steps to reproduce
> fish --version
fish, version 2.5.0

> echo $WORKON_HOME
/Users/me/virtualenvs

> vf new -p python3 foo  # manual creation of `foo` virtual environment

> (foo) echo $VIRTUAL_ENV
/Users/me/virtualenvs/foo

> (foo) pip install pipenv

> (foo) pipenv --version
pipenv, version 3.5.4

> (foo) pipenv install django==1.11rc1
Creating a Pipfile for this project...
Creating a virtualenv for this project...
Expected result
Pipenv would use the currently-active virtual environment.
Observed result
Pipenv ignores the currently-active virtual environment and creates a new environment, as seen above.
Additional notes
I sincerely hope this is merely a bug, and that the answer to this is not, "Virtualenv is behaving as intended." I say this because (1) Pipenv supported this use case last month, and (2) I believe that Pipenv should support this use case: namely, installing Pipenv into a virtual environment, installing packages into that already-active virtual environment, and not insisting on creating its own virtual environment. I suspect this was introduced in a81197d, but that's just a guess.
In addition to other problems, this change breaks automatic linking of projects and virtual environments based on identical naming conventions. Up until now, I have always been able to workon foo, which automatically activates the foo environment and switches to the ~/projects/foo directory. This change breaks that automation.
8
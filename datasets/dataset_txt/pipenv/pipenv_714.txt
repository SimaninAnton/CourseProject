Contributor
sirosen commented on 25 Aug 2018
Reading #2765 , I considered making a comment there, but I think this is really a distinct issue.
Docs state that one should not commit Pipfile.lock to your VCS: that appears to conflict with trying to use pipenv to get reproducible deployments and testing.
Perhaps I'm misunderstanding the expected pipenv usage, but having used bundler in the past, it's worth noting that bundler explicitly recommends committing Gemfile.lock.
Bundler provides a pretty good explanation of why its valuable to put the Gemfile.lock into version control. Why does that reasoning not apply to pipenv?
Is there a philosophical gulf between pipenv and bundler at play? If I do want to record my Pipfile.lock, where is that going to let me down?
Note that the Ruby community has been pretty successful with Bundler so far -- that's the justification for following their lead on dev requirements (and I buy it! I may not love everything Ruby, but it seems to work fine for that community). So it seems that there needs to be a pretty strong justification for breaking from their typical practice here.
My team is currently committing our lockfiles as we start using pipenv, and using pipenv install --ignore-pipfile. I'd really like more clarity -- either here or in the docs -- on how pipenv expects to be used to produce simple, reproducible builds if the Pipfile.lock is never recorded.
Use Cases
I was able to think of a few simple scenarios in which it's clear to me why you want Pipfile.lock in the git repo.
I'm sure there are others too, these are just the ones most familiar to me personally.
If there's a clear answer on how to handle these use-cases with pipenv, I'd love to know (and to change what I and my coworkers are doing as we start trying out pipenv usage).
1: simple deployment with pipenv
wsgi app in a git repo
servers git clone the repo, pipenv ... to setup a virtualenv, and then serve the app with a wsgi server
should be able to deploy old commits easily, even if there are newer versions of packages
the servers should all use the same package versions
if pipenv commands fail, try to recover, and if they keep failing, abort the whole deployment and the new servers never go live
2: simple (less risky) deployment with pipenv
same as above except...
after install, server is turned into an image (e.g. AWS AMI, Docker Container, etc)
real servers spin up from that image
Note that we can just install from the Pipfile in this case, but it would mean that we have less control over when we update dependencies.
3: git-bisect with reliable results
a bug is found in an app
a simple test for the bug is devised
apply that test to see where the bug was introduced with git bisect, using Pipfile.lock to guarantee that we don't break past versions of the code by introducing newer-than-expected libraries
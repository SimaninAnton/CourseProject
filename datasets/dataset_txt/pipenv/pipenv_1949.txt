mattjegan commented on 12 Oct 2017
Motivation
I tried to run pipenv install and recieved the warning:
Warning: Your dependencies could not be resolved. You likely have a mismatch in your sub-dependencies.
  You can use $ pipenv install --skip-lock to bypass this mechanism, then run $ pipenv graph to inspect the situation.
Upon running pipenv install --skip-lock I ran pipenv graph too try inspect the dependancy tree for the specific package that couldn't be resolved. For a large project, it takes a considerable amount of time to find the package since it is a sub-dependancy in a large tree. It would be useful to be able to get just the subtrees I'm looking for.
Proposal
I propose that a --why flag could be added to pipenv graph such that we can get the subtrees associated with some package.
Example
The currrent behaviour would look like this:
$ pipenv graph

.
.
.
blessed==1.14.2
  - six [required: >=1.9.0, installed: 1.11.0]
  - wcwidth [required: >=0.1.4, installed: 0.1.7]
.
.
.
cement==2.10.2
ConfigArgParse==0.12.0
crayons==0.1.2
  - colorama [required: Any, installed: 0.3.9]
.
.
.
django-cacheops==4.0.1
  - django [required: >=1.8, installed: 1.11.6]
    - pytz [required: Any, installed: 2017.2]
  - funcy [required: <2.0,>=1.8, installed: 1.9.1]
  - redis [required: >=2.9.1, installed: 2.10.6]
  - six [required: >=1.4.0, installed: 1.11.0]
.
.
.
But upon trying to search for six usages we would get something like this:
$ pipenv graph --why six

blessed==1.14.2
  - six [required: >=1.9.0, installed: 1.11.0]
django-cacheops==4.0.1
  - six [required: >=1.4.0, installed: 1.11.0]
I believe this would make manual dependency resolving much faster for users.
Also, thanks for the awesome work
2
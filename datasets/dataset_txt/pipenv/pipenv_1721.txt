Member
uranusjr commented on 15 Dec 2017 •
edited
I understand the existence of #902, but the it seems the OP was looking for something different.
Sometimes I want Pipenv to handle one particular project differently than others. The most common problem is I don’t usually set PIPENV_VENV_IN_PROJECT, but for some projects I want to do. This is however not possible, because they are loaded for shell and run, not install etc., and even if they are, .env is loaded during runtime, therefore doesn’t affect values in environments.py.
direnv and similar tools like autoenv are not an option for me because they are all shell-depedent, and I operate in the command prompt on Windows.
My current workaround is to use a custom Dotenv loader, and a Batch script like this:
REM pipenv.bat
REM Shim to wrap Pipenv invocation in a loaded environment.
REM Put this in the project root so it’s picked up when you call "pipenv".

if exist ".env" (
    dotenv-run pipenv %*
) else (
    pipenv %*
)
which sort of works, but is suboptimal. I wish Pipenv could handle this more cleanly since it already loads .env files anyway.
Steps to replicate
Create a project
Run pipenv install with PIPENV_VENV_IN_PROJECT set
Unset PIPENV_VENV_IN_PROJECT, create .env with PIPENV_VENV_IN_PROJECT=1
Expected result
> pipenv install
Loading .env environment variables…
Installing dependencies from Pipfile.lock
Pipenv should go on reusing .venv and perform operations.
Actual result
> pipenv install
Creating a virtualenv for this project…
Pipenv goes on to create a virtualenv in the default location, not respecting values in .env.
1
Member
brosner commented on 16 Sep 2017
In my shell environment, I am seeing behavior I would not expect. I've been able to correct the behavior by setting PIPENV_IGNORE_VIRTUALENVS, but why I have to is really confusing me.
I am using pyenv for managing Python versions only (no funny virtualenv management, this is why I want to use pyenv). I've configured my shell to ensure pyenv doesn't sit in-front of the virtual environment's bin path. I understand this can be accomplished with PIPENV_SHELL_COMPAT, but I am effectively doing the same thing and confirmed it is working correctly.
That aside, when I cd to my project and run pipenv install --verbose I see it choose the correct pip path (the pip in the environment for the project). Then I used pipenv shell and at some point realized I needed to install another dependency so naturally I ran pipenv install -d flake8. This invocation is using my system pip. This was completely unexpected. After digging around I found that the basis of this decision is in how PIPENV_USE_SYSTEM is set. If the environment variable VIRTUAL_ENV has a value it will use the system pip (or more precisely the pip in the environment where pipenv is installed). To further complicate matters, the comment above PIPENV_USE_SYSTEM confused me:
Tells Pipenv to use the virtualenv-provided pip instead.
which leads me to think that pipenv must be installed in each virtual environment?
I am not quite sure what the solution is, but I feel there is at least a documentation change needed somewhere. The fact that setting PIPENV_IGNORE_VIRTUALENVS actually lets me respect the the virtual env is backwards.
Thank you for pipenv and I am looking forward to continuing to use it! Great work!
guyzmo commented on 29 Apr 2017 •
edited
You say pipenv is a marriage of Pipfile, Pip, & Virtualenv. But there's one depency related task that's left to be done manually, that's managing setup.py's install_requires.
As @dstufft wisely says in his article, abstract depencies and concrete depencies are used in different contexts. But when you do your code, you're managing them at the same time. If you change a depency, you'll have to modify both setup.py or the Pipfile. I believe, it'd be nice to make it possible to manage the abstract dependencies using pipenv.
From a pipenv user perspective, I mean something that would look like:
# in Pipfile → [dev-packages]
pipenv install --dev pytest mock delegator.py toml Sphinx
# in Pipfile → [packages]
pipenv install pew>=0.1.26
# in setup.py → install_requires
pipenv install --abstract virtualenv pip pew>=0.1.26
Maybe could we extend the syntax so it has three options:
# in Pipfile → [dev-packages]
pipenv install --dev pytest mock delegator.py toml Sphinx
# in Pipfile → [packages] (only)
pipenv install --concrete foobar
# in Pipfile → [packages] and setup.py → install_requires
pipenv install pew>=0.1.26
# in setup.py → install_requires (only)
pipenv install --abstract virtualenv pip 
That way, pipenv is the entry point tool to manipulate everything related to dependency management and associated virtualenv. And from a trouple marriage, it'll be a marriage of four tools .
Now, on the question on how to implement this, I'm not much in favour of automatic edition of a .py file, because there are just too many ways it can go wrong. But instead, store the abstract depencies externally in a new [abstract-packages] section of Pipfile if it's ok with @pypa, or in an abstract-requirements.txt file or any other smarter solution I haven't think of yet.
What do you think?
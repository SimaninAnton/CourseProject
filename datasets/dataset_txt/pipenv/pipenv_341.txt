geoffroy-noel-ddh commented on 8 Jan 2019 â€¢
edited
I'm new to pipenv but my colleagues and I maintain a very large number of legacy and current projects running on pip + virtualenv (or conda in some cases). We are thinking of migrating to pipenv because it is a well supported tool with two major benefits: the deterministic builds and the dependency management.
However while trying to migrate our environments and provisioning tools I got caught by existing habits which have become obsolete with pipenv and I'm wondering if it would be useful to extend the doc for other dev teams to know upfront which practices no longer apply or ease their migration process?
Here are some examples of what we found quite surprising, coming from pip+virtualenv:
if you call myenv/bin/python or myenv/bin/pip directly they are aware of the environment they belong to. But if you call myenv/bin/pipenv directly, the environment it uses is based on your current working directory;
similarly, if you activate your virtual environment and call pip or python (or conda), they will always relate to that environment, whatever the current directory is. This is no longer the case with pipenv, try pipenv shell, then move out of your project directory, then do pipenv graph and it will give you a warning about the absence of virtual environment. Compare that with pip freeze, which will still lists packages from the actived VE. This is probably the most confusing behaviour as you'd expect activate to force a permanent link with environment;
if you call pip (un)install, it will still work but obviously ignores the Pipfiles. So once you start using pipenv to manage your package it is preferable to no longer use pip directly for that purpose. Which is easy to forget if you work on a mix new projects (managed with pipenv/Pipfiles) and legacy ones (still on pip/requirements.txt);
if you have a legacy virtual environment and want to start managing it with pipenv by installing pipenv into it, you should be cautious about some commands such as pipenv clean which will behave differently if you had created the VE with pipenv. That workflow is not well supported and you might consider recreating your VE with pipenv instead;
again if you have a legacy system and want to keep your VE in a specific location of your choice, you can set WORKON_HOME variable to point to that location so pipenv is aware of it;
pipenv shell starts a subshell, and you need to leave it with exit. Which is quite different from myenv/bin/activate and deactivate;
Let me know if any of the above is incorrect, I'm still learning so I might have misunderstood sa few things. The idea here is to provide some tips for people who want to migrate legacy projects (i.e. not created with pipenv).
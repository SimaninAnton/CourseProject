Contributor
noyainrain commented on 26 Mar 2019
First of all, thanks for adding type annotations to Tornado
For stricter type checking, in our code base we have enabled mypy's disallow-any-expr flag. Unfortunately, this leads to errors in conjunction with Tornado's current type annotations.
Consider main.py, a shortened version of the hello world example:
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
 ...

application = tornado.web.Application([(r"/", MainHandler)])
Running mypy on it produces the following error:
$ mypy --disallow-any-expr main.py 
main.py:7: error: Expression type contains "Any" (has type "Type[MainHandler]")
The reason is that the signature of RequestHandler.__init__() contains Any. The type system interprets RequestHandler as def (..., **kwargs: Any) -> main.MainHandler. Using the class as an expression (passing it to Application) will then trigger the (correct) error.
It seems to me the current convention is to rather use object in constructors and make use of Any only if something cannot be expressed completely by the type system. For example, this is what the typeshed coding style says:
When adding type hints, avoid using the Any type when possible. Reserve the use of Any for when:
the correct type cannot be expressed in the current type system; and
to avoid Union returns (see above).
Note that Any is not the correct type to use if you want to indicate that some function can accept literally anything: in those cases use object instead.
Thus, a solution for the problem would be to swap **kwargs: Any with **kwargs: object for RequestHandler.
PS: Grepping through the Tornado code base, I found 29 occurrences of Any in init. So for a general solution it may be necessary to look at each constructor and determine case-by-case if object would be more appropriate than Any.
FZambia commented on 15 May 2014
Hello, @bdarnell and others! Sorry for such an abstract issue subject. But at moment I can not describe a problem better.
I am developing project Centrifuge ( https://github.com/FZambia/centrifuge ) on top of Tornado. Today I tried to update Tornado to master branch and test that everything works fine. Unfortunately it doesn't.
In Centrifuge I use redis wrapper by @mrjoes - https://github.com/mrjoes/toredis . This is a very simple wrapper - client has a list of callbacks which fire with data as soon as data comes from Redis (hiredis parser split data coming from redis into separate messages).
I have a benchmark where many clients connect to Centrifuge and send messages. And when many cients connected and message rate is high in tornado 3.3 some Tasks yield results from other different Tasks from another coroutine. To describe it simple let's write some abstract code:
@coroutine
def func_first():
    value = yield Task(redis.get, "key", "value")

@coroutine
def func_second():
    # this value seem to be a result yielded by Task from coroutine above 
    value = yield Task(redis.expire, "key", "value")
At moment I don't find a way how to reproduce this in a simple way - just started researching. Also I am not so sure that this problem must be fixed in Tornado and not in toredis or in my application code.
So, things work well in tornado 3.1.1, 3.2.0, 3.2.1 - I then started to search for a commit where a problem starts and found this one - 184d796 .
Here is a change in Tornado gen.py after which my problem appears:
if isinstance(yielded, YieldPoint):
    self.future = TracebackFuture()

    def start_yield_point():
        try:
            yielded.start(self)
            if yielded.is_ready():
                self.future.set_result(
                    yielded.get_result())
            else:
                self.yield_point = yielded
        except Exception:
            self.exc_info = sys.exc_info()

    if self.stack_context_deactivate is None:
        # Start a stack context if this is the first
        # YieldPoint we've seen.
        with stack_context.ExceptionStackContext(
                self.handle_exception) as deactivate:
            self.stack_context_deactivate = deactivate
            def cb():
                start_yield_point()
                self.run()
            self.io_loop.add_callback(cb)
            return
    else:
        start_yield_point()
instead of just:
if isinstance(yielded, YieldPoint):
    self.future = TracebackFuture()
    try:
        yielded.start(self)
        if yielded.is_ready():
            self.future.set_result(
                yielded.get_result())
        else:
            self.yield_point = yielded
    except Exception:
        self.exc_info = sys.exc_info()
I do not understand clearly what's going on in this place. Could these changes introduce a problem described above?
djt5019 commented on 28 Jun 2013
Hi everyone!
I was messing around a bit and I noticed that the Application.__call__ method will always fall back to the stock ErrorHandler class when there is no applicable handler for the request.
My question is would there be value in allowing the Application object to take a RequestHandler and use that in place of the hard coded error handler?
This can be emulated by defining a "catch-all" RequestHandler with a .* regex pattern however I am not really a fan of that since it needs to be the last handler in the handlers list.
I was think something along the lines of:
class Application(object):

    def __init__(self, handlers=None, default_host="", transforms=None,
                 wsgi=False, **settings):
        # Some of the other __init__ stuff...
        self._error_handler = settings.get('error_handler', ErrorHandler)
        if not isinstance(self._error_handler, RequestHandler):
            raise Exception("That's not a proper request handler!") 
        # rest of the __init__ code 

    def __call__(self, request):
        # __call__ code
        for spec in handlers:
            # look for an applicable handler

        if not handler:
           handler = self._error_handler(self, request, status_code=404)
It could in turn be used kind of like:
from tornado.web import Application, ErrorHandler

class JsonErrorHandler(ErrorHandler):

    def write_error(self, status_code, **kwargs):
        self.set_status(status_code)
        self.write({'error': 'Hey man, quit it!'})

app = Application(handlers=[], error_hander=JsonErrorHandler)
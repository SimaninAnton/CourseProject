Contributor
AaronOpfer commented on 22 Nov 2015
I propose adding a decorator called debounce. It would be similar in function to the method of the same name in lodash, a JavaScript library.
debounce would be a sort of relative of PeriodicCallback so I suppose it could live in tornado.gen.
Often times when writing asynchronous code on the server, clients may all ask for the same event to occur within a very short time. Or, an asynchronous server may have a continuous data-feed from a TCP socket which has tendencies to be bursty but also have periods of inactivity. This information could also be ephemeral where only the latest piece of information is relevant to users (examples of data that fits this description might be event counters, change notifications for a file or remote resource, etc.).
If servers acted on every event in this theoretical data stream, it would perform the work on every invocation. Then, the result of this work would be thrown away immediately afterward when the new updated data arrived. In fact, a server could begin to have severe latency and performance problems if the length of time the work the server wants to perform on an event is longer than the period between the duplicate events.
debounce would be a silver bullet for this problem. It would be able to collapse several calls to the same method in some time frame into a single invocation of that method. The return value of debounce would be a Future, which will eventually hold the result of the method call when it occurs. debounce would have options for whether to trigger on the leading edge, the trailing edge, or both the leading and trailing edge of the timeout value.
In addition, debounce would also have an optional feature its version in lodash does not: the ability to prevent further calls to the method if there is already an incomplete future from a previous call. This incomplete future would be returned by debounce instead. This would make debounce act like a simple job queue that prevents duplicate entries.
The only part of this feature that's a bit iffy is handling methods of classes, since they would most likely want a different timer per class instance. It would be possible to approximate this behavior automatically with a kwarg self=None on the wrapped function, and then using self as a key to differentiate sets of timers, but that only would work if the wrapped function was following the unenforced convention of using 'self' as the class instance argument. This is probably a reasonable assumption to make.
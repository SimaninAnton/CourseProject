mjhostet commented on 27 Jun 2013
I noticed I had a large number of Python objects that were unexpectedly not being garbage collected. I tracked down the problem to PollIOLoop holding on to the memory for its most recent batch of callbacks while it blocks waiting for new callbacks to come in. So anything that a callback transitively points to cannot be freed until you post another callback.
I propose the following simple change to release callback memory before blocking in poll().
--- tornado/tornado/ioloop.py.orig  2013-06-27 12:18:17.120725000 -0400
+++ tornado/tornado/ioloop.py   2013-06-27 12:19:16.324277000 -0400
@@ -600,18 +600,21 @@

             # Prevent IO event starvation by delaying new callbacks
             # to the next iteration of the event loop.
             with self._callback_lock:
                 callbacks = self._callbacks
                 self._callbacks = []
             for callback in callbacks:
                 self._run_callback(callback)

+            # Allow these to get garbage collected before poll() blocks below.
+            callback = callbacks = None
+
             if self._timeouts:
                 now = self.time()
                 while self._timeouts:
                     if self._timeouts[0].callback is None:
                         # the timeout was cancelled
                         heapq.heappop(self._timeouts)
                         self._cancellations -= 1
                     elif self._timeouts[0].deadline <= now:
                         timeout = heapq.heappop(self._timeouts)
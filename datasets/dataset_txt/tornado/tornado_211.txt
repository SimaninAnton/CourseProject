adamrothman commented on 24 Mar 2018
Creating a new AsyncIOLoop always creates a new underlying asyncio event loop. I think this makes sense in most cases but it would be very helpful (especially for testing, read on) to be able to pass an existing asyncio event loop for Tornado to wrap.
We use pytest with the pytest-asyncio plugin to run our test suite for several Tornado applications. After upgrading one of these apps to Tornado 5 and improving our test hygiene to use a new event loop for each test, our test suite broke.
Our unit tests are simple because they don't interact with or depend on tornado.testing.AsyncTestCase at all. Our integration tests do (because they make requests against the application), however, and this is where I ran into trouble. When I ran the tests, I would get a ton of errors due to Tasks getting Futures attached to a different loop, like this:
RuntimeError: Task <Task pending coro=<test_get_targets() running at /Users/adam/Other/src/pusheen/tests/integration/application_api_test.py:279> cb=[IOLoop.add_future..() at /Users/adam/Other/src/pusheen/.tox/verbose/lib/python3.6/site-packages/tornado/ioloop.py:721]> got Future <Task pending coro=<AioBaseClient._make_api_call() running at /Users/adam/Other/src/pusheen/.tox/verbose/lib/python3.6/site-packages/aiobotocore/client.py:65>> attached to a different loop
pytest-asyncio creates a new event loop for each async test that it runs (which is a good thing). Previously we were overriding this behavior to always return the "main" loop via asyncio.get_event_loop() and explicitly not close the loop between tests. This worked under Tornado 4 because we were using AsyncIOMainLoop, and Tornado 4 did not close the underlying asyncio event loop in such a configuration. But this override has always felt kind of gross to me, so I resolved to remove it. After all, there's no reason it should be necessary; we are careful to pass the testing event loop to classes that require it so they don't grab the main loop by default. Plus, Tornado 5 does close the underlying loop when closing AsyncIOMainLoop.
But making this change borked our tests.
We have some setup code that is shared between the unit and integration tests. This setup is handled by pytest, so a number of async singletons (e.g. DB connectors) get configured to use the event loop created by pytest-asyncio for each test.
tornado.testing.AsyncTestCase also creates a loop for each test – an IOLoop – by calling get_new_ioloop as part of setUp. This is still a good thing – but turned out to be the cause of my sadness. During the integration tests, our application logic is run by Tornado's loop, but per the above, the async singletons use pytest-asyncio's loop. When async code running on one loop tries to interact with async code on the other, people weep in the streets.
Being able to override AsyncTestCase.get_new_ioloop goes most of the way towards solving this issue. It's not difficult to expose pytest-asyncio's event loop to this function – the problem is that I can't use this existing asyncio event loop to instantiate the Tornado IOLoop get_new_ioloop is expected to return.
For now I'm working around this limitation by overriding pytest-asyncio's default behavior to first create an AsyncIOLoop and then using the underlying .asyncio_loop. This feels wrong, though. pytest shouldn't need to know about what's happening "downstream" as long as it implements a compatible test interface like unittest.TestCase.
Mine is just one (long-winded, sorry) case but I can imagine there are other situations in which users would want to provide an existing event loop to Tornado. What do you think @bdarnell?
1
Contributor
pitrou commented on 29 Dec 2017
I'm having an infinite coroutine (basically a while True: ... wrapped in a @gen.coroutine) that seems to create a leak somewhere, even though all external references get cleared. I was scratching my head a bit and came to the following hypothesis: the existence of the _futures_to_runners mapping keeps the Runner alive until its Future gets destroyed. However, if the Future itself is for some reason kept alive by the Runner (through an arbitrarily complex reference chain), then the cyclic collector isn't able to make out the reference cycle and break it.
Does that sound like a reasonable explanation? Does it mean that moving to await and async def would clear the reference leak (as an external mapping is not needed anymore)?
P-EB commented on 30 Sep 2018 â€¢
edited
Hi,
I'm trying to have vcr.py tests pass in python3.7 (python3.6 and earlier are going fine), and during tests with tornado 5.1.1 (from debian), I get this error :
=================================== FAILURES ===================================
_________________ test_tornado_exception_can_be_caught[simple] _________________

get_client = <function get_client.<locals>.<lambda> at 0x7f5f24da02f0>

    @pytest.mark.gen_test
    @vcr.use_cassette(path_transformer=vcr.default_vcr.ensure_suffix('.yaml'))
    def test_tornado_exception_can_be_caught(get_client):
        try:
            yield get(get_client(), 'http://httpbin.org/status/500')
        except http.HTTPError as e:
            assert e.code == 500
    
        try:
>           yield get(get_client(), 'http://httpbin.org/status/404')

tests/integration/test_tornado.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <vcr.cassette.CassetteContextDecorator object at 0x7f5f256781d0>
fn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7f5f256e69d8>

    def _handle_generator(self, fn):
        """Wraps a generator so that we're inside the cassette context for the
            duration of the generator.
            """
        with self as cassette:
            coroutine = fn(cassette)
            # We don't need to catch StopIteration. The caller (Tornado's
            # gen.coroutine, for example) will handle that.
            to_yield = next(coroutine)
            while True:
                try:
>                   to_send = yield to_yield

vcr/cassette.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tornado.gen.Runner object at 0x7f5f256728d0>

    def run(self):
        """Starts or resumes the generator, running until it reaches a
            yield point that is not ready.
            """
        if self.running or self.finished:
            return
        try:
            self.running = True
            while True:
                future = self.future
                if not future.done():
                    return
                self.future = None
                try:
                    orig_stack_contexts = stack_context._state.contexts
                    exc_info = None
    
                    try:
>                       value = future.result()
E                       tornado.httpclient.HTTPClientError: HTTP 404: NOT FOUND

/usr/lib/python3/dist-packages/tornado/gen.py:1133: HTTPClientError

During handling of the above exception, another exception occurred:

self = <vcr.cassette.CassetteContextDecorator object at 0x7f5f256781d0>
fn = <function CassetteContextDecorator._execute_function.<locals>.handle_function at 0x7f5f256e69d8>

    def _handle_generator(self, fn):
        """Wraps a generator so that we're inside the cassette context for the
            duration of the generator.
            """
        with self as cassette:
            coroutine = fn(cassette)
            # We don't need to catch StopIteration. The caller (Tornado's
            # gen.coroutine, for example) will handle that.
            to_yield = next(coroutine)
            while True:
                try:
                    to_send = yield to_yield
                except Exception:
>                   to_yield = coroutine.throw(*sys.exc_info())
E                   StopIteration

vcr/cassette.py:139: StopIteration

The above exception was the direct cause of the following exception:

pyfuncitem = <Function 'test_tornado_exception_can_be_caught[simple]'>

    @pytest.mark.tryfirst
    def pytest_pyfunc_call(pyfuncitem):
        gen_test_mark = pyfuncitem.keywords.get('gen_test')
        if gen_test_mark:
            io_loop = pyfuncitem.funcargs.get('io_loop')
            run_sync = gen_test_mark.kwargs.get('run_sync', True)
    
            funcargs = dict((arg, pyfuncitem.funcargs[arg])
                            for arg in _argnames(pyfuncitem.obj))
            if iscoroutinefunction(pyfuncitem.obj):
                coroutine = pyfuncitem.obj
                future = tornado.gen.convert_yielded(coroutine(**funcargs))
            else:
                coroutine = tornado.gen.coroutine(pyfuncitem.obj)
                future = coroutine(**funcargs)
            if run_sync:
>               io_loop.run_sync(lambda: future, timeout=_timeout(pyfuncitem))

/usr/lib/python3/dist-packages/pytest_tornado/plugin.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3/dist-packages/tornado/ioloop.py:576: in run_sync
    return future_cell[0].result()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <tornado.gen.Runner object at 0x7f5f256728d0>

    def run(self):
        """Starts or resumes the generator, running until it reaches a
            yield point that is not ready.
            """
        if self.running or self.finished:
            return
        try:
            self.running = True
            while True:
                future = self.future
                if not future.done():
                    return
                self.future = None
                try:
                    orig_stack_contexts = stack_context._state.contexts
                    exc_info = None
    
                    try:
                        value = future.result()
                    except Exception:
                        self.had_exception = True
                        exc_info = sys.exc_info()
                    future = None
    
                    if exc_info is not None:
                        try:
>                           yielded = self.gen.throw(*exc_info)
E                           RuntimeError: generator raised StopIteration

/usr/lib/python3/dist-packages/tornado/gen.py:1141: RuntimeError
I submitted an issue here : kevin1024/vcrpy#396 but I'm not convinced the change of behaviour isn't due to tornado updates. My guess would be that the exception handling behaves differently before 3.7.
Does anyone have a little time to help me find the issue?
Thanks in advance! :)
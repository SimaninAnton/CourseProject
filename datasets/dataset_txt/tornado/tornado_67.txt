itayB commented on 4 Apr 2019
Hi,
I'm using tornado 5.1 & python 2.7.
I have a coroutine function that sometimes yield another coroutine function (fetch) and sometimes not (using "cache"). Is it ok to have such function or should I wrap the cached value with future (or something) and yield it as well?
In other words, does coroutine function must have yield in it?
For example:
    @coroutine
    def my_function(self, request):
        async_http_client = AsyncHTTPClient()
        if self.cached_res is None:  # first time only
            response = yield async_http_client.fetch(self.url, method='POST', body=request)
            self.cached_res = ujson.loads(response.body)
        raise Return(self.cached_res)
Same thing in OO design, let say I have BaseClass that 2 derived class AClass and BClass that both implement abstruct method of BaseClass:
class BaseClass(object):
    @coroutine
    def handle(self, request):
        pass

class AClass(BaseClass):
    @coroutine
    def handle(self, request):
        response = yield async_http_client.fetch(self.url, method='POST', body=request)
        raise Return(self.cached_res)
    
class BClass(BaseClass):
    @coroutine
    def handle(self, request):
        raise Return([])
handle of BClass needed to be coroutine method (for polymorphizm things) but doesn't really yield something. Is it ok?
hackrole commented on 19 Nov 2014
I have a utils function like this:
@gen.coroutine
def nd_sms_verify(code, mobile):
    u"""
    发送短信接口
    """
    url = "http://baidu.com"

    http_client = AsyncHTTPClient()
    response = yield http_client.fetch(url)
    print response

    if response.body == '100':
        raise gen.Return([True, u"发送成功"])
    else response.body == '108':
        raise gen.Return([False, u"短信请求太频繁"])
I write a unittest for this, and it works fine.
from unittest2 import TestCase
from view_utils import nd_sms_verify
from tornado.ioloop import IOLoop


class SendSmsTestCase(TestCase):

    def test_send_sms_return_ok(self):
        code = "8899"
        mobile = "18321445606"
        io_loop = IOLoop.instance()
        data = io_loop.run_sync(
            lambda: nd_sms_verify(code, mobile), timeout=20)
        self.assertIsNotNone(data)
        self.assertIn(data[0], [True, False])
but when I called it on my view function, it works ok, but all the unittest cases raise timeout.
class RegisterFinishHandler(BaseHandler):

    @gen.coroutine
    def get(self):
        code = '2209'
        mobile = '13113113131'

        # send sms
        result = yield view_utils.nd_sms_verify(code['code'], mobile)
        print result
I checked the source. It seems that AsyncHTTPClient may create a new IOLoop, which cause error with the AsyncHTTPTestCase io_loop.
I have meet a lot questions like this, I want to know why the AsyncTestCase have its own ioloop, which may cause other function fails.
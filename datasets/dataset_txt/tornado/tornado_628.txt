jetz commented on 23 Jul 2015
Recently we develop a comet server using tornado 4.1, but it eats more and more memory. After analyzing by guppy, we find the Future objects are increasing all the time. Only a few hundreds at the beginning, but a few days later, there are tens of thousand, and never decrease even with lower http requests. Like:
Especially when clients close with long poll unfinished (it will lead on_connection_close), the new Futures will stay there and can't release with gc. I figure it out using ab, so I think it is main reason for the leak.
Fllowing is core part of the code:
class StatusCometHandler(tornado.web.RequestHandler):

    def initialize(self):
        self.broker = Broker()

    def prepare(self):
        self.broker.connect()

    def on_finish(self):
        self.broker.disconnect()

    def on_connection_close(self):
        # WARNNING: disconnect here will lead memory leak, no idea
        pass

    @tornado.gen.coroutine
    def get(self):
        try:
            sid = self.get_query_argument('sid')
            appid = self.get_query_argument('appid')
        except tornado.web.MissingArgumentError as e:
            self.write(...)
            return
        except AssertionError:
            self.write(...)
            return
        step = yield self.broker.get_step(sid, timeout=5)
        if not step:
            self.write(...)
        else:
            r = yield self.broker.get_auth(sid)
            self.write(...)
Here broker is redis and get_step will return a gen.Task wrapped blpop (tornadoredis). get_auth is just a wrapped get command .
So, is it possible Future leaks in some situation, eg. can't be resoved and always stay there? Or I do something wrong?
Contributor
abhinav commented on 25 Feb 2016
As per the docs for PeriodicCallback,
If the callback runs for longer than callback_time milliseconds, subsequent invocations will be skipped to get back on schedule.
This doesn't appear to be the behavior. Here's an example where things are running on time:
from tornado import gen
from tornado.ioloop import IOLoop
from tornado.ioloop import PeriodicCallback

calls = []
finished = 0
start_time = None
sleep_time = 0.250


@gen.coroutine
def cb():
    global finished
    calls.append(IOLoop.current().time())
    yield gen.sleep(sleep_time)
    finished += 1


@gen.coroutine
def main():
    global start_time
    start_time = IOLoop.current().time()
    PeriodicCallback(cb, 300).start()
    yield gen.sleep(1)


IOLoop.current().run_sync(main)
print "calls:", ", ".join("%.2f" % (t - start_time) for t in calls)
print "finished:", finished
Output, as expected:
calls: 0.30, 0.60, 0.90
finished: 2
3 invocations at 300 millisecond intervals. The last one doesn't finish because the IOLoop stops too early.
If you change the sleep_time to 0.5, you get,
calls: 0.30, 0.60, 0.90
finished: 1
3 invocations at 300 millisecond intervals, only one of them finishing. As per the docs, this should really be, "calls: 0.30, 0.90" because the one at 0.6 overlaps with the ongoing invocation from 0.3.
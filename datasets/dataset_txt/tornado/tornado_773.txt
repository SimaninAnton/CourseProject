bbirand commented on 25 Aug 2014
I am trying to write a simple, blocking function my_recv_future that sends a ZMQ packet, and then returns when the response is received. The ZMQ library supports the Tornado ioloop, and its knowledge is not necessary for this example
I wrote this function:
@gen.coroutine
def my_recv_future(socket, amsg):
    zmqstream = ZMQStream(socket)  # Required for ZMQ
    future = Future()
    def _finish(reply):
        future.set_result(reply)
        zmqstream.close()
    zmqstream.on_recv(_finish)
    zmqstream.send(amsg)
    resp = yield future   #Block here waiting for the reply
    raise gen.Return(resp)
I then want to call this function as:
val = my_recv_future(socket, amsg) #Blocking call, wait till reply
# Do things with val
The problem is that since my_recv_future is a @gen.coroutine, it returns a Future, while I want it to return the actual value. When I try to block on val.result(), I get an error saying that DummyFuture doesn't support blocking. I tried installing concurrent.futures, but I still get the same error (I thought it was supposed to overwrite the supplied version).
How does one block on a Future? What is the right way to create a blocking function as in above?
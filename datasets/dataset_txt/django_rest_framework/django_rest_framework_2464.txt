Contributor
kdazzle commented on 26 Jul 2014
If a queryset is defined as a static property like so:
from rest_framework.viewsets import ViewSet
class MyViewSet(ViewSet):
    queryset = Foo.objects.all()

    def list(self, request):
        serializer = FooSerializer(self.queryset, many=True)
        return Response(serializer.data)
Since MyViewSet.queryset is static, it is assigned a value only when the queryset is evaluated for the first time, so when a Foo is added, changed, or deleted, that change will not be shown in methods like list. The result being that list will serialize the same queryset until the server is restarted.
That problem can be averted by changing the list method to the following, with the difference being in calling self.queryset.all() in the serializer arguments:
def list(self, request):
    serializer = FooSerializer(self.queryset.all(), many=True)
    return Response(serializer.data)
But in my opinion, leaning on that as a solution will lead to hard-to-find bugs, as the workaround depends on always remembering that extra .all() call.
Here is a link to a similar issue: http://grokbase.com/t/gg/django-users/127510xk5w/queryset-caching-without-caching-middleware
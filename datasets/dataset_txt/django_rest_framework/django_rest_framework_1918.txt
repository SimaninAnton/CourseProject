kunalbhagawati commented on 21 Mar 2015
This is what is given in the the example for custom exceptions (v3.0.2):
from rest_framework.views import exception_handler

def custom_exception_handler(exc, context):
    # Call REST framework's default exception handler first,
    # to get the standard error response.
    response = exception_handler(exc, context)

    # Now add the HTTP status code to the response.
    if response is not None:
        response.data['status_code'] = response.status_code

    return response
But on raising an exception from the view, this returns the error:
custom_exception_handler() missing 1 required positional argument: 'context'
So if we set context=None, like so:
def custom_exception_handler(exc, context=None):
The server now raises an exception:
exception_handler() takes 1 positional argument but 2 were given
Looking at the function rest_framework.views.exception_handler:
def exception_handler(exc):
    """
    Returns the response that should be used for any given exception.

    By default we handle the REST framework `APIException`, and also
    Django's built-in `ValidationError`, `Http404` and `PermissionDenied`
    exceptions.

    Any unhandled exceptions may return `None`, which will cause a 500 error
    to be raised.
    """
So I guess this could be a bug, since the source just contains one argument, or am i missing something?
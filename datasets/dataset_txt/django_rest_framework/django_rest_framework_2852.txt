HarryR commented on 9 May 2013
It would be really cool to be able to specify multiple fields in the lookup_field attribute of a View Set, this would allow hierarchical URLs.
With lookup_field=('domain__hostname','username') and a record in urls.py with named regex matches for both domain__hostname and username it would be trivial to implement something like:
/domains
/domain/google.com/users
/domain/google.com/user/harry
This can be half-done by implementing get_queryset() taking arguments from self.kwargs, but the other half is more complicated.
Allowing multiple values in lookup_field would not break backwards compatibility, and would be a cleaner extension of: #347 (I see slug field is now deprecated).
It does introduce a small amount of additional complexity, and it would be unlikely that people could use the default routers.
./rest_framework/generics.py:    lookup_field = 'pk'
./rest_framework/generics.py:        lookup = self.kwargs.get(self.lookup_field, None)
./rest_framework/generics.py:            filter_kwargs = {self.lookup_field: lookup}
./rest_framework/generics.py:        elif pk is not None and self.lookup_field == 'pk':
./rest_framework/generics.py:                'Use the `lookup_field` attribute instead',
./rest_framework/generics.py:        elif slug is not None and self.lookup_field == 'pk':
./rest_framework/generics.py:                'Use the `lookup_field` attribute instead',
./rest_framework/generics.py:                'named "%s". Fix your URL conf, or set the `.lookup_field` '
./rest_framework/generics.py:                (self.__class__.__name__, self.lookup_field)
./rest_framework/mixins.py:def _get_validation_exclusions(obj, pk=None, slug_field=None, lookup_field=None):
./rest_framework/mixins.py:    if lookup_field and lookup_field != 'pk':
./rest_framework/mixins.py:        include.append(lookup_field)
./rest_framework/mixins.py:        lookup = self.kwargs.get(self.lookup_field, None)
./rest_framework/mixins.py:            setattr(obj, self.lookup_field, lookup)
./rest_framework/mixins.py:            exclude = _get_validation_exclusions(obj, pk, slug_field, self.lookup_field)
./rest_framework/relations.py:    lookup_field = 'pk'
./rest_framework/relations.py:        self.lookup_field = kwargs.pop('lookup_field', self.lookup_field)
./rest_framework/relations.py:            msg = 'pk_url_kwarg is pending deprecation. Use lookup_field instead.'
./rest_framework/relations.py:            msg = 'slug_url_kwarg is pending deprecation. Use lookup_field instead.'
./rest_framework/relations.py:            msg = 'slug_field is pending deprecation. Use lookup_field instead.'
./rest_framework/relations.py:        May raise a `NoReverseMatch` if the `view_name` and `lookup_field`
./rest_framework/relations.py:        lookup_field = getattr(obj, self.lookup_field)
./rest_framework/relations.py:        kwargs = {self.lookup_field: lookup_field}
./rest_framework/relations.py:            # Otherwise, the default `lookup_field = 'pk'` has us covered.
./rest_framework/relations.py:                          'You should set `lookup_field=slug` on the HyperlinkedRelatedField.'
./rest_framework/relations.py:        lookup = view_kwargs.get(self.lookup_field, None)
./rest_framework/relations.py:            filter_kwargs = {self.lookup_field: lookup}
./rest_framework/relations.py:                '`lookup_field` attribute on this field.'
./rest_framework/routers.py:        base_regex = '(?P<{lookup_field}>[^/]+)'
./rest_framework/routers.py:        lookup_field = getattr(viewset, 'lookup_field', 'pk')
./rest_framework/routers.py:        return base_regex.format(lookup_field=lookup_field)
./rest_framework/serializers.py:        self.lookup_field = getattr(meta, 'slug_field', None)
./rest_framework/serializers.py:        if self.opts.lookup_field:
./rest_framework/serializers.py:            kwargs['lookup_field'] = self.opts.lookup_field
guillaumekpomda commented on 15 May 2015
Let's say I have a Compilation model. It has a name, and a set of Tracks.
When creating a compilation, the user picks a set of existing tracks. Which means only the actual compilation is created. Not the tracks.
When retrieving a compilation from the database, I want the representation to look like this:
{
  id: 17,
  name: 'My compilation',
  tracks: [
    {
      id: 1,
      name: 'Sunflower'
    },
    {
      id: 2,
      name: 'Whitetail'
    }
  ]
}
So my serializer looks like:
class CompilationSerializer(serializers.ModelSerializer):

  id            = serializers.IntegerField(read_only=True)
  tracks        = TrackSerializer(many=True)

  class Meta:
    model  = Compilation
    fields = (
      'id',
      'tracks',
    )
I want to be able to create a compilation using the same serializer. Which means the JSON that I will POST to the server looks like this (it's basically the same as above, without the id field, since it's a new record):
{
  name: 'My brand new compilation',
  tracks: [
    {
      id: 1,
      name: 'Sunflower'
    },
    {
      id: 2,
      name: 'Whitetail'
    }
  ]
}
I added the option read_only=False to my serializer:
tracks        = TrackSerializer(many=True, read_only=False)
Now the issue is that Django-Rest-Framework thinks that I want to create the tracks. Which makes sense in some cases, but not in my case. I'd like to be able to tell Django-Rest-Framework: "Don't create the tracks, but select them by id". I know that it's not necessary to send the whole representation when creating a compilaton. Only the actual id's are necessary. But again, I'm doing this because i'd like to use the same serializer and keep the code cleaner.
Does that make sense? Is this the DRF way to go?
Thanks in advance.
EDIT. This actually works. My problem is another one. So I close the issue.
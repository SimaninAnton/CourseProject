Hau-Hau commented on 27 Apr 2019 â€¢
edited
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
class View(generics.CreateAPIView,
           generics.DestroyAPIView,
           generics.GenericAPIView):
    http_method_names = ('post', 'delete')

    def create(self, request, *args, **kwargs):
        return Response(status=status.HTTP_200_OK)

    def delete(self, request, *args, **kwargs):
        return Response(status=status.HTTP_200_OK)
Expected behavior
Allow only POST and DELETE HTTP methods in all environments.
Actual behavior
In Postman it is impossible to make GET request (I got 405), but request from Firefox and Chrome is passed as allowed method.
I also found that after small change in _allowed_methods method everything works as i expect:
class View(generics.CreateAPIView,
           generics.DestroyAPIView,
           generics.GenericAPIView):
    http_method_names = ('post', 'delete')

    def _allowed_methods(self):
       #removed .upper() from 'm.upper()'
        return [m for m in self.http_method_names if hasattr(self, m)]

    def create(self, request, *args, **kwargs):
        return Response(status=status.HTTP_200_OK)

    def delete(self, request, *args, **kwargs):
        return Response(status=status.HTTP_200_OK)
I know that I can block methods with permissions etc. But this behaviour is not clear for me at all and looks like a bug
Contributor
vyscond commented on 30 Jan 2016
So i was trying to pass this JSON as payload to API
{
  "field_1": 1,
  "field_2_uuid": "436c3e71-787e-4cd9-bbbb-284560cddde1",
  "field_3_list": [
    {"field_a": 1, "field_b": 18}
  ]
}
using the Client object from django.test:
payload = {
  "field_1": 1,
  "field_2_uuid": "436c3e71-787e-4cd9-bbbb-284560cddde1",
  "field_3_list": [
    {"field_a": 1, "field_b": 18}
  ]
}
self.client.post("/api/url", json.dumps(payload), content_type="application/json")
The serializer responsible is this one:
class Table2_Serializer(serializers.Serializer):

    field_a = serializers.IntegerField(write_only=True)
    field_b = serializers.IntegerField(write_only=True)

class Table1_Serializer(serializers.ModelSerializer, SerializerUtils):
    field_1 = serializers.IntegerField(write_only=True)
    field_2 = serializers.CharField(write_only=True)
    field_3_list = serializers.ListField(child=Table2_Serializer(), write_only=True)
But all i got was a 400 error saying that field_3_list was expecting a dictionary but got a str.
After that i changed field_3_list to JSONField and overrided the create function to see how was the structure of the data.
class Table2_Serializer(serializers.Serializer):

    field_a = serializers.IntegerField(write_only=True)
    field_b = serializers.IntegerField(write_only=True)

class Table1_Serializer(serializers.ModelSerializer, SerializerUtils):
    field_1 = serializers.IntegerField(write_only=True)
    field_2 = serializers.CharField(write_only=True)
    field_3_list = serializers.JSONField(write_only=True)

    @transaction.atomic
    def create(self, validated_data):
        logger.debug(validated_data)
The log show that the dictionary over the field_3_list is being received as a string
{
  "field_1": 1,
  "field_2_uuid": "436c3e71-787e-4cd9-bbbb-284560cddde1",
  "field_3_list": [
    "{'field_a': 1, 'field_b': 18}"
  ]
}
So i was thinking if this is a bug (for real) or am i missing something?
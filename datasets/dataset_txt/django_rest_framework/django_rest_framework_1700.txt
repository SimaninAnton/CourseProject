Miserlou commented on 17 Jul 2015
Hey all!
Easy but extremely important one here!
By default, ModelSerializers do not respect commit on save(). This defies Django conventions - and had me pulling my proverbial hair out for an hour!
Imagine a situation where I want to consume API from a distributed application, and I want to use Django Rest Framework to deserialize data from another API endpoint. I just want to consume it for a view, but not write it to a database. Ex:
serializer = KittenSerializer(data=data, many=True)
kittens = serializer.save(commit=False)
print kittens
[<Kitten 1>, <Kitten 2>] # Not written to database
kitten[0].purr()
purrrrrr
But instead, you fill get:
kittens = serializer.save(commit=False)
'commit' is an invalid keyword argument for this function
Now, an even more confusing thing is that it behaves differently with many=False. So, instead of the desired behavior, you will find:
serializer = KittenSerializer(data=data, many=False)
kitten = serializer.save(commit=False)
print kitten
<Kitten 1> # Written to database! :(
I did ultimately find a simply solution by overriding create in my Serializer like so (although it doesn't ever actually save, and I don't see a way to pass data to this function to make it conditional):
def create(self, validated_data):
   return Kitten(**validated_data)
However, this should really work out of the box! If you want to user Django-Rest-Framework as an API consumer (which I think is a larger use case than the documentation accounts for, especially as microservices become more popular ) - this is really important information that should be more readily available!
This has already come up here, with no official answer: #2958
but I think needs to be a) handed without overriding create and b) documented. I am willing to write the changes to the code and documentation if you will accept the feature in a PR.
Thoughts?
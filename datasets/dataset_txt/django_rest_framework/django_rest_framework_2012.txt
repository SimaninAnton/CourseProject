amc1804 commented on 14 Feb 2015
Completely-empty JSON requests (which are not valid JSON) are rejected by the browsable API but accepted by the production API, which confuses debugging attempts.
In request.py, if stream is None, the parser is not invoked, and an empty DATA is created. I don't know why an empty request body is represented as None rather than an empty stream, but if the parser had been given a chance to parse an empty stream, it might have yielded something other than empty DATA. For example, the JSON parser raises a ParseError.
In the browsable API, where requests are tunneled through forms, the parser does get invoked (and in the case of JSON, does reject an empty request).
Bypassing the parser for empty requests allowed a bug in Firefox 35 to cause data loss.
https://bugzilla.mozilla.org/show_bug.cgi?id=1128038
The browser bug sometimes truncates a PATCH request to zero length. The rest framework turns this into empty data instead of a parse error, the application code applies the no-op patch and returns 200 OK, and the user is not alerted that the data was not actually saved.
Perhaps, rather than construct an empty DATA, the framework should construct an empty stream, and let it be parsed normally.
(By the way, many thanks to Tom and all contributors. This framework has been very helpful!)
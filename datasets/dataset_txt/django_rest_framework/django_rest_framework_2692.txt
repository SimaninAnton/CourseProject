Contributor
craigds commented on 15 Oct 2013
This one is a little involved. I don't really have a suggestion for how best to handle this but here goes:
We have a view that accepts multipart/form-data content via POST. Some parts are file uploads, while specific parts have special meaning (one in particular is a JSON blob we need to parse separately).
I expected to handle this with a custom parser, which would put most of the parts in request.FILES and parse the JSON blob into request.DATA.
that is:
request.DATA == {"some-dict": "loaded-from-json"}
In fact my custom parser was skipped entirely because DRF doesn't consult the parsers in the view's parser_classes at all. So I got this instead:
request.DATA == <QueryDict: {u'part-name': [u'{"actual": "data"}']}>
I think the problem is that DRF treats multipart/form-data POSTs specially and calls request._perform_form_overloading which assumes my request is form data.
As I mentioned I don't have any suggestions for fixing this, sorry :s
One option would be for me to use another multipart content-type that DRF doesn't know about, e.g. multipart/x-my-custom-type but that precludes clients from using cURL and generally makes things more difficult so I'd prefer not to.
At present I've got a workaround in my view's initial() method which hacks request._data to what I want. But I figured I'd report this anyway in case you can think of a fix.
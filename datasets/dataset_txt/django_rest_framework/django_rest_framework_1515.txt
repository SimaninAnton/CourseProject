arpheno commented on 6 Oct 2015
In a current project I have to return data in different representations depending on the user and the request.
I wrote 3 different Serializers: EventDetailSerializer, EventPublicSerializer and EventListSerializer in serializers.py and inviews.py`selected the appropriate one:
def get_serializer_class(self):
    if self.serializer_class:
        return self.serializer_class
    if can_add(self.request.user, self.model):
        return EventDetailSerializer
    if can_change(self.request.user, self.get_object()):
        return EventDetailSerializer
    return EventPublicSerializer

def list(self, request, *args, **kwargs):
    self.serializer_class = EventListSerializer
    return super(EventViewSet, self).list(request, *args, **kwargs)
This worked fine for Event, however I have 7 model classes subclassing Event which all require roughly the same logic, though not exactly, because some will include additional fields. (e.g.: TrainingSession(Event) will have an additional Trainer field that must be publicly visible.)
Declaring 7 x 3 additional serializers which inherit from the basic Event*Serializer classes does not seem very dry, so I made a factory function that allows serializers to be dynamically created, without having to declare them separately. https://github.com/arpheno/eestecnet/blob/green/common/serializers.py#L182
My questions:
Is this a good approach?
Is there functionality for dynamic serializer creation implemented in restframework?
Would it be worthwhile to create a third party package that provides factories for restframework serializers?
1
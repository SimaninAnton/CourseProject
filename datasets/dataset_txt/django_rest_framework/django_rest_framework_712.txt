rknLA commented on 24 Jul 2017
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
Create a HyperlinkedModelSerializer subclass
Add view_name to the Meta class of your subclass
Attempt to serialize an instance of the model
Expected behavior
The model should serialize, and the url field of the model should use the correct view name.
Actual behavior
If the default view name is not defined, the model does not successfully serialize. If it is defined, then the default model-detail URL will render, rather than the view_name view.
Some backstory here:
I was trying to solve the same problem as #1321, except that IMO, inheriting a Meta class that defines a namespace is a better approach for my particular use case than manually setting all of the view names.
In this process, I discovered that even when I set the view name manually, my tests still fail with a:
django.core.exceptions.ImproperlyConfigured: Could not resolve URL for hyperlinked relationship using view name "model-detail". You may have failed to include the related model in your API, or incorrectly configured the `lookup_field` attribute on this field.
It looks like #4854 was also closed for a similar reason, explaining that setting view_name should work, but when I look at the code path that actually gets the URL, it doesn't even check for view_name in the serializer (build_url_field calls get_url_kwargs, which only looks at the model to get the default view_name)
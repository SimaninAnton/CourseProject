tiagoboldt commented on 4 Oct 2016 â€¢
edited
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
When selecting the fields for a ModelSerializer, I would expect that the serializer would be able to use fields from a related model.
Example: an Example class has a related field which is a ForeignKey to a model which has a name field.
class ExampleSerializer(serializers.ModelSerializer):
  class Meta:
    model = Example
    fields = ['field1', 'related__name']
Expected behavior
The serialized result should have field1 from model Example and field related__name with the value of name from the related model.
Furthermore, relation resolutions should be possible at multiple levels, just like in Django. Example: related__related2__name.
Actual behavior
Instead, the following error is observable:
Field name `related__name` is not valid for model `Example`.
Discussion
This can currently be achieved by either specifying a serializer specific for the related field or by using a SerializerMethodField with a function to get the value. IMHO, both approaches are too complex for addressing such a simple and (in my case) recurrent situation.
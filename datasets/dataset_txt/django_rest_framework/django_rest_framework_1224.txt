Contributor
resalisbury commented on 28 Apr 2016 â€¢
edited
See PR #4078 for changes
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Rational
Passing in *args and **kwargs into get_serializer_class allows the method greater flexibility in determining which serializer class to use.
For example, I want to return either a RestaurantSerializer or a BarSerializer (Bar and Restaurant are subclasses of Place) from get_serializer_class, but, to do so, I need access to the instance that is passed as an argument to get_serializer, but is not passed into get_serializer_class.
To solve this issue, I'm currently overriding get_serializer (which is not suggested via the docs), thusly:
    def get_serializer(self, instance, *args, **kwargs):
        kwargs['context'] = self.get_serializer_context()
        serializer_class = BarSerializer if isinstance(instance, Bar) else RestaurantSerializer
        return serializer_class(instance, *args, **kwargs)
The proposed change would allow me to instead override get_serializer_class thusly:
def get_serializer_class(self, instance, *args, **kwargs):
    return BarSerializer if isinstance(instance, Bar) else RestaurantSerializer
notes: there may be other use cases as well where this is helpful. In my use case (shown above), it may be better to handle the polymorphism at the serializer level instead of at the view level.
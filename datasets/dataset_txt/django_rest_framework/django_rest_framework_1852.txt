gio82 commented on 22 Apr 2015
I'm using has_object_permission to create a custom permission.
It works as expected when creating an object.
But it seems doesn't works as expected when updating an object.
I'll try to synthesize my example here below:
# Models
class AdminHouse(models.Model):
    user = models.ForeignKey(User)
    house = models.ForeignKey(House)
class Item(models.Model):
    house = models.ForeignKey(House)
    ...

# Permissions
class IsHouseAdminPermission(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        return AdminHouse.objects.filter(user=request.user, house=obj.house).exists()
The expected behaviour is that a user can create or update only items of the houses where he is an administrator.
What happens is that when an item is already created a user can update the item itself giving any available house not only those where he is admin.
It seems that the check is done only to the existing item and not to the modified one.
So a user can create an item for his house and then update it to any other house without control.
At the moment as a turn around I added this to the permission class above:
def has_permission(self, request, view):
    if request.method not in permissions.SAFE_METHODS and 'shop' in request.DATA:
        return AdminHouse.objects.filter(user=request.user, house=request.DATA['house']).exists()
    return True
Contributor
carljm commented on 11 Jul 2014
I am using a model ArrayField which uses a Postgres array column, and represents itself as a Python list, and I have choices set on it.
Django-rest-framework (in ModelSerializer.get_field) hardcodes the use of rest_framework.fields.ChoiceField for any model field with choices. But ChoiceField does not know how to handle multiple-choice-fields; it doesn't use getlist() to pull the full list from the QueryDict if data is submitted via multipart/form-data, and if you submit a list via JSON, it tries to validate the entire list at once, which fails validation because the list is not a valid choice.
I can easily implement a MultipleChoiceField as subclass of ChoiceField, but DRF makes it unnecessarily difficult to override the use of ChoiceField for a particular field. Serializer.field_mapping isn't useful for this purpose. If I define my own Serializer.get_field method, I have to duplicate a bunch of the kwarg setup (for required, read_only, default, label, help_text) in order to return my own alternate field type.
I would propose that there should be a Serializer.choices_field_mapping or similar, which would be empty by default, and if the model field class isn't found in it, would default to ChoiceField, or that Serializer.get_field should accept a choices_field_class optional keyword argument, defaulting to ChoiceField.
If the idea is acceptable and I get clarification on which implementation approach you'd prefer, I'd be happy to supply a pull request.
leonardoarroyo commented on 7 Oct 2016 â€¢
edited
Let's start with a working code sample: view gist
With the above code, everything works just fine. I can POST to /users/ and I can GET /users/current-user/.
Now, on this gist, you can see the same code. The difference between this and the first gist is that UserUpdateSerializer and UserUpdateViewSet are now implemented and added to urls.py
The new urls.py now looks like this:
router = routers.DefaultRouter()
router.register(r'users', views.UserCreateViewSet, 'user')
router.register(r'users', views.UserUpdateViewSet, 'user')
router.register(r'users/current-user', views.CurrentUserViewSet, 'current-user')
However, adding line 3 (UserUpdateViewSet) breaks the next route(CurrentUserViewSet). It stops accepting GET requests(the one which is actually implemented) and starts accepting PUT and PATCH. I believe something about registering viewsets with the same prefix and base_name somehow messes with other unrelated routes.
Is this functionality unsupported by django-rest-framework or is it a bug? I certainly could implement create and update under the same viewset, but as drf don't support different serializer_class for input and output this become impossible. Overriding the list or update method to avoid self.get_serializer_class is not a solution, as drf-swagger users ViewSet.serializer_class to generate documentation.
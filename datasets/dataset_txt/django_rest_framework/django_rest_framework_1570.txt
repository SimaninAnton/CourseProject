ncoghlan commented on 8 Sep 2015
I'm using Django REST Framework for an API integration project (i.e. presenting a unified API that abstracts a subset of the APIs for multiple backend services), and aiming to keep the abstraction layer as stateless as possible.
I think it's excellent for this purpose, but the regular ViewSet examples in the documentation all assume the use of local model objects, and so have required a bit reverse engineering to figure out the key patterns needed to implement my own custom ViewSet classes that work correctly with the rest of the framework (including the browsable API). So far I've figured out that the bare minimum is:
define a Serializer subclass, and set that as serializer_class on the custom ViewSet (this is needed to get the submission forms to appear correctly on the browsable API)
return Response(self.serializer_class(data, many=True).data) from list methods
return Response(self.serializer_class(data).data) from retrieve methods
to pass along an unstructured JSON blob retrieved from another API without parsing it locally, use a field definition like raw_data = serializers.DictField(read_only=True)
I'm still figuring out the right implementation patterns for create, update, partial update, and destroy...
As far as where this could go in the documentation, it seems to me that the current "Marking extra extractions for routing" section in http://www.django-rest-framework.org/api-guide/viewsets/ could be broken up to have a preceding section on "Integrating with Routers and the Browsable API" that covers the default methods the routers look for, and how the browsable API generates the default forms.
If this seems reasonable, I'd be happy to work on a PR for it.
3
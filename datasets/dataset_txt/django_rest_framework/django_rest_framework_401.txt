willmcgugan commented on 22 May 2018
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
I've noticed some behaviour to serializers which tripped me up recently. I'm not certain if this is a problem with my expectations, a documentation issue, or a legitimate bug...
The BaseSerializer class caches its data attribute on the object, but Serializer.data returns a copy of BaseSerializer.data every time it is accessed (via ReturnDict).
This is a little inefficient (which is not a big deal), but it means that any changes to the data dict will essentially be reset when Serializer.data is next called.
Should I expect to be able to mutate the .data attribute? For my particular use case I wanted to pop a key, and pass the remaining values to another part of my code. Something along these lines:
name = serializer.data.pop('name')
call_thing(name, **serializer.data)
That failed because name still existed in the second call to serializer.data.
How about caching the return value of .data on Serializer, to preserve mutable semantics?
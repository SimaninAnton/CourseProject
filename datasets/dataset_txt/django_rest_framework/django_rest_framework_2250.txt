mkching commented on 20 Nov 2014
I was unsure if this should be posted as an update to #2092, or in a new issue.
When a validator is present with the unique_together fields, it is called with a NOT_PROVIDED value if not present. This results in a str representation of the NOT_PROVIDED object being passed back to the serializer. In DRF 2.4, the default value itself would be passed in.
Model:
class DefaultFieldModel(models.Model):
    ip = models.CharField(max_length=15)
    port = models.CharField(max_length=5, default="5060")

    class Meta:
        unique_together = (('ip', 'port'),)
Serializer:
class DefaultFieldSerializer(serializers.ModelSerializer):
    def validate_port(self, value):
        return value

    class Meta:
        model = DefaultFieldModel
        fields = ('id', 'ip', 'port')
Code:
s = DefaultFieldSerializer(data={'ip': '127.0.0.1'})
if s.is_valid():
    o = s.save()
    print("ok", o.id, o.ip, o.port)
else:
    print("errors", s.errors)
Output:
ok 1 127.0.0.1 <django.db.models.fields.NOT_PROVIDED object at 0x7f289e0b1518>
When fields are not part of a unique_together constraint and a default value is used, the validation function is not called at all. This is different from DRF 2.4, where the validator would be called with the default value as well. I am not sure if this would cause an issue, but if validating against other fields it might. Let me know if an example of this is required.
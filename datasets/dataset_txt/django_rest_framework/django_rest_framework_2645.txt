Contributor
dustinfarris commented on 19 Dec 2013
I think this has been danced around before, but I can't remember what the consensus was and Google is not helping me today.
If I have:
class Book(models.Model):
    publisher = models.ForeignKey(Publisher, null=True, blank=True)

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book

class BookViewSet(viewsets.ViewSet):
    model = Book
    serializer_class = BookSerializer
Then in shell:
>>> from django.test.client import Client
>>> client = Client()
>>> book = Book()
>>> serializer = BookSerializer(book)
>>> serializer.data
{'id': None, 'publisher': None}
>>> response = client.post('/books/', serializer.data)
>>> response.data
{'publisher': ['Incorrect type.  Expected pk value, received str.']}
To make this work I have to manually convert the None value to an empty string (which is hinted at in the documentation under the "required" attribute for relation fields):
>>> response.data.update({'publisher': ''})
>>> response = client.post('/books/', serializer.data)
>>> response.data
{'id': 1, 'publisher': None}
It seems like the first request should not return a 400 given the model is valid, and the data was created using DRF's own serializer.
In case this is intended behavior, I've also inquired on SO for best practices:
http://stackoverflow.com/questions/20681468/how-to-make-foreignkey-play-nice-with-none-in-drf
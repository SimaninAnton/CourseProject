shanavas786 commented on 3 Jul 2018 â€¢
edited
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
use the following code
models.py
from django.db import models
class A(models.Model):
  key = models.CharField(max_length=10, unique=True)
  other = models.CharField(max_length=10)
serializers.py
from rest_framework import serializers
from <app>.models import A
class ASerlzr(serializers.ModelSerializer):
  class Meta:
    model = A
    fields = ('other', 'key')
    read_only_fields = ('key', )
insert one entry to A with empty key
run the following in shell
from <app>.models import A
from <app>.serializers import ASerlzr

data = {'other': 'other'}
s = ASerlzr(data=data)
print(s.is_valid())
s.save()
Expected behavior
s.is_valid() should return False
It does so when key is removed from read_only_fields
Actual behavior
s.is_valid() returns True
s.save() fails because of unique constraint violation
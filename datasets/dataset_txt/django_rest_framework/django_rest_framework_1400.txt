Symmetric commented on 4 Dec 2015
I have an API through which users can register and authenticate. I based my implementation on this recipe.
This solution works as desired for first-order function; a superuser can GET /users, whereas normal users cannot. A normal user can POST /users to create a new user, and can GET /users/<my_user_id to view their own User information. Finally, a normal user cannot GET /users/<other_user_id>, since this is forbidden.
However, due to the way DRF appears to resolve permissions, this solution leaks information about the existence of user IDs:
GET /users/<not_my_id> => 403
GET /users/<nonexistant_user_id> => 404
Ideally we'd get a 403 in both cases; users should not be able to probe for valid user IDs. I speculate that DRF makes a has_permission check, and then short-circuits with a 404 before checking has_object_permission. Could we resolve this by running the has_object_permission check with obj=None in this case?
It seems like in the general case, if there is a per-object permission in the view, it should get the opportunity to 403 the request even if the requested resource isn't present.
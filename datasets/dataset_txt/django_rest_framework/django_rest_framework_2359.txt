pcompassion commented on 4 Oct 2014
class Thread:
   main_post = OnetoOneField('Post', null=True, blank=True, related_name='_thread')

class Post:
   thread = ForeignKey('Thread', related_name='posts')
Thread has one and only-one main_post, and 0-to-many posts.
Now I want to create Thread + Post from a thread view.
 class PostSerializer(serializers.ModelSerializer):
    thread = ThreadField(required=False, read_only=False)

 class ThreadSerializer(serializers.ModelSerializer):
     main_post = PostSerializer()

class ThreadField(serializers.PrimaryKeyRelatedField):

     def field_from_native(self, data, files, field_name, into):
         super(ThreadField, self).field_from_native(data, files, field_name, into)

         # PrimaryKeyRelatedField inserts 'thread' = None, I don't want it
         if into[field_name] is None:
             into.pop(field_name)
problem is, threadSerializer -> postSerialzier relationship is stored in nested_forwarded_relations (in serialziers:restore_object) and DRF tries to save the Post data although my data model doesn't allow it.
I can unset the nested_forwarded_relations at some point but wanted to ask first.
It seems DRF at the moment doesn't support the following scenario:
One model refers another model (thread -> post) in serializer relations, and the referred model (post) needs the referring model (thread) in model relations
What would be the best alternative or strategy to work around it for the situation?
(fix the database scheme? :( )
mikeengland commented on 1 Feb 2017
I ran into an use case recently where it would have been very useful to define an ordering_class on a view, similar to how filter_class is implemented. I had a model with a field '_owner', with property getters and setters exposing it as 'owner', which seems like standard Django practice when using properties on a model.
I implemented a filter using a FilterSet class like follows which allowed me to abstract this field name and allow users to filter using 'owner=xyz'
class BaseFilter(filters.FilterSet):
    owner = django_filters.CharFilter(name='_owner__username')

    class Meta:
        fields = ('name', 'owner',)
However, I could not do this for ordering, so for now I have had to expose an ordering field of '_owner_username' which isn't very friendly.
ordering_fields = ('name',  '_owner__username')
Steps to reproduce
N/A
Expected behavior
An ordering_class could be defined on a view to abstract any fields with unfriendly names or 'private' names i.e. those prefixed with an underscore to make them more friendly for end-users.
Actual behavior
The ordering fields needed to be specified in string form.
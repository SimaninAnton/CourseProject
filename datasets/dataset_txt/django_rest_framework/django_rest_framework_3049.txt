Collaborator
j4mie commented on 24 Oct 2012
If a view raises some sort of exception (404, say), APIView.handle_exception will directly return a response, eg:
...
elif isinstance(exc, Http404):
        return Response({'detail': 'Not found'},
                        status=status.HTTP_404_NOT_FOUND)
...
Normally this is fine, but if an HTMLRenderer is being used to render the response, it will cause ConfigurationError: Returned a template response with no template_name.
For cases like 404 this is fairly easy to fix - HTMLRenderer.get_template_names should return the appropriate 404.html. It might be a bit less clear how to deal with more esoteric status codes - you don't want users to have to create 400.html, 401.html, 402.html and so on. Maybe get_template_names should return a list with the first item being the exact status code, and the second being the top-level status class (ie 400.html) to cover all "something is broken" cases.
On the other hand, an HTMLRenderer might have been used to display a form, in which case a 400 error should be re-rendered with the same template (including error messages), right?
I'm fairly sure there's a similar issue with APIView.options as that directly returns a Response, so it'll break if the client asked for text/html (or the HTMLRenderer was the first in the list).
There's probably an obvious solution to this but I'm a bit frazzled and I'm struggling to think of the best way. Have a think and I'll try implementing it tomorrow.
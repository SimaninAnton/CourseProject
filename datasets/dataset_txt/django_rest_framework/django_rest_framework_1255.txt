yiakwy commented on 21 Mar 2016
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
django-rest serializer has a very upset feature, "I cann not attached value to a serlializer class!!!"
Expected behavior
for example:
    def __init__(self, *args, **kwargs):
        super(DynamicFieldsModelSerializer, self).__init__(*args, **kwargs)
        self._drop_cols()

    def _drop_cols(self):
        if hasattr(self.Meta, '__sign') and \
                hasattr(self.Meta, '__fields'):
            try:
                # the following method doesn't work
                sign = self.Meta.sign
                fields = self.Meta.fields
            except:
                # always error!
                return
            if fields is not None:
                if sign \
                        == u'+':
                    allowed = set(self.__fields)
                    existing = set(self.fields.keys())
                    for field_name in existing - allowed:
                        self.fields.pop(field_name)
                elif sign \
                        == u'-':
                    for fields_name in self.__fields:
                        self.fields.pop(fields_name)
Actual behavior
Here is confusion of the software
hasattr(self, 'sign') == True # yes
self.sign # always KeyError or None
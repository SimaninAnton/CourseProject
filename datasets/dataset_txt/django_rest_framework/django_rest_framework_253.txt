eeriksp commented on 4 Jan 2019 â€¢
edited
Consider the following model structure:
class Author(models.Model):
    name = models.CharField(max_length=150)
    year_of_birth = models.SmallIntegerField()

class Book(models.Model):
    title= models.CharField(max_length=150)
    author = models.ForeignKey(Author, on_delete=models.PROTECT, related_name='written_books')
First of all I want to have a serialzer representing all the fields of Author model.
class AuthorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Author
        fields = '__all__'
This syntax is nice and clear. However, when I want to add written_books (from the Book model) to serializer fields, I also have to manually type the names of all fields, which were previously represented by __all__.
class AuthorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Author
        fields = ('name', 'year_of_birth', 'written_books')
This syntax is not DRY and is quite fragile because when I update the Author model I also must remember to update the serializer.
I would like to have the following syntax:
class AuthorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Author
        fields = ('__all__', 'written_books')
However, as __all__ is also a valid name for Python class attribute, the name __all__ should, in this case, be replaced with something, which would not be a valid Python variable name, such as __all-fields__.
1
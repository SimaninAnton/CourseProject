Contributor
mrmachine commented on 13 Sep 2013
The API browser makes use of an override_method context manager to change the request method on a view so that it can check permissions for different endpoints (than the current request) and determine whether or not a form should be created.
My permissions are GET/list (deny) and POST/create (allow) on one URL, and GET/retrieve (allow), PUT/update (deny) and PATCH/partial_update (deny) on another. I want anonymous users to be able to create objects and retrieve specific objects, but not list or update objects.
All of these action methods are defined on one ModelViewSet, which is mapped to two URLs (one maps GET to list and the other maps GET to retrieve). I have a custom permission (applied to the whole viewset) that checks view.action and allows create and retrieve actions but denies list, update and partial_update actions for anonymous users.
I think this should work for real clients making real requests against the API. But the API browser gets confused on the list page because it displays the results for GET/list and a form for POST/create endpoints on the same page.
The API browser uses override_method to change the request method from GET to POST when checking if it should render a form, but it does not change the action from list to create.
I suppose in this particular case I could check a combination of request method and action. E.g. use view.action to differentiate between GET/list and GET/retrieve and use request.method for everything else?
But it feels wrong that the API browser doesn't behave consistently with the real API when checking permissions for various endpoints. If view.action is there to be tested when implementing custom permissions, then it should be consistently overridden along with request.method when the API browser checks for permissions.
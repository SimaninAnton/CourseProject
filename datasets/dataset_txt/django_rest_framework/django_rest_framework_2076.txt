fredericcambon commented on 14 Jan 2015
We recently upgraded to DRF 3.0 and noticed an important change of behaviour with the serializers.
For performance reasons, we implemented serializers in DRF 2.X that inherited each other to stay as DRY as possible. For one type of model we sometimes have up to 5/6 sub serializers
class TestSerializer(serializers.ModelSerializer):
    a = serializers.SerializerMethodField('get_a')

    class Meta:
        model = TestModel
        fields = ['a', 'b', 'c']

    def get_a(self, obj):
        return 0


class TestSubSerializer(TestSerializer):
    class Meta:
        model = TestModel
        fields = ['a']
This is useful because we don't have to rewrite get_a for each subserializer.
However this does not work in 3.0 because the __new__,__init__ methods of SerializerMetaclass retrieve the declared_fields of the current serializer class, not of its parents.
The following classes (with real code obviously) throw this error :
ImproperlyConfigured: Field name 'a' is not valid for model ModelBase.
It does so because a = serializers.serializers.SerializerMethodField('get_a') is declared in the parent class
Perhaps we are doing something wrong and not using the serializers properly ?
Thank you for your answer
13rac1 commented on 10 Sep 2014
Creating custom lookup filters can be tedious with DRF and django-filter:
class SessionFilter(django_filters.FilterSet):
    client_type__contains = django_filters.CharFilter(name='client_type', lookup_type='contains')
    client_system__contains = django_filters.CharFilter(name='client_system', lookup_type='contains')

    starttime__gte = django_filters.DateTimeFilter(name='starttime', lookup_type='gte')
    starttime__lte = django_filters.DateTimeFilter(name='starttime', lookup_type='lte')
    starttime__range = django_filters.DateRangeFilter(name='starttime')
    class Meta:
        model = Session
        fields = ['client_type',
                  'client_system',
                  'starttime',
                  'project',
                  'language',
                  ]

class SessionList(generics.ListAPIView):
    queryset = Session.objects.all()
    serializer_class = SessionSerializer
    filter_class = SessionFilter
Here's the same thing with TastyPie:
class SessionResource(ModelResource):
    class Meta:
        queryset = Session.objects.all()
        resource_name = "session"
        allowed_methods = ['get']
        serializer = JSONSerializer()
        filtering = {
            "client_type": ('exact', 'contains',),
            "client_system": ('exact', 'contains'),
            "starttime": ('exact', 'gte', 'lte', 'range'),
            "project": ('exact'),
            "language": ('exact'),
        }
It would be great if a filtering dictionary were similarly optionally supported with DRF. Most of the work would probably need to be in django-filter in filterset.py, but I thought it reasonable to start the dicussion here.
RDF/django-filter currently supports filter_fields for exact filtering only:
class ProductList(generics.ListAPIView):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    filter_fields = ('category', 'in_stock')
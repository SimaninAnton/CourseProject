mark0978 commented on 19 Dec 2013
Model
    start_at = models.DateTimeField(verbose_name='Starts At')

Serializer
    startAt = serializers.WritableField(source='start_at')


    def restore_fields(self, data, files):
        """
        Core of deserialization, together with `restore_object`.
        Converts a dictionary of data into a dictionary of deserialized fields.
        """
        reverted_data = {}

        if data is not None and not isinstance(data, dict):
            self._errors['non_field_errors'] = ['Invalid data']
            return None

        for field_name, field in self.fields.items():
            field.initialize(parent=self, field_name=field_name)
            try:
                field.field_from_native(data, files, field_name, reverted_data)
            except ValidationError as err:
# this raises a validation error for start_at, even though start_at already has a 
# value from the startAt alias that came back from the client
                self._errors[field_name] = list(err.messages)
start_at = models.DateTimeField(verbose_name='Starts At')
Using exclude in the for those fields will work around the problem, but it reads wrong, those fields haven't been excluded
I'm thinking this line in field_from_native:
        if value in (None, '') and self.required:
            raise ValidationError(self.error_messages['required'])
should be changed ...
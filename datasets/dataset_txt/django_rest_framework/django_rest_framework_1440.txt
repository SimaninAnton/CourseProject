Contributor
mlorant commented on 12 Nov 2015
(Might be related to #3308, please close this as duplicate if it is the case)
Almost all my models have ForeignKey to other models (limited choice defined by the user, parent/child relations...), and I want them to be updatable by the user in AJAX, which means through DRF. The problem is I did not find an ideal method yet to have something clean in my API codebase.
I need to override the create AND update methods of my serializer, which tends to make a lot of code for one or two fields sometimes. I propose something that might help in this process: we should be able to define a function (like clean_* in Django forms) that would be set the attribute of the object. Let's take an example:
# Assume MySuperModel.related_baz is a ForeignKey to RelatedBaz model
class MySuperModelSerializer(ModelSerializer):
    related_baz = RelatedBazSerializer()

    def set_related_baz(self, request, data):
         """
         data would be the value from request.data['related_baz'], which can be a string or a dict 
         Assume a dict {'name': '...'}, sent by the client, here
         """
         # My custom method to return the correct value for the field
         return get_object_or_404(RelatedBaz, name=data['name'], user=request.user)

    class Meta:
        model = MySuperModel
        fields = ('foo', 'bar', 'related_baz')
This would ease the workaround when encountering « AssertionError: The .update() method does not support writable nestedfields by default. »
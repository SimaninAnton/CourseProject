maennel commented on 5 Jan 2015
Hi, I've promised you some summary of migrating from 2.4 to 3.0 a while ago. Let me tell you that I've started the migration when there was only the "What's new in 3.0" page published, which may have as a consequence that I've pointed out something well-documented in the meanwhile.
Also, I think 3.0 was a big step in the right direction and I appreciate a lot what you, Tom together with everyone contributing on DRF did here!
So, hereafter you'll find most of the points that made me struggle in some way during migration.
Invocation order of 'save' and 'restore_object/create/update' got inverted
In the docs for DRF 3.0 it says somewhere that DRF 2.4's 'restore_object' has been replaced by the create/update functions.
However, I believe that this sentence is not entirely correct. In DRF 2.4 'restore_object' was followed by a call to 'save' (on the Serializer), which called 'save' on the model. In DRF 3.0 we have 'save' (on the Serializer) calling 'create/update' directly.
(self.)instance
It is not clear, whether (on a Serializer instance) 'self.instance' or 'instance' (available inside 'update' as an independent object) should be used.
I went on by using the provided 'instance' object and return the updated instance. The availability of self.instance seems, however, confusing to me.
Serializer Workflow
It would be good to have some graphical representation of a workflow through a serializer to find out, where DRF hooks in and what is up to the user (if anything ;) ).
Object creation
DRF 3.0 calls the model's 'create' method which implies calling the 'init' constructor with all supplied arguments directly followed by the save() method.
DRF 2.4 did not act this way - it called the constructor without arguments and initialized properties one by one afterwards.
Currently, there is no mean to use 'init' decoupled from save(), except overriding the create method completely.
In our use case, we should be able to call the constructor, do some actions on the object and then save the object. With the DRF 3.0 way of doing things, either we're obliged to accept two DB round-trips (which is not really an option) or we can overwrite 'create()' completely, which does the trick, but is not very nice.
Reversed Relations (like ManyToManyFields) are not considered inside Serializers
This issue is not new in DRF 3.0, but was already there in DRF 2.4
It is documented here.
However, I think this is a big lack and should, if possible, be addressed. The suggested way of working around the issue requires one to specify all the model fields in the 'Meta.fields' property, which - in my opinion - violates the pythonic DRY principle.
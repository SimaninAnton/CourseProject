Contributor
radyz commented on 23 Mar 2018
Checklist
I have verified that that issue exists against the master branch of Django REST framework.
I have searched for similar issues in both open and closed tickets and cannot find a duplicate.
This is not a usage question. (Those should be directed to the discussion group instead.)
This cannot be dealt with as a third party library. (We prefer new functionality to be in the form of third party libraries where possible.)
I have reduced the issue to the simplest possible case.
I have included a failing test as a pull request. (If you are unable to do so we can still accept the issue.)
Steps to reproduce
Configure django guardian object level permissions
Configure view with DjangoObjectPermissionsFilter
Create view permission for queryset
Expected behavior
Multiple calls to list objects should cache the result of the permission content type
Actual behavior
Multiple calls to list objects calls multiple times the database
When using guardian to filter by object permission I noticed the DjangoObjectPermissionsFilter class uses the shortcut function get_objects_for_user to get the object queryset, however in doing so, it's building the permission parameter in the form of app_label.view_model. When used in this manner guardian is performing a database call each time the function is called to determine the proper content type for which the permission is valid. Instead it should be using the form of view_model and guardian is smart to figure out where that permission belongs from the queryset parameter and under the hood uses django's contenttype manager which caches the result so further calls do not query the database.
For the time being I'm working around this issue by overriding this class and setting perm_format = 'view_%(model_name)s' instead, so when passed to guardian it's in the form of 'view_model' only.
andreip commented on 30 Jun 2015
I'm trying to define a usecase where I was expecting this to work, but since I don't have enough experience with rest framework, I wanted to first ask if this makes any sense, before I check how I can add a patch here.
class CampaignViewSet(viewsets.ModelViewSet):
    queryset = models.Campaign.objects.all()
    serializer_class = serializers.CampaignSerializer

    @detail_route(methods=['get'], permission_classes=[])
    @renderer_classes((TemplateHTMLRenderer,))
    def get_brief(self, request, *args, **kwargs):
        self.object = self.get_object()
        return Response({'o': self.object}, template_name='campaign_briefs.html')
So the way I see the URLs logic behind the viewset is:
/campaigns/{pk}/ would return me a Campaign.objects.get(pk=pk) object jsonified/browsable as I expect (left the default renderers on the class)
post, put etc. requests work too as expected
/campaigns/{pk}/get_brief would return me an HTML formatted campaign
I get Campaign is not JSON serializable error at the /get_brief though, because it's not seeing my TemplateHTMLRenderer renderer when trying to form the response, but instead it looks at class level only in rest_framework/renderers.py:get_default_renderer and uses the JSON default one. So would it make sense to first look at the corresponding method (inferred from context['request'] or somewhere else, idk) and if nothing is there then fallback to the behavior from now (looking at class level renderers?)?
Or if I can achieve this in a different way then that would work for me too. I can do it in a different endpoint, but was curious if this logic makes sense. Thank you!
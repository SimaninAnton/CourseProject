amir-f commented on Aug 15, 2013
I use Python 2.7 and used a partial function (functools.partial) as part of an input_processor for the ItemLoader. For instance,
price = Field(input_processor=Compose(some_partial_func, some_other_func))
During execution, get_func_args() from scrapy.util.python goes into an infinite loop until
/usr/local/lib/python2.7/dist-packages/scrapy/utils/python.pyc in get_func_args(func, stripself)
    161             return []
    162         else:
--> 163             return get_func_args(func.__call__, True)
    164     else:
    165         raise TypeError('%s is not callable' % type(func))

/usr/local/lib/python2.7/dist-packages/scrapy/utils/python.pyc in get_func_args(func, stripself)
    161             return []
    162         else:
--> 163             return get_func_args(func.__call__, True)
    164     else:
    165         raise TypeError('%s is not callable' % type(func))

/usr/local/lib/python2.7/dist-packages/scrapy/utils/python.pyc in get_func_args(func, stripself)
    151     if inspect.isfunction(func):
    152         func_args, _, _, _ = inspect.getargspec(func)
--> 153     elif inspect.isclass(func):
    154         return get_func_args(func.__init__, True)
    155     elif inspect.ismethod(func):

/usr/lib/python2.7/inspect.pyc in isclass(object)
     63         __doc__         documentation string
     64         __module__      name of module in which this class was defined"""
---> 65     return isinstance(object, (type, types.ClassType))
     66 
     67 def ismethod(object):

RuntimeError: maximum recursion depth exceeded while calling a Python object
happens. Looks like get_func_args needs to handle partial functions as a separate case.
shirk3y commented on Jun 19, 2014
CSS, or Xpath. That is the question. Even if you are CSS lover, you probably want more. XPath has the most what you probably want, but unfortunately, when you have to select by CSS class, expression looks like:
//p[contains(concat( " ", @class, " " ), concat( " ", "mb-author", " " ))]
or
descendant-or-self::p[@class and contains(concat(' ', normalize-space(@class), ' '), ' mb-author ')]
Isn't it painful if we select by many classes in one expression? For example the CSS expression p.mb-content.initial.rendered, div.content is converted to something like this:
descendant-or-self::p[@class and contains(concat(' ', normalize-space(@class), ' '), ' mb-content ') and (@class and contains(concat(' ', normalize-space(@class), ' '), ' initial ')) and (@class and contains(concat(' ', normalize-space(@class), ' '), ' rendered '))]
Why not extend Xpath to handle CSS classes more easily and less verbose? The example above could be expressed in following way:
//p[has-class("p.mb-content", "initial", "rendered")]
I've already done first step in this gist: https://gist.github.com/shirk3y/458224083ce5464627bc
If you like the idea, maybe it can be easily ported to Scrapy selector
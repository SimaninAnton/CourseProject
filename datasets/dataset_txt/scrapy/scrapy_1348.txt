daveoncode commented on Sep 30, 2014
The current implementation of DjangoItem's instance should be rewritten in order to reflect further modifications of the item to the underlying django's model instance.
These are the steps to reproduce the issue:
create a django item:
item = MyDjangoItem()
set a field value:
item['foo'] = 1
save the item:
model = item.save(commit=False)
item.instance is now cached and further modifications to the item are not reflected...
this returns "1"... and it's ok, because has been previously assigned to the instance
print model.foo
now... set a new item field
item['bar'] = 2
this prints None (because the underlying cache has not been updated!!)
print item.instance.bar
In conclusion... the cache should be purged each times the item is updated!
Currently I overrided the DjangoItem in this way to avoid the issue:
from scrapy.contrib.djangoitem import DjangoItem as BaseDjangoItem

class DjangoItem(BaseDjangoItem):
    def __setitem__(self, key, value):
        self._instance = None
        return super(DjangoItem, self).__setitem__(key, value)

    def __delitem__(self, key):
        self._instance = None
        super(DjangoItem, self).__delitem__(key)
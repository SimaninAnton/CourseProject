Contributor
erg commented on Nov 1, 2012
Suppose we are predicting the weather. The output labels are [temperature, wetness] where temperature = ["hot", "cold"] and wetness = ["dry", "wet"].
LabelEncoder flattens it all down to one set, thus allowing labels that have out of domain.
from sklearn.preprocessing import LabelEncoder
enc = LabelEncoder()
enc.fit(np.array([["hot","wet"], ["cold","dry"]]))
enc.transform(np.array([["cold", "dry"]])) # ok, since there's a [temperature, wetness] pair
enc.transform(np.array([["dry", "cold"]])) # should be an error since it's [wetness, temperature]
The correct way to handle this, IMO, is to group the data by column in the fit method, uniqueing each column separately, and throwing an error if the data passed to transform is out of the domain of its column.
Additionally, if you pass a multi-output list to transform, it errors:
from sklearn.preprocessing import LabelEncoder
enc = LabelEncoder()
enc.fit(np.array([["hot","wet"], ["cold","dry"]]))
enc.transform([["cold", "dry"]]) # ok, since there's a [temperature, wetness] pair
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-176-c2831dc31bf3> in <module>()
----> 1 enc.transform([["cold", "dry"]])

/usr/lib/python2.7/site-packages/sklearn/preprocessing.pyc in transform(self, y)
    677         self._check_fitted()
    678 
--> 679         classes = np.unique(y)
    680         if len(np.intersect1d(classes, self.classes_)) < len(classes):
    681             diff = np.setdiff1d(classes, self.classes_)

/usr/lib/python2.7/site-packages/numpy/lib/arraysetops.pyc in unique(ar, return_index, return_inverse)
    161     except AttributeError:
    162         if not return_inverse and not return_index:
--> 163             items = sorted(set(ar))
    164             return np.asarray(items)
    165         else:

TypeError: unhashable type: 'list'
It looks like it just needs an asarray.
Ichaab commented on Apr 6, 2018 â€¢
edited by glemaitre
Description
I would like to use the Index_balanced_accuracy as the scoring metric when using cross_val_score.
Steps/Code to Reproduce
1- I have included the definition of this metric in classification.py as make_index_balanced_accuracy_score
2- Make scorer for it : iba_scorer= make_scorer(make_index_balanced_accuracy_score) and add iba in the dict of scorer.py
3- include 'make_index_balanced_accuracy_score' in all of init.py
4- cv_iba = cross_val_score(clf, X, Y, cv=kf, scoring='iba')
Expected Results
Evaluating the classification according to iba
Actual Results
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-21-2eb46e06e631> in <module>()
----> 1 run_pipeline(clfs, X,Y)

<ipython-input-17-b7d2f830d17e> in run_pipeline(clfs, X_num, Y_num)
     19         cv_auc = cross_val_score(clf, X_num, Y_num, cv=kf, scoring='roc_auc')
     20         cv_f1 = cross_val_score(clf, X_num, Y_num, cv=kf, scoring='f1')
---> 21         cv_iba = cross_val_score(clf, X_num, Y_num, cv=kf, scoring=ibaa)
     22         #cv_iba=cross_val_score(clf, X_num, Y_num, cv=kf, scoring='make_index_balanced_accuracy')
     23         print("Accuracy for {0} is: {1:.3f} +/- {2:.3f} (in {3:.2f} seconds)".format(clf_name, np.mean(cv_acc), np.std(cv_acc), end-begin))

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\model_selection\_validation.py in cross_val_score(estimator, X, y, groups, scoring, cv, n_jobs, verbose, fit_params, pre_dispatch)
    354                                 n_jobs=n_jobs, verbose=verbose,
    355                                 fit_params=fit_params,
--> 356                                 pre_dispatch=pre_dispatch)
    357     return cv_results['test_score']
    358 

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\model_selection\_validation.py in cross_validate(estimator, X, y, groups, scoring, cv, n_jobs, verbose, fit_params, pre_dispatch, return_train_score, return_estimator)
    213             fit_params, return_train_score=return_train_score,
    214             return_times=True, return_estimator=return_estimator)
--> 215         for train, test in cv.split(X, y, groups))
    216 
    217     zipped_scores = list(zip(*scores))

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\parallel.py in __call__(self, iterable)
    777             # was dispatched. In particular this covers the edge
    778             # case of Parallel used with an exhausted iterator.
--> 779             while self.dispatch_one_batch(iterator):
    780                 self._iterating = True
    781             else:

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\parallel.py in dispatch_one_batch(self, iterator)
    623                 return False
    624             else:
--> 625                 self._dispatch(tasks)
    626                 return True
    627 

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\parallel.py in _dispatch(self, batch)
    586         dispatch_timestamp = time.time()
    587         cb = BatchCompletionCallBack(dispatch_timestamp, len(batch), self)
--> 588         job = self._backend.apply_async(batch, callback=cb)
    589         self._jobs.append(job)
    590 

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\_parallel_backends.py in apply_async(self, func, callback)
    109     def apply_async(self, func, callback=None):
    110         """Schedule a func to be run"""
--> 111         result = ImmediateResult(func)
    112         if callback:
    113             callback(result)

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\_parallel_backends.py in __init__(self, batch)
    330         # Don't delay the application, to avoid keeping the input
    331         # arguments in memory
--> 332         self.results = batch()
    333 
    334     def get(self):

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\parallel.py in __call__(self)
    129 
    130     def __call__(self):
--> 131         return [func(*args, **kwargs) for func, args, kwargs in self.items]
    132 
    133     def __len__(self):

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\externals\joblib\parallel.py in <listcomp>(.0)
    129 
    130     def __call__(self):
--> 131         return [func(*args, **kwargs) for func, args, kwargs in self.items]
    132 
    133     def __len__(self):

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\model_selection\_validation.py in _fit_and_score(estimator, X, y, scorer, train, test, verbose, parameters, fit_params, return_train_score, return_parameters, return_n_test_samples, return_times, return_estimator, error_score)
    517         fit_time = time.time() - start_time
    518         # _score will return dict if is_multimetric is True
--> 519         test_scores = _score(estimator, X_test, y_test, scorer, is_multimetric)
    520         score_time = time.time() - start_time - fit_time
    521         if return_train_score:

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\model_selection\_validation.py in _score(estimator, X_test, y_test, scorer, is_multimetric)
    554     """
    555     if is_multimetric:
--> 556         return _multimetric_score(estimator, X_test, y_test, scorer)
    557     else:
    558         if y_test is None:

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\model_selection\_validation.py in _multimetric_score(estimator, X_test, y_test, scorers)
    584             score = scorer(estimator, X_test)
    585         else:
--> 586             score = scorer(estimator, X_test, y_test)
    587 
    588         if hasattr(score, 'item'):

~\Anaconda35\Lib\site-packages\scikit-learn\sklearn\metrics\scorer.py in __call__(self, estimator, X, y_true, sample_weight)
    106         else:
    107             return self._sign * self._score_func(y_true, y_pred,
--> 108                                                  **self._kwargs)
    109 
    110 

TypeError: unsupported operand type(s) for *: 'int' and 'function'
Versions
Windows-8.1-6.3.9600-SP0
Python 3.6.4 Anaconda, Inc
Numpy 1.14.0
SciPy 1.0.0
Scikit-learn: 0.20.dev0
Any help would be much appreciated.
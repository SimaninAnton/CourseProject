olebole commented on Jan 23, 2019 â€¢
edited
There are a number of failures on our non-intel platforms, which currently prevent scikit-learn from migration to the upcoming "buster" release.
The logs can be found here.
Relevant Debian bug is Debian#919918.
test_estimate_bandwidth_1sample
(on arm64, s390x, ppc64)
    def test_estimate_bandwidth_1sample():
        # Test estimate_bandwidth when n_samples=1 and quantile<1, so that
        # n_neighbors is set to 1.
        bandwidth = estimate_bandwidth(X, n_samples=1, quantile=0.3)
>       assert_equal(bandwidth, 0.)

sklearn/cluster/tests/test_mean_shift.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python2.7/unittest/case.py:513: in assertEqual
    assertion_func(first, second, msg=msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sklearn.utils._unittest_backport.TestCase testMethod=__init__>
first = 2.384185791015625e-07, second = 0.0
msg = '2.384185791015625e-07 != 0.0'

    def _baseAssertEqual(self, first, second, msg=None):
        """The default assertEqual implementation, not type specific."""
        if not first == second:
            standardMsg = '%s != %s' % (safe_repr(first), safe_repr(second))
            msg = self._formatMessage(msg, standardMsg)
>           raise self.failureException(msg)
E           AssertionError: 2.384185791015625e-07 != 0.0

/usr/lib/python2.7/unittest/case.py:506: AssertionError
test_decode_anneal
(on arm64, armel)
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0xffff8ac04790>

    def test_decode_anneal(monkeypatch):
        data_id = 2
        _monkey_patch_webbased_functions(monkeypatch, data_id, False)
>       _test_features_list(data_id)

sklearn/datasets/tests/test_openml.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data_id = 2

    def _test_features_list(data_id):
        [...]
        for i in range(len(data_bunch.feature_names)):
            # XXX: Test per column, as this makes it easier to avoid problems with
            # missing values
    
            np.testing.assert_array_equal(data_downloaded[:, i],
>                                         decode_column(data_bunch, i))
E           AssertionError: 
E           Arrays are not equal
E           
E           (mismatch 100.0%)
E            x: array([None, None, None, None, None, None, None, None, None, None, None],
E                 dtype=object)
E            y: array(['GB', 'GB', 'GB', 'GB', 'GB', 'GB', 'GB', 'GB', 'GB', 'GB', 'GB'],
E                 dtype=object)

sklearn/datasets/tests/test_openml.py:65: AssertionError
test_dump
(on arm64)
    def test_dump():
        [...]
        for X in (X_sparse, X_dense, X_sliced):
            for y in (y_sparse, y_dense, y_sliced):
                for zero_based in (True, False):
                    for dtype in [np.float32, np.float64, np.int32]:
          [...]
                        if dtype == np.float32:
                            # allow a rounding error at the last decimal place
                            assert_array_almost_equal(
                                X_dense.astype(dtype), X2_dense, 4)
                            assert_array_almost_equal(
                                y_dense.astype(dtype), y2, 4)
                        else:
                            # allow a rounding error at the last decimal place
                            assert_array_almost_equal(
>                               X_dense.astype(dtype), X2_dense, 15)
E                           AssertionError: 
E                           Arrays are not almost equal to 15 decimals
E                           
E                           (mismatch 0.793650793651%)
E                            x: array([[         0,          0,          2,          0,          0,
E                                            0,          0,          0,          0,          0,
E                                           -5,          0,          0,          0,          0,...
E                            y: array([[         0,          0,          2,          0,          0,
E                                            0,          0,          0,          0,          0,
E                                           -5,          0,          0,          0,          0,...

sklearn/datasets/tests/test_svmlight_format.py:267: AssertionError
test_matthews_corrcoef_multiclass
(on armel)
    def test_matthews_corrcoef_multiclass():
        [...]
        # Zero variance will result in an mcc of zero and a Runtime Warning
        y_true = [0, 1, 2]
        y_pred = [3, 3, 3]
        mcc = assert_warns_message(RuntimeWarning, 'invalid value encountered',
>                                  matthews_corrcoef, y_true, y_pred)

sklearn/metrics/tests/test_classification.py:515: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

warning_class = <type 'exceptions.RuntimeWarning'>
message = 'invalid value encountered'
func = <function matthews_corrcoef at 0xb2af0530>, args = ([0, 1, 2], [3, 3, 3])
kw = {}, w = [], result = 0.0

    def assert_warns_message(warning_class, message, func, *args, **kw):
        # very important to avoid uncontrolled state propagation
        """{...]"""
        clean_warning_registry()
        with warnings.catch_warnings(record=True) as w:
            # Cause all warnings to always be triggered.
            warnings.simplefilter("always")
            if hasattr(np, 'VisibleDeprecationWarning'):
                # Let's not catch the numpy internal DeprecationWarnings
                warnings.simplefilter('ignore', np.VisibleDeprecationWarning)
            # Trigger a warning.
            result = func(*args, **kw)
            # Verify some things
            if not len(w) > 0:
                raise AssertionError("No warning raised when calling %s"
>                                    % func.__name__)
E               AssertionError: No warning raised when calling matthews_corrcoef

sklearn/utils/testing.py:200: AssertionError
Bus error in sklearn/neighbors/tests/test_lof.py
(on armhf)
test_non_meta_estimators[KernelPCA-KernelPCA-check_pipeline_consistency]
(on ppc64el; repeats similarly three times)
name = 'KernelPCA'
Estimator = <class 'sklearn.decomposition.kernel_pca.KernelPCA'>
check = <function check_pipeline_consistency at 0x3fff8b056b18>

    @pytest.mark.parametrize(
            "name, Estimator, check",
            _generate_checks_per_estimator(_yield_all_checks,
                                           _tested_non_meta_estimators()),
            ids=_rename_partial
    )
    def test_non_meta_estimators(name, Estimator, check):
        # Common tests for non-meta estimators
        with ignore_warnings(category=(DeprecationWarning, ConvergenceWarning,
                                       UserWarning, FutureWarning)):
            estimator = Estimator()
            set_checking_parameters(estimator)
>           check(name, estimator)

sklearn/tests/test_common.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sklearn/utils/testing.py:350: in wrapper
    return fn(*args, **kwargs)
sklearn/utils/estimator_checks.py:1048: in check_pipeline_consistency
    assert_allclose_dense_sparse(result, result_pipe)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = array([[ 9.17543358e-01,  4.04410079e-02,  2.21585378e-02,
        -2.69563828...,  2.47000231e-11,
         2.81623715e-09,  1.36863809e-09,  1.28803077e-09]])
y = array([[ 9.17543358e-01,  4.04410079e-02,  2.21585378e-02,
        -2.69560026..., -6.90266524e-10,
        -8.33997668e-11,  1.37018888e-09,  2.03087265e-09]])
rtol = 1e-07, atol = 1e-09, err_msg = ''

    def assert_allclose_dense_sparse(x, y, rtol=1e-07, atol=1e-9, err_msg=''):
        """[...]"""
        if sp.sparse.issparse(x) and sp.sparse.issparse(y):
            x = x.tocsr()
            y = y.tocsr()
            x.sum_duplicates()
            y.sum_duplicates()
            assert_array_equal(x.indices, y.indices, err_msg=err_msg)
            assert_array_equal(x.indptr, y.indptr, err_msg=err_msg)
            assert_allclose(x.data, y.data, rtol=rtol, atol=atol, err_msg=err_msg)
        elif not sp.sparse.issparse(x) and not sp.sparse.issparse(y):
            # both dense
>           assert_allclose(x, y, rtol=rtol, atol=atol, err_msg=err_msg)
E           AssertionError: 
E           Not equal to tolerance rtol=1e-07, atol=1e-09
E           
E           (mismatch 13.7777777778%)
E            x: array([[ 9.175434e-01,  4.044101e-02,  2.215854e-02, -2.695638e-08,
E                    3.128852e-08,  0.000000e+00,  0.000000e+00,  0.000000e+00,
E                    0.000000e+00,  0.000000e+00,  0.000000e+00,  0.000000e+00,...
E            y: array([[ 9.175434e-01,  4.044101e-02,  2.215854e-02, -2.695600e-08,
E                    3.128926e-08,  0.000000e+00,  0.000000e+00,  0.000000e+00,
E                    0.000000e+00,  0.000000e+00,  0.000000e+00,  0.000000e+00,...

sklearn/utils/testing.py:464: AssertionError
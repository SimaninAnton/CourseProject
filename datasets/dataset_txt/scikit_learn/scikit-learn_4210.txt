Contributor
perimosocordiae commented on Sep 21, 2014
With master branches of both scipy and scikit-learn, I found that scipy's L1 distance implementation is much faster:
In [1]: import numpy as np
In [2]: from sklearn.metrics.pairwise import manhattan_distances
In [3]: from scipy.spatial.distance import cdist
In [4]: X = np.random.random((100,1000))
In [5]: Y = np.random.random((50,1000))
In [6]: %timeit manhattan_distances(X, Y)
10 loops, best of 3: 25.9 ms per loop

In [7]: %timeit cdist(X, Y, 'cityblock')
100 loops, best of 3: 6.48 ms per loop

In [8]: np.allclose(manhattan_distances(X,Y), cdist(X,Y,'cityblock'))
Out[8]: True
Upon inspection, scipy has a C function whereas scikit-learn uses numpy broadcasting (which allocates a large intermediate matrix).
Is there a reason not to simply use scipy's implementation here (for the dense case)? If using scipy's version is a problem, would a Cython version of dense pairwise L1 be desirable?
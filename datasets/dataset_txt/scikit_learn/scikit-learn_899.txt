Member
jnothman commented on Nov 27, 2018
Reported by @arnau126 at #12443 (comment):
This change breaks transform in _legacy_mode. It raises NotFittedError when it's actually fitted. This is because check_is_fitted checks categories_ when _legacy_transform doesn't use it at all.
In _legacy_mode we should check _feature_indices_, _n_values_ and _active_features_ instead.
I propose:
def transform(self, X):
   if self._legacy_mode:
       check_is_fitted(self, ('_feature_indices_', '_n_values_', '_active_features_'))
       return _transform_selected(X, self._legacy_transform, self.dtype,
                                                   self._categorical_features, copy=True)
   else:
       check_is_fitted(self, 'categories_')
       return self._transform_new(X)
I'm surprised we don't already have tests for this case. @arnau126, please submit a minimal verifiable example, or just a test case by which we can confirm the error and your fix. Or submit a pull request with your fix and a test.
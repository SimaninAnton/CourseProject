pemistahl commented on Feb 4, 2013
Hey all, I know that the issue tracker is meant to be used for reporting bugs and such but I have a question about the standardization of SVMs in scikit-learn. I posted my question on Stackoverflow but it's obviously too special for people there to be answered. I hope that you can answer my question, either here or on Stackoverflow which would be better probably.
Thank you very much in advance! :)
Let me state my question here again:
I'm using the current stable version 0.13 of scikit-learn. I'm applying a linear support vector classifier to some data using the class sklearn.svm.LinearSVC.
In the chapter about preprocessing in scikit-learn's documentation, I've read the following:
Many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2 regularizers of linear models) assume that all features are centered around zero and have variance in the same order. If a feature has a variance that is orders of magnitude larger that others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.
Question 1: Is standardization useful for SVMs in general, also for those with a linear kernel function as in my case?
Question 2: As far as I understand, I have to compute the mean and standard deviation on the training data and apply this same transformation on the test data using the class sklearn.preprocessing.StandardScaler. However, what I don't understand is whether I have to transform the training data as well or just the test data prior to feeding it to the SVM classifier.
That is, do I have to do this:
scaler = StandardScaler()
scaler.fit(X_train)  # only compute mean and std here
X_test = scaler.transform(X_test)  # perform standardization by centering and scaling

clf = LinearSVC()
clf.fit(X_train, y_train)
clf.predict(X_test)
Or do I have to do this:
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)  # compute mean, std and transform training data as well
X_test = scaler.transform(X_test)  # same as above

clf = LinearSVC()
clf.fit(X_train, y_train)
clf.predict(X_test)
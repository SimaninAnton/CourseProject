LBlnd commented on Jun 19, 2017 â€¢
edited
Hello !
I'm using SVC from Sklearn to discriminate between different matrices.
The datas are 95 matrices of correlation, computed from IRM of patients with schizophrenia (50 matrices) and healty controls (45 matrices). They are pretty big (264*264), so I wasn't expecting perfect results, but 0% accuracy seems really low.
Code
Here is the code:
## Datas
#control_matrices: list of 45 matrices
#patient_matrices: list of 50 matrices

n_training = 25 #Number of matrices of control to train SVC (25 control and 25 patient)
indices = np.triu_indices(264,1) #Since the matrices are symetric, I just take the upper triangle

perm_control = np.random.permutation(45) #Doing a permutation to take random matrices for training
contr_matrices = control_matrices[perm_control] #control_matrices is a list of matrices
perm_patient = np.random.permutation(50) #Same with the patient matrices
pat_matrices = patient_matrices[perm_patient] 

x_control = [m[indices] for m in contr_matrices[:n_training]] #Data for training
x_patient = [m[indices] for m in pat_matrices[:n_training]]

test_control = [m[indices] for m in contr_matrices[n_training:]] #Data for test once the SVM is trained
test_patient = [m[indices] for m in pat_matrices[n_training:]]

X = np.concatenate((x_control, x_patient))
Y = np.asarray( n_training*["Control"] + n_training*["Patient"] )

## Training

clf = SVC()
clf.fit(X,Y)
Expected Results
Since the size of the data is huge compared to the number of matrices, I would have expected low results (something just a little bit better than 50%).
Actual Results
clf.score(np.concatenate((test_control, test_patient)), 20*['Control']+25*['Patient'])
0.0
The same happens whenever I run the code (so, with different permutations), and for n_training from 10 to 45. However the SVC does remember well the first matrices, for the training.
Try
I also tried this, with exactly the same results:
from sklearn.cross_validation import StratifiedKFold, cross_val_score
from nilearn import connectome

connectivity_coefs = connectome.sym_to_vec(matrices, ConnectivityMeasure) 
# This turns the matrices to a list of vectors

Y = 45*["Control"] + 50*["Patient"]

cv = StratifiedKFold(Y, n_folds=3, shuffle=True)
svc = LinearSVC()

cv_scores = cross_val_score(svc, connectivity_coefs, Y, cv=cv, scoring='accuracy')

print('Score: %1.2f +- %1.2f' % (cv_scores.mean(), cv_scores.std()))
 Score: 0.00 +- 0.00
I completely fail to understand what is happening here.
Versions
Windows-8-6.2.9200
Python 3.4.1 |Continuum Analytics, Inc.| (default, May 19 2014, 13:02:30) [MSC v.1600 64 bit (AMD64)]
NumPy 1.9.1
SciPy 0.15.1
Scikit-Learn 0.15.2
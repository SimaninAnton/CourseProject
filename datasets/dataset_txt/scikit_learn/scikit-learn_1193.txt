caifazhou commented on Aug 2, 2018 â€¢
edited
I am trying to extend the KNN object for taking a custom-defined weight with the parameters.
# custom-defined weights for knn (sklearn)
def customWeights(distances, **kwargs):
#     print(repr(distances.shape))
    n = distances.shape[1]
    expFactor = kwargs.get('expFactor',9)
    reWeights = re(n, expFactor=expFactor)/np.sum(re(n, expFactor=expFactor))  #self defined weighting
    rankWeigths = np.tile(np.reshape(reWeights, newshape=(1,-1)), (distances.shape[0], 1))
    invDistWeigths = np.divide(np.divide(1, distances + np.finfo(np.float).eps), 
                               np.tile(np.reshape(np.sum(np.divide(1, distances + np.finfo(np.float).eps), axis=1), newshape=(-1, 1)), 
                                       (1, distances.shape[1])))
    alpha = kwargs.get('alpha', 4.5)
    weights = varF1Score(rankWeigths, invDistWeigths, alpha=alpha) # self defined combination
    weights = np.divide(weights, np.tile(np.reshape(np.sum(weights, axis=1), newshape=(-1, 1)), (1, weights.shape[1])))
#     print(invDistWeigths.shape)
    return weights

def varF1Score(x, y, alpha=1.0):
    if not ((x.shape == y.shape)):
        raise ValueError('The input x and y must in the same shape {} != {}.'.format(x.shape, y.shape))
    return np.divide(np.multiply((1 + alpha) * x, y), np.add(y, alpha * x))
I have a problem of how to extend the KNN object for taking the parameters for the callable weights (similar to 'metric_params')? Anyone has experience for this? Thanks in advance.
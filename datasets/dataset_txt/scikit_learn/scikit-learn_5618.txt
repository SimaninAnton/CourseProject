denzilc commented on May 19, 2011
The C value varies on the n_jobs parameter passed to the grid search.
X = sparse_feats
Y = target_labels
C_start, C_end, C_step = -3, 15, 2


train, test = iter(StratifiedKFold(Y, 2, indices = True)).next()

# Generate grid search values for C, gamma
C_val = 2. ** np.arange(C_start, C_end + C_step, C_step)


grid_clf = svm.sparse.LinearSVC()   
print grid_clf

linear_SVC_params = {'C': C_val}


grid_search = GridSearchCV(grid_clf , linear_SVC_params, n_jobs = 100 , score_func = f1_score)
grid_search.fit(X[train], Y[train], cv = StratifiedKFold(Y[train],10, indices = True))
y_true, y_pred = Y[test], grid_search.predict(X[test])                   

print "Classification report for the best estimator: "
print grid_search.best_estimator

print "Tuned for  with optimal value: %0.3f" % f1_score(y_true, y_pred)
print classification_report(y_true, y_pred)

print "Grid scores:"
pprint(grid_search.grid_scores_)

print "Best score: %0.3f" % grid_search.best_score


best_parameters = grid_search.best_estimator._get_params()
print "Best C: %0.3f " % best_parameters['C']
Just to make sure you can re-produce, X is a sparse CSR matrix of features.
The documentation suggests that this variable specifies only the number of jobs to be run in parallel and I hence assume it's for efficiency of the program.
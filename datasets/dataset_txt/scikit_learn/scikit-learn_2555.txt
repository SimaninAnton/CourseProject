Contributor
chkoar commented on Dec 1, 2016
Currently, all implemented ensembles are iterables except the VotingClassifier.
from sklearn.datasets import load_iris
from sklearn.ensemble import RandomForestClassifier as RFC
from sklearn.ensemble import VotingClassifier as VC
from sklearn.neighbors import KNeighborsClassifier as KNC
from sklearn.neighbors import RadiusNeighborsClassifier as  RNC

X, y = load_iris(return_X_y=True)
rfc = RFC(random_state=42)
vc = VC([['knc', KNC()],['rnc', RNC()]])

rfc.fit(X,y)
vc.fit(X,y)

for e in rfc:
    print e.score(X,y)

for e in vc:
    print e.score(X,y)

0.986666666667
0.986666666667
0.966666666667
0.966666666667
0.966666666667
0.98
0.973333333333
0.953333333333
0.98
0.986666666667

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-78-76bbb0338c14> in <module>()
     15     print e.score(X,y)
     16 
---> 17 for e in vc:
     18     print e.score(X,y)

TypeError: 'VotingClassifier' object is not iterable
Apart from the fact that one could iterate over the ensemble.estimators_, I believe that we could remove the __len__, __getitem__ and __iter__ magic methods from the BaseEnsemble and create an IterableMixin. So, the BaseEnsemble and the VotingClassifier could inherit from that.
class IterableMixin(object):
    def __len__(self):
        """Returns the number of estimators in the ensemble."""
        return len(self.estimators_)

    def __getitem__(self, index):
        """Returns the index'th estimator in the ensemble."""
        return self.estimators_[index]

    def __iter__(self):
        """Returns iterator over estimators in the ensemble."""
        return iter(self.estimators_)
Thoughts?
IrvicRodriguez commented on Dec 6, 2015
I am trying to use grid search to find the parameters for some models I am trying out but Grid Search is giving an error when invoked. The same code was used last week with similar data and grid search was working fine.
RFC = RandomForestClassifier(n_jobs=-1, n_estimators=64)
parameters = {'criterion': ['gini', 'entropy'], 'max_depth': np.linspace(1, 20, 10), 'min_samples_leaf': np.linspace(1, 30, 15),'min_samples_split': np.linspace(2, 20, 10), 'bootstrap' : ['True', 'False']}
gs = GridSearchCV(RFC, parameters, verbose=1, cv=5)
%time _ = gs.fit(X_train1, y_train1)
gs.best_params_, gs.best_score_
Fitting 5 folds for each of 6000 candidates, totalling 30000 fits
TypeError Traceback (most recent call last)
in ()
----> 1 get_ipython().magic(u'time _ = gs.fit(X_train1, y_train1)')
2
3 gs.best_params_, gs.best_score_
C:\Users\irvic\Anaconda\lib\site-packages\IPython\core\interactiveshell.pyc in magic(self, arg_s)
2334 magic_name, _, magic_arg_s = arg_s.partition(' ')
2335 magic_name = magic_name.lstrip(prefilter.ESC_MAGIC)
-> 2336 return self.run_line_magic(magic_name, magic_arg_s)
2337
2338 #-------------------------------------------------------------------------
C:\Users\irvic\Anaconda\lib\site-packages\IPython\core\interactiveshell.pyc in run_line_magic(self, magic_name, line)
2255 kwargs['local_ns'] = sys._getframe(stack_depth).f_locals
2256 with self.builtin_trap:
-> 2257 result = fn(args,*kwargs)
2258 return result
2259
C:\Users\irvic\Anaconda\lib\site-packages\IPython\core\magics\execution.pyc in time(self, line, cell, local_ns)
C:\Users\irvic\Anaconda\lib\site-packages\IPython\core\magic.pyc in (f, _a, *_k)
191 # but it's overkill for just that one bit of state.
192 def magic_deco(arg):
--> 193 call = lambda f, _a, *_k: f(_a, *_k)
194
195 if callable(arg):
C:\Users\irvic\Anaconda\lib\site-packages\IPython\core\magics\execution.pyc in time(self, line, cell, local_ns)
1165 else:
1166 st = clock2()
-> 1167 exec(code, glob, local_ns)
1168 end = clock2()
1169 out = None
in ()
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\grid_search.pyc in fit(self, X, y)
730
731 """
--> 732 return self._fit(X, y, ParameterGrid(self.param_grid))
733
734
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\grid_search.pyc in _fit(self, X, y, parameter_iterable)
503 self.fit_params, return_parameters=True,
504 error_score=self.error_score)
--> 505 for parameters in parameter_iterable
506 for train, test in cv)
507
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\externals\joblib\parallel.pyc in call(self, iterable)
657 self._iterating = True
658 for function, args, kwargs in iterable:
--> 659 self.dispatch(function, args, kwargs)
660
661 if pre_dispatch == "all" or n_jobs == 1:
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\externals\joblib\parallel.pyc in dispatch(self, func, args, kwargs)
404 """
405 if self._pool is None:
--> 406 job = ImmediateApply(func, args, kwargs)
407 index = len(self._jobs)
408 if not _verbosity_filter(index, self.verbose):
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\externals\joblib\parallel.pyc in init(self, func, args, kwargs)
138 # Don't delay the application, to avoid keeping the input
139 # arguments in memory
--> 140 self.results = func(_args, *_kwargs)
141
142 def get(self):
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\cross_validation.pyc in _fit_and_score(estimator, X, y, scorer, train, test, verbose, parameters, fit_params, return_train_score, return_parameters, error_score)
1450 start_time = time.time()
1451
-> 1452 X_train, y_train = _safe_split(estimator, X, y, train)
1453 X_test, y_test = _safe_split(estimator, X, y, test, train)
1454
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\cross_validation.pyc in _safe_split(estimator, X, y, indices, train_indices)
1520
1521 if y is not None:
-> 1522 y_subset = safe_indexing(y, indices)
1523 else:
1524 y_subset = None
C:\Users\irvic\Anaconda\lib\site-packages\sklearn\utils__init__.pyc in safe_indexing(X, indices)
155 indices.dtype.kind == 'i'):
156 # This is often substantially faster than X[indices]
--> 157 return X.take(indices, axis=0)
158 else:
159 return X[indices]
TypeError: take_nd() got an unexpected keyword argument 'axis'
I do not know how to get it working
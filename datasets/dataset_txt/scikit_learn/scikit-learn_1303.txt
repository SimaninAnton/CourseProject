Zaharid commented on Jun 18, 2018
Description
I am trying to understand the implementation of the KDTree structure here, and I came across this line
scikit-learn/sklearn/neighbors/kd_tree.pyx
Line 75 in 066b501
 rad += pow(0.5 * abs(upper_bounds[j] - lower_bounds[j]), 
I do not understand how the code corresponds to the description in the comments below
    # The radius will hold the size of the circumscribed hypersphere measured
    # with the specified metric: in querying, this is used as a measure of the
    # size of each node when deciding which nodes to split.
As far as I can tell, the value of j is set to nfeatures-1 and the code is repeated once for each datapoint instead once for each dimension. Moreover the boundaries are being added while they are still changing.
Steps/Code to Reproduce
Consider
In [1]: from sklearn.neighbors import KDTree

In [2]: data = [[0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0]]

In [3]: t = KDTree(data,leaf_size=1)

In [4]: t.node_data[0]
Out[4]: {'idx_end': 7, 'idx_start': 0, 'is_leaf': 0, 'radius': 0.0}

In [5]: t.node_data[1]
Out[5]: {'idx_end': 3, 'idx_start': 0, 'is_leaf': 0, 'radius': 0.0}

In [6]: t.node_data[2]
Out[6]: {'idx_end': 7, 'idx_start': 3, 'is_leaf': 0, 'radius': 0.0}

In [7]: t.node_data[3]
Out[7]: {'idx_end': 1, 'idx_start': 0, 'is_leaf': 1, 'radius': 0.0}

In [8]: t.node_data[4]
Out[8]: {'idx_end': 3, 'idx_start': 1, 'is_leaf': 1, 'radius': 0.0}

In [9]: t.node_data[5]
Out[9]: {'idx_end': 5, 'idx_start': 3, 'is_leaf': 1, 'radius': 0.0}

In [10]: t.node_data[6]
Out[10]: {'idx_end': 7, 'idx_start': 5, 'is_leaf': 1, 'radius': 0.0}
Note that all radii are zero.
Expected Results
I would expect the radii of these nodes to be different, not all zero. I think they are zero in the example because they only look at the last dimension.
Actual Results
I believe this might lead to degraded performance when quering, trough the use of radii in this function:
scikit-learn/sklearn/neighbors/binary_tree.pxi
Line 1849 in 066b501
 cdef int _query_dual_depthfirst(self, ITYPE_t i_node1, 
but I have not tested it, and still do not understand the algorithm well enough.
Versions
I am looking at the current master version on github. The example above works with version 0.19.1.
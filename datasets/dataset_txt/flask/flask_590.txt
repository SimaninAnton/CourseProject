dotSlashLu commented on 16 Jun 2017 â€¢
edited
Hi,
Is there any reason the view function name is used as the default endpoint? Taken view_func.__name__ as the default endpoint name I have to specify endpoints myself if my view functions are all subclassed from a same class and call a same method, or an View function mapping is overwriting an existing endpoint function error will be raised, which is not good for reusability.
Take the example below:
class APIBase():
    def call(self, **kwargs):
        # assign url variables to self
        for k, v in kwargs.iteritems():
            self.setattr(k, v)
        m = getattr(self, request.method)
        m()

class DuckAPI(APIBase):
    def post(self):
        pass

class ChickenAPI(APIBase):
    def post(self):
        pass

context.route('/duck/<duck_id>', *args, **kwargs)(DuckAPI().call)
context.route('/chicken/<chicken_id>', *args, **kwargs)(ChickenAPI().call)
This will raise View function mapping is overwriting an existing endpoint function module_name.call, but actually the call function are from different instances.
I understand that typically context.route is used as a decorator thus having little possibility that the decorated functions' names in the same module will collide, but there're chances people like me will prefer to use it as a wrapper to define routes dynamically.
Will it be better if we use str(view_func) as the default endpoint?
I think we should at least change the error message, since the call in the above error message is not bound to the module it self, but described as endpoint function {module_name}.call. This took me a long time to trace the problem.
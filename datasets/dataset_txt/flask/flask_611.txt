Member
jeffwidman commented on 23 May 2017
flask/tests/test_reqctx.py
Lines 147 to 196 in c8e56d5
 @pytest.mark.skipif(greenlet is None, reason='greenlet not installed') 
 def test_greenlet_context_copying(): 
     app = flask.Flask(__name__) 
     greenlets = [] 
        @app.route('/') 
     def index(): 
         reqctx = flask._request_ctx_stack.top.copy() 
         def g(): 
             assert not flask.request 
             assert not flask.current_app 
             with reqctx: 
                 assert flask.request 
                 assert flask.current_app == app 
                 assert flask.request.path == '/' 
                 assert flask.request.args['foo'] == 'bar' 
             assert not flask.request 
             return 42 
         greenlets.append(greenlet(g)) 
         return 'Hello World!' 
        rv = app.test_client().get('/?foo=bar') 
     assert rv.data == b'Hello World!' 
        result = greenlets[0].run() 
     assert result == 42 
    @pytest.mark.skipif(greenlet is None, reason='greenlet not installed') 
 def test_greenlet_context_copying_api(): 
     app = flask.Flask(__name__) 
     greenlets = [] 
        @app.route('/') 
     def index(): 
         reqctx = flask._request_ctx_stack.top.copy() 
         @flask.copy_current_request_context 
         def g(): 
             assert flask.request 
             assert flask.current_app == app 
             assert flask.request.path == '/' 
             assert flask.request.args['foo'] == 'bar' 
             return 42 
         greenlets.append(greenlet(g)) 
         return 'Hello World!' 
        rv = app.test_client().get('/?foo=bar') 
     assert rv.data == b'Hello World!' 
        result = greenlets[0].run() 
     assert result == 42 
could be organized into a single class specifically for tests about greenlets.
This is cleaner because Pytest supports conditionally skipping the entire class if greenlets are missing rather than having to mark each test separately. And can trigger just that class of tests etc.
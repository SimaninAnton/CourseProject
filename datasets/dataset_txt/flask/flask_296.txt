karlcow commented on 12 Sep 2018
Both in http://flask.pocoo.org/docs/1.0/testing/ and http://flask.pocoo.org/docs/1.0/blueprints/
there's not much said about Blueprint and unittesting.
Let's say that the project is organized such as:
myapp/
  __init__.py
  other_stuff.py
  myblueprint/
    __init__.py
    utils.py
tests/
  __init__.py
  some_unit_tests.py
In myapp/__init__.py, we register the blueprint
from myblueprint import myblueprint
app.register_blueprint(myblueprint)
In utils.py, we import do_amazing from other_stuff.py.
Then for mocking do_amazing, we usually import it in the context of utils.py. This is done by something like:
with patch('myapp.myblueprint.utils.do_amazing') as mock_amazing:
    # More stuff and test.
When there is no blueprint, this is working well.
As soon as myblueprint is a Blueprint object we end up having an error as soon as we hit the patch context.
AttributeError: 'Blueprint' object has no attribute 'utils'
If we print in the test before the patch.
        print 'myapp', myapp
        print 'myapp.myblueprint', myapp.myblueprint
        print 'myapp.myblueprint.utils', myapp.myblueprint.utils
We get:
myapp <module 'myapp' from '/Users/well/code/project/myapp/__init__.pyc'>
myapp.myblueprint <flask.blueprints.Blueprint object at 0x108847450>
ERROR
I still wonder if
it is the ambiguity of using the same name for folder and blueprint keywords
it is a limitation of the Mock library when patching.
it is a limitation of Blueprints themselves.
But it would be probably good to have something in the documentation under Blueprints or Testing addressing either the limitations or a minimal example of a test scenario for Blueprint cases.
1
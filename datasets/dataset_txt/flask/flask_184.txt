ekor15 commented on 3 Mar 2019
When working with a custom response class the test_client calls the response class constructor, after the make_response already called the response class constructor
This causes a CustomResponse object to be passed to the constructor of the CustomResponse class.
A basic example of the problem
import json
from unittest import TestCase

from flask import Response, Flask
from hamcrest import has_entry
from hamcrest.core import assert_that
from hamcrest.core.core import is_


class TestMediaAppRestResponse(TestCase):

    def setUp(self):
        self.media_app = MyApp(__name__)
        self.client = self.media_app.test_client()

    def _test_client(self):
        return self.media_app.test_client()

    def test_rest_response__dict_register_response_class_before_test_client(self):
        return_value = {'dict_prop': 'dict_value'}
        self.media_app.route('/')(_make_handler_with_response(return_value))
        self.media_app.register_response_class()

        test_client = self._test_client()

        response = test_client.get('/')
        print ('will never get here')

    def test_rest_response__dict_register_response_class_after_test_client(self):
        return_value = {'dict_prop': 'dict_value'}

        test_client = self._test_client()

        self.media_app.register_response_class()
        self.media_app.route('/')(_make_handler_with_response(return_value))

        response = test_client.get('/')
        assert_that(response.get_json(), has_entry('payload', is_(return_value)))


def _make_handler_with_response(response):
    def wrapped_handler():
        return response
    return wrapped_handler


class MyApp(Flask):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def register_response_class(self):
        self.response_class = MyResponse

    def make_response(self, response_value):
        if isinstance(response_value, self.response_class):
            return response_value
        return self.response_class(response_value, http_status=200, code=0, message='ok')


class MyResponse(Response):
    def __init__(self, payload=None, http_status: int = 200,
                 code: int = None,
                 message: str = '', *args, **kwargs):
        message = message
        code = code if code is not None else http_status
        payload = payload
        body_str = json.dumps({'code': code, 'message': message, 'payload': payload}, separators=(',', ':'))

        super().__init__(body_str, status=http_status, mimetype='application/json', *args, **kwargs)
Expected Behavior
The custom response class constructor should only be called by the make_response method
Actual Behavior
The constructor was called by the make_response method then by the test_client becuase the custom response class is passed to the client when it is created by the app.
Traceback (most recent call last):
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/case.py", line 59, in testPartExecutor
    yield
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/case.py", line 615, in run
    testMethod()
  File "/Users/elirans/projects/media-framework/tests/media_framework_test/http/flask/test_media_app_rest_response_multiple_calls.py", line 26, in test_rest_response__dict_register_response_class_before_test_client
    response = test_client.get('/')
  File "/Users/elirans/projects/media-framework/run/lib/python3.7/site-packages/werkzeug/test.py", line 830, in get
    return self.open(*args, **kw)
  File "/Users/elirans/projects/media-framework/run/lib/python3.7/site-packages/flask/testing.py", line 200, in open
    follow_redirects=follow_redirects
  File "/Users/elirans/projects/media-framework/run/lib/python3.7/site-packages/werkzeug/test.py", line 822, in open
    response = self.response_wrapper(*response)
  File "/Users/elirans/projects/media-framework/tests/media_framework_test/http/flask/test_media_app_rest_response_multiple_calls.py", line 72, in __init__
    body_str = json.dumps({'code': code, 'message': message, 'payload': payload}, separators=(',', ':'))
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py", line 238, in dumps
    **kw).encode(obj)
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py", line 199, in encode
    chunks = self.iterencode(o, _one_shot=True)
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py", line 257, in iterencode
    return _iterencode(o, 0)
  File "/usr/local/Cellar/python/3.7.1/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/encoder.py", line 179, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Headers is not JSON serializable
Environment
Python version: 3.7.1
Flask version: 1.0.2
Werkzeug version: 0.14.1
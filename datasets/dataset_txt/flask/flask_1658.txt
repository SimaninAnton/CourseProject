Contributor
dag commented on 19 Apr 2011
It would be neat to be able to control the serialization of arbitrary objects with jsonify. The dumps function allows you to pass a callable for this. I propose the addition of either an overridable method on the Flask class that is passed by jsonify, or a decorator for registering such a function. The "default default" could simply raise TypeError, the "default default" for the json module.
class JSONAdaptiveFlask(Flask):

    def json_defaults(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        try:
            return obj.__json__()
        except AttributeError:
            raise TypeError
… or …
@app.json_defaults
def json_adaption(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    try:
        return obj.__json__()
    except AttributeError:
        raise TypeError
Unlike the rejected pull-request, this should be thread-safe. As for direct use of the json module, one can simply pass the reference:
json.dumps(obj, default=app.json_defaults)
In a discussion on IRC, Armin expressed concern that this kind of adaption isn't very useful in practice, because it differs between requests what one wants serialized from an object. This problem can be solved by exploiting the fact that jsonify is request-bound, and the defaults function is able to read context-locals such as 'g'. It may not "feel" right but it is essentially what we need: a global state for the request.
class User(Model):

    def __json__(self):
        data = dict(name=self.name, joined=self.created_at)
        if g.user is self:
            data.update(email=self.email)
        if g.verbose_json:
            data.update(posts=self.posts)
The gain is that we can simplify views and structure the code better by moving model-logic to models. We can avoid repeating ourselves — the serialization is recursive, we just reference a datetime object and a list of instances of the Post model. We don't lose anything because by default it will behave as before and regardless we can still pass standard types directly to jsonify.
If you [Armin] approve the idea and decide on an API, I'll try my hand at a patch if you like.
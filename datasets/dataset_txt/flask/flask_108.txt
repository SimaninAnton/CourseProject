ArshanKhanifar commented on 6 Jul 2019
Expected Behavior
Catching an exception type in an error handler and raising another exception type breaks the flask app instead of passing control to the corresponding error handler.
Given the following flask application:
from flask import Flask, jsonify
from werkzeug.exceptions import BadRequest, HTTPException

class CustomAppException(Exception):
    pass

class AppFactory(object):
    def create(self):
        app = Flask(__name__)

        @app.errorhandler(HTTPException)
        def handle_generic_http_exceptions(e):
            return jsonify({
                "error": str(e)
            }), e.code

        @app.errorhandler(CustomAppException)
        def unhandled_meteor_errors(e):
            raise BadRequest(str(e))

        @app.route("/")
        def raise_error_endpoint():
            msg = 'some bad msg'
            raise CustomAppException(msg)

        return app
A get request to the endpoint / should show the following response:
{
"error": "400 Bad Request: some bad msg"
}
Actual Behavior
Instead it gives this response:
{
"error": "500 Internal Server Error: The server encountered an internal error and was unable to complete your request. Either the server is overloaded or there is an error in the application."
}
Environment
Python version: 3.7.3
Flask version: 1.1.0
Werkzeug version: 0.15.4
$ pip freeze
atomicwrites==1.3.0
attrs==19.1.0
certifi==2019.6.16
Click==7.0
Flask==1.1.0
importlib-metadata==0.18
itsdangerous==1.1.0
Jinja2==2.10.1
MarkupSafe==1.1.1
more-itertools==7.1.0
packaging==19.0
pluggy==0.12.0
py==1.8.0
pyparsing==2.4.0
pytest==5.0.1
six==1.12.0
wcwidth==0.1.7
Werkzeug==0.15.4
zipp==0.5.1
This is not broken in Flask 1.0.3. Here's the repo that tests this.
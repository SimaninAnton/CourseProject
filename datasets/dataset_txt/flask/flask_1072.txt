Contributor
mjpieters commented on 23 Mar 2015
Consider the following:
from flask import Flask
app = Flask(__name__)

@app.teardown_appcontext
def teardown(exception):
    print exception

with app.app_context():
    try:
        raise ValueError()
    except ValueError:
        pass
Within the app.app_context() context (managed by with) an exception is raised and handled. However, the teardown_appcontext() handler is still passed the exception value.
That's because the exception was raised and handled within the same frame, and thus sys.exc_info() is still available. The AppContext.__exit__() method did pass in None for the exception value:
def __exit__(self, exc_type, exc_value, tb):
    self.pop(exc_value)
but the AppContext.pop() method cannot distinguish this from not passing in a value at all:
def pop(self, exc=None):
    """Pops the app context."""
    self._refcnt -= 1
    if self._refcnt <= 0:
        if exc is None:
            exc = sys.exc_info()[1]
        self.app.do_teardown_appcontext(exc)
This can easily be remedied by using a different sentinel default value:
_sentinel = object()

def pop(self, exc=_sentinel):
    """Pops the app context."""
    self._refcnt -= 1
    if self._refcnt <= 0:
        if exc is _sentinel:
            exc = sys.exc_info()[1]
        self.app.do_teardown_appcontext(exc)
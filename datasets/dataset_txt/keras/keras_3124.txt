QuantumLiu commented on 26 Feb 2017 â€¢
edited
I defined a function in the the backen code file
def FloorSampling(x):
    """Returns a tensor which is only consist of several 1 and several 0.
    This function can be used when the target we want to predict is an opreation.
    Such as press 1~N piano keys in one time.Pianos have 88 keys,if we want 
    to code this opreation as an one-hot vector,the vector will has a dimession of
    88^N.
    By using this function in the outputlayer,the target vector like [1,0,1,1,0,...,1,0]"""
    return tf.floor(x + tf.random_uniform(tf.shape(x), 0, 1))
My custom layer is like this:
add(Lambda(K.FloorSampling,output_shape=lambda x:x))
When i fit the model,it got ValueError: None values not supported. .It probably caused by gradients of tf.floor() and tf.round() is [None]
def _FloorGrad(_, unused_grad):
  return [unused_grad]


@ops.RegisterGradient("Ceil")
def _CeilGrad(_, unused_grad):
  return [None]


@ops.RegisterGradient("Round")
def _RoundGrad(_, unused_grad):
  return [None]


@ops.RegisterGradient("Rint")
def _RintGrad(_, unused_grad):
  # the gradient of Rint is zero
  return [None]
freesunshine0316 commented on 25 Feb 2017
The errors are below that I have 39832 sentences, and I clip the length of each sentence to be 50.
So the input is a matrix of integers with the size (39832, 50).
My code are also below
File "train.py", line 98, in
model.fit(trainX, trainY, nb_epoch=1, batch_size=args.batch_size)
File "/software/python/2.7.12/lib/python2.7/site-packages/keras/models.py", line 652, in fit
sample_weight=sample_weight)
File "/software/python/2.7.12/lib/python2.7/site-packages/keras/engine/training.py", line 1038, in fit
batch_size=batch_size)
File "/software/python/2.7.12/lib/python2.7/site-packages/keras/engine/training.py", line 967, in _standardize_user_data
exception_prefix='model target')
File "/software/python/2.7.12/lib/python2.7/site-packages/keras/engine/training.py", line 100, in standardize_input_data
str(array.shape))
Exception: Error when checking model target: expected activation_1 to have 3 dimensions, but got array with shape (39832, 50)
def build_rnn(args, weight_w):
model = Sequential()
model.add(InputLayer(batch_input_shape=(args.batch_size, args.seq_length)))
model.add(Embedding(weight_w.shape[0], weight_w.shape[1], weights=[weight_w], mask_zero=True, W_regularizer=l2(args.l2)))
for i in range(args.layer_num):
model.add(LSTM(args.hidden_size, return_sequences=True, stateful=True))
model.add(Dropout(args.dropout))
model.add(TimeDistributed(Dense(weight_w.shape[0])))
model.add(Activation('softmax'))
model.compile(loss='categorical_crossentropy', optimizer=args.opt)
return model
print 'loading data'
trainX = []
trainY = []
for line in open('../exp_data/train.tok','rU'):
    X = [vocab_w[x] if x in vocab_w else vocab_w['UNK'] for x in line.strip().split()]
    Y = X[1:]
    X = X[:args.seq_length]
    Y = Y[:args.seq_length]
    X = X + [0,]*(args.seq_length-len(X))
    Y = Y + [0,]*(args.seq_length-len(Y))
    trainX.append(X)
    trainY.append(Y)
trainX = np.array(trainX, dtype='int')
trainY = np.array(trainY, dtype='int')
print trainX.shape, trainY.shape

for iter in range(args.iter_num):
    model.fit(trainX, trainY, nb_epoch=1, batch_size=args.batch_size)
ch779 commented on 14 Aug 2017 â€¢
edited
Hey guys, I'm new to this area, just got my hands on it for a couple of weeks.
Problem: I need to build a network to model a dynamic System with multi-inputs and outputs.
so I decide to predict a single value for each of my outputs at time t+1 based on multiple Inputs through the past, say 10 time-steps.
I take here 2 Inputs and 3 Outputs. Every Input and Output is a vector (y_values-time). I intended to build for both Inputs a separate LSTM layer, and the two Layers come together and then give 3 outputs.
questions: 0. any suggestions what kind of net architecture and type might work?
1. should I merge the two Inputs (same size) into one Matrix and feed it into LSTM?
2. should I prepare my whole Input vector into fractions (batches) and feed once in the network or should I build a Loop to cut my Input(s) into sections for each Iteration?
3. how should I define my batch_shape in functional API
here is the code, I can't get it running and I'm a little confused about the shape of the data, can you enlighten me on this? many thx.
#Setup
import ...
#Prepare data
t= pd.read_table...
lw= pd.read_table...
gas= pd.read_table...
psi= pd.read_table...
accx= pd.read_table...
accy= pd.read_table...
#define data structure and reshape data
batch_start= 0
batch_size= 10
input_length= 1
target_length= 1
t= t.values
lw= lw.values
gas= gas.values
psi= psi.values
accx= accx.values
accy= accy.values
#Build network
input1= Input(batch_shape= (batch_size, input_length), name='input1')
input2= Input(batch_shape= (batch_size, input_length), name='input2')
L1= LSTM(10, stateful= True, return_sequences= True)(input1)
L2= LSTM(10, stateful= True, return_sequences= True)(input2)
target= concatenate([L1, L2])
target1= TimeDistributed(Dense(target_length, activation= 'linear'))(target)
target2= TimeDistributed(Dense(target_length, activation= 'linear'))(target)
target3= TimeDistributed(Dense(target_length, activation= 'linear'))(target)
model= Model(
inputs= [input1, input2],
outputs= [target1, target2, target3]
)
model.compile(optimizer= 'rmsprop', loss= 'mean_squared_error')
plot_model(model, to_file= 'my_net.png', show_shapes= True, show_layer_names= True)
#Train network
#for step in range() ... build a loop
t_fit= t[batch_start:batch_sizeinput_length]
lw_fit= lw[batch_start:batch_sizeinput_length]
gas_fit= gas[batch_start:batch_sizeinput_length]
psi_fit= psi[batch_start:batch_sizeinput_length]
accx_fit= accx[batch_start:batch_sizeinput_length]
accy_fit= accy[batch_start:batch_sizeinput_length]
#update batch_start
batch_start += batch_size*input_length
model.fit(
[lw_fit, gas_fit],
[psi_fit, accx_fit, accy_fit]
)
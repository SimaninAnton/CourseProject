Imorton-zd commented on 7 Jan 2017
def simple_autoencode_test3p():
    input_size = max_features
    encoding_size = 1000

    x = Input(shape=(input_size,))
    z = Dense(encoding_size*2, activation='relu',name='z')(x)
    x_reconstruction = Dense(input_size, activation='sigmoid',name='reconstruction')(z)  
    
    out = Dense(1, activation='sigmoid', name='classification')(z)
    
    def ae_loss(x, out):
        xent_loss = objectives.binary_crossentropy(x, out)
        xrec_loss = objectives.binary_crossentropy(x, x_reconstruction)
        return xent_loss + xrec_loss

    test_model = Model(input=[x], output=[out])
    test_model.compile(optimizer='rmsprop',
                  loss = ae_loss, metrics=['accuracy'])   
    
    return test_model
ae_loss is the new definition of loss, including reconstruction loss and classification loss, as the final total loss, but return some errors!
ValueError: GpuElemwise. Input dimension mis-match. Input 2 (indices start at 0) has shape[1] == 1, but the output's size on that axis is 8000.
Apply node that caused the error: GpuElemwise{Composite{((i0 * log(i1)) + (i2 * log(i3)))},no_inplace}(GpuFromHost.0, GpuElemwise{clip,no_inplace}.0, GpuElemwise{sub,no_inplace}.0, GpuElemwise{sub,no_inplace}.0)
Toposort index: 76
Inputs types: [CudaNdarrayType(float32, matrix), CudaNdarrayType(float32, matrix), CudaNdarrayType(float32, matrix), CudaNdarrayType(float32, matrix)]
Inputs shapes: [(32, 1), (32, 8000), (32, 1), (32, 8000)]
Inputs strides: [(1, 0), (8000, 1), (1, 0), (8000, 1)]
Inputs values: ['not shown', 'not shown', 'not shown', 'not shown']
Outputs clients: [[GpuCAReduce{add}{0,1}(GpuElemwise{Composite{((i0 * log(i1)) + (i2 * log(i3)))},no_inplace}.0)]]

HINT: Re-running with most Theano optimization disabled could give you a back-trace of when this node was created. This can be done with by setting the Theano flag 'optimizer=fast_compile'. If that does not work, Theano optimizations can be disabled with 'optimizer=None'.
HINT: Use the Theano flag 'exception_verbosity=high' for a debugprint and storage map footprint of this apply node. 
malanfer commented on 13 Apr 2016
I need to apply sample weights not only to the training set, but also to the validation set.
For the moment when working with a sequential model, I'm working with the following:
        if args.validation_split==0.: # use separate set for validation
            history = model.fit(X_train, Y_train,
                                batch_size=batch_size, nb_epoch=nb_epoch,
                                show_accuracy=True, verbose=1,
                                validation_data=(X_dev, Y_dev),
                                sample_weight=sample_weight)
        else: # use separate part of the training set (reshuffled at each epoch) for validation
            history = model.fit(X_train, Y_train,
                                batch_size=batch_size, nb_epoch=nb_epoch,
                                show_accuracy=True, verbose=1,
                                validation_split=args.validation_split,
                                sample_weight=sample_weight)
However, this is suboptimal as this (as far as I can see) in both cases the weights are only applied to the training set.
It seems like choosing validation_data in fit_generator(self, generator, samples_per_epoch, nb_epoch, verbose=1, callbacks=[], validation_data=None, nb_val_samples=None, class_weight=None) to be a 3-dimensional tuple (i.e. (inputs, targets, sample_weights)) instead of a 2-dimensional (i.e. (inputs, targets)) one might be a solution for the first case where the validation set is fixed. According to the documentation such an option does not exist for the model method fit().
Any advice on how to best deal with this? Is there an example on how to do this somewhere?
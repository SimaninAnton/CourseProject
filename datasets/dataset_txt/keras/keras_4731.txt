Contributor
linxihui commented on 23 Jul 2016
If I use outer_model=TimeDistributed(inner_model, trainable=True)(default), according to the code below, function collect_trainable_weights will call property trainble_weights of TimeDistributed, which will concatenate all the trainable_weights in all layers of inner_model regardless if their trainable's areTrue or False', i.e., propertytrainable_weightsdisregardstrainable`.
Another thing I am not really understand is that the trainable_weights is not empty even if Dense(10, trainable=False).
def collect_trainable_weights(layer):
    '''Collects all `trainable_weights` attributes,
    excluding any sublayers where `trainable` is set the `False`.
    '''
    trainable = getattr(layer, 'trainable', True)
    if not trainable:
        return []
    weights = []
    if layer.__class__.__name__ == 'Sequential':
        for sublayer in layer.flattened_layers:
            weights += collect_trainable_weights(sublayer)
    elif layer.__class__.__name__ == 'Model':
        for sublayer in layer.layers:
            weights += collect_trainable_weights(sublayer)
    elif layer.__class__.__name__ == 'Graph':
        for sublayer in layer._graph_nodes.values():
            weights += collect_trainable_weights(sublayer)
    else:
        weights += layer.trainable_weights
    # dedupe weights
    weights = list(set(weights))
    weights.sort(key=lambda x: x.name)
return weights
2
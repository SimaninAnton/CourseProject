Moshewiner commented on 16 Mar 2017 â€¢
edited
Hello,
I am trying to write my own objective (cost function) which should do that:
I have vector shaped to (None, 88) and I need to proceed over it loss algorithm of my own.
I have tried to convert the y_pred and y_true params to numpy arrays but I failed because the shape of the tensors is Shape.0 - also I have noticed that the loss function runs (while debugging or printing in it) only once while the model defined.
Please help me how to use numpy in my loss function (K.eval didn't work because the shape is Shape.0) and how to debug it to see if it works.
Thanks!!
edit:
I wrote this loss function:
def my_loss(y_true, y_pred):
    # run over the sequence, jump by 3
    # calc the lable
    # if the lable uncorrect punish

    y_pred = K.reshape(y_pred, (1, 88, 3))

    y_pred = K.argmax(y_pred, axis=1)

    zero_count = K.sum(K.clip(y_pred, 0, 0))
    one_count = K.sum(K.clip(y_pred, 1, 1))
    two_count = K.sum(K.clip(y_pred, 2, 2))

    zero_punish = 1 - zero_count / K.count_params(y_true)
    one_punish = 1- one_count/ K.count_params(y_true)
    two_punish = 1- two_count/ K.count_params(y_true)

    false_arr = K.not_equal(y_true, y_pred)

    mask0 = K.equal(y_true, K.zeros_like(y_pred))
    mask0_miss = K.dot(false_arr, mask0) * zero_punish

    mask1 = K.equal(y_true, K.ones_like(y_pred))
    mask1_miss = K.dot(false_arr, mask1) * one_punish

    mask2 = K.equal(y_true, K.zeros_like(y_pred)+2)
    mask2_miss = K.dot(false_arr, mask2) * two_punish

    return K.sum(mask0_miss) + K.sum(mask1_miss) + K.sum(mask2_miss)
It fails on:
theano.gof.fg.MissingInputError: A variable that is an input to the graph was neither provided as an input to the function nor given a value. A chain of variables leading from this input to an output is [/dense_1_target, Shape.0]. This chain may not be unique
Backtrace when the variable is created:
How can I fix it?
thanks!
yananchen1989 commented on 30 Jul 2018
I have a model which give three outputs and my self-defined metrics is just tend to calculate on the first output, named main_output
def rankscore(y_true, y_pred):
    #diff = y_pred.eval()
    diff = y_pred
    right_cnt = diff[diff>0.5].shape[0]
    lose_cnt = diff[diff<=0.5].shape[0]
    return right_cnt / lose_cnt
def get_model():
    sequence_input_q = Input(shape=(maxlen, ), name = 'query')
    sequence_input_tp = Input(shape=(maxlen, ), name = 'title_pos')
    sequence_input_tn = Input(shape=(maxlen, ), name = 'title_neg')
    share_model =  side_model() 
    score_pos = share_model([sequence_input_q, sequence_input_tp]) # (?, 1)
    score_neg = share_model([sequence_input_q, sequence_input_tn]) # (?, 1)
    sim_diff = subtract([score_pos, score_neg]) # tensor (?, 1)
    main_output = Lambda(lambda x: tf.sigmoid(x))(sim_diff)# tensor (?, 1)
    main_output = Lambda(lambda x: x, name='main_output')(main_output)
    score_pos = Lambda(lambda x: x, name='score_pos')(score_pos)
    score_neg = Lambda(lambda x: x, name='score_neg')(score_neg)
    model = Model(inputs = [sequence_input_q, sequence_input_tp, sequence_input_tn], \
                    outputs = [main_output, score_pos, score_neg]) #[(None, 1), (None, 1), (None, 1)]   
    return model 
    
model = get_model()

model.compile(loss={'main_output':'binary_crossentropy'},optimizer=Adam(),metrics={'main_output':['rankscore']}) 
Here is my code and ValueError: Unknown metric function:rankscore comes out. I do not know how to implements my idea. Any hints ?
thanks.
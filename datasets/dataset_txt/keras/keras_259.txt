nadianaji commented on 26 Apr 2019 â€¢
edited
I have a simple network in Keras and I define a custom layer which does some operations on input tensor and then returns it to the network, but when I want to implement it, it produces the following error and said the input has not been fed while I think when we use fit function it feeds the network and it is weird for me. could you please help me with this issue? I could not find a suitable answer to solve my problem. I put my code here too. Thank you.
Traceback (most recent call last):
File "", line 124, in decoded_noise=JPEGLayer()(decoded)#16
File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\engine\base_layer.py", line 457, in call output = self.call(inputs, **kwargs)
File "", line 94, in call return noise()
File "", line 88, in noise slicAndJpeg(K.eval(noised_image_pad))
File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\backend\tensorflow_backend.py", line 673, in eval return to_dense(x).eval(session=get_session())
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\framework\ops.py", line 713, in eval return _eval_using_default_session(self, feed_dict, self.graph, session)
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\framework\ops.py", line 5157, in _eval_using_default_session return session.run(tensors, feed_dict)
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\client\session.py", line 929, in run run_metadata_ptr)
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\client\session.py", line 1152, in _run feed_dict_tensor, options, run_metadata)
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\client\session.py", line 1328, in _do_run run_metadata)
File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\client\session.py", line 1348, in _do_call raise type(e)(node_def, op, message)
InvalidArgumentError: You must feed a value for placeholder tensor 'input_1' with dtype float and shape [?,28,28,1] [[node input_1 (defined at D:\software\Anaconda3\envs\py36\lib\site-packages\keras\backend\tensorflow_backend.py:517) = Placeholderdtype=DT_FLOAT, shape=[?,28,28,1], _device="/job:localhost/replica:0/task:0/device:GPU:0"]] [[{{node jpeg_layer_1/zero_padding2d_1/Pad/_9}} = _Recvclient_terminated=false, recv_device="/job:localhost/replica:0/task:0/device:CPU:0", send_device="/job:localhost/replica:0/task:0/device:GPU:0", send_device_incarnation=1, tensor_name="edge_39_jpeg_layer_1/zero_padding2d_1/Pad", tensor_type=DT_FLOAT, _device="/job:localhost/replica:0/task:0/device:CPU:0"]]
Caused by op 'input_1', defined at: File "D:\software\Anaconda3\envs\py36\lib\runpy.py", line 193, in run_module_as_main "main", mod_spec) File "D:\software\Anaconda3\envs\py36\lib\runpy.py", line 85, in run_code exec(code, run_globals) File "D:\software\Anaconda3\envs\py36\lib\site-packages\spyder_kernels\console__main.py", line 11, in start.main() File "D:\software\Anaconda3\envs\py36\lib\site-packages\spyder_kernels\console\start.py", line 310, in main kernel.start() File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\kernelapp.py", line 505, in start self.io_loop.start() File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\platform\asyncio.py", line 132, in start self.asyncio_loop.run_forever() File "D:\software\Anaconda3\envs\py36\lib\asyncio\base_events.py", line 438, in run_forever self._run_once() File "D:\software\Anaconda3\envs\py36\lib\asyncio\base_events.py", line 1451, in _run_once handle._run() File "D:\software\Anaconda3\envs\py36\lib\asyncio\events.py", line 145, in _run self._callback(*self._args) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\ioloop.py", line 758, in _run_callback ret = callback() File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\stack_context.py", line 300, in null_wrapper return fn(*args, **kwargs) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\gen.py", line 1233, in inner self.run() File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\gen.py", line 1147, in run yielded = self.gen.send(value) File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\kernelbase.py", line 357, in process_one yield gen.maybe_future(dispatch(*args)) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\gen.py", line 326, in wrapper yielded = next(result) File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\kernelbase.py", line 267, in dispatch_shell yield gen.maybe_future(handler(stream, idents, msg)) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\gen.py", line 326, in wrapper yielded = next(result) File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\kernelbase.py", line 534, in execute_request user_expressions, allow_stdin, File "D:\software\Anaconda3\envs\py36\lib\site-packages\tornado\gen.py", line 326, in wrapper yielded = next(result) File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\ipkernel.py", line 294, in do_execute res = shell.run_cell(code, store_history=store_history, silent=silent) File "D:\software\Anaconda3\envs\py36\lib\site-packages\ipykernel\zmqshell.py", line 536, in run_cell return super(ZMQInteractiveShell, self).run_cell(*args, **kwargs) File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\interactiveshell.py", line 2819, in run_cell raw_cell, store_history, silent, shell_futures) File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\interactiveshell.py", line 2845, in _run_cell return runner(coro) File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\async_helpers.py", line 67, in _pseudo_sync_runner coro.send(None) File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\interactiveshell.py", line 3020, in run_cell_async interactivity=interactivity, compiler=compiler, result=result) File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\interactiveshell.py", line 3185, in run_ast_nodes if (yield from self.run_code(code, result)): File "D:\software\Anaconda3\envs\py36\lib\site-packages\IPython\core\interactiveshell.py", line 3267, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File "", line 114, in image = Input((28, 28, 1)) File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\engine\input_layer.py", line 178, in Input input_tensor=tensor) File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\legacy\interfaces.py", line 91, in wrapper return func(*args, **kwargs) File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\engine\input_layer.py", line 87, in init name=self.name) File "D:\software\Anaconda3\envs\py36\lib\site-packages\keras\backend\tensorflow_backend.py", line 517, in placeholder x = tf.placeholder(dtype, shape=shape, name=name) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\ops\array_ops.py", line 1747, in placeholder return gen_array_ops.placeholder(dtype=dtype, shape=shape, name=name) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\ops\gen_array_ops.py", line 5206, in placeholder "Placeholder", dtype=dtype, shape=shape, name=name) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\framework\op_def_library.py", line 787, in _apply_op_helper op_def=op_def) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\util\deprecation.py", line 488, in new_func return func(*args, **kwargs) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\framework\ops.py", line 3274, in create_op op_def=op_def) File "D:\software\Anaconda3\envs\py36\lib\site-packages\tensorflow\python\framework\ops.py", line 1770, in init self._traceback = tf_stack.extract_stack()
InvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'input_1' with dtype float and shape [?,28,28,1] [[node input_1 (defined at D:\software\Anaconda3\envs\py36\lib\site-packages\keras\backend\tensorflow_backend.py:517) = Placeholderdtype=DT_FLOAT, shape=[?,28,28,1], _device="/job:localhost/replica:0/task:0/device:GPU:0"]] [[{{node jpeg_layer_1/zero_padding2d_1/Pad/_9}} = _Recvclient_terminated=false, recv_device="/job:localhost/replica:0/task:0/device:CPU:0", send_device="/job:localhost/replica:0/task:0/device:GPU:0", send_device_incarnation=1, tensor_name="edge_39_jpeg_layer_1/zero_padding2d_1/Pad", tensor_type=DT_FLOAT, _device="/job:localhost/replica:0/task:0/device:CPU:0"]]
def C(u):
    if u == 0:
        return 1. / np.sqrt(2.)
    else:
        return 1.

def DCT(a, b):
    for u in range(8):
        for v in range(8):
            for x in range(8):
                for y  in range(8):
                    b[u,v] = b[u, v] + 0.25 * C(u) * C(v) * a[x, y]* np.cos((2 * x+1) * (u) * np.pi / 16) * np.cos((2 * y+1) * (v) * np.pi / 16)

def IDCT(a, b):
    for u in range(8):
        for v in range(8):
            for x in range(8):
                for y  in range(8):
                    b[x,y] = b[x, y] + 0.25 * C(u) * C(v) * a[u,v] * np.cos((2 * x+1) * (u) * np.pi / 16) * np.cos((2 * y+1) * (v) * np.pi / 16)

def quntize_mask(window_size: int, keep_count: int):
    mask = np.zeros((window_size, window_size), dtype=np.uint8)

    index_order = sorted(((x, y) for x in range(window_size) for y in range(window_size)),
                         key=lambda p: (p[0] + p[1], -p[1] if (p[0] + p[1]) % 2 else p[1]))

    for i, j in index_order[0:keep_count]:
        mask[i, j] = 1
    return mask
def slicAndJpeg(img):
    for i in range (int(img.shape[1].value/8)):
        for j in range(int(img.shape[2].value/8)):
            temp=(img[:,i*8:i*8+8,j*8:j*8+8])
            tempb=np.zeros((8,8))
            DCT(temp,tempb)
            mask=quntize_mask(8,9)
            qunz=Kr.layers.multiply(mask,tempb)
            tempc=K.zeros((8,8))
            IDCT(qunz,tempc)
            img[:,i*8:i*8+8,j*8:j*8+8]=tempc

class JPEGLayer(Layer):

    def __init__(self,**kwargs):
        super(JPEGLayer, self).__init__(**kwargs)
        self.supports_masking = True
    def call(self, noised_image, training=True):
        def noise():
#            noised_image = noised_and_cover
            # pad the image so that we can do dct on 8x8 blocks
            pad_height = (8 - noised_image.shape[1] % 8) % 8
            pad_width = (8 - noised_image.shape[2] % 8) % 8

            noised_image_pad = Kr.layers.ZeroPadding2D(padding=(( pad_width, 0),( pad_height,0)))(noised_image)
            slicAndJpeg(K.eval(noised_image_pad))


        # un-pad
            noised_and_cover = noised_image_pad[ :, :noised_image_pad.shape[1]-pad_height, :noised_image_pad.shape[2]-pad_width]
            return noised_and_cover 
        return noise()

#-----------------building w train---------------------------------------------
wt_random=np.random.randint(2, size=(49999,4,4))
w_expand=wt_random.astype(np.float32)
wv_random=np.random.randint(2, size=(9999,4,4))
wv_expand=wv_random.astype(np.float32)
x,y,z=w_expand.shape
w_expand=w_expand.reshape((x,y,z,1))
x,y,z=wv_expand.shape
wv_expand=wv_expand.reshape((x,y,z,1))

#-----------------building w test---------------------------------------------
w_test = np.random.randint(2,size=(1,4,4))
w_test=w_test.astype(np.float32)
w_test=w_test.reshape((1,4,4,1))


#-----------------------encoder------------------------------------------------
#------------------------------------------------------------------------------
image = Input((28, 28, 1))
conv1 = Conv2D(64, (5, 5),activation='relu',padding='same', name='convl1e')(image)
wtm=Input((4,4,1))
#--------------------------------------------------------------
wpad=Kr.layers.Lambda(lambda xy: xy[0] + Kr.backend.spatial_2d_padding(xy[1], padding=((0, 24), (0, 24))))
encoded_merged=wpad([conv1,wtm])#-----------------------decoder------------------------------------------------
#------------------------------------------------------------------------------
decoded = Conv2D(1, (5, 5),activation='relu', padding='same', name='decoder_output')(encoded_merged) 
model=Model(inputs=[image,wtm],outputs=decoded)
model.summary()
decoded_noise=JPEGLayer()(decoded)#16

#----------------------w extraction------------------------------------
convw1 = Conv2D(64, (5,5),activation='relu' , name='conl1w')(decoded_noise)#24
convw2 = Conv2D(64, (5,5),activation='relu' , name='conl2w')(convw1)#20
#Avw1=AveragePooling2D(pool_size=(2,2))(convw2)
convw3 = Conv2D(64, (5,5),activation='relu' ,name='conl3w')(convw2)#16
convw4 = Conv2D(64, (5,5), activation='relu' ,name='conl4w')(convw3)#12
#Avw2=AveragePooling2D(pool_size=(2,2))(convw4)
convw5 = Conv2D(64, (5,5), activation='relu' ,name='conl5w')(convw4)#8

convw6 = Conv2D(64, (5,5), activation='relu' ,name='conl6w')(convw5)#4
pred_w = Conv2D(1, (1, 1),activation='relu' ,padding='same', name='reconstructed_W')(convw6)

model1=Model(inputs=[image,wtm],outputs=[decoded,pred_w])

model1.summary()
#----------------------training the model--------------------------------------
#------------------------------------------------------------------------------
#----------------------Data preparesion----------------------------------------

(x_train, _), (x_test, _) = mnist.load_data()
x_validation=x_train[1:10000,:,:]
x_train=x_train[10001:60000,:,:]
#
x_train = x_train.astype('float32') / 255.
x_test = x_test.astype('float32') / 255.
x_validation = x_validation.astype('float32') / 255.
x_train = np.reshape(x_train, (len(x_train), 28, 28, 1))  # adapt this if using `channels_first` image data format
x_test = np.reshape(x_test, (len(x_test), 28, 28, 1))  # adapt this if using `channels_first` image data format
x_validation = np.reshape(x_validation, (len(x_validation), 28, 28, 1))

#---------------------compile and train the model------------------------------
opt=SGD(momentum=0.99,lr=0.0001)
model1.compile(optimizer='adam', loss={'imageprim':'mse','wprim':'binary_crossentropy'}, loss_weights={'imageprim': 0.5, 'wprim': 1.0},metrics=['mae'])
es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=40)
#rlrp = ReduceLROnPlateau(monitor='val_loss', factor=0.1, patience=20, min_delta=1E-4, verbose=1)
mc = ModelCheckpoint('sendAct.h5', monitor='val_loss', mode='min', verbose=1, save_best_only=True)
history=model1.fit([x_train,w_expand], [x_train,w_expand],
          epochs=4000,
          batch_size=32, 
          validation_data=([x_validation,wv_expand], [x_validation,wv_expand]),
          callbacks=[TensorBoard(log_dir='/home/jamalm8/tensorboardGNWLoss/', histogram_freq=0, write_graph=False),es,mc])
model1.summary()
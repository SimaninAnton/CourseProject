eyaler commented on 26 Oct 2016
check_loss_and_target_compatibility is looking at y.shape[1] to get the number of classes. however for rnn with return_sequences=True this should be y.shape[-1]
code to recreate:
from keras.models import Model
from keras.layers import LSTM, Input
import numpy as np
input = Input(batch_shape=(100,None,10))
output = LSTM(10, stateful=True, return_sequences=True)(input)
model = Model(input, output)
model.compile(loss='categorical_crossentropy', optimizer='sgd')
x=np.zeros((100,1,10))
y=np.zeros((100,1,10))
model.fit(x,y, batch_size=100)
error message:
Using Theano backend.
Using gpu device 0: GeForce GTX 860M (CNMeM is enabled with initial size: 80.0% of memory, cuDNN 5105)
Traceback (most recent call last):
File "C:/Users/eyalg/Dropbox/python/writer/temp4.py", line 11, in
model.fit(x,y, batch_size=100)
File "C:\Anaconda34\lib\site-packages\keras\engine\training.py", line 1047, in fit
batch_size=batch_size)
File "C:\Anaconda34\lib\site-packages\keras\engine\training.py", line 987, in _standardize_user_data
check_loss_and_target_compatibility(y, self.loss_functions, self.internal_output_shapes)
File "C:\Anaconda34\lib\site-packages\keras\engine\training.py", line 197, in check_loss_and_target_compatibility
' while using as loss categorical_crossentropy. '
Exception: You are passing a target array of shape (100, 1, 10) while using as loss categorical_crossentropy. categorical_crossentropy expects targets to be binary matrices (1s and 0s) of shape (samples, classes). If your targets are integer classes, you can convert them to the expected format via:
from keras.utils.np_utils import to_categorical
y_binary = to_categorical(y_int)
Alternatively, you can use the loss function sparse_categorical_crossentropy instead, which does expect integer targets.
Process finished with exit code 1
Imorton-zd commented on 4 May 2016 â€¢
edited
@fchollet
With the post code in the shared layers section of functional API, I try to tell whether two tweets are from the same person or not. I consider it as a classification task, the same person's tweet pair as positive samples and different persons' tweet pair as negative samples (the two types of samples are balanced). For example
But the classification accuracy is below 0.5, it is impossible. Are there some mistakes in the post code or the method of my idea as my example is wrong? I don't modify the original code. I don't think the concat operator can get the same effect of similarity. Any suggestions would be appreciated!
tweet_a = Input(shape=(140, 256))
tweet_b = Input(shape=(140, 256))
# this layer can take as input a matrix
# and will return a vector of size 64
shared_lstm = LSTM(64)

# when we reuse the same layer instance
# multiple times, the weights of the layer
# are also being reused
# (it is effectively *the same* layer)
encoded_a = shared_lstm(tweet_a)
encoded_b = shared_lstm(tweet_b)

# we can then concatenate the two vectors:
merged_vector = merge([encoded_a, encoded_b], mode='concat', concat_axis=-1)

# and add a logistic regression on top
predictions = Dense(1, activation='sigmoid')(merged_vector)

# we define a trainable model linking the
# tweet inputs to the predictions
model = Model(input=[tweet_a, tweet_b], output=predictions)

model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['accuracy'])
model.fit([data_a, data_b], labels, nb_epoch=10)
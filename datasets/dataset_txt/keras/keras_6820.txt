loyeamen commented on 28 Jul 2015
Hi,
In case some of you are interested in retriveing the output from intermediate layers i have changed the compile function and added a 'predict_layer' for predicting the output for a given layer index.
I guess some of you will find this code useful so i post it here (you can also submit PR):
def compile(self, optimizer, loss, class_mode="categorical", theano_mode=None, predict_layers = None):

    Sequential.compile(self, optimizer, loss, class_mode, theano_mode)
    self._predict_layers = None
    if predict_layers is not None:
        if type(self.X_train) == list:
            predict_ins = self.X_test
        else:
            predict_ins = [self.X_test]
        self._predict_layers = [None] * len(self.layers)
        for layer_index in predict_layers:
            self._predict_layers[layer_index] = theano.function(predict_ins, self.layers[layer_index].get_output(train = False), 
                                                                  allow_input_downcast=True, mode=theano_mode)
def predict_layer(self, X, layer_index, batch_size=128, verbose=1):
if self._predict_layers is None or self._predict_layers[layer_index] is None:
raise ValueError("Prediction function for layer {} is not compiled!".format(layer_index))
X = standardize_X(X)
batches = make_batches(len(X[0]), batch_size)
if verbose == 1:
progbar = Progbar(target=len(X[0]))
for batch_index, (batch_start, batch_end) in enumerate(batches):
X_batch = slice_X(X, batch_start, batch_end)
batch_preds = self._predict_layers[layer_index] (*X_batch
if batch_index == 0:
shape = (len(X[0]),) + batch_preds.shape[1:]
preds = np.zeros(shape)
preds[batch_start:batch_end] = batch_preds
if verbose == 1:
progbar.update(batch_end)
return preds
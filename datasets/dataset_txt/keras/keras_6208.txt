vinhqdang commented on 25 Dec 2015
Hi everyone,
I have a dataset with 24 inputs, and 1 output, which is categorical value.
So my X_train.shape is (20000,24) and X_test.shape is (5000,24) and the output should be only one 1 six values: a, b, c, d, e, f. So the Y_train.shape is (20000,6).
Adapting from #579
batch_size = 32
embedding_dims = 24
nb_filters = 250
filter_length = 3
hidden_dims = 250
nb_epoch = 10
test_split=0.2
seed=113
nb_words=None
skip_top=0
maxlen=200
start_char=1 
oov_char=2
index_from=3
nb_classes = 6

Y_train = np_utils.to_categorical(Y_train, nb_classes)
Y_test = np_utils.to_categorical(Y_test, nb_classes)


print('Build model...')
model = Sequential()

# we start off with an efficient embedding layer which maps
# our vocab indices into embedding_dims dimensions
#model.add(Embedding(max_features, embedding_dims))
#model.add(Dropout(0.25))

# we add a Convolution1D, which will learn nb_filters
# word group filters of size filter_length:
model.add(Convolution1D(input_dim=embedding_dims,
            nb_filter=nb_filters,
            filter_length=filter_length,
            border_mode="valid",
            activation="relu",
            subsample_length=1))

# we use standard max pooling (halving the output of the previous layer):
model.add(MaxPooling1D(pool_length=2))

# We flatten the output of the conv layer, so that we can add a vanilla dense layer:
model.add(Flatten())

# Computing the output shape of a conv layer can be tricky;
# for a good tutorial, see: http://cs231n.github.io/convolutional-networks/
output_size = nb_filters * (((maxlen - filter_length) / 1) + 1) / 2

# We add a vanilla hidden layer:
model.add(Dense(output_size, hidden_dims))
model.add(Dropout(0.25))
model.add(Activation('relu'))

# We project onto a single unit output layer, and squash it with a sigmoid:
model.add(Dense(hidden_dims, nb_classes))
model.add(Activation('softmax'))

# model.add(Dense(128, 1, init='normal'))
# model.add(Activation('relu'))

# sgd = SGD(l2=0.0,lr=0.005, decay=1e-6, momentum=0.9, nesterov=True)
# model.compile(loss='categorical_crossentropy', optimizer=sgd, class_mode="categorical")
# model.compile(loss='categorical_crossentropy', optimizer='sgd', class_mode="categorical")
model.compile(loss='categorical_crossentropy', optimizer='rmsprop')
model.fit(X_train, Y_train, batch_size=batch_size, nb_epoch=nb_epoch,show_accuracy=True, validation_data=(X_test, Y_test))
score, acc = model.evaluate(X_test, Y_test, batch_size=batch_size, show_accuracy=True)
print('Test score:', score)
print('Test accuracy:', acc)
but I met the problem
TypeError: unsupported operand type(s) for *: 'NoneType' and 'int'
at line
model.add(Dense(output_size, hidden_dims))
Could you help to point out what I did wrong?
Thanks,
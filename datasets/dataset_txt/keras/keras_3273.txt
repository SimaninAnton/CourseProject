LukeMathWalker commented on 8 Feb 2017
Hi everybody,
I'm trying to do some fine-tuning using a pre-trained VGG19 model with a custom trained top-model, following more or less the advices given at https://blog.keras.io/building-powerful-image-classification-models-using-very-little-data.html
An issue arose when I tried to compose the base-model with the top-model in order to fine tune the last convolutional block.
I started with two different naive approaches:
base_model = VGG19(include_top=False, weights='imagenet')
top_model = load_model(model_path)
base_model.add(top_model)

Error: 'Model' object has no attribute 'add'

base_model = VGG19(include_top=False, weights='imagenet')
top_model = load_model(model_path)
test = Model(base_model.input,top_model.output, name='test')`

Error: Graph disconnected: cannot obtain value for tensor Tensor("flatten_input_1:0", shape=(?, 512, 10, 5), dtype=float32) at layer "flatten_input_1". The following previous layers were accessed without issue: []
In order to clarify the situation, my model is built as follows:
model3 = Sequential()
model3.add(Flatten(input_shape=train_data_shape[1:]))
model3.add(Dropout(dropout_rate_0))
model3.add(Dense(nb_hidden_nodes_1, activation='relu', init=init_mode_1, W_constraint=maxnorm(weight_constraint)))
model3.add(Dropout(dropout_rate_1))
model3.add(Dense(nb_hidden_nodes_2, activation='relu', init=init_mode_2, W_constraint=maxnorm(weight_constraint)))
model3.add(Dropout(dropout_rate_1))
model3.add(Dense(8, activation='softmax'))
model3.compile(loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])
And the input shape of the top model matches the output shape of the last convolutional block of the VGG19 model - I actually trained the top model using the "features" extracted by the VGG19 net.
How can I overcome this situation?
Does this have something to do with VGG19 being a Model object and my top_model being a Sequential object?
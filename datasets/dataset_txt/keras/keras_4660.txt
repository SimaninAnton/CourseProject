kuchenrolle commented on 2 Aug 2016 â€¢
edited
Hello.
I keep getting the error above. I tried the solutions I found (add Flatten() after maxpool, specify input_dim for the first layer and/or the layer after Flatten), but the error remains. Here's the function that throws the error, the input data have a dimensionality of 300:
def run_cnn(x_train, y_train, x_test, y_test):
    # create cnn
    reviews_cnn = Sequential()
    reviews_cnn.add(Convolution1D(50, 10, input_dim = 300, init = 'uniform', activation = 'relu'))
    # reviews_cnn.add(MaxPooling1D(pool_length = reviews_cnn.output_shape[1]))
    reviews_cnn.add(MaxPooling1D(pool_length = 291))
    reviews_cnn.add(Flatten())
    reviews_cnn.add(Dense(50, init = 'uniform', activation = 'relu'))
    # reviews_cnn.add(Dense(50, input_dim = 50, init = 'uniform', activation = 'relu'))
    reviews_cnn.add(Dense(1, init = 'uniform', activation = 'sigmoid'))
    # compile
    reviews_cnn.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])
    # train network
    reviews_cnn.fit(x_train, y_train, nb_epoch = 100, batch_size = 10)
    # get accuracy
    accuracy = reviews_cnn.evaluate(x_test, y_test)[1]
    return(accuracy)
Also, is there a way to automatically determine the output length of the cnn layer (to feed into the Maxpooling)? I tried using model.output_shape, but this is "None".
Edit: So, the problem was solved by expanding the dimensionality of the input array:
def run_cnn(x_train, y_train, x_test, y_test):
    x_train = np.expand_dims(x_train, 2)
    x_test = np.expand_dims(x_test, 2)
    # create cnn
    reviews_cnn = Sequential()
    reviews_cnn.add(Convolution1D(50, 10, input_dim = 300, init = 'uniform', activation = 'relu'))
    # reviews_cnn.add(MaxPooling1D(pool_length = reviews_cnn.output_shape[1]))
    reviews_cnn.add(MaxPooling1D(pool_length = 291))
    reviews_cnn.add(Flatten())
    reviews_cnn.add(Dense(50, init = 'uniform', activation = 'relu'))
    # reviews_cnn.add(Dense(50, input_dim = 50, init = 'uniform', activation = 'relu'))
    reviews_cnn.add(Dense(1, init = 'uniform', activation = 'sigmoid'))
    # compile
    reviews_cnn.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy'])
    # train network
    reviews_cnn.fit(x_train, y_train, nb_epoch = 100, batch_size = 10)
    # get accuracy
    accuracy = reviews_cnn.evaluate(x_test, y_test)[1]
    return(accuracy)
I don't understand this. Can someone explain it to me?
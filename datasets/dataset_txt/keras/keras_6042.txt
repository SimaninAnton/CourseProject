sebastianruder commented on 28 Jan 2016
I'd like to implement a layer that receives some word embeddings from an Embedding layer, which received a padded list of word indexes, and averages all non-zero word vectors to produce one output vector. The input dimensions would be something like (None, 5, 200) and the corresponding output dimensions should then be (None, 1, 200).
I've implemented this so far:
class NonZeroAverage(Layer):

    @property
    def output_shape(self):
        shape = list(self.input_shape)
        assert len(shape) == 3  # only valid for 3D tensors
        shape[1] = 1
        return tuple(shape)

    def get_output(self, train=False):
        x = self.get_input(train)
        shape = list(self.input_shape)
        sums = x.sum(axis=-1)
        counts = T.neq(x, 0).sum(axis=-1)
        avg_non_zeros = sums / counts
        reshaped = avg_non_zeros.reshape((shape[0], 1, shape[2])).astype('float32') # convolution requires float32
        return reshaped
I'm not sure if this is correct, though. I'm getting the following error as I'm not sure how to broadcast to the None dimension again.
theano.tensor.var.AsTensorError: ('Cannot convert (None, 1, 200) to TensorType', <type 'tuple'>)
Can you help me?
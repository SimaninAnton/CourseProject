RianGoossens commented on 8 Oct 2017
If I try out following script:
import tensorflow as tf
from keras import backend as K

K.arange(K.shape(K.constant([1]))[0])
I get following error:
Traceback (most recent call last):

  File "<ipython-input-30-9bb33f311b39>", line 4, in <module>
    K.arange(K.shape(K.constant([1]))[0])

  File "C:\Anaconda\lib\site-packages\keras\backend\tensorflow_backend.py", line 1871, in arange
    if stop is None and start < 0:

  File "C:\Anaconda\lib\site-packages\tensorflow\python\framework\ops.py", line 564, in __bool__
    raise TypeError("Using a `tf.Tensor` as a Python `bool` is not allowed. "

TypeError: Using a `tf.Tensor` as a Python `bool` is not allowed. Use `if t is not None:` instead of `if t:` to test if a tensor is defined, and use TensorFlow ops such as tf.cond to execute subgraphs conditioned on the value of a tensor.

Traceback (most recent call last):

  File "<ipython-input-30-9bb33f311b39>", line 4, in <module>
    K.arange(K.shape(K.constant([1]))[0])

  File "C:\Anaconda\lib\site-packages\keras\backend\tensorflow_backend.py", line 1871, in arange
    if stop is None and start < 0:

  File "C:\Anaconda\lib\site-packages\tensorflow\python\framework\ops.py", line 564, in __bool__
    raise TypeError("Using a `tf.Tensor` as a Python `bool` is not allowed. "

TypeError: Using a `tf.Tensor` as a Python `bool` is not allowed. Use `if t is not None:` instead of `if t:` to test if a tensor is defined, and use TensorFlow ops such as tf.cond to execute subgraphs conditioned on the value of a tensor.
However if I replace K.arange with tf.range this just works, looking at the source code the implementation for arange seems simple enough:
def arange(start, stop=None, step=1, dtype='int32'):
    """Creates a 1D tensor containing a sequence of integers.
    The function arguments use the same convention as
    Theano's arange: if only one argument is provided,
    it is in fact the "stop" argument.
    The default type of the returned tensor is `'int32'` to
    match TensorFlow's default.
    # Arguments
        start: Start value.
        stop: Stop value.
        step: Difference between two successive values.
        dtype: Integer dtype to use.
    # Returns
        An integer tensor.
    """
    # Match the behavior of numpy and Theano by returning an empty seqence.
    if stop is None and start < 0:
        start = 0
    result = tf.range(start, limit=stop, delta=step, name='arange')
    if dtype != 'int32':
        result = cast(result, dtype)
    return result
The problem is obviously the start < 0 part, as K.shape(x)[0] outputs a tensor instead of a number, so the < also becomes a tensor. I don't really see a way around this, but it would be a shame if this simple check would make K.arange less powerful than tf.range.
1
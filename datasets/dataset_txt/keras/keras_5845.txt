sergeyf commented on 2 Mar 2016
I've been using a Lambda layer as follows to learn an inner-product metric:
def dot_product(inputs):
    assert len(inputs) == 2, ('Dot product needs '
                              '2 inputs, %d given' % len(inputs))
    u, v = inputs.values()
    return  K.sum(u*v, axis=1, keepdims=True)

# the model
model = Graph()
model.add_input(name='input_1',input_shape=(d,))
model.add_input(name='input_2',input_shape=(d,))

branch_1 = Sequential()
# define branch_1 here

branch_2 = Sequential()
# define branch_2 here

model.add_node(branch_1,
               name="branch_1", 
               input='input_1')

model.add_node(branch_2,
               name="branch_2", 
               input='input_2')       

model.add_node(Lambda(dot_product), name='ip_layer', 
               inputs=['branch_1','branch_2'],
               merge_mode='join')
But it would be great to learn a bilinear mapping. What I mean is currently the ip_layer is doing an inner product: <u,v>, but I would like it to learn an inner product weight matrix: <u,W*v>. What is the right way to modify the dot_product function to have a learnable weight W?
Thanks for the great software.
1
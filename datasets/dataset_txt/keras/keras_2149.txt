shamsulmasum commented on 13 Jun 2017
`from pandas import DataFrame
from pandas import Series
from pandas import concat
from pandas import read_csv
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from math import sqrt
from matplotlib import pyplot
import numpy as np
frame a sequence as a supervised learning problem
def timeseries_to_supervised(data, lag=1):
df = DataFrame(data)
columns = [df.shift(i) for i in range(1, lag+1)]
columns.append(df)
df = concat(columns, axis=1)
df.fillna(0, inplace=True)
return df
create a differenced series
def difference(dataset, interval=1):
diff = list()
for i in range(interval, len(dataset)):
value = dataset[i] - dataset[i - interval]
diff.append(value)
return Series(diff)
invert differenced value
def inverse_difference(history, yhat, interval=1):
return yhat + history[-interval]
scale train and test data to [-1, 1]
def scale(train):
# fit scaler
scaler = MinMaxScaler(feature_range=(-1, 1))
scaler = scaler.fit(train)
# transform train
train = train.reshape(train.shape[0], train.shape[1])
train_scaled = scaler.transform(train)
return scaler, train_scaled
inverse scaling for a forecasted value
def invert_scale(scaler, X, value):
new_row = [x for x in X] + [value]
array = np.array(new_row)
array = array.reshape(1, len(array))
inverted = scaler.inverse_transform(array)
return inverted[0, -1]
def generate_features(x, forecast, window):
""" Concatenates a time series vector x with forecasts from
the iterated forecasting strategy.
Arguments:
----------
    x:        Numpy array of length T containing the time series.
    forecast: Scalar containing forecast for time T + 1.
    window:   Autoregressive order of the time series model.
"""
augmented_time_series = np.hstack((x, forecast))

return augmented_time_series[-window:].reshape(1, -1)

# fit an LSTM network to training data
def fit_lstm(train, batch_size, nb_epoch, neurons):
X, y = train[:, 0:-1], train[:, -1]
X = X.reshape(X.shape[0], 1, X.shape[1])
model = Sequential()
model.add(LSTM(neurons, batch_input_shape=(batch_size, X.shape[1], X.shape[2]), stateful=True))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
for i in range(nb_epoch):
model.fit(X, y, epochs=1, batch_size=batch_size, verbose=0, shuffle=False)
model.reset_states()
return model
def iterative_forecast(model, x, window, H):
""" Implements iterative forecasting strategy
Arguments:
----------
    model: scikit-learn model that implements a predict() method
           and is trained on some data x.
    x:     Numpy array containing the time series.
    h:     number of time periods needed for the h-step ahead
           forecast
"""
forecast = np.zeros(H)    
forecast[0] = model.predict(x.reshape(1, -1))

for h in range(1, H):
    features = generate_features(x, forecast[:h], window)

    forecast[h] = model.predict(features)

return forecast
load dataset
series = read_csv('shampoosales.csv', header=0, index_col=0, squeeze=True)
transform data to be stationary
raw_values = series.values
diff_values = difference(raw_values, 1)
transform data to be supervised learning
supervised = timeseries_to_supervised(diff_values, 1)
supervised_values = supervised.values
train = supervised_values[0:-12]
test = supervised_values[-12:]
transform the scale of the data
scaler, train_scaled = scale(train)
fit the model
lstm_model = fit_lstm(train_scaled, 1, 3000, 4)
yhat = iterative_forecast(lstm_model, train, 1, 10)
predictions = list()
predictions.append(yhat)
expected = raw_values[len(test)]
print('Predicted=%f, Expected=%f' % ( yhat, expected))
report performance
rmse = sqrt(mean_squared_error(expected, yhat))
print('Test RMSE: %.3f' % rmse)`
ValueError: Error when checking : expected lstm_4_input to have 3 dimensions, but got array with shape (1, 46)
i am after an iterative forecast approach for multistep forecast. dataset can be downloaded from:
https://datamarket.com/data/set/22r0/sales-of-shampoo-over-a-three-year-period#!ds=22r0&display=line
Seems to be something wrong with the code. would you be kind enough to help?
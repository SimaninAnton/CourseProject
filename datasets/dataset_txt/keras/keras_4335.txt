hbredin commented on 21 Sep 2016 â€¢
edited
In case the loss is a callable but not a function (e.g. an instance of a class implementing the __call__ method), .compile will raise an AttributeError.
I just thought I'd let you know as this happened to me when trying to do something like this:
>>> class MyLoss(object):
...    def __call__(self, y_true, y_pred):
...        # do something 
...        pass

>>> model.compile(loss=MyLoss())
AttributeError: 'MyLoss' object has no attribute '__name__'
The first faulty line is here: https://github.com/fchollet/keras/blob/f2aa89f44380044d9d6ed94e9e2f471e68198654/keras/engine/training.py#L952
I guess we should check whether hasattr(loss_fn, '__name__') beforehand.
Though I am not quite sure what the _standardize_user_data function does, I can try to write a pull request to fix this but I first wanted to make sure that supporting callables as user-defined losses is something you might consider.
This might come in handy when the user-defined loss has (hyper-)parameters (e.g. the margin value in the triplet loss paradigm, see https://arxiv.org/abs/1503.03832).
Thanks for this awesome library, by the way.
Thanks to Keras, I managed to do this (http://arxiv.org/abs/1609.04301) very quickly!
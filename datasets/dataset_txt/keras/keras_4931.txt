lan2720 commented on 21 Jun 2016
Hi, I want to build a network like that,

It includes three similar parts. Each part has convolution, maxpooling. The only difference between them is filter window size=3,4,5 respectively.
If I use the deprecated api Graph(), the code is like
for fsz in filter_sizes:
    conv = Convolution1D(nb_filter=num_filters,
                         filter_length=fsz,
                         border_mode='valid',
                         activation='relu',
                         subsample_length=1)
    pool = MaxPooling1D(pool_length=2)
    graph.add_node(conv, name='conv-%s' % fsz, input='input')
    graph.add_node(pool, name='maxpool-%s' % fsz, input='conv-%s' % fsz)
    graph.add_node(Flatten(), name='flatten-%s' % fsz, input='maxpool-%s' % fsz)

graph.add_output(name='output', inputs=['flatten-%s' % fsz for fsz in filter_sizes], merge_mode='concat')
I can use for loop and don't need 3 different Convolution1D instances for each window size.
And more importantly, add_output() function can receive the inputs as a list of node name! It's very convenient.
However, I didn't find similar usage in the new version.
For example, I've define Input layer and didn't want to define several Conv and Maxpool layer by hand, just use for loop and assign different names. But I need define a Merge layer as output. Merge layer should receive a list of Keras tensors or a list of layer instances, not their name. I can't do that.
In other word, there're just 3 convs and maxpools. If there is 100 similar parts like the graph, I can't define them by hand at all. How can I solve such a problem?
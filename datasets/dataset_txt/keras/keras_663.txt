Contributor
andhus commented on 26 Oct 2018
Summary
Outputs and states are not masked correctly in tensorflow_backend.rnn when the number of dimensions of any of these is larger than 2. The issue is that masks are only "tiled" along the second dimension of outputs/states, see e.g. this line. Note that the docs does not state that outputs or states should be restricted to 2 dimensions.
Examples replicating the issue
Output ndim > 2
n_samples = 3
n_timesteps = 4

def step_function(inputs, states):
    outputs = K.tile(K.expand_dims(inputs), [1, 1, 2])
    return outputs, states

inputs_vals = np.ones((n_samples, n_timesteps, 5))
inputs_vals[:, -1] = 0  # this should be ignored due to mask
initial_state_vals = [np.ones((n_samples, 6))]
mask_vals = np.ones((n_samples, n_timesteps))
mask_vals[:, -1] = 0  # final timestep masked

inputs = K.variable(inputs_vals)
initial_state = [K.variable(initial_state_vals[0])]
mask = K.variable(mask_vals)
for unroll in [True , False]:
    last_output, outputs, last_states = K.rnn(
        step_function,
        inputs,
        initial_state,
        mask=mask,
        unroll=unroll)

    expected_outputs = np.ones((n_samples, n_timesteps, 5, 2))
    assert_allclose(K.eval(outputs), expected_outputs)
Gives:
ValueError: Shapes must be equal rank, but are 3 and 2 for 'Select' (op: 'Select') with input shapes: [3,5], [3,5,2], [3,5,2].
States ndim > 2
n_samples = 3
n_timesteps = 4

def step_function(inputs, states):
    return inputs, [s + 1 for s in states]

inputs_vals = np.ones((n_samples, n_timesteps, 5))
initial_state_vals = [np.zeros((n_samples, 6, 6))]
mask_vals = np.ones((n_samples, n_timesteps))
mask_vals[:, -1] = 0  # final timestep masked

inputs = K.variable(inputs_vals)
initial_state = [K.variable(initial_state_vals[0])]
mask = K.variable(mask_vals)
for unroll in [True , False]:
    last_output, outputs, last_states = K.rnn(
        step_function,
        inputs,
        initial_state,
        mask=mask,
        unroll=unroll)
    # not updated last timestep:
    expected_last_state = np.ones((n_samples, 6, 6)) * (n_timesteps - 1)
    assert_allclose(K.eval(last_states[0]), expected_last_state)
Gives:
ValueError: Shapes must be equal rank, but are 3 and 2 for 'Select_1' (op: 'Select') with input shapes: [3,6], [3,6,6], [3,6,6]
Further Implications
Becasue of this, masking does not work for e.g. ConvLSTM2D, modified unit test below:
def test_convolutional_recurrent():

    class Masking5D(Masking):
        """Regular masking layer returns wrong shape of mask for RNN"""
        def compute_mask(self, inputs, mask=None):
            return K.any(K.not_equal(inputs, 0.), axis=[2, 3, 4])

    for data_format in ['channels_first', 'channels_last']:

        if data_format == 'channels_first':
            inputs = np.random.rand(num_samples, sequence_len,
                                    input_channel,
                                    input_num_row, input_num_col)
        else:
            inputs = np.random.rand(num_samples, sequence_len,
                                    input_num_row, input_num_col,
                                    input_channel)

        for use_mask in [False, True]:  # MODIFIED
            for return_sequences in [True, False]:
                # test for return state:
                x = Input(batch_shape=inputs.shape)
                kwargs = {'data_format': data_format,
                          'return_sequences': return_sequences,
                          'return_state': True,
                          'stateful': True,
                          'filters': filters,
                          'kernel_size': (num_row, num_col),
                          'padding': 'valid'}
                layer = convolutional_recurrent.ConvLSTM2D(**kwargs)
                layer.build(inputs.shape)
                
                # MODIFIED
                if use_mask:
                    outputs = layer(Masking5D()(x))
                else:
                    outputs = layer(x)
                
                output, states = outputs[0], outputs[1:]
                assert len(states) == 2
                model = Model(x, states[0])
                state = model.predict(inputs)
                np.testing.assert_allclose(
                    K.eval(layer.states[0]), state, atol=1e-4)

                # test for output shape:
                output = layer_test(convolutional_recurrent.ConvLSTM2D,
                                    kwargs={'data_format': data_format,
                                            'return_sequences': return_sequences,
                                            'filters': filters,
                                            'kernel_size': (num_row, num_col),
                                            'padding': 'valid'},
                                    input_shape=inputs.shape)
Gives:
ValueError: Dimension must be 2 but is 5 for 'conv_lst_m2d_5/transpose_1' (op: 'Transpose') with input shapes: [1,2], [5]
GKalliatakis commented on 14 May 2018
Following issue #10120, I am using the functional API to build a model with multiple (five) outputs and the same input, in order to simultaneously predict different properties of the data (images in my case). All the metadata of the dataset are stored in different CSV files (one for training, one for validation and one for test data).
An example of those entries is the following:
filename emotions valence arousal dominance age
train/images/000000.jpg 7,9 5 3 9 Adult
train/images/000001.jpg 3 6 4 7 Adult
I have already written code to parse the CSV and save all different annotations into different numpy arrays (x_train.npy, emotions.npy etc.) which later I am loading in order to train my CNN.
The issues I want to raise are the following:
First, what is the most efficient way to save the parsed annotations in order to load them afterwards ?
Is it better to read the annotations on the fly from the CSV file instead of saving them to numpy (or any other format) ?
When I load the saved numpy arrays (the following example contains only images and a single metadata)
 (x_train, y_train),(x_val, y_val)
then I do
train_generator = datagen.flow(x_train, y_train, batch_size=32)
and finally,
history = model.fit_generator(train_generator,
                        epochs=nb_of_epochs,
                        steps_per_epoch= steps_per_epoch,
                        validation_data=val_generator,
                        validation_steps=validation_steps,
                        callbacks=callbacks_list)
My program seems to consume up to 20-25GB of RAM for the whole duration of the training process (which is done on GPU). In case I add more than one output my program crashes because of that memory leak (max RAM I've got is 32GB).
What will be a correct approach for loading the parsed annotations alongside the raw images ?
Let's say the above issue is fixed, what will be a correct approach to make use of ImageDataGenerator for multiple outputs like the following (discussed here as well):
Xi[0], [Yi1[1], Yi2[1],Yi3[1], Yi4[1],Yi5[1]]
abdulqayyum commented on 27 Mar 2017
I have data in ndarray which i then converted by np.array(.) This is the error that raise in model.fit(.). Input data dimension is (500,124,124,1) Can anyone tell me what it is I was unable to find on google
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-17-8c90e7a13d1a> in <module>()
     12               validation_data=(X_test, Y_test),
     13               shuffle=False,
---> 14               callbacks=[early_stop,model_ckpt,tboard])
     15 res = model.evaluate(X_test, Y_test,batch_size=batch_size, verbose=1, show_accuracy=True)

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/models.pyc in fit(self, x, y, batch_size, nb_epoch, verbose, callbacks, validation_split, validation_data, shuffle, class_weight, sample_weight, initial_epoch, **kwargs)
    670                               class_weight=class_weight,
    671                               sample_weight=sample_weight,
--> 672                               initial_epoch=initial_epoch)
    673 
    674     def evaluate(self, x, y, batch_size=32, verbose=1,

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/engine/training.pyc in fit(self, x, y, batch_size, nb_epoch, verbose, callbacks, validation_split, validation_data, shuffle, class_weight, sample_weight, initial_epoch)
   1166         else:
   1167             ins = x + y + sample_weights
-> 1168         self._make_train_function()
   1169         f = self.train_function
   1170 

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/engine/training.pyc in _make_train_function(self)
    758             training_updates = self.optimizer.get_updates(self._collected_trainable_weights,
    759                                                           self.constraints,
--> 760                                                           self.total_loss)
    761             updates = self.updates + training_updates
    762 

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/optimizers.pyc in get_updates(self, params, constraints, loss)
    414 
    415     def get_updates(self, params, constraints, loss):
--> 416         grads = self.get_gradients(loss, params)
    417         self.updates = [K.update_add(self.iterations, 1)]
    418 

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/optimizers.pyc in get_gradients(self, loss, params)
     80 
     81     def get_gradients(self, loss, params):
---> 82         grads = K.gradients(loss, params)
     83         if hasattr(self, 'clipnorm') and self.clipnorm > 0:
     84             norm = K.sqrt(sum([K.sum(K.square(g)) for g in grads]))

/home/qayyum/anaconda2/lib/python2.7/site-packages/keras/backend/tensorflow_backend.pyc in gradients(loss, variables)
   1966     with regard to `loss`.
   1967     """
-> 1968     return tf.gradients(loss, variables, colocate_gradients_with_ops=True)
   1969 
   1970 

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/gradients.pyc in gradients(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method)
    476                 # If grad_fn was found, do not use SymbolicGradient even for
    477                 # functions.
--> 478                 in_grads = _AsList(grad_fn(op, *out_grads))
    479               else:
    480                 # For function call ops, we add a 'SymbolicGradient'

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/image_grad.pyc in _ResizeNearestNeighborGrad(op, grad)
     42       grad,
     43       op.inputs[0].get_shape()[1:3],
---> 44       align_corners=op.get_attr("align_corners"))
     45   # pylint: enable=protected-access
     46   return [grads, None]

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/gen_image_ops.pyc in _resize_nearest_neighbor_grad(grads, size, align_corners, name)
    816   result = _op_def_lib.apply_op("ResizeNearestNeighborGrad", grads=grads,
    817                                 size=size, align_corners=align_corners,
--> 818                                 name=name)
    819   return result
    820 

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)
    456             # What type does convert_to_tensor think it has?
    457             observed = ops.convert_to_tensor(values,
--> 458                                              as_ref=input_arg.is_ref).dtype.name
    459             prefix = ("Input '%s' of '%s' Op has type %s that does not match" %
    460                       (input_name, op_type_name, observed))

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in convert_to_tensor(value, dtype, name, as_ref)
    619     for base_type, conversion_func in funcs_at_priority:
    620       if isinstance(value, base_type):
--> 621         ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)
    622         if ret is NotImplemented:
    623           continue

/home/qayyum/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/constant_op.pyc in _tensor_shape_tensor_conversion_function(s, dtype, name, as_ref)
    196   if not s.is_fully_defined():
    197     raise ValueError(
--> 198         "Cannot convert a partially known TensorShape to a Tensor: %s" % s)
    199   if dtype is not None:
    200     if dtype not in (dtypes.int32, dtypes.int64):

ValueError: Cannot convert a partially known TensorShape to a Tensor: (?, ?)
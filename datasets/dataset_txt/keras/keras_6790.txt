Contributor
wxs commented on 6 Aug 2015
As far as I can tell, if you pass in both a class_weight and a sample_weight, the class_weight is ignored. Here is the relevant code:
def standardize_weights(y, sample_weight=None, class_weight=None):
    if sample_weight is not None:
        return standardize_y(sample_weight)
    elif isinstance(class_weight, dict):
        if len(y.shape) > 2:
Is this the desired behaviour? If so we should probably warn when you set both parameters. But I don't see why we couldn't multiply the class_weight with the sample_weight.
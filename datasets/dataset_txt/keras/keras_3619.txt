Contributor
danielegrattarola commented on 22 Dec 2016 â€¢
edited
Hello,
I've built a convolutional autoencoder with the functional API as follows:
from keras.models import Model, load_model
from keras.layers import *
from keras.optimizers import *

# Input layer
self.inputs = Input(shape=input_shape)  # 64x96

# Encoding layers
self.encoded = Convolution2D(128, 2, 2, subsample=(2, 2), border_mode='valid', activation='relu', dim_ordering=self.dim_ordering)(self.inputs)  # 32x48
self.encoded = Convolution2D(64, 2, 2, subsample=(2, 2), border_mode='valid', activation='relu', dim_ordering=self.dim_ordering)(self.encoded)  # 16x24
self.encoded = Convolution2D(32, 2, 2, subsample=(2, 2), border_mode='valid', activation='relu', dim_ordering=self.dim_ordering)(self.encoded)  # 8x12
self.encoded = Convolution2D(16, 2, 2, subsample=(2, 2), border_mode='valid', activation='relu', dim_ordering=self.dim_ordering)(self.encoded)  # 4x6
self.encoded = Convolution2D(1, 2, 2, subsample=(2, 2), border_mode='valid', activation='relu', dim_ordering=self.dim_ordering)(self.encoded)  # 2x3

# Decoding layers
self.decoded = Convolution2D(1, 2, 2, border_mode='same', activation='relu', dim_ordering=self.dim_ordering)(self.encoded)
self.decoded = UpSampling2D(size=(2, 2), dim_ordering=self.dim_ordering)(self.decoded)  # 4x6
self.decoded = Convolution2D(16, 2, 2, border_mode='same', activation='relu', dim_ordering=self.dim_ordering)(self.decoded)
self.decoded = UpSampling2D(size=(2, 2), dim_ordering=self.dim_ordering)(self.decoded)  # 8x12
self.decoded = Convolution2D(32, 2, 2, border_mode='same', activation='relu', dim_ordering=self.dim_ordering)(self.decoded)
self.decoded = UpSampling2D(size=(2, 2), dim_ordering=self.dim_ordering)(self.decoded)  # 16x24
self.decoded = Convolution2D(64, 2, 2, border_mode='same', activation='relu', dim_ordering=self.dim_ordering)(self.decoded)
self.decoded = UpSampling2D(size=(2, 2), dim_ordering=self.dim_ordering)(self.decoded)  # 32x48
self.decoded = Convolution2D(128, 2, 2, border_mode='same', activation='relu', dim_ordering=self.dim_ordering)(self.decoded)
self.decoded = UpSampling2D(size=(2, 2), dim_ordering=self.dim_ordering)(self.decoded)  # 64x96
self.decoded = Convolution2D(1, 3, 3, border_mode='same', activation='sigmoid', dim_ordering=self.dim_ordering)(self.decoded)

# Models
self.autoencoder = Model(input=self.inputs, output=self.decoded)
self.encoder = Model(input=self.inputs, output=self.encoded)

# Compile
self.optimizer = Adadelta()
self.autoencoder.compile(optimizer=self.optimizer, loss='binary_crossentropy', metrics=['accuracy'])
If I try to save the model and reload it with:
self.autoencoder.save('autoencoder.h5')
self.autoencoder = load_model('autoencoder.h5')
the Tensorflow backend will throw this error:
Traceback (most recent call last):
  File "/home/user/dev/Autoencoder.py", line 91, in load
    self.autoencoder = load_model( 'autoencoder.h5')
  File "/usr/local/lib/python2.7/dist-packages/keras/models.py", line 143, in load_model
    model.load_weights_from_hdf5_group(f['model_weights'])
  File "/usr/local/lib/python2.7/dist-packages/keras/engine/topology.py", line 2787, in load_weights_from_hdf5_group
    K.batch_set_value(weight_value_tuples)
  File "/usr/local/lib/python2.7/dist-packages/keras/backend/tensorflow_backend.py", line 1544, in batch_set_value
    assign_op = x.assign(assign_placeholder)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/variables.py", line 505, in assign
    return state_ops.assign(self._variable, value, use_locking=use_locking)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/gen_state_ops.py", line 45, in assign
    use_locking=use_locking, name=name)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/op_def_library.py", line 749, in apply_op
    op_def=op_def)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py", line 2382, in create_op
    set_shapes_for_outputs(ret)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py", line 1783, in set_shapes_for_outputs
    shapes = shape_func(op)
  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/common_shapes.py", line 596, in call_cpp_shape_fn
    raise ValueError(err.message)
ValueError: Dimension 1 in both shapes must be equal, but are 2 and 1
Similar problems arise with the Theano backend: in this case, the loading works fine, but at the first predict_on_batch call the program will crash with an error about out of bounds access.
I should also mention that saving the model weigths to hdf5 with self.autoencoder.save_weights('weights.h5') and then restoring them with self.autoencoder.load_weights(path) works perfectly. Moreover, the network works as intended when instantiated and compiled from scratch: the error only arises when using load_model.
Any idea what it could be?
Thanks
1
1
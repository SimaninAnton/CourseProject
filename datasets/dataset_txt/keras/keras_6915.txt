Collaborator
fchollet commented on 30 Jun 2015
Following the discussion in: #291, let's design a Graph container class, as well as a Graph model inheriting from containers.Graph and from models.Model.
Based on @pranv's initial work, here's a proposal for an API:
model = Graph()

model.input(shape=(3, 32, 32), name='input1')
model.input(shape=(3, 32, 32), name='input2')
model.node(MaxPooling2D(poolsize=(2, 2)), name='base', inputs=['input1', 'input2'], merge_mode='sum'))

model.node(Convolution2D(64, 64, 1, 1), name='conv11', input='base')
model.node(Convolution2D(64, 64, 1, 1), name='conv12', input='base')
model.node(MaxPooling2D(poolsize=(3, 3)), name='pool1', input='base'))

model.node(Convolution2D(64, 64, 1, 1), name='conv21', input='base')

model.node(Convolution2D(64, 64, 3, 3), name='conv22', input='conv11')
model.node(Convolution2D(64, 64, 5, 5), name='conv23', input='conv12')
model.node(Convolution2D(64, 64, 1, 1), name='conv24', input='pool1'))

model.output(inputs=['conv21', 'conv22', 'conv23', 'conv24' ], name='output1', merge_mode='concat')
model.output(input=['conv24'], name='conv24_output')

# loss_merge can be a custom function
model.compile(loss={'output1':'mae', 'conv24_output':'mse'}, loss_merge='sum', optimizer='sgd')
model.fit(train={'input1':X1, 'input2':X2, 'output1':Y1, 'conv24_output':Y2})
Basic behavior:
no merge / fork layers; every node can act as a merge over a list of inputs. Supports arguments input (name of layer) or inputs (list of names of layers).
the fit/evaluate/etc methods interface with models.Model, which takes list of inputs and list of outputs. Internally the input/output dictionary are flattened in a list following the expected order.
layer names (unique identifiers) are mandatory
use of the same layer identifier twice results in an exception
Remarks, suggestions, and questions welcome.
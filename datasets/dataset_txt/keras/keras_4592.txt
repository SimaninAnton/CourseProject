guirighetto commented on 15 Aug 2016
Hello, I'm using lately ImageDataGenerator to be able to use dataser larger. So I am trying to replicate the same example using dataArgumentation, I get the same accuracy for the two examples, but the return of model.predict and model.predict_generator are completely different. Does anyone know why this happens? Remembering that I know they can be different but in this case is completely different. Below the two examples with the same architecture.
dataArgumentation:
`   model.compile(loss="categorical_crossentropy", optimizer="Adadelta",metrics=['accuracy'])
    train_datagen = ImageDataGenerator(rescale=1./255)

    test_datagen = ImageDataGenerator(rescale=1./255)

    train_generator = train_datagen.flow_from_directory(
        trainPath,
        target_size=(blockWidth, blockHeight),
        color_mode='grayscale',
        batch_size=batchSize,
        class_mode='categorical',
        shuffle=True)

    validation_generator = test_datagen.flow_from_directory(
        testPath,
        target_size=(blockWidth, blockHeight),
        color_mode='grayscale',
        batch_size=batchSize,
        class_mode='categorical',
        shuffle=False)

    model.fit_generator(
        train_generator,
        samples_per_epoch=10500,
        nb_epoch=epoch,
        validation_data=validation_generator,
        nb_val_samples=5250)

    scoreSeg = model.evaluate_generator(validation_generator,5250)
    print("Accuracy = ",scoreSeg[1])
    predict = model.predict_generator(validation_generator,5250)
No dataArgumetation:
def loadDatabase():

    numSamplesTrain = float(numImgClass*(float(train)/100))
    numSamplesTrain = round(numSamplesTrain)

    dataTrain = []
    labelTrain = []
    dataTest = []
    labelTest = []
    filesTest = []
    filesCount = 0
    patchesCount = 0

    for c in range(1,classes+1):
        filesTest.append([])

        for s in range(1,numImgClass+1):

            if(s < numSamplesTrain+1):
                folderTrainTest = 'Treino/'
            else:
                folderTrainTest = 'Teste/'

            for b in range(1,numblock+1):
                nameImg = preName + str(c).zfill(5) + sep + str(s) + sep + str(b)
                folderClass = preName + str(c).zfill(5) + '/'
                fullPathImg = pathImages + folderClass + folderTrainTest + nameImg + imagesFormat
                image = plt.imread(fullPathImg)

                image = image[np.newaxis]

                if(folderTrainTest == 'Treino/'):
                    dataTrain.append(image)
                    labelTrain.append(c-1)
                else:
                    dataTest.append(image)
                    labelTest.append(c-1)
                    filesTest[filesCount].append(patchesCount)
                    patchesCount += 1
        filesCount+=1

    #train
    dataTrain = np.array(dataTrain)
    labelTrain = np.array(labelTrain)

    LUT = np.arange(len(dataTrain), dtype=int)
    random.shuffle(LUT)
    randomDataTrain = dataTrain[LUT]
    randomLabelTrain = labelTrain[LUT]

    X_Train = randomDataTrain.astype("float32")/255
    Y_Train = np_utils.to_categorical(randomLabelTrain, classes)

    #test       
    dataTest = np.array(dataTest)
    labelTest = np.array(labelTest)
    filesTest = np.array(filesTest)

    X_Test = dataTest.astype("float32")/255
    Y_Test = np_utils.to_categorical(labelTest, classes)

    print("Number samples train: ",numSamplesTrain*numblock*classes)
    print("Number samples test: ",(numImgClass-numSamplesTrain)*numblock*classes)       

    return X_Train, Y_Train, X_Test, Y_Test, filesTest

main():
    X_Train, Y_Train, X_Test, Y_Test, filesTest = loadDatabase()

    model = buildModel()

    model.compile(loss="categorical_crossentropy", optimizer="Adadelta",metrics=['accuracy'])
    model.fit(X_Train, Y_Train, nb_epoch=epoch, batch_size=batchSize, verbose=1, validation_data=(X_Test, Y_Test))
    scoreSeg = model.evaluate(X_Test, Y_Test, verbose=1)
    predict = model.predict(X_Test, verbose=1)
13
akbacak commented on 15 Aug 2018
The model below should be trained by a custom loss
e=0.5
def c_loss(Dense_48, e):
def loss(y_true, y_pred):
return (K.categorical_crossentropy(y_true, y_pred) - (K.sum((Dense_48 - e)**2) ) * (1/48))
return loss
Here my intention is to use the output of Dense_48 layer (sigmoid activation) as a parameter in the loss function during training
visible = Input(shape=(256,256,3),name = 'visible')
conv_1 = Conv2D(32, kernel_size=4, activation='linear')(visible)
lReLU_1 = LeakyReLU(alpha=0.1)(conv_1)
MaxPool_1 = MaxPooling2D((2, 2),padding='same')(lReLU_1)
Drop_1 = Dropout(0.25)(MaxPool_1)
conv_2 = Conv2D(64, kernel_size=3, activation='linear')(Drop_1)
lReLU_2 = LeakyReLU(alpha=0.1)(conv_2)
MaxPool_2 = MaxPooling2D((2, 2),padding='same')(lReLU_2)
Drop_2 = Dropout(0.25)(MaxPool_2)
conv_3 = Conv2D(128, kernel_size=3, activation='linear')(Drop_2)
lReLU_3 = LeakyReLU(alpha=0.1)(conv_3)
MaxPool_3 = MaxPooling2D((2, 2),padding='same')(lReLU_3)
Drop_3 = Dropout(0.4)(MaxPool_3)
Flat_1 = Flatten()(Drop_3)
Dense_128 = Dense(128, activation='linear')(Flat_1)
lReLU_4 = LeakyReLU(alpha=0.1)(Dense_128)
Drop_4 = Dropout(0.4)(lReLU_4)
Dense_48 = Dense(48, activation='sigmoid')(Drop_4)
Dense_5 = Dense(5, activation='sigmoid')(Dense_48)
model = Model(inputs=visible, outputs=Dense_5)
model.compile(loss = c_loss, optimizer=sgd, metrics=['accuracy'])
train_dropout = model.fit(train_X, train_label,
shuffle=True, batch_size=batch_size,epochs=epochs,verbose=1,
validation_data=(valid_X, valid_label) )
During compiling i got this error, anybody help ?
Traceback (most recent call last):
File "./mult_loss.py", line 116, in
model.compile(loss = c_loss, optimizer=sgd, metrics=['accuracy'])
File "/usr/local/lib/python2.7/dist-packages/keras/engine/training.py", line 332, in compile
sample_weight, mask)
File "/usr/local/lib/python2.7/dist-packages/keras/engine/training_utils.py", line 416, in weighted
ndim = K.ndim(score_array)
File "/usr/local/lib/python2.7/dist-packages/keras/backend/tensorflow_backend.py", line 616, in ndim
dims = x.get_shape()._dims
AttributeError: 'function' object has no attribute 'get_shape'
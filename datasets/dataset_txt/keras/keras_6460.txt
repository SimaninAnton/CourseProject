dpappas commented on 9 Nov 2015
I have written the code below
import numpy as np
from keras.models import Sequential
from keras.layers.core import Dense, Dropout, Activation
from keras.layers.recurrent import LSTM
from keras.optimizers import SGD, RMSprop, Adagrad

train_x = [
    [[ 1 ,3 ]],
    [[ 2 ,4 ]],
    [[ 3 ,5 ]],
    [[ 4 ,6 ]],
    [[ 5 ,7 ]],
    [[ 6 ,8 ]],
    [[ 7 ,9 ]],
    [[ 8 ,10 ]],
    [[ 9 ,11 ]]
]

# train_y = [ [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], [ 10 ] ]    # that surprisingly did not work when using just 1 output
train_y = [
    [ 1,0,0,0,0,0,0,0,0 ],
    [ 0,1,0,0,0,0,0,0,0 ],
    [ 0,0,1,0,0,0,0,0,0 ],
    [ 0,0,0,1,0,0,0,0,0 ],
    [ 0,0,0,0,1,0,0,0,0 ],
    [ 0,0,0,0,0,1,0,0,0 ],
    [ 0,0,0,0,0,0,1,0,0 ],
    [ 0,0,0,0,0,0,0,1,0 ],
    [ 0,0,0,0,0,0,0,0,1 ]
]

test_x = [ [[ 6 ,8 ]], [[ 7 ,9 ]], ]
# test_y = [ [ 7 ], [ 8 ] ]    # that surprisingly did not work when using just 1 output
test_y = [ [ 0,0,0,0,0,1,0,0,0 ], [ 0,0,0,0,0,0,1,0,0 ] ]

train_x = np.array(train_x)
train_y = np.array(train_y)
test_x = np.array(test_x)
test_y = np.array(test_y)

print('Build model...')
model = Sequential()
model.add(LSTM(output_dim=128, input_dim = 2, activation='tanh')) 
model.add(Dropout(0.5))
model.add(Dense(9, activation='softmax'))  # try using a GRU instead, for fun
model.compile(loss='categorical_crossentropy', optimizer='sgd')
t = model.fit(train_x, train_y, batch_size=2, nb_epoch=5)
model.predict_classes(test_x)
# array([5, 5])
model.predict(test_x)

score, acc = model.evaluate(test_x, test_y, show_accuracy=True)
How do I get the weights of the LSTM network ?
I want to use them as Embeddings.
i saw that there are many weights:
>>> print(len( model.layers[0].get_weights() ))
12
one matrix for each of these
>>> pprint(model.layers[0].get_config())
{'activation': 'tanh',
 'forget_bias_init': 'one',
 'init': 'glorot_uniform',
 'inner_activation': 'hard_sigmoid',
 'inner_init': 'orthogonal',
 'input_dim': 2,
 'input_length': 9,
 'input_shape': (9, 2),
 'name': 'LSTM',
 'output_dim': 128,
 'return_sequences': False,
 'truncate_gradient': -1}
but which one exactly should i use?
e.g.
>>> print(len( model.layers[0].get_weights()[0][1] ))
128

>>> print(len( model.layers[0].get_weights()[11]))
128

>>> print(len( model.layers[0].get_weights()[1][127]))
128
Thank you in advance for your support
Dimitris
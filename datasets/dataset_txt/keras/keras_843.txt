KiriteeGak commented on 1 Aug 2018
Please make sure that the boxes below are checked before you submit your issue. If your issue is an implementation question, please ask your question on StackOverflow or join the Keras Slack channel and ask there instead of filing a GitHub issue.
Thank you!
Check that you are up-to-date with the master branch of Keras. You can update with:
pip install git+git://github.com/keras-team/keras.git --upgrade --no-deps
If running on TensorFlow, check that you are up-to-date with the latest version. The installation instructions can be found here.
If running on Theano, check that you are up-to-date with the master branch of Theano. You can update with:
pip install git+git://github.com/Theano/Theano.git --upgrade --no-deps
Provide a link to a GitHub Gist of a Python script that can reproduce your issue (or just copy the script here if it is short).
Hi Guys,
I tried asking this on StackOverflow with no results and slack channel does not look active at all.
I am building a CNN model for speech recognition. I got a requirement that after each segment of speech being convolved, the outputs from filter should be taken in such a way that should be match a particular slice of frames. This means if each output from filter is being frames x features, If I know that frame_1 to frame_2 does belong to some label, I want to get filter output from these alone. So for each data point, I will be having different frame_1, frame_2 values. So all I need to do is pass it along with data point the frame values and use it to slice or multiply to makes other signals zero. But I have been researching for it like a day and half, I came across Lambda layer where we can pass in an input, but that do have weights. I just want to send in an input of where to look at in an point. Can any one point me to right documentation at what I need to be looking at.
Snippet of code if it is of any help.
    def time_based_slicing(x):
        return tf.squeeze(tf.tensordot(x[1], x[0], axes=1), [1, 2])/tf.reduce_sum(x[1])

    main_input = Input(shape=(None, 525, 40), dtype='float32', name='main_input')
    custom_pooling = Input(shape=(None, 1, 525), dtype='float32', name='custom_pooling')

    conv1 = Conv2D(filters=48,
                   border_mode='same',
                   kernel_size=3,
                   use_bias=True,
                   data_format="channels_last",
                   activation='relu')(main_input)
    conv2 = Conv2D(filters=48,
                   border_mode='same',
                   kernel_size=2,
                   use_bias=True,
                   activation='relu')(conv1)

    pool1 = AveragePooling2D(pool_size=(1, 1))(conv2)

    conv3 = Conv2D(filters=96,
                   kernel_size=(2, 2),
                   border_mode='same',
                   activation='relu')(pool1)
    conv4 = Conv2D(filters=96,
                   kernel_size=(2, 2),
                   border_mode='same',
                   activation='relu')(conv3)

    pool2 = Lambda(time_based_slicing)([conv4, custom_pooling])
    global_pool = GlobalAveragePooling2D()(pool2)

    dense1 = Dense(units=100, init='normal', activation='relu')(global_pool)
    dense2 = Dense(units=46, init='normal', activation='softmax')(dense1)

    model = Model(inputs=[main_input, custom_pooling], outputs=dense2)
    model.compile(optimizer=sgd_, loss=categorical_crossentropy, metrics=['accuracy'])
    model.summary()
Thanks.
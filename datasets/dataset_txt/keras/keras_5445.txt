trungnt13 commented on 18 Apr 2016
This is the model I used:
x = Input(shape=Xtrain.shape[1:], name='X')
vad = Input(shape=Xtrain_vad.shape[1:], name='vad')
l1 = LSTM(200)(x, mask=vad)
l2 = Dense(len(label), activation='softmax')(l1)

model = Model(input=[x, vad], output=l2)
model.compile(optimizer='rmsprop',
              loss='categorical_crossentropy',
              metrics=['accuracy'])
model.fit([Xtrain, Xtrain_vad], ytrain, nb_epoch=1)
And the output:
but the provided input variable at index 1 is not part of the computational graph needed to compute the outputs: vad.
Everything ran fine, but the model didn't take mask into account. Probably issue come from call of Layers, this method totally ignore the mask:
        # raise exceptions in case the input is not compatible
        # with the input_spec set at build time
        self.assert_input_compatibility(x)
        # build and connect layer
        input_added = False
        input_tensors = to_list(x)

        inbound_layers = []
        node_indices = []
        tensor_indices = []
        for input_tensor in input_tensors:
            if hasattr(input_tensor, '_keras_history') and input_tensor._keras_history:
                # this is a Keras tensor
                previous_layer, node_index, tensor_index = input_tensor._keras_history
                inbound_layers.append(previous_layer)
                node_indices.append(node_index)
                tensor_indices.append(tensor_index)
            else:
                inbound_layers = None
                break
        if inbound_layers:
            # this will call layer.build() if necessary
            self.add_inbound_node(inbound_layers, node_indices, tensor_indices)
            input_added = True
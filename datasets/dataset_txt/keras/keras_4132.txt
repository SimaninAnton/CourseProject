EhsanEI commented on 18 Oct 2016
Hi,
I wrote a custom loss function that just uses the built-in binary crossentropy loss:
from keras.objectives import get as get_objective
def my_loss(y_true, y_pred):
    co = get_objective('binary_crossentropy')
    return co(y_true, y_pred)
However, the behavior is different when I use this function instead of passing 'binary_crossentropy' to the model's compile method. This function yields worse results. I suspect it might be a numerical problem but I don't know how to fix it.
In this gist, I get ~99% validation accuracy on MNIST with the built-in function and ~96% validation accuracy with my_loss after the first epoch. The difference is much bigger on my own dataset.
1
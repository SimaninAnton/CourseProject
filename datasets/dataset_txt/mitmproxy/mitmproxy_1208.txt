Contributor
felixonmars commented on 15 Feb 2016
All four tests in test_protocol_http2.py currently fail here. I have checked CI and they seem to be skipped.
=================================== FAILURES ===================================
____________________________ TestSimple.test_simple ____________________________

self = <test.test_protocol_http2.TestSimple object at 0x7f5cfbc1d490>

    def test_simple(self):
        client, h2_conn = self._setup_connection()

        self._send_request(client.wfile, h2_conn, headers=[
            (':authority', "127.0.0.1:%s" % self.server.server.address.port),
            (':method', 'GET'),
            (':scheme', 'https'),
            (':path', '/'),
        ], body='my request body echoed back to me')

        done = False
        while not done:
            try:
                events = h2_conn.receive_data(b''.join(http2_read_raw_frame(client.rfile)))
            except:
                break
            client.wfile.write(h2_conn.data_to_send())
            client.wfile.flush()

            for event in events:
                if isinstance(event, h2.events.StreamEnded):
                    done = True

        h2_conn.close_connection()
        client.wfile.write(h2_conn.data_to_send())
        client.wfile.flush()

>       assert len(self.master.state.flows) == 1
E       assert 0 == 1
E        +  where 0 = len(<libmproxy.flow.FlowStore object at 0x7f5cfbc11550>)
E        +    where <libmproxy.flow.FlowStore object at 0x7f5cfbc11550> = <libmproxy.flow.State object at 0x7f5cfbc11350>.flows
E        +      where <libmproxy.flow.State object at 0x7f5cfbc11350> = <test.tservers.TestMaster object at 0x7f5cfbc11490>.state
E        +        where <test.tservers.TestMaster object at 0x7f5cfbc11490> = <test.test_protocol_http2.TestSimple object at 0x7f5cfbc1d490>.master

test/test_protocol_http2.py:201: AssertionError
_______________________ TestWithBodies.test_with_bodies ________________________

self = <test.test_protocol_http2.TestWithBodies object at 0x7f5cfbc11d50>

    def test_with_bodies(self):
        client, h2_conn = self._setup_connection()

        self._send_request(
            client.wfile,
            h2_conn,
            headers=[
                (':authority', "127.0.0.1:%s" % self.server.server.address.port),
                (':method', 'GET'),
                (':scheme', 'https'),
                (':path', '/'),
            ],
            body='foobar with request body',
        )

        done = False
        while not done:
            try:
                events = h2_conn.receive_data(b''.join(http2_read_raw_frame(client.rfile)))
            except:
                break
            client.wfile.write(h2_conn.data_to_send())
            client.wfile.flush()

            for event in events:
                if isinstance(event, h2.events.StreamEnded):
                    done = True

        h2_conn.close_connection()
        client.wfile.write(h2_conn.data_to_send())
        client.wfile.flush()

>       assert self.master.state.flows[0].response.body == b'foobar with request body'

test/test_protocol_http2.py:270:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <libmproxy.flow.FlowStore object at 0x7f5cfbcd6e90>, item = 0

    def __getitem__(self, item):
>       return self._list[item]
E       IndexError: list index out of range

libmproxy/flow.py:383: IndexError
______________________ TestPushPromise.test_push_promise _______________________

self = <test.test_protocol_http2.TestPushPromise object at 0x7f5cfbc1de50>

    def test_push_promise(self):
        client, h2_conn = self._setup_connection()

        self._send_request(client.wfile, h2_conn, stream_id=1, headers=[
            (':authority', "127.0.0.1:%s" % self.server.server.address.port),
            (':method', 'GET'),
            (':scheme', 'https'),
            (':path', '/'),
            ('foo', 'bar')
        ])

        done = False
        ended_streams = 0
        pushed_streams = 0
        responses = 0
        while not done:
            try:
                raw = b''.join(http2_read_raw_frame(client.rfile))
                events = h2_conn.receive_data(raw)
            except:
                break
            client.wfile.write(h2_conn.data_to_send())
            client.wfile.flush()

            for event in events:
                if isinstance(event, h2.events.StreamEnded):
                    ended_streams += 1
                elif isinstance(event, h2.events.PushedStreamReceived):
                    pushed_streams += 1
                elif isinstance(event, h2.events.ResponseReceived):
                    responses += 1
                if isinstance(event, h2.events.ConnectionTerminated):
                    done = True

            if responses == 3 and ended_streams == 3 and pushed_streams == 2:
                done = True

        h2_conn.close_connection()
        client.wfile.write(h2_conn.data_to_send())
        client.wfile.flush()

>       assert ended_streams == 3
E       assert 0 == 3

test/test_protocol_http2.py:372: AssertionError
___________________ TestPushPromise.test_push_promise_reset ____________________

self = <test.test_protocol_http2.TestPushPromise object at 0x7f5cfc030fd0>

    def test_push_promise_reset(self):
        client, h2_conn = self._setup_connection()

        self._send_request(client.wfile, h2_conn, stream_id=1, headers=[
            (':authority', "127.0.0.1:%s" % self.server.server.address.port),
            (':method', 'GET'),
            (':scheme', 'https'),
            (':path', '/'),
            ('foo', 'bar')
        ])

        done = False
        ended_streams = 0
        pushed_streams = 0
        responses = 0
        while not done:
            try:
                events = h2_conn.receive_data(b''.join(http2_read_raw_frame(client.rfile)))
            except:
                break
            client.wfile.write(h2_conn.data_to_send())
            client.wfile.flush()

            for event in events:
                if isinstance(event, h2.events.StreamEnded) and event.stream_id == 1:
                    ended_streams += 1
                elif isinstance(event, h2.events.PushedStreamReceived):
                    pushed_streams += 1
                    h2_conn.reset_stream(event.pushed_stream_id, error_code=0x8)
                    client.wfile.write(h2_conn.data_to_send())
                    client.wfile.flush()
                elif isinstance(event, h2.events.ResponseReceived):
                    responses += 1
                if isinstance(event, h2.events.ConnectionTerminated):
                    done = True

            if responses >= 1 and ended_streams >= 1 and pushed_streams == 2:
                done = True

        h2_conn.close_connection()
>       client.wfile.write(h2_conn.data_to_send())

test/test_protocol_http2.py:421:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <netlib.tcp.Writer object at 0x7f5cfbaf1350>
v = '\x00\x00\x08\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

    def write(self, v):
        """
                May raise TcpDisconnect
            """
        if v:
            self.first_byte_timestamp = self.first_byte_timestamp or time.time()
            try:
                if hasattr(self.o, "sendall"):
                    self.add_log(v)
                    return self.o.sendall(v)
                else:
                    r = self.o.write(v)
                    self.add_log(v[:r])
                    return r
            except (SSL.Error, socket.error) as e:
>               raise TcpDisconnect(str(e))
E               TcpDisconnect: (32, 'EPIPE')

/usr/lib/python2.7/site-packages/netlib/tcp.py:183: TcpDisconnect
==================== 4 failed, 308 passed in 44.22 seconds =====================
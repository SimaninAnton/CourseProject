piescotch commented on 10 Oct 2019
Steps to reproduce the problem:
pytest --full-trace ./test/mitmproxy/proxy/test_server.py
Hangs forever
Any other comments? What have you tried so far?
Here is the trace on my system
============================ test session starts ==============================
platform linux -- Python 3.7.4, pytest-5.2.1, py-1.8.0, pluggy-0.13.0
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/mnt/HD1/aur/cache/mitmproxy-git/src/mitmproxy/test/mitmproxy/proxy/.hypothesis/examples')
rootdir: /mnt/HD1/aur/cache/mitmproxy-git/src/mitmproxy, inifile: setup.cfg
plugins: asyncio-0.10.0, hypothesis-4.36.2
collected 109 items

test_server.py ...................
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

config = <_pytest.config.Config object at 0x7f6a91a67a50>
doit = <function _main at 0x7f6a91b39b90>

    def wrap_session(config, doit):
        """Skeleton command line program"""
        session = Session(config)
        session.exitstatus = ExitCode.OK
        initstate = 0
        try:
            try:
                config._do_configure()
                initstate = 1
                config.hook.pytest_sessionstart(session=session)
                initstate = 2
>               session.exitstatus = doit(config, session) or 0

/usr/lib/python3.7/site-packages/_pytest/main.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

config = <_pytest.config.Config object at 0x7f6a91a67a50>
session = <Session mitmproxy exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=109>

    def _main(config, session):
        """ default command line protocol for initialization, session,
        running tests and reporting. """
        config.hook.pytest_collection(session=session)
>       config.hook.pytest_runtestloop(session=session)

/usr/lib/python3.7/site-packages/_pytest/main.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtestloop'>, args = ()
kwargs = {'session': <Session mitmproxy exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=109>}
notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    "Argument(s) {} which are declared in the hookspec "
                    "can not be found in this hook call".format(tuple(notincall)),
                    stacklevel=2,
                )
>       return self._hookexec(self, self.get_hookimpls(), kwargs)

/usr/lib/python3.7/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7f6a92f80c10>
hook = <_HookCaller 'pytest_runtestloop'>
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/lib/python3.7/site-packages/_pytest/main.py'>>...plugin.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f6a91d16d10>>]
kwargs = {'session': <Session mitmproxy exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=109>}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook, methods, kwargs)

/usr/lib/python3.7/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = <_HookCaller 'pytest_runtestloop'>
methods = [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from '/usr/lib/python3.7/site-packages/_pytest/main.py'>>...plugin.py'>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f6a91d16d10>>]
kwargs = {'session': <Session mitmproxy exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=109>}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
>       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
    )

/usr/lib/python3.7/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

session = <Session mitmproxy exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=109>

    def pytest_runtestloop(session):
        if session.testsfailed and not session.config.option.continue_on_collection_errors:
            raise session.Interrupted("%d errors during collection" % session.testsfailed)
    
        if session.config.option.collectonly:
            return True
    
        for i, item in enumerate(session.items):
            nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
>           item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)

/usr/lib/python3.7/site-packages/_pytest/main.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_protocol'>, args = ()
kwargs = {'item': <Function test_tcp>, 'nextitem': <Function test_clientcert_file>}
notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    "Argument(s) {} which are declared in the hookspec "
                    "can not be found in this hook call".format(tuple(notincall)),
                    stacklevel=2,
                )
>       return self._hookexec(self, self.get_hookimpls(), kwargs)

/usr/lib/python3.7/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7f6a92f80c10>
hook = <_HookCaller 'pytest_runtest_protocol'>
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.7/site-packages/_pytest/runner...lugin_name='warnings', plugin=<module '_pytest.warnings' from '/usr/lib/python3.7/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_tcp>, 'nextitem': <Function test_clientcert_file>}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook, methods, kwargs)

/usr/lib/python3.7/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = <_HookCaller 'pytest_runtest_protocol'>
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.7/site-packages/_pytest/runner...lugin_name='warnings', plugin=<module '_pytest.warnings' from '/usr/lib/python3.7/site-packages/_pytest/warnings.py'>>]
kwargs = {'item': <Function test_tcp>, 'nextitem': <Function test_clientcert_file>}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
>       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
    )

/usr/lib/python3.7/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_tcp>, nextitem = <Function test_clientcert_file>

    def pytest_runtest_protocol(item, nextitem):
        item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)
>       runtestprotocol(item, nextitem=nextitem)

/usr/lib/python3.7/site-packages/_pytest/runner.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_tcp>, log = True
nextitem = <Function test_clientcert_file>

    def runtestprotocol(item, log=True, nextitem=None):
        hasrequest = hasattr(item, "_request")
        if hasrequest and not item._request:
            item._initrequest()
        rep = call_and_report(item, "setup", log)
        reports = [rep]
        if rep.passed:
            if item.config.getoption("setupshow", False):
                show_test_item(item)
            if not item.config.getoption("setuponly", False):
>               reports.append(call_and_report(item, "call", log))

/usr/lib/python3.7/site-packages/_pytest/runner.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_tcp>, when = 'call', log = True, kwds = {}

    def call_and_report(item, when, log=True, **kwds):
>       call = call_runtest_hook(item, when, **kwds)

/usr/lib/python3.7/site-packages/_pytest/runner.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_tcp>, when = 'call', kwds = {}
hookname = 'pytest_runtest_call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    def call_runtest_hook(item, when, **kwds):
        hookname = "pytest_runtest_" + when
        ihook = getattr(item.ihook, hookname)
        reraise = (Exit,)  # type: Tuple[Type[BaseException], ...]
        if not item.config.getoption("usepdb", False):
            reraise += (KeyboardInterrupt,)
        return CallInfo.from_call(
>           lambda: ihook(item=item, **kwds), when=when, reraise=reraise
        )

/usr/lib/python3.7/site-packages/_pytest/runner.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class '_pytest.runner.CallInfo'>
func = <function call_runtest_hook.<locals>.<lambda> at 0x7f6a8c08d5f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of "setup", "call",
        #: "teardown", "memocollect"
        start = time()
        excinfo = None
        try:
>           result = func()

/usr/lib/python3.7/site-packages/_pytest/runner.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

/usr/lib/python3.7/site-packages/_pytest/runner.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_runtest_call'>, args = ()
kwargs = {'item': <Function test_tcp>}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    "Argument(s) {} which are declared in the hookspec "
                    "can not be found in this hook call".format(tuple(notincall)),
                    stacklevel=2,
                )
>       return self._hookexec(self, self.get_hookimpls(), kwargs)

/usr/lib/python3.7/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7f6a92f80c10>
hook = <_HookCaller 'pytest_runtest_call'>
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.7/site-packages/_pytest/runner..._item=None>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f6a91d16d10>>]
kwargs = {'item': <Function test_tcp>}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook, methods, kwargs)

/usr/lib/python3.7/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = <_HookCaller 'pytest_runtest_call'>
methods = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/usr/lib/python3.7/site-packages/_pytest/runner..._item=None>>, <HookImpl plugin_name='logging-plugin', plugin=<_pytest.logging.LoggingPlugin object at 0x7f6a91d16d10>>]
kwargs = {'item': <Function test_tcp>}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
>       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
    )

/usr/lib/python3.7/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = <Function test_tcp>

    def pytest_runtest_call(item):
        _update_current_test_var(item, "call")
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
>           item.runtest()

/usr/lib/python3.7/site-packages/_pytest/runner.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Function test_tcp>

    def runtest(self):
        """ execute the underlying test function. """
>       self.ihook.pytest_pyfunc_call(pyfuncitem=self)

/usr/lib/python3.7/site-packages/_pytest/python.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_HookCaller 'pytest_pyfunc_call'>, args = ()
kwargs = {'pyfuncitem': <Function test_tcp>}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError("hook calling supports only keyword arguments")
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set(["__multicall__"]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    "Argument(s) {} which are declared in the hookspec "
                    "can not be found in this hook call".format(tuple(notincall)),
                    stacklevel=2,
                )
>       return self._hookexec(self, self.get_hookimpls(), kwargs)

/usr/lib/python3.7/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_pytest.config.PytestPluginManager object at 0x7f6a92f80c10>
hook = <_HookCaller 'pytest_pyfunc_call'>
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/usr/lib/python3.7/site-packages/_pytest/python...lugin_name='skipping', plugin=<module '_pytest.skipping' from '/usr/lib/python3.7/site-packages/_pytest/skipping.py'>>]
kwargs = {'pyfuncitem': <Function test_tcp>}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
>       return self._inner_hookexec(hook, methods, kwargs)

/usr/lib/python3.7/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = <_HookCaller 'pytest_pyfunc_call'>
methods = [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from '/usr/lib/python3.7/site-packages/_pytest/python...lugin_name='skipping', plugin=<module '_pytest.skipping' from '/usr/lib/python3.7/site-packages/_pytest/skipping.py'>>]
kwargs = {'pyfuncitem': <Function test_tcp>}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
>       firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
    )

/usr/lib/python3.7/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pyfuncitem = <Function test_tcp>

    @hookimpl(trylast=True)
    def pytest_pyfunc_call(pyfuncitem):
        def async_warn():
            msg = "async def functions are not natively supported and have been skipped.\n"
            msg += "You need to install a suitable plugin for your async framework, for example:\n"
            msg += "  - pytest-asyncio\n"
            msg += "  - pytest-trio\n"
            msg += "  - pytest-tornasync"
            warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))
            skip(msg="async def function and no async plugin installed (see warnings)")
    
        testfunction = pyfuncitem.obj
        if iscoroutinefunction(testfunction) or (
            sys.version_info >= (3, 6) and inspect.isasyncgenfunction(testfunction)
        ):
            async_warn()
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>       result = testfunction(**testargs)

/usr/lib/python3.7/site-packages/_pytest/python.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test.mitmproxy.proxy.test_server.TestHTTPS object at 0x7f6a85737110>

    def test_tcp(self):
        n = self.pathod("304")
        self._tcpproxy_on()
>       i = self.pathod("305")

test_server.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test.mitmproxy.proxy.test_server.TestHTTPS object at 0x7f6a85737110>
spec = '305', sni = None

    def pathod(self, spec, sni=None):
        """
            Constructs a pathod GET request, with the appropriate base and proxy.
        """
        p = self.pathoc(sni=sni)
        if self.ssl:
            q = "get:'/p/%s'" % spec
        else:
            q = "get:'%s/p/%s'" % (self.server.urlbase, spec)
        with p.connect():
>           return p.request(q)

../tservers.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test.mitmproxy.tservers.LazyPathoc object at 0x7f6a856fd510>
r = 'GET':'/p/305'

    def request(self, r):
        """
            Performs a single request.
    
            r: A language.message.Message object, or a string representing
            one.
    
            Returns Response if we have a non-ignored response.
    
            May raise a exceptions.NetlibException
        """
        if isinstance(r, str):
            r = next(language.parse_pathoc(r, self.use_http2))
    
        if isinstance(r, language.http.Request):
            if r.ws:
                return self.websocket_start(r)
            else:
>               return self.http(r)

../../../pathod/pathoc.py:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test.mitmproxy.tservers.LazyPathoc object at 0x7f6a856fd510>
r = 'GET':'/p/305'

    def http(self, r):
        """
            Performs a single request.
    
            r: A language.http.Request object, or a string representing one
            request.
    
            Returns Response if we have a non-ignored response.
    
            May raise a exceptions.NetlibException
        """
        logger = log.ConnectionLogger(
            self.fp,
            self.hexdump,
            False,
            self.rfile if self.showresp else None,
            self.wfile if self.showreq else None,
        )
        with logger.ctx() as lg:
            lg(">> %s" % r)
            resp, req = None, None
            try:
                req = language.serve(r, self.wfile, self.settings)
                self.wfile.flush()
    
                # build a dummy request to read the response
                # ideally this would be returned directly from language.serve
                dummy_req = net_http.Request(
                    first_line_format="relative",
                    method=req["method"],
                    scheme=b"http",
                    host=b"localhost",
                    port=80,
                    path=b"/",
                    http_version=b"HTTP/1.1",
                    content=b'',
                )
    
>               resp = self.protocol.read_response(self.rfile, dummy_req)

../../../pathod/pathoc.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

rfile = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>
request = Request(GET localhost:80/), body_size_limit = None

    def read_response(rfile, request, body_size_limit=None):
>       response = read_response_head(rfile)

../../../mitmproxy/net/http/http1/read.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

rfile = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>

    def read_response_head(rfile):
        """
        Parse an HTTP response head (response line + headers) from an input stream
    
        Args:
            rfile: The input stream
    
        Returns:
            The HTTP request object (without body)
    
        Raises:
            exceptions.HttpReadDisconnect: No bytes can be read from rfile.
            exceptions.HttpSyntaxException: The input is malformed HTTP.
            exceptions.HttpException: Any other error occurred.
        """
    
        timestamp_start = time.time()
        if hasattr(rfile, "reset_timestamps"):
            rfile.reset_timestamps()
    
>       http_version, status_code, message = _read_response_line(rfile)

../../../mitmproxy/net/http/http1/read.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

rfile = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>

    def _read_response_line(rfile):
        try:
>           line = _get_first_line(rfile)

../../../mitmproxy/net/http/http1/read.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

rfile = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>

    def _get_first_line(rfile):
        try:
>           line = rfile.readline()

../../../mitmproxy/net/http/http1/read.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>, size = None

    def readline(self, size=None):
        result = b''
        bytes_read = 0
        while True:
            if size is not None and bytes_read >= size:
                break
>           ch = self.read(1)

../../../mitmproxy/net/tcp.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <mitmproxy.net.tcp.Reader object at 0x7f6a85777110>, length = 1

    def read(self, length):
        """
            If length is -1, we read until connection closes.
        """
        result = b''
        start = time.time()
        while length == -1 or length > 0:
            if length == -1 or length > self.BLOCKSIZE:
                rlen = self.BLOCKSIZE
            else:
                rlen = length
            try:
>               data = self.o.read(rlen)

../../../mitmproxy/net/tcp.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <OpenSSL.SSL.Connection object at 0x7f6a85711250>, bufsiz = 1
flags = None

    def recv(self, bufsiz, flags=None):
        """
        Receive data on the connection.
    
        :param bufsiz: The maximum number of bytes to read
        :param flags: (optional) The only supported flag is ``MSG_PEEK``,
            all other flags are ignored.
        :return: The string read from the Connection
        """
        buf = _no_zero_allocator("char[]", bufsiz)
        if flags is not None and flags & socket.MSG_PEEK:
            result = _lib.SSL_peek(self._ssl, buf, bufsiz)
        else:
>           result = _lib.SSL_read(self._ssl, buf, bufsiz)
E           KeyboardInterrupt

/usr/lib/python3.7/site-packages/OpenSSL/SSL.py:1790: KeyboardInterrupt
Traceback (most recent call last):
  File "/usr/bin/pytest", line 11, in <module>
    load_entry_point('pytest==5.2.1', 'console_scripts', 'pytest')()
  File "/usr/lib/python3.7/site-packages/_pytest/config/__init__.py", line 90, in main
    return config.hook.pytest_cmdline_main(config=config)
  File "/usr/lib/python3.7/site-packages/pluggy/hooks.py", line 286, in __call__
    return self._hookexec(self, self.get_hookimpls(), kwargs)
  File "/usr/lib/python3.7/site-packages/pluggy/manager.py", line 92, in _hookexec
    return self._inner_hookexec(hook, methods, kwargs)
  File "/usr/lib/python3.7/site-packages/pluggy/manager.py", line 86, in <lambda>
    firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 208, in _multicall
    return outcome.get_result()
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 80, in get_result
    raise ex[1].with_traceback(ex[2])
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 187, in _multicall
    res = hook_impl.function(*args)
  File "/usr/lib/python3.7/site-packages/_pytest/main.py", line 228, in pytest_cmdline_main
    return wrap_session(config, _main)
  File "/usr/lib/python3.7/site-packages/_pytest/main.py", line 221, in wrap_session
    session=session, exitstatus=session.exitstatus
  File "/usr/lib/python3.7/site-packages/pluggy/hooks.py", line 286, in __call__
    return self._hookexec(self, self.get_hookimpls(), kwargs)
  File "/usr/lib/python3.7/site-packages/pluggy/manager.py", line 92, in _hookexec
    return self._inner_hookexec(hook, methods, kwargs)
  File "/usr/lib/python3.7/site-packages/pluggy/manager.py", line 86, in <lambda>
    firstresult=hook.spec.opts.get("firstresult") if hook.spec else False,
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 203, in _multicall
    gen.send(outcome)
  File "/usr/lib/python3.7/site-packages/_pytest/terminal.py", line 650, in pytest_sessionfinish
    outcome.get_result()
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 80, in get_result
    raise ex[1].with_traceback(ex[2])
  File "/usr/lib/python3.7/site-packages/pluggy/callers.py", line 187, in _multicall
    res = hook_impl.function(*args)
  File "/usr/lib/python3.7/site-packages/_pytest/runner.py", line 75, in pytest_sessionfinish
    session._setupstate.teardown_all()
  File "/usr/lib/python3.7/site-packages/_pytest/runner.py", line 326, in teardown_all
    self._pop_and_teardown()
  File "/usr/lib/python3.7/site-packages/_pytest/runner.py", line 299, in _pop_and_teardown
    self._teardown_with_finalization(colitem)
  File "/usr/lib/python3.7/site-packages/_pytest/runner.py", line 319, in _teardown_with_finalization
    self._callfinalizers(colitem)
  File "/usr/lib/python3.7/site-packages/_pytest/runner.py", line 307, in _callfinalizers
    fin()
  File "/usr/lib/python3.7/site-packages/_pytest/nose.py", line 14, in <lambda>
    item.session._setupstate.addfinalizer((lambda: teardown_nose(item)), item)
  File "/usr/lib/python3.7/site-packages/_pytest/nose.py", line 20, in teardown_nose
    call_optional(item.parent.obj, "teardown")
  File "/usr/lib/python3.7/site-packages/_pytest/nose.py", line 37, in call_optional
    method()
  File "/mnt/HD1/aur/cache/mitmproxy-git/src/mitmproxy/test/mitmproxy/tservers.py", line 161, in teardown
    self.server.wait_for_silence()
  File "/mnt/HD1/aur/cache/mitmproxy-git/src/mitmproxy/pathod/test.py", line 43, in wait_for_silence
    self.thread.server.wait_for_silence(timeout=timeout)
  File "/mnt/HD1/aur/cache/mitmproxy-git/src/mitmproxy/mitmproxy/net/tcp.py", line 668, in wait_for_silence
    if self.handler_counter.count == 0:
KeyboardInterrupt
Exception ignored in: <module 'threading' from '/usr/lib/python3.7/threading.py'>
Traceback (most recent call last):
  File "/usr/lib/python3.7/threading.py", line 1308, in _shutdown
    lock.acquire()
KeyboardInterrupt
System information
Mitmproxy: 5.0.0.dev
Python: 3.7.4
OpenSSL: OpenSSL 1.1.1d 10 Sep 2019
Platform: Linux-5.3.1-arch1-1-ARCH-x86_64-with-arch
2
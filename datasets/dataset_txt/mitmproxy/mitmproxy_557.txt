gkumarpatel commented on 13 Sep 2017 â€¢
edited
I am using mitmdump with python script to intercept https request and manipulate flow.request.host, flow.request.scheme, flow.request.port and flow.request.path with in def request(flow):. I have been able to achieve the same and get a response for the manipulated request. After first getting response for first request, my application send a second request. In the second request, instead of the host and port set by my application, I get the same previously manipulated host and port, that is flow.request.host and flow.request.port are from my last manipulated request but flow.request.scheme and flow.request.path are same as my application sets in second request.
I am getting wrong request in def request(flow): for the second request.
is there any keep-alive or caching thing that is manipulating my second request?
from mitmproxy import http
import sys
    
def request(flow):
     print("\nOriginal Request : " + str(flow.request)+"\n")
     if flow.request.pretty_host.endswith("original.host.com"):
      flow.request.host = "mock.host.com"
      flow.request.scheme = "http"
      flow.request.port = 8081
      flow.request.path = re.sub(r"billing",r"moquer-0.0.2/mockbillingBinding",flow.request.path)
      print("Manipulated Request : " + str(flow.request)+"\n")
    def response(flow):
     print("Response : " +str(flow.response)+"\n")
Edited : After debugging the python script, found that MITMProxy is not able to disconnect from client before the second request arrives. I think I might have to some how disconnect from client. is there any api for disconnecting MITMProxy from client and also from the sever? Thoughts please.
System information
Mitmproxy version: 2.0.2 (release version)
Python version: 3.6.2
Platform: Darwin-16.7.0-x86_64-i386-64bit
SSL version: OpenSSL 1.1.0f 25 May 2017
Mac version: 10.12.6 ('', '', '') x86_64
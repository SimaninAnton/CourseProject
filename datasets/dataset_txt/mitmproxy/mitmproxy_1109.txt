Contributor
thiagoarrais commented on 6 May 2016 â€¢
edited
I don't know what is the expected behavior here, but I've found out that doing this results in very large flow files:
Start some webserver
python -m SimpleHTTPServer 8000
Start a reverse proxy to that server. Append flows to some (non-existent) file
mitmproxy -a /tmp/somewhere.flows -p 8080 -R http://localhost:8000
Make some requests to said proxy:
curl -s http://localhost:8080 > /dev/null
Stop the proxy
Check the size of the flows file:
stat -c "%s %n" /tmp/somewhere.flows => 23059 /tmp/somewhere.flows
Start a new proxy instance. Append flows to same file. But, this time, try to read from it too.
mitmproxy -r /tmp/somewhere.flows -a /tmp/somewhere.flows -R http://localhost:8000
Do not issue any requests. Just wait for a few seconds (the process hangs)
Kill the proxy process
Check the size of the flows file again:
stat -c "%s %n" /tmp/somewhere.flows => 21942730 /tmp/somewhere.flows
Wow!
I did this expecting to be able to work with the previous captured flows (filter them, repeat requests, etc.) while still recording the new interactions. Do you think this is a valid use case?
Tested with mitmproxy 0.17 and master.